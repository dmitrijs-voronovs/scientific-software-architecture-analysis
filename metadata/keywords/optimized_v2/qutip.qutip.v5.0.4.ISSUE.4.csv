quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Integrability,"rator we're looking for. `G` is anti-Hermitian, and so it shares its eigensystem (up to scaling of the eigenvalues) with the Hermitian `i G` and consequently is diagonalised by a unitary formed of its eigenvectors. Now `S = i G / abs(alpha)` is a tridiagonal Hermitian, and with a similarity transformation we can find a _real-symmetric_ tridiagonal `T = P^-1 . S . P` for some diagonal unitary `P` (which is easy to calculate). The reason for scaling out `alpha` here should become clear at the end. The main diagonal of `T` is all zeros, and the first sub- and super-diagonals look like; ```[sqrt(1), -sqrt(2), sqrt(3), -sqrt(4), ...]```; and the diagonal of `P` looks like; ```[i, e^(-1i arg(alpha)), i e^(-2i arg(alpha)), e^(-3i arg(alpha)), ...]```. Now this real-symmetric tridiagonal form is the basis of Hermitian eigenvalue solvers, and has direct entry points in LAPACK (e.g. `?stemr`), which allow us to pass only the main diagonal and the first subdiagonal. Scipy provides convenient wrapped access in Python by `scipy.linalg.eigh_tridiagonal`. This lets us get the full eigensystem of `T`, which is related to that of `G` by dividing the eigenvalues by the scaling factor, and multiplying the eigenvectors by `P` to transform them into the correct basis. We now have a diagonalised matrix `G = Q^-1 . D . Q`, so `exp(G) = Q^-1 . exp(D) . Q`, which is now trivial because `D` is diagonal. Putting all this together allows us to use our knowledge of the problem domain to convert the matrix exponentiation problem into a much simpler real-symmetric tridiagonal eigensystem problem, which gets us a nice big speed up, and it's equivalent up to the tolerance of the eigenvalue solver (~1e-14). Even better for you, a lot of the hard work is done in the eigensystem solver, and I scaled out `alpha` at the start, so we can do a good chunk _without fixing alpha_. That means we can pay the computational cost only once at the start, and then get faster calculations from then on. If I make a t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-645685030:1353,wrap,wrapped,1353,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-645685030,2,['wrap'],['wrapped']
Integrability,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2946,interface,interface,2946,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,2,['interface'],['interface']
Integrability,"re `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Technically it can be well-approximated by using an interpolation for each individual matrix element, as the time-dependent Hamiltonian can be solved ahead of time, but that's not at all sensible. Most pressingly, the documentation is currently wrong and should be changed to reflect reality. Secondly, we have to decide whether we're going to implement this functionality at all, perhaps as a part of @Ericgig's refactor of the solvers?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260:2111,depend,dependent,2111,https://qutip.org,https://github.com/qutip/qutip/issues/1260,1,['depend'],['dependent']
Integrability,"re""><code>@​radarhere</code></a>]</li>; <li>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved putdata() documentation and data handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5910"">#5910</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Exclude carriage return in PDF regex to help prevent ReDoS <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5912"">#5912</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Image.NONE is only used for resampling and dithers <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5908"">#5908</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed freeing pointer in ImageDraw.Outline.transform <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5909"">#5909</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Add Tidelift alignment action and badge <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5763"">#5763</a> [<a href=""https://github.com/aclark4life""><code>@​aclark4life</code></a>]</li>; <li>Replaced further direct invocations of setup.py <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5906"">#5906</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added ImageShow support for xdg-open <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5897"">#5897</a> [<a href=""https://github.com/m-shinder""><code>@​m-shinder</code></a>]</li>; <",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:4506,depend,dependabot,4506,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"re, and while the licence would give us permission to improve the code, it's the reorganisation I'm worried about. Secondly, about the code itself: this sort of local operation is something I absolutely would like to include, but I'm not certain that the form it's in right now is the best, general way to do it. I think this is part of much larger discussion about how to handle tensor networks - for example, at the moment, `targets` is fine for states and operators, but it won't work for superoperators. I'm not sure that this is solvable in an ergonomic way with QuTiP's current dimensions specifiers, but it's something we're definitely going to look into after the initial release of 5.0. Also, there are already several disparate functions in QuTiP that provide sort-of similar functionality, and I think we need to have a proper go at tidying them all up into one cohesive interface. This includes `subsystem_apply` (most similar to this), but also `ptrace` and `partial_tranpose`, which can be seen as special cases of this exact same type of tensor contraction (not to mention `tensor_contract`!). The other thing from a code perspective is that this doesn't use the data-layer in the intended manner. A lot of this may be because our documentation of the data-layer isn't readily available yet (we weren't expecting interest this early!). It does individual detection on two different types, rather than creating a `Dispatcher` to handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:2073,contract,contraction,2073,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,2,['contract'],['contraction']
Integrability,"re/9.4.0...10.0.1"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=pillow&package-manager=pip&previous-version=9.4.0&new-version=10.0.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself); ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:13658,Depend,Dependabot,13658,https://qutip.org,https://github.com/qutip/qutip/pull/2237,9,"['Depend', 'depend']","['Dependabot', 'dependabot']"
Integrability,"re/cy/coefficient.pyx; [ 3/31] Cythonizing qutip/core/cy/math.pyx; [ 4/31] Cythonizing qutip/core/data/add.pyx; [ 5/31] Cythonizing qutip/core/data/base.pyx; [ 6/31] Cythonizing qutip/core/data/csr.pyx; [ 7/31] Cythonizing qutip/core/data/dense.pyx; [ 8/31] Cythonizing qutip/core/data/dia.pyx; [ 9/31] Cythonizing qutip/core/data/dispatch.pyx; [10/31] Cythonizing qutip/core/data/matmul.pyx; [11/31] Cythonizing qutip/core/data/mul.pyx; [12/31] Cythonizing qutip/core/data/norm.pyx; [13/31] Cythonizing qutip/core/data/permute.pyx; [14/31] Cythonizing qutip/core/data/ptrace.pyx; [15/31] Cythonizing qutip/core/data/reshape.pyx; [16/31] Cythonizing qutip/core/data/tidyup.pyx; [17/31] Cythonizing qutip/piqs/_piqs.pyx; [18/31] Cythonizing qutip/core/_brtensor.pyx; [19/31] Cythonizing qutip/core/cy/_element.pyx; [20/31] Cythonizing qutip/core/cy/qobjevo.pyx; [21/31] Cythonizing qutip/core/data/adjoint.pyx; [22/31] Cythonizing qutip/core/data/expect.pyx; [23/31] Cythonizing qutip/core/data/inner.pyx; [24/31] Cythonizing qutip/core/data/kron.pyx; [25/31] Cythonizing qutip/core/data/pow.pyx; [26/31] Cythonizing qutip/core/data/project.pyx; [27/31] Cythonizing qutip/core/data/properties.pyx; [28/31] Cythonizing qutip/core/data/trace.pyx; [29/31] Cythonizing qutip/solver/integrator/explicit_rk.pyx; [30/31] Cythonizing qutip/solver/sode/_sode.pyx; [31/31] Cythonizing qutip/solver/sode/ssystem.pyx; Getting requirements to build wheel ... done; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. </details>. I have also tried to install QuTiP in a virtualenv where I have previously manually installed numpy v 1.24, but it didn't work either. Installing with `pip install ""qutip<5""` succesfully installs qutip 4.7.6. I saw #2322, but I have `g++` installed and available on PATH.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:10874,integrat,integrator,10874,https://qutip.org,https://github.com/qutip/qutip/issues/2412,3,"['depend', 'integrat']","['dependencies', 'integrator']"
Integrability,"re</code></a>]</li>; <li>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>When saving RGBA to GIF, make use of first transparent palette entry <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5859"">#5859</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved putdata() documentation and data handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5910"">#5910</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Exclude carriage return in PDF regex to help prevent ReDoS <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5912"">#5912</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Image.NONE is only used for resampling and dithers <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5908"">#5908</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed freeing pointer in ImageDraw.Outline.transform <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5909"">#5909</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Add Tidelift alignment action and badge <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5763"">#5763</a> [<a href=""https://github.com/aclark4life""><code>@​aclark",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:4052,depend,dependabot,4052,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"record layer failure&quot; (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3405"">#3405</a>)</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/b60064388302f54a3455259ddab121618650a154""><code>b600643</code></a> [1.26] Bump RECENT_DATE (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3404"">#3404</a>)</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/7e2d3890926d4788e219f63e2e36fbeb8714827f""><code>7e2d389</code></a> [1.26] Fix running CPython 2.7 tests in CI (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3137"">#3137</a>)</li>; <li>See full diff in <a href=""https://github.com/urllib3/urllib3/compare/1.26.18...1.26.19"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=urllib3&package-manager=pip&previous-version=1.26.18&new-version=1.26.19)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2458:4024,depend,dependabot-security-updates,4024,https://qutip.org,https://github.com/qutip/qutip/pull/2458,1,['depend'],['dependabot-security-updates']
Integrability,"rect.dependabot.com/python-pillow/Pillow/issues/5570"">#5570</a>; [hugovk, radarhere]</li>; </ul>; <h2>Fixed regressions</h2>; <ul>; <li>; <p>Ensure TIFF <code>RowsPerStrip</code> is multiple of 8 for JPEG compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5588"">#5588</a>; [kmilos, radarhere]</p>; </li>; <li>; <p>Updates for <code>ImagePalette</code> channel order <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5599"">#5599</a>; [radarhere]</p>; </li>; <li>; <p>Hide FriBiDi shim symbols to avoid conflict with real FriBiDi library <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5651"">#5651</a>; [nulano]</p>; </li>; </ul>; <h2>8.3.1</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/8.3.1.html"">https://pillow.readthedocs.io/en/stable/releasenotes/8.3.1.html</a></p>; <h2>Changes</h2>; <ul>; <li>Catch OSError when checking if fp is sys.stdout <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5585"">#5585</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Handle removing orientation from alternate types of EXIF data <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5584"">#5584</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Make Image.<strong>array</strong> take optional dtype argument <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5572"">#5572</a> [<a href=""https://github.com/t-vi""><code>@​t-vi</code></a>]</li>; </ul>; <h2>8.3.0</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/8.3.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/8.3.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>Use snprintf instead of sprintf <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5567"">#5567</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit T",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:1802,depend,dependabot,1802,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['depend'],['dependabot']
Integrability,"redfool</code></a>]</li>; <li>Inline fname2char to fix memory leak <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6329"">#6329</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix memory leaks related to text features <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6330"">#6330</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Use double quotes for version check on old CPython on Windows <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6695"">#6695</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>GHA: replace deprecated set-output command with GITHUB_OUTPUT file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6697"">#6697</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Upload fribidi.dll to GitHub Actions <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6532"">#6532</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fixed set_variation_by_name offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6445"">#6445</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Windows build improvements <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6562"">#6562</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Only use ASCII characters in C source file <a href=""https",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:1833,depend,dependabot,1833,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"ref=""https://github.com/JayWiz""><code>@​JayWiz</code></a>]</li>; <li>Raise an error when allocating translucent color to RGB palette <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6654"">#6654</a> [<a href=""https://github.com/jsbueno""><code>@​jsbueno</code></a>]</li>; <li>Moved mode check outside of loops <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6650"">#6650</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added reading of TIFF child images <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6569"">#6569</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved ImageOps palette handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6596"">#6596</a> [<a href=""https://github.com/PososikTeam""><code>@​PososikTeam</code></a>]</li>; <li>Defer parsing of palette into colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6567"">#6567</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Apply transparency to P images in ImageTk.PhotoImage <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6559"">#6559</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use rounding in ImageOps contain() and pad() <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6522"">#6522</a> [<a href=""https://github.com/bibinhashley""><code>@​bibinhashley</code></a>]</li>; <li>Fixed GIF remapping to palette with duplicate entries <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6548"">#6548</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow remap_palette() to return an image with less than 256 palette entries <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6543"">#6543</a> [<a href=""https://github.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:8722,depend,dependabot,8722,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"ref=""https://github.com/numpy/numpy/commit/032fca5e2e9749b152ec56153f476e05efdff287""><code>032fca5</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/19280"">#19280</a> from charris/backport-19277</li>; <li><a href=""https://github.com/numpy/numpy/commit/7d25b81025a50cc0368f5727c65e875ca769469a""><code>7d25b81</code></a> BUG: Fix refcount leak in ResultType</li>; <li><a href=""https://github.com/numpy/numpy/commit/fa5754e8c159a37fcd9345df261cf82821088ea0""><code>fa5754e</code></a> BUG: Add missing DECREF in new path</li>; <li><a href=""https://github.com/numpy/numpy/commit/61127bb4d46d523b699da1b63abaa5035670da27""><code>61127bb</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/19268"">#19268</a> from charris/backport-19264</li>; <li><a href=""https://github.com/numpy/numpy/commit/143d45fff3ed9e051bdeef7bdb4df38025ea7d1c""><code>143d45f</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/19269"">#19269</a> from charris/backport-19228</li>; <li><a href=""https://github.com/numpy/numpy/commit/d80e4738f781a1d206bbc04a2e863299e5f2e104""><code>d80e473</code></a> BUG: Removed typing for == and != in dtypes</li>; <li>Additional commits viewable in <a href=""https://github.com/numpy/numpy/compare/v1.19.5...v1.21.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.19.5&new-version=1.21.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot comm",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1767:4036,depend,dependabot,4036,https://qutip.org,https://github.com/qutip/qutip/pull/1767,1,['depend'],['dependabot']
Integrability,"ref=""https://redirect.github.com/python-pillow/Pillow/issues/7927"">#7927</a> from python-pillow/imagemath</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/f5eeeacf7539eaa0d93a677d7666bc7c142c8d1c""><code>f5eeeac</code></a> Name as 'options' in lambda_eval and unsafe_eval, but '_dict' in deprecated eval</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/facf3af93dabcbdd8cdbda8c3b50eefafa3bb04c""><code>facf3af</code></a> Added release notes</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/2a93aba5cfcf6e241ab4f9392c13e3b74032c061""><code>2a93aba</code></a> Use strncpy to avoid buffer overflow</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/a670597bc30e9d489656fc9d807170b8f3d7ca57""><code>a670597</code></a> Update CHANGES.rst [ci skip]</li>; <li>Additional commits viewable in <a href=""https://github.com/python-pillow/Pillow/compare/10.2.0...10.3.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=pillow&package-manager=pip&previous-version=10.2.0&new-version=10.3.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` w",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:15236,Depend,Dependabot,15236,https://qutip.org,https://github.com/qutip/qutip/pull/2381,2,"['Depend', 'depend']","['Dependabot', 'dependabot-badges']"
Integrability,"requests/issues/6688"">#6688</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/f1bb07d39b74d6444e333879f8b8a3d9dd4d2311""><code>f1bb07d</code></a> Merge pull request <a href=""https://redirect.github.com/psf/requests/issues/6687"">#6687</a> from psf/dependabot/github_actions/github/codeql-act...</li>; <li><a href=""https://github.com/psf/requests/commit/60047ade64b0b882cbc94e047198818ab580911e""><code>60047ad</code></a> Bump github/codeql-action from 3.24.0 to 3.25.0</li>; <li><a href=""https://github.com/psf/requests/commit/31ebb8102c00f8cf8b396a6356743cca4362e07b""><code>31ebb81</code></a> Merge pull request <a href=""https://redirect.github.com/psf/requests/issues/6682"">#6682</a> from frenzymadness/pytest8</li>; <li>Additional commits viewable in <a href=""https://github.com/psf/requests/compare/v2.31.0...v2.32.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=requests&package-manager=pip&previous-version=2.31.0&new-version=2.32.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` w",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:10018,depend,dependency-name,10018,https://qutip.org,https://github.com/qutip/qutip/pull/2434,1,['depend'],['dependency-name']
Integrability,"rer way: there's a ; > big risk of misinterpreting the operator.; >; > —; > You are receiving this because you modified the open/close state.; > Reply to this email directly, view it on GitHub ; > <https://github.com/qutip/qutip/issues/661#issuecomment-286282270>, or ; > mute the thread ; > <https://github.com/notifications/unsubscribe-auth/ABMPqSiIdpvqRZIZO2kklDrotB4b-6b0ks5rldpigaJpZM4MbmLX>.; >; > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 11:48; >; > When I tried to use the |qutip.squeeze| function for my simulations I ; > noticed that something was off. Upon further investigation I found out ; > that the output is not a truncated version of the single-mode ; > squeezing unitary, but rather the matrix exponential of the truncated ; > generator. These are /very/ different things!; >; > Am I right in assuming that the most useful matrix would be the ; > truncated unitary? If that's the case, the current method to compute ; > it is wrong. To compute the right matrix one can use the disentangling ; > formula for SU(1,1) (formula (31) here ; > <http://aip.scitation.org/doi/pdf/10.1063/1.3413923>):; >; > def squeeze(n,z):; > s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); > s1 = -2*np.log(np.cosh(abs(z))); > s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); >; > L = s0*0.5*(qt.create(n)*qt.create(n)); > K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); > R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); >; > return (L.expm())*(K.expm())*(R.expm()); >; > As you can see, this definition does /not/ depend on the truncation ; > parameter. Specifically, the upper-left portion of the matrix that ; > |qutip.squeeze| outputs converges to my |squeeze| function for large |n|.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub ; > <https://github.com/qutip/qutip/issues/661>, or mute the thread ; > <https://github.com/notifications/unsubscribe-auth/ABMPqdPPw6WOAYMpYw_kA9pRxVhgVyxIks5rlYF9gaJpZM4MbmLX>.; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286284316:1989,depend,depend,1989,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286284316,4,['depend'],['depend']
Integrability,"res</code> from <code>setup.cfg</code></li>; </ul>; <p><strong>0.38.2 (2022-11-05)</strong></p>; <ul>; <li>Fixed regression introduced in v0.38.1 which broke parsing of wheel file names with; multiple platform tags</li>; </ul>; <p><strong>0.38.1 (2022-11-04)</strong></p>; <ul>; <li>Removed install dependency on setuptools</li>; <li>The future-proof fix in 0.36.0 for converting PyPy's SOABI into a abi tag was; faulty. Fixed so that future changes in the SOABI will not change the tag.</li>; </ul>; <p><strong>0.38.0 (2022-10-21)</strong></p>; <ul>; <li>Dropped support for Python &lt; 3.7</li>; <li>Updated vendored <code>packaging</code> to 21.3</li>; <li>Replaced all uses of <code>distutils</code> with <code>setuptools</code></li>; <li>The handling of <code>license_files</code> (including glob patterns and default; values) is now delegated to <code>setuptools&gt;=57.0.0</code> (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/466"">#466</a>).; The package dependencies were updated to reflect this change.</li>; <li>Fixed potential DoS attack via the <code>WHEEL_INFO_RE</code> regular expression</li>; <li>Fixed <code>ValueError: ZIP does not support timestamps before 1980</code> when using; <code>SOURCE_DATE_EPOCH=0</code> or when on-disk timestamps are earlier than 1980-01-01. Such; timestamps are now changed to the minimum value before packaging.</li>; </ul>; <p><strong>0.37.1 (2021-12-22)</strong></p>; <ul>; <li>Fixed <code>wheel pack</code> duplicating the <code>WHEEL</code> contents when the build number has changed (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/415"">#415</a>)</li>; <li>Fixed parsing of file names containing commas in <code>RECORD</code> (PR by Hood Chatham)</li>; </ul>; <p><strong>0.37.0 (2021-08-09)</strong></p>; <ul>; <li>Added official Python 3.10 support</li>; <li>Updated vendored <code>packaging</code> library to v20.9</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2052:1747,depend,dependencies,1747,https://qutip.org,https://github.com/qutip/qutip/pull/2052,1,['depend'],['dependencies']
Integrability,"ress between time in `tlist` and take a snapshot of the state at these time. The work of this loop have been moved to 2 classes: `Result` and `Evolver`. . `Result` was previously just a container of the solver output. It now does the snapshot: compute the expectation values, save the state, compute trajectories average, etc. . `Evolver` is qutip's ODE solver interface: the states are `Data` object and the function is `QovjEvo`(or `QobjEvoFunc`). There are multiple type of evolver wrapping different scipy's ode solver and a few of our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Ad",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1055,depend,dependent,1055,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['depend'],['dependent']
Integrability,"result a lot. The `floquet_modes_mod` function that appears in the code below is exactly `floquet_modes`, only I modified it to also accept Options that are then passed to `propagator` (by the way, is there a smarter way to do this without defining this new function?). . ### Code to Reproduce the Bug. ```shell; from qutip import *; import numpy as np; import numpy.linalg as la; from numpy import angle, pi. # create a modified floquet_modes that also accepts Options; def floquet_modes_mod(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args, options = options). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1864:1719,depend,dependent,1719,https://qutip.org,https://github.com/qutip/qutip/issues/1864,1,['depend'],['dependent']
Integrability,"rint(opt). progress_bar : False; store_state : True; method : 'bdf'; atol : 1e-5; ...; ```; The option can also be initialized from a dict or another options instance, it will make a copy. I added the capacity to add a safety check when setting an options. It is only used for `use_cython` which will error when trying to set it to `True` without cython installed. Otherwise, it will fail when trying to use the options. *Solver's options*; Each solver has it's option class (SeOptions, MeOptions, etc.) with only needed keys.This somewhat feel overkill since they are all the some for now, until mcsolve is merged. Each integrator also has an associated options and the solver options contain an integrator options. Conversion between options type will raise an error. When creating a solver options, it read the `method` key and setup a matching integrator options. Thus only the keys used by the solver or integrator are defined in the instance. This allow adding new integrator with their own options without adding complexity to the solver options. It can be used as such:; ```; opt = SolverOptions(method='lsoda'); opt['progress_bar'] = False; opt.ode['max_order_ns'] = 10; ```; To make it work smoothly, each integrator must be associated to only one method thus `zvode` was split between `adams` and `bdf`. There is also a generic `Options` class that accept any keys used by integrator or solver and can be converted to any specific solver options:; ```; Options(futur_cupy_ode_specific_options=True) # Will work; Options(not_an_options=True) # Error; # For most solver:; __solve(..., opt=Options()); ```; Once options are associated to a solver, they are frozen:; ```; opt = SeOptions(); solver = SeSolver(..., opt); opt['...'] = ... # Ok, but solver has a copy and is unaffected.; solver.options['...'] = ... # Error; solver.options = opt; ```; This is because changing options without the solver knowing will not take effect. I removed saving / storing options for now. It was mostly used ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1812:1929,integrat,integrator,1929,https://qutip.org,https://github.com/qutip/qutip/pull/1812,1,['integrat'],['integrator']
Integrability,"rix multiplications, taking advantage the new Dense data layer. In particular, for cases where the density matrix/state has few zero's, and we want to multiply a local operator (e.g. one acting on only a small subset of the full system), this routine is expected to be faster. **What is does**; Using some standard tools, such as NumPy's einsum one can compute the local matrix operation directly, i.e. applying a one or two-local gate on a Qobj of many qubits. This is only really useful if one uses the Dense data layer, since otherwise there are conversion overheads which kill any speed-up (at the end of the day, we need NumPy arrays). The code has two 'backends', one using einsum as mentioned, and another using what I call a 'vectorization' approach (where the density matrix or vector is reshaped to a vector over the target qubits). Note: It will work on qudits in general (does not have to be qubits). **Performance**; I find, in systems where the state is dense (few zeros), one can get a speed-up of between 2 and up to around 10x faster (depends on the size and system etc). Of course, sometimes using the standard built in sparse routines are faster, so it really depends what one is doing. Attached is a wall-clock time comparison between the standard sparse way for a 1-local multiplication on a vector (using `gate_expand_1toN`), and the added code (dense local). N being the number of qubits. Here I made things as hard as possible for the sparse routine (all elements non-zero), so this is probably the limit of the speed-up. ![1_local_vector_adaptive_backend](https://user-images.githubusercontent.com/47875526/101932409-91f44900-3b8f-11eb-8b5b-7a00dabec2e4.png). **Other notes**; 1. I am a contractor for NASA, and they required a slight change to the license for the code I added. This is why I made two new files for this work specifically (instead of putting it in e.g. gates.py), which now includes a Copyright NASA sentence. I will talk privately with someone about this. 2",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405:1289,depend,depends,1289,https://qutip.org,https://github.com/qutip/qutip/pull/1405,1,['depend'],['depends']
Integrability,"rk4life""><code>@​aclark4life</code></a>]</li>; <li>Replaced further direct invocations of setup.py <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5906"">#5906</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added ImageShow support for xdg-open <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5897"">#5897</a> [<a href=""https://github.com/m-shinder""><code>@​m-shinder</code></a>]</li>; <li>Fixed typo <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5902"">#5902</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Switched from deprecated &quot;setup.py install&quot; to &quot;pip install .&quot; <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5896"">#5896</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support 16-bit grayscale ImageQt conversion <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5856"">#5856</a> [<a href=""https://github.com/cmbruns""><code>@​cmbruns</code></a>]</li>; <li>Fixed raising OSError in _safe_read when size is greater than SAFEBLOCK <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5872"">#5872</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Convert subsequent GIF frames to RGB or RGBA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5857"">#5857</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>WebP: Fix memory leak during decoding on failure <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5798"">#5798</a> [<a href=""https://github.com/ilai-deutel""><code>@​ilai-deutel</code></a>]</li>; <li>Do not prematurely return in ImageFile when saving to stdout <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5665"">#5665</a> [<a href=""https://github.com/inf",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:6030,depend,dependabot,6030,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"rlo: Time-dependent H (str format) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=True) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=False) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=True) ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as function list ... ok; > > > mesolve: simple time-dependence as partial function list ... ok; > > > mesolve: simple time-dependence as string list ... ok; > > > mesolve: simple constant decay ... ok; > > > mesolve: constant decay as function list ... ok; > > > mesolve: constant decay as string list ... ok; > > > mesolve: simple constant decay ... ok; > > > mesolve: simple constant decay ... ok; > > > Metrics: Checks that average gate fidelities are sensible for random ... ok; > > > odechecks: monte-carlo ... ok; > > > Spin 1/2 operators ... ok; > > > Spin 3/2 operators ... ok; > > > Spin 2 operators ... ok; > > > Spin 5/2 operators ... ok; > > > Destruction operator ... ok; > > > Creation operator ... ok; > > > Identity operator ... ok; > > > Number operator ... ok; > > > Squeezing operator ... ok; > > > Displacement operator ... ok; > > > parfor ... ok; > > > partial transpose of bipartite systems ... ok; > > > partial transpose: comparing sparse and dense implementations ... ok; > > > partial transpose: randomized tests on tripartite s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:5446,depend,dependence,5446,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,2,['depend'],['dependence']
Integrability,"rmed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventual",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2185,interface,interface,2185,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['interface'],['interface']
Integrability,roject.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/dense.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/integrator/explicit_rk.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/dispatch.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/__init__.pxd.; Compiling qutip/core/data/expect.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/_brtensor.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/permute.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/matmul.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/trace.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/norm.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/sode/_sode.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/_brtools.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/properties.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compi,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:7257,depend,depends,7257,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['depends']
Integrability,"rom <a href=""https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>9.0.0 (2022-01-02)</h2>; <ul>; <li>; <p>Restrict builtins for ImageMath.eval(). CVE-2022-22817 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5923"">#5923</a>; [radarhere]</p>; </li>; <li>; <p>Ensure JpegImagePlugin stops at the end of a truncated file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a>; [radarhere]</p>; </li>; <li>; <p>Fixed ImagePath.Path array handling. CVE-2022-22815, CVE-2022-22816 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5920"">#5920</a>; [radarhere]</p>; </li>; <li>; <p>Remove consecutive duplicate tiles that only differ by their offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5919"">#5919</a>; [radarhere]</p>; </li>; <li>; <p>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#5901</a>; [radarhere]</p>; </li>; <li>; <p>Limit quantized palette to number of colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5879"">#5879</a>; [radarhere]</p>; </li>; <li>; <p>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a>; [radarhere]</p>; </li>; <li>; <p>When saving RGBA to GIF, make use of first transparent palette entry <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5859"">#5859</a>; [radarhere]</p>; </li>; <li>; <p>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a>; [radarhere]</p>; </li>; <li>; <p>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a>; [radarhere]</p>; </li>; <li>; <p>Improved putdata() documentation and data",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:11224,depend,dependabot,11224,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"ropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo` does: In the benchmarking, there didn't seem to be any difference whether I wrap my nested lists into `QobjEvo` or not. Is there something specific that `QobjEvo` should enable that I can't do with nested lists?. > QuTiP 5 is (probably) going to formalise that (^) sort of low-level calling convention of `mesolve`, but it should work already. The new one look a bit different because instead of doing the setup very manually, there'll be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8198,interface,interface,8198,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['interface'],['interface']
Integrability,"rouble with the function mesolve. The situation is the following: I have a collection of Hamiltonians and Jump Operators which includes 69 timesteps each, and I want to evolve a initial state to each of this timesteps. However, Qutip is returning ""Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class."". I tryied to change nsteps parameter but it just doesnt work for any value of it, no matter how big the number is. H= Hamiltonian, shape: 69,2,2; list_Jump-op= Jump operators, shape:69,2,2; time= timesteps, shape (69,); estados_val= the different states that I want to evolve on this dynamics, shape( 6,69,2,2) . Note that I am only taking the 0th element on the axis with lenght of 69. predictions=[mesolve(H,; Qobj(estados_val[i][0]),; time,list_Jump_op,options=Options(nsteps=10000000000000000)) for i in range(len(estados_val))]. The terminal out put is; /home/andrius/anaconda3/lib/python3.8/site-packages/scipy/integrate/_ode.py:1013: UserWarning: zvode: Excess accuracy requested. (Tolerances too small.); warnings.warn('{:s}: {:s}'.format(self.__class__.__name__,; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-11-0bc27bfd6f01> in <module>; 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. <ipython-input-11-0bc27bfd6f01> in <listcomp>(.0); 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 pr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605:1022,integrat,integrate,1022,https://qutip.org,https://github.com/qutip/qutip/issues/1605,1,['integrat'],['integrate']
Integrability,"rray. Point 2 is mostly an extension of that: I'm not sure there is a sensible way for numpy's broadcasting rules to be applied to quantum objects as they exist now, even without extensions. ## More control over dispatch: `__array_ufunc__` and `__array_function__`. See [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html), [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html) and [NEP 35](https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html). Later versions of numpy allowed greater control over how ufuncs get implemented, which was most recently extended in 1.16 to cover non-ufuncs like `tensordot`. These functions are intended for classes to define how ufuncs operate on their data, but implementors should still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (mostly elementwise operations or reductions). Several libraries implement only these, but _not_ `__array__`, but given my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:6032,rout,route,6032,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['rout'],['route']
Integrability,"rtionError Traceback (most recent call last); Input In [11], in <cell line: 6>(); 2 return w * np.exp(-w); 4 out = brmesolve(sigmax(), psi0=basis(2,0), tlist=np.arange(0, 1, 0.01), a_ops=[[sigmax(), psd]]); ----> 6 assert len(out.states) == len(out.times), f'{len(out.states)} vs {len(out.times)}'. AssertionError: 10 vs 100; ```. ### Expected Behaviour. As we see, the above code does run and produces an output, but the states list is not the same as the times lists (these should be the same length as they have a 1-1 correspondence). It actually appears it has only given data for the first 10 time-steps in this case.; The same code works fine on Intel chip. ; We can increase the `nsteps` parameter to give the correct number of output states, but they do not agree with Intels output (also see below for related issue), and actually are not always even quantum states, so something in the solver went wrong. Another example, using the cython string formatting:. ```brmesolve([[sigmax(), 'cos(t)']], psi0=basis(2,0), tlist=np.arange(0, 1, 0.01), a_ops=[[sigmax(), '1']])``` works fine on Intel, but gives error ```Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.``` on M1. . Moreover, if I do increase the `nsteps` sufficiently, this does appear to run correctly, but the output states are not the same as we get on Intel (and so I assume are incorrect). ### Your Environment. ```shell; QuTiP Version: 4.7.0; Numpy Version: 1.21.6; Scipy Version: 1.7.3; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.9.13; Number of CPUs: 10; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); ```. ### Additional Context. A few random observations, hopefully not just an issue on my side due to my local configurations. I installed qutip via conda, and it generally seems to work fine on M1. In the meantime, everything runs as expected with Rosetta.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965:1784,integrat,integration,1784,https://qutip.org,https://github.com/qutip/qutip/issues/1965,1,['integrat'],['integration']
Integrability,"s (WIP)</li>; <li><a href=""https://github.com/python-babel/babel/commit/d1bbc08e845d03d8e1f0dfa0e04983d755f39cb5""><code>d1bbc08</code></a> import_cldr: use logging; add -q option</li>; <li><a href=""https://github.com/python-babel/babel/commit/156b7fb9f377ccf58c71cf01dc69fb10c7b69314""><code>156b7fb</code></a> Quiesce CLDR download progress bar if requested (or not a TTY)</li>; <li><a href=""https://github.com/python-babel/babel/commit/613dc1700f91c3d40b081948c0dd6023d8ece057""><code>613dc17</code></a> Make the import warnings about unsupported number systems less verbose</li>; <li>Additional commits viewable in <a href=""https://github.com/python-babel/babel/compare/v2.9.0...v2.9.1"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=babel&package-manager=pip&previous-version=2.9.0&new-version=2.9.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1695:3466,depend,dependabot-security-updates,3466,https://qutip.org,https://github.com/qutip/qutip/pull/1695,1,['depend'],['dependabot-security-updates']
Integrability,"s (there are some warnings, but unrelated to this pull request). However, the check here failed and I do not see a useful error message. Does someone have an idea what is going on?. The error in the documentation (HTTP Error 403) is unrelated the the actual build. It happen from time to time randomly... you can ignore it.; However the documentation build will fail on warnings. > * We have two example notebooks to add to qutip-notebooks. How to proceed in practice: do we open a separate pull request in qutip-notebooks?; ; qutip-notebook is no longer used, we migrated to qutip-tutorial. Please open a new PR there. > * The _run_one_traj function now exists 3 times, with practically identical code:; > https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L197; > https://github.com/qutip/qutip/blob/master/qutip/solver/mcsolve.py#L427; > https://github.com/pmenczel/qutip/blob/nonmarkovian-mcsolve/qutip/solver/nm_mcsolve.py#L160; > Maybe it would be a good idea to make the type of `Result` that is used for single trajectories generic in multi-trajectory solvers (just like the `resultclass` is already generic in solvers in general)? I have implemented that [here](https://github.com/pmenczel/qutip/commit/4a25709f90ed7c6dc2153011ee5a8110f3957c95) and could merge that commit into this PR if you think that's a good idea. There is a fourth `_run_one_traj` coming for the stochastic solver with also almost the same code...; Yes, some cleaning is needed and having a swap-able trajectory result class would be nice.; I looked at your implementation and it look fine.; I would just rename `trajectoryclass` to `trajectory_result_class` or something similar, otherwise it make me think it refer to the removed `TrajectorySolver`. > I've noticed a small bug that has gone unnoticed because of this: ""step"" [here](https://github.com/qutip/qutip/blob/master/qutip/solver/multitraj.py#L206) should be ""integrate"", I think. ; `step` was renamed to `integrate` a while ago. Good catch!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702:2086,integrat,integrate,2086,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1446867702,4,['integrat'],['integrate']
Integrability,"s and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... ok; BR Tools : dense operator to eigenbasis ... ok; BR Tools : vector to eigenbasis ... ok; BR Tools : eigvector to fockbasis ... ok; BR Tools : vector roundtrip transform ... ok; BR Tools : Diagonal liouvillian mult ... ok; BR Tools : cop_super_mult ... ok; BR Tools : br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (tau) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (Qobj) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (O",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576:1368,depend,dependent,1368,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576,2,['depend'],['dependent']
Integrability,"s changed (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/415"">#415</a>)</li>; <li>Fixed parsing of file names containing commas in <code>RECORD</code> (PR by Hood Chatham)</li>; </ul>; <p><strong>0.37.0 (2021-08-09)</strong></p>; <ul>; <li>Added official Python 3.10 support</li>; <li>Updated vendored <code>packaging</code> library to v20.9</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/pypa/wheel/commit/6f1608dc1a88f00d2390b9044bd655753f39234c""><code>6f1608d</code></a> Created a new release</li>; <li><a href=""https://github.com/pypa/wheel/commit/cf8f5ef50e32b836c4ffb43af68107f78dca8d80""><code>cf8f5ef</code></a> Moved news item from PR <a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/484"">#484</a> to its proper place</li>; <li><a href=""https://github.com/pypa/wheel/commit/9ec201660fa07ee0714edd17c979a7039ea852a4""><code>9ec2016</code></a> Removed install dependency on setuptools (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/483"">#483</a>)</li>; <li><a href=""https://github.com/pypa/wheel/commit/747e1f6090547abcf65108c5a229cbe21a64a2ae""><code>747e1f6</code></a> Fixed PyPy SOABI parsing (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/484"">#484</a>)</li>; <li><a href=""https://github.com/pypa/wheel/commit/76275484bc0de72d1f56601dbba3e816fc2f00c6""><code>7627548</code></a> [pre-commit.ci] pre-commit autoupdate (<a href=""https://github-redirect.dependabot.com/pypa/wheel/issues/480"">#480</a>)</li>; <li><a href=""https://github.com/pypa/wheel/commit/7b9e8e1022b9c850756ef34bc1a4a88042988a86""><code>7b9e8e1</code></a> Test on Python 3.11 final</li>; <li><a href=""https://github.com/pypa/wheel/commit/a04dfef41be0ab10eadbb2ed5d02b600682dc487""><code>a04dfef</code></a> Updated the pypi-publish action</li>; <li><a href=""https://github.com/pypa/wheel/commit/94bb62cb182023ac6586c5510ae9031ea56bd",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2052:3335,depend,dependency,3335,https://qutip.org,https://github.com/qutip/qutip/pull/2052,1,['depend'],['dependency']
Integrability,"s not seem to be compatible with a PEP517 build. The problem shows up in the Debian build of the qutip package. Debian provides its own tool (pybuild from the dh-python package) to manage the build of python packages. PEP517 is relatively new, so by default pybuild uses setup.py if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build, not PEP517 build); INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```. ### Additional Context. PEP517 support is new for Debian. It is possible the pybuild build tool needs to be adapted to handle setup.py option",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:1255,depend,dependency-check,1255,https://qutip.org,https://github.com/qutip/qutip/issues/1875,1,['depend'],['dependency-check']
Integrability,"s relatively new, so by default pybuild uses setup.py if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build, not PEP517 build); INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```. ### Additional Context. PEP517 support is new for Debian. It is possible the pybuild build tool needs to be adapted to handle setup.py options like `--with-openmp` in the context of PEP517. But I've tried to pose the issue here in terms of the underlying python3 build commands without needing to consider pybuild as such. Is there a different way in which `--with-ope",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:1479,depend,dependency-check,1479,https://qutip.org,https://github.com/qutip/qutip/issues/1875,1,['depend'],['dependency-check']
Integrability,"s simply a time-dependent weight from this point of view; * The ""improved sampling"" option for `mcsolve` weights the no-jump trajectory with its exact probability, and then only samples from the ensemble of trajectories with at least one jump. Currently, these two things cannot be combined: ""improved sampling"" does not work for `nm_mcsolve`. With these changes, it would work.; In the future, there might be at least one more application for weighted trajectories:; * For mixed initial states in `mcsolve`, it might be useful to allow sampling of initial states with frequencies or probabilities that are different from their true prefactor in the initial state. The ratio between the sampling frequencies and true prefactors would be weights on the trajectories. This also fixes some things in merging `McResult`s and `NmmcResult`s, and perhaps fixes the target tolerance computation for the ""improved sampling"" option. **Implementation**. A difficulty in the implementation is that the weights depend on the total number of trajectories in different ways. For example, the no-jump trajectory has a fixed weight that never changes, but all other trajectories come with prefactors $(1-p_0) / (N-1)$ where $p_0$ is the probability of the no-jump trajectory, and $N$ the total number of trajectories (including the one no-jump trajectory). For this reason, I separate weights into *absolute weights* (like $p_0$) and *relative weights* (like the others). The average is performed as follows:. $$ \bar\rho = \sum_{T: \text{abs}} w_a(T) w_r(T) \rho(T) + \frac{1}{N_{\text{rel}}} \sum _{T: \text{rel}} w_r(T) \rho(T) $$. where the first sum is over all trajectories T that have absolute weights, and the second sum over all other trajectories. Here, $w_a(T)$ and $w_r(T)$ are the absolute and relative weights, $\rho(T)$ the state associated with a trajectory, and $N_{\text{rel}}$ the number of trajectories that have not been assigned absolute weights. Intuitively, the idea is that absolute weights ar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2369:1242,depend,depend,1242,https://qutip.org,https://github.com/qutip/qutip/pull/2369,1,['depend'],['depend']
Integrability,"s tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:1048,depend,dependent,1048,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,2,['depend'],['dependent']
Integrability,"s/6416"">#6416</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/a7da1ab3498b10ec3a3582244c94b2845f8a8e71""><code>a7da1ab</code></a> try on ubuntu 22.04 (<a href=""https://redirect.github.com/psf/requests/issues/6418"">#6418</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/psf/requests/compare/v2.28.2...v2.31.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=requests&package-manager=pip&previous-version=2.28.2&new-version=2.31.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2164:7899,Depend,Dependabot,7899,https://qutip.org,https://github.com/qutip/qutip/pull/2164,1,['Depend'],['Dependabot']
Integrability,"s://github.com/urllib3/urllib3/commit/07bed791e9c391d8bf12950f76537dc3c6f90550""><code>07bed79</code></a> Fix deprecation warnings for Python 3.10 ssl module</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/d725a9b56bb8baf87c9e6eee0e9edf010034b63b""><code>d725a9b</code></a> Add Python 3.10 to GitHub Actions</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/339ad34c677c98fd9ad008de1d8bbeb9dbf34381""><code>339ad34</code></a> Use pytest==6.2.4 on Python 3.10+</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/f271c9c3149e20d7feffb6429b135bbb6c09ddf4""><code>f271c9c</code></a> Apply latest Black formatting</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/1884878aac87ef0494b282e940c32c24ee917d52""><code>1884878</code></a> [1.26] Properly proxy EOF on the SSLTransport test suite</li>; <li>See full diff in <a href=""https://github.com/urllib3/urllib3/compare/1.26.4...1.26.5"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=urllib3&package-manager=pip&previous-version=1.26.4&new-version=1.26.5)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1563:2838,Depend,Dependabot,2838,https://qutip.org,https://github.com/qutip/qutip/pull/1563,2,"['Depend', 'depend']","['Dependabot', 'dependabot-badges']"
Integrability,same Time-dependent Hamiltonian but different evolution result,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2161:10,depend,dependent,10,https://qutip.org,https://github.com/qutip/qutip/issues/2161,1,['depend'],['dependent']
Integrability,"says which input arguments are meant to be dispatched on, and whether the output should be dispatched on, and all other arguments are passed through like normal. #### Implementation details. The backing specialisations can be found in `Dispatcher._specialisations`, and the complete lookup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lifting is done when `add_specialisations` or `rebuild_lookup` is called. On call, the generic signature `(*args, **kwargs)` has to be bound to the actual ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338:16411,depend,depend,16411,https://qutip.org,https://github.com/qutip/qutip/pull/1338,1,['depend'],['depend']
Integrability,"se a warning if NumPy failed to raise an error during conversion <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6594"">#6594</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Only read a maximum of 100 bytes at a time in IMT header <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6623"">#6623</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Show all frames in ImageShow <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6611"">#6611</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow FLI palette chunk to not be first <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6626"">#6626</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>If first GIF frame has transparency for RGB_ALWAYS loading strategy, use RGBA mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6592"">#6592</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Round box position to integer when pasting embedded color <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6517"">#6517</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed EXIF prefix when saving WebP <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6582"">#6582</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pad IM palette to 768 bytes when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6579"">#6579</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added DDS BC6H reading <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6449"">#6449</a> [<a href=""https://github.com/ShadelessFox""><code>@​ShadelessFox</code></a>]</li>; <li>Added support f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:6574,depend,dependabot,6574,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,sesolve with list func time-dependence and rhs_with_state option will fail?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/824:28,depend,dependence,28,https://qutip.org,https://github.com/qutip/qutip/issues/824,1,['depend'],['dependence']
Integrability,"site may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67AJF3WTZBCU4YWFY23RRMHMHANCNFSM4LCKXE6A>; > .; >; -- ; Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:1341,interface,interface,1341,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,1,['interface'],['interface']
Integrability,"sl""><code>@​DWesl</code></a>]</li>; <li>Changed error type to allow for incremental WebP parsing <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5404"">#5404</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#5901</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Ensure that BMP pixel data offset does not ignore palette <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5899"">#5899</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit quantized palette to number of colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5879"">#5879</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use latin1 encoding to decode bytes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5870"">#5870</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>When saving RGBA to GIF, make use of first transparent palette entry <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5859"">#5859</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</co",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:2943,depend,dependabot,2943,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"so accept Options that are then passed to `propagator` (by the way, is there a smarter way to do this without defining this new function?). . ### Code to Reproduce the Bug. ```shell; from qutip import *; import numpy as np; import numpy.linalg as la; from numpy import angle, pi. # create a modified floquet_modes that also accepts Options; def floquet_modes_mod(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args, options = options). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sor",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1864:1849,depend,dependence,1849,https://qutip.org,https://github.com/qutip/qutip/issues/1864,1,['depend'],['dependence']
Integrability,"sounds good to me. On 10 Jan 2017 07:30, ""Paul Nation"" <notifications@github.com> wrote:. > A faster isherm function. 3-5x faster if operator is Hermitian, 100x+; > faster if not. Essentially does a modified adjoint calculation. This; > requires having a csr matrix in canonical format, which is not guaranteed; > under sparse multiplication. Since canonical format is important for; > time-dependent dynamics as well, fast_csr_matrix now does the indices and; > data sorting for canonical format after multiplication. This gives a slight; > performance hit, but having all Qobj in canonical format outweighs this.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/qutip/qutip/pull/629; > Commit Summary; >; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - ENH: Faster isherm; >; > File Changes; >; > - *M* qutip/cy/spmath.pyx; > <https://github.com/qutip/qutip/pull/629/files#diff-0> (82); >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/629#issuecomment-271928375:391,depend,dependent,391,https://qutip.org,https://github.com/qutip/qutip/pull/629#issuecomment-271928375,1,['depend'],['dependent']
Integrability,"specific to some methods. SInce new integrators could be added by project such as qutip-cupy, `Options` can no longer be the place to list all supported options. It become little more that a dict. So I propose deprecating it. The documentation of `sesolve`, `mesolve`, etc. now list the options used by the solver and most common ode options and link the the integrator documentation. The class interface has the options property which document the options used by the solver and the integrators have the same. In the online documentation, the integrator api entries only contain the description of the method and the supported options. Since users don't need to call them directly, other methods are hidden and will be included in the dev documentation only. Usage will look like this, for functions:; ```; sesolve(H, psi, tlist, options={""store_states"": True, ""method"": ""lsoda"", ""atol"": 1e-5}); ```; and for the class interface:; ```; solver = SeSolver(H, options={""store_states"": True, ""method"": ""lsoda"", ""atol"": 1e-5}); solver.run(...); solver.options[""atol""] = 1e-9; solver.run(...) # run with the new tol.; solver.options = {""atol"": 1e-2} # only change the affected items. ; solver.run(...) # Also run with the new tol.; solver.options[""method""] = ""adams"" # reset all ode options, including ""atol"" supported by both.; solver.options = {""method"": ""bdf"", ""atol"": 1e-2} # reset all ode options then apply the new atol ; ```. Inside solvers, options are stored in a `_SolverOptions` which is a dict with frozen keys and feedback (chaging atol will reset the integrator).; ; Some `Intergrator` are slip so one method correspond to one integrator. Otherwise, `method` was an options used by both the solver to know which integrator to use and by some integrators. `Options` and `SolverOptions` still both exist for backward compatibility: they raise a warning but return the dict of the same options so the change should not immediately break any code. **Related issues or PRs**; Alternative to #1947",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1955:1834,integrat,integrator,1834,https://qutip.org,https://github.com/qutip/qutip/pull/1955,4,['integrat'],"['integrator', 'integrators']"
Integrability,"ssues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed experiment on a small subset of tests, which are more suited to property-based testing, and examining how that affects the test-run-completion time(s) and whether it introduces more failures than what would be desired/cost-efficient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2780,depend,depending,2780,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['depend'],['depending']
Integrability,"ssues/287"">#287</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/1fc808626a895a916b1e4c2b63abae6c5eafdbe3""><code>1fc8086</code></a> Bump peter-evans/create-pull-request from 6.0.4 to 6.0.5 (<a href=""https://redirect.github.com/certifi/python-certifi/issues/288"">#288</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/certifi/python-certifi/compare/2023.07.22...2024.07.04"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=certifi&package-manager=pip&previous-version=2023.7.22&new-version=2024.7.4)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2483:3355,depend,dependabot-automerge-start,3355,https://qutip.org,https://github.com/qutip/qutip/pull/2483,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,"ssues/6330"">#6330</a>; [nulano]</p>; </li>; <li>; <p>Use double quotes for version check on old CPython on Windows <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6695"">#6695</a>; [hugovk]</p>; </li>; <li>; <p>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a>; [cgohlke]</p>; </li>; <li>; <p>Fixed set_variation_by_name offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6445"">#6445</a>; [radarhere]</p>; </li>; <li>; <p>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a>; [cgohlke]</p>; </li>; <li>; <p>Release Python GIL when converting images using matrix operations <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6418"">#6418</a>; [hmaarrfk]</p>; </li>; <li>; <p>Added ExifTags enums <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6630"">#6630</a>; [radarhere]</p>; </li>; <li>; <p>Do not modify previous frame when calculating delta in PNG <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6683"">#6683</a>; [radarhere]</p>; </li>; <li>; <p>Added support for reading BMP images with RLE4 compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6674"">#6674</a>; [npjg, radarhere]</p>; </li>; <li>; <p>Decode JPEG compressed BLP1 data in original mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6678"">#6678</a>; [radarhere]</p>; </li>; <li>; <p>Added GPS TIFF tag info <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6661"">#6661</a>; [radarhere]</p>; </li>; <li>; <p>Added conversion between RGB/RGBA/RGBX and LAB <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6647"">#6647</a>; [radarhere]</p>; </li>; <li>; <p>Do not attempt normalization if mode i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:11908,depend,dependabot,11908,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"ssues/6695"">#6695</a>; [hugovk]</p>; </li>; <li>; <p>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a>; [cgohlke]</p>; </li>; <li>; <p>Fixed set_variation_by_name offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6445"">#6445</a>; [radarhere]</p>; </li>; <li>; <p>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a>; [cgohlke]</p>; </li>; <li>; <p>Release Python GIL when converting images using matrix operations <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6418"">#6418</a>; [hmaarrfk]</p>; </li>; <li>; <p>Added ExifTags enums <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6630"">#6630</a>; [radarhere]</p>; </li>; <li>; <p>Do not modify previous frame when calculating delta in PNG <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6683"">#6683</a>; [radarhere]</p>; </li>; <li>; <p>Added support for reading BMP images with RLE4 compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6674"">#6674</a>; [npjg, radarhere]</p>; </li>; <li>; <p>Decode JPEG compressed BLP1 data in original mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6678"">#6678</a>; [radarhere]</p>; </li>; <li>; <p>Added GPS TIFF tag info <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6661"">#6661</a>; [radarhere]</p>; </li>; <li>; <p>Added conversion between RGB/RGBA/RGBX and LAB <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6647"">#6647</a>; [radarhere]</p>; </li>; <li>; <p>Do not attempt normalization if mode is already normal <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6644"">#6644</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:12093,depend,dependabot,12093,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"st method to GET after HTTP 303 &quot;See Other&quot; redirect responses.</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/urllib3/urllib3/commit/9c2c2307dd1d6af504e09aac0326d86ee3597a0b""><code>9c2c230</code></a> Release 1.26.18 (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3159"">#3159</a>)</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/b594c5ceaca38e1ac215f916538fb128e3526a36""><code>b594c5c</code></a> Merge pull request from GHSA-g4mx-q9vg-27p4</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/944f0eb134485f41bc531be52de12ba5a37bca73""><code>944f0eb</code></a> [1.26] Use vendored six in urllib3.contrib.securetransport</li>; <li>See full diff in <a href=""https://github.com/urllib3/urllib3/compare/1.26.17...1.26.18"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=urllib3&package-manager=pip&previous-version=1.26.17&new-version=1.26.18)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2246:1723,depend,dependency-name,1723,https://qutip.org,https://github.com/qutip/qutip/pull/2246,1,['depend'],['dependency-name']
Integrability,"st_public_api.py</li>; <li><a href=""https://github.com/numpy/numpy/commit/7662c0789cc6a70d5ad4d950ee2e95f3afef7df6""><code>7662c07</code></a> Update <strong>init</strong>.py</li>; <li><a href=""https://github.com/numpy/numpy/commit/311ab52488a7d096ac3bc4c2de0fdae17ecd13ef""><code>311ab52</code></a> Update armccompiler.py</li>; <li>Additional commits viewable in <a href=""https://github.com/numpy/numpy/compare/v1.21.0...v1.22.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.21.0&new-version=1.22.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:5555,depend,dependabot-automerge-start,5555,https://qutip.org,https://github.com/qutip/qutip/pull/1940,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,"stalled.; > > > Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (Bucky) ... ok; > > > Graph: Reverse Cuthill-McKee Ordering (boost) ... ok; > > > Monte-carlo: Constant H with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H (str format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (func format) with no collapse ops (expect) ... ok; > > > Monte-carlo: Constant H (str format) with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H (func format) with no collapse ops (states) ... ok; > > > Monte-carlo: Constant H with constant collapse ... ok; > > > Monte-carlo: Constant H with single collapse operator ... ok; > > > Monte-carlo: Constant H with single expect operator ... ok; > > > Monte-carlo: Collapse terms constant (func format) ... ok; > > > Monte-carlo: Collapse terms constant (str format) ... ok; > > > Monte-carlo: Time-dependent H (func format) ... ok; > > > Monte-carlo: Time-dependent H (str format) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=True) ... ok; > > > Monte-carlo: check for correct dtypes (average_states=False) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=True) ... ok; > > > mcsolve_f90: check for correct dtypes (average_states=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... ok; > > > mesolve: qubit without dissipation ... ok; > > > mesolve: simple time-dependence as fu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:4400,depend,dependent,4400,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,2,['depend'],['dependent']
Integrability,step function in string-version of time dependent Hamiltonians,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1240:40,depend,dependent,40,https://qutip.org,https://github.com/qutip/qutip/issues/1240,1,['depend'],['dependent']
Integrability,"strict builtins for ImageMath.eval(). CVE-2022-22817 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5923"">#5923</a>; [radarhere]</p>; </li>; <li>; <p>Ensure JpegImagePlugin stops at the end of a truncated file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a>; [radarhere]</p>; </li>; <li>; <p>Fixed ImagePath.Path array handling. CVE-2022-22815, CVE-2022-22816 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5920"">#5920</a>; [radarhere]</p>; </li>; <li>; <p>Remove consecutive duplicate tiles that only differ by their offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5919"">#5919</a>; [radarhere]</p>; </li>; <li>; <p>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#5901</a>; [radarhere]</p>; </li>; <li>; <p>Limit quantized palette to number of colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5879"">#5879</a>; [radarhere]</p>; </li>; <li>; <p>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a>; [radarhere]</p>; </li>; <li>; <p>When saving RGBA to GIF, make use of first transparent palette entry <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5859"">#5859</a>; [radarhere]</p>; </li>; <li>; <p>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a>; [radarhere]</p>; </li>; <li>; <p>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a>; [radarhere]</p>; </li>; <li>; <p>Improved putdata() documentation and data handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5910"">#5910</a>; [radarhere]</p>; </li>; <li>; <p>Exclude carriage return in PDF reg",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:11394,depend,dependabot,11394,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"t I've been working on. Beyond that, I've been working on adding a third system to this paper I'm; working on that describes FLiME. This third system should be able to show; changes based on the time_sense argument that aren't shown with the other; two systems, as those systems are so dominated by their primary frequency; that relaxing the secular approximation doesn't seem to change much in; terms of the results. The happy side effect is that I've had to fix some; issues with dimensionality that Eric mentioned, such that it ended up being; good bug testing for FLiMESolve as well. I'm hoping to have another pull request ready for review by the end of this; week or early next week, but I'm trying to really put everything under a; magnifying glass to the best of my ability, such that I don't leave Eric; wading through a bunch of formatting and code issues again. On Wed, Jul 5, 2023 at 3:33 PM Simon Cross ***@***.***> wrote:. > @magnamancer <https://github.com/magnamancer> I think part of the issue; > was that you merged qutip-5.0.X into master but that shouldn't have been; > done because master now contains the latest 5.X qutip code.; >; > Sorry to be a pain, but could you open a new new PR with just your; > changes? No need to be fancy -- just create a new branch from master, copy; > across the files you want to change, create PR.; >; > The VERSION file should not be changed.; >; > How hard would it be to add tests? I remember you have tests in a notebook; > somewhere. If you can point me at the latest versions, I can think about; > how to convert them into unit tests and add them to the new PR.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1622360050>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5AU2Z2WLCVH7BFC2QLXOW6QNANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >. -- ; Best Regards,; Fenton Clawson",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036:2516,Message,Message,2516,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1622617036,1,['Message'],['Message']
Integrability,"t handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conversion, if you want, or we could organise a small round table among a bunch of developers to talk about this on skype, but for now, all i'm asking, is to agree on the design of an interface to allow easy conversion of objects to qutip objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:3536,interface,interface,3536,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['interface'],['interface']
Integrability,"t some point we do `qeye(L.shape[0])` instead of `qeye(L.dims[0])`. There's sometimes quite a bit of that in older code - it used to slip through because we weren't super strict about dimension handling, so in certain cases (like this one), we'd accept bad dimensions. I might try and have a look tonight (UK time), if I have time - I've wanted to break up the large `propagator` monolith into smaller components for quite a while. ---. About numerical precision: if you want to try increasing the precision of the integrators, try passing `options=qutip.Options(nsteps=1_000_000, atol=1e-12, rtol=1e-10)` to `propagator`. `atol` and `rtol` are absolute and relative tolerances respectively, and `nsteps` is the number of subdivisions the integrator is _allowed_ to take (if it reaches its tolerance goals, it won't take all of them). You'll find that `atol` and `rtol` will have only a loose relation to the tolerance of your fidelity value, because there's a _lot_ of floating-point operations between those points in which the errors compound, and there's a hard limit on the tolerances the integrator can achieve, so you might not be able to get a perfect answer. The fidelity calculation involves finding the square root of a density operator, so that's another large possible source of error. About times: if you only care about the state at the last time, setting `tlist = np.linspace(0, x, 201)` is quite inefficient. Instead, set `tlist = [0, x]`, and then pass `options=qutip.Options(nsteps=<very very big integer>)`. It's more efficient because it doesn't need to achieve tolerance goals and construct/store `Qobj` instances at every intermediate timestep. Temporary workaround: this is _very_ temporary, and generally a bad idea in QuTiP, but you can ""flatten"" all your operators into a single space for now, while we implement a fix. To do that:; ```python; # initial setup; H = qutip.tensor(...); c_ops = [qutip.tensor(...)]. original_dimensions = H.dims.copy(); new_dimensions = list(H.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199:1147,integrat,integrator,1147,https://qutip.org,https://github.com/qutip/qutip/issues/1585#issuecomment-865903199,1,['integrat'],['integrator']
Integrability,"t there's a `correlation` test that takes around 2 minutes to run, which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because I now install _all_ optional dependencies in most runners, so slightly more gets tested than before. Currently there's also a slowdown on several machines because `cvxpy` doesn't build many wheels, and none at all for Linux, on `pip`. I install all our dependencies except BLAS/LAPACK stuff that way, since it's easiest to read out the dependencies like that. We can potentially save some build time (maybe ~3 minutes?) if we install that from conda-forge instead. I also fixed a minor point of how environment variables are read within `setup.py` (in the end I didn't actually use the new behaviour in the action, but I did during testing), and added a warning filter on dnorm tests to account for a deprecated Numpy alias being used within `cvxpy` code. Also of note: this [should allow us to have commits that skip the testing stages](https://github.blog/changelog/2021-02-08-github-actions-skip-pull-request-and-push-workflows-with-skip-ci/) (though possibly not codeclimate). You sho",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:2030,depend,dependencies,2030,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['depend'],['dependencies']
Integrability,"t to multiply a local operator (e.g. one acting on only a small subset of the full system), this routine is expected to be faster. **What is does**; Using some standard tools, such as NumPy's einsum one can compute the local matrix operation directly, i.e. applying a one or two-local gate on a Qobj of many qubits. This is only really useful if one uses the Dense data layer, since otherwise there are conversion overheads which kill any speed-up (at the end of the day, we need NumPy arrays). The code has two 'backends', one using einsum as mentioned, and another using what I call a 'vectorization' approach (where the density matrix or vector is reshaped to a vector over the target qubits). Note: It will work on qudits in general (does not have to be qubits). **Performance**; I find, in systems where the state is dense (few zeros), one can get a speed-up of between 2 and up to around 10x faster (depends on the size and system etc). Of course, sometimes using the standard built in sparse routines are faster, so it really depends what one is doing. Attached is a wall-clock time comparison between the standard sparse way for a 1-local multiplication on a vector (using `gate_expand_1toN`), and the added code (dense local). N being the number of qubits. Here I made things as hard as possible for the sparse routine (all elements non-zero), so this is probably the limit of the speed-up. ![1_local_vector_adaptive_backend](https://user-images.githubusercontent.com/47875526/101932409-91f44900-3b8f-11eb-8b5b-7a00dabec2e4.png). **Other notes**; 1. I am a contractor for NASA, and they required a slight change to the license for the code I added. This is why I made two new files for this work specifically (instead of putting it in e.g. gates.py), which now includes a Copyright NASA sentence. I will talk privately with someone about this. 2. ~~I actually think that we could make a wrapper function `local_multiply` which can additionally take a backend 'sparse', so that it is easier to",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405:1382,rout,routines,1382,https://qutip.org,https://github.com/qutip/qutip/pull/1405,2,"['depend', 'rout']","['depends', 'routines']"
Integrability,"t.com/ipython/ipython/issues/13427"">#13427</a>: wn 731</li>; <li><a href=""https://github.com/ipython/ipython/commit/7f253dcf7b1c3a791a98d44b0dfc848d62bd27df""><code>7f253dc</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/ipython/ipython/issues/13412"">#13412</a> from bnavigator/backport-inspect</li>; <li><a href=""https://github.com/ipython/ipython/commit/4f26796cf368d24edadbb3d62e052e6aa4ddc820""><code>4f26796</code></a> fix xxlimited_35 import name</li>; <li><a href=""https://github.com/ipython/ipython/commit/77ca4a6312374f0659fb6973925e5b696d5dc74e""><code>77ca4a6</code></a> don't run nose-based iptest on py310, only pytest</li>; <li><a href=""https://github.com/ipython/ipython/commit/533e5094aa36b51549cf6a316fc439c6404643c9""><code>533e509</code></a> back to decorator skip</li>; <li>Additional commits viewable in <a href=""https://github.com/ipython/ipython/compare/7.22.0...7.31.1"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ipython&package-manager=pip&previous-version=7.22.0&new-version=7.31.1)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1780:2158,Depend,Dependabot,2158,https://qutip.org,https://github.com/qutip/qutip/pull/1780,2,"['Depend', 'depend']","['Dependabot', 'dependabot-badges']"
Integrability,"t.dependabot.com/python-pillow/Pillow/issues/5570"">#5570</a>; [hugovk, radarhere]</p>; </li>; <li>; <p>Ensure TIFF <code>RowsPerStrip</code> is multiple of 8 for JPEG compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5588"">#5588</a>; [kmilos, radarhere]</p>; </li>; <li>; <p>Updates for <code>ImagePalette</code> channel order <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5599"">#5599</a>; [radarhere]</p>; </li>; <li>; <p>Hide FriBiDi shim symbols to avoid conflict with real FriBiDi library <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5651"">#5651</a>; [nulano]</p>; </li>; </ul>; <h2>8.3.1 (2021-07-06)</h2>; <ul>; <li>; <p>Catch OSError when checking if fp is sys.stdout <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5585"">#5585</a>; [radarhere]</p>; </li>; <li>; <p>Handle removing orientation from alternate types of EXIF data <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5584"">#5584</a>; [radarhere]</p>; </li>; <li>; <p>Make Image.<strong>array</strong> take optional dtype argument <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5572"">#5572</a>; [t-vi, radarhere]</p>; </li>; </ul>; <h2>8.3.0 (2021-07-01)</h2>; <ul>; <li>; <p>Use snprintf instead of sprintf. CVE-2021-34552 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5567"">#5567</a>; [radarhere]</p>; </li>; <li>; <p>Limit TIFF strip size when saving with LibTIFF <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5514"">#5514</a>; [kmilos]</p>; </li>; <li>; <p>Allow ICNS save on all operating systems <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4526"">#4526</a>; [baletu, radarhere, newpanjing, hugovk]</p>; </li>; <li>; <p>De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/is",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:5705,depend,dependabot,5705,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['depend'],['dependabot']
Integrability,"t/51716c4ef390136b0d4b800ec7665dd5503e64fc""><code>51716c4</code></a> enable the warnings plugin (<a href=""https://redirect.github.com/psf/requests/issues/6416"">#6416</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/a7da1ab3498b10ec3a3582244c94b2845f8a8e71""><code>a7da1ab</code></a> try on ubuntu 22.04 (<a href=""https://redirect.github.com/psf/requests/issues/6418"">#6418</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/psf/requests/compare/v2.28.2...v2.31.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=requests&package-manager=pip&previous-version=2.28.2&new-version=2.31.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2164:7780,depend,dependabot,7780,https://qutip.org,https://github.com/qutip/qutip/pull/2164,1,['depend'],['dependabot']
Integrability,"t/799a6a01052cea3f417a571d7c64cd14acc18c64""><code>799a6a0</code></a> Fix linting</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/00b25fd3ac3648bc28eff5d4c4d816e605e3f05f""><code>00b25fd</code></a> Hide UserWarning in logs</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/05b175ef88c22f5c416bc9b8d5b897dea1abbf2c""><code>05b175e</code></a> Tighter test case</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/13f2c5ae14901c89c38f898496102afd9daeaf6d""><code>13f2c5a</code></a> Prevent DOS with large SAMPLESPERPIXEL in Tiff IFD</li>; <li>Additional commits viewable in <a href=""https://github.com/python-pillow/Pillow/compare/9.0.1...9.3.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=pillow&package-manager=pip&previous-version=9.0.1&new-version=9.3.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:15423,depend,dependabot-security-updates,15423,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot-security-updates']
Integrability,"t/a011765b44febfb11bae122d2ed7db763621ac8f""><code>a011765</code></a> Isolate the attack tests with setUp and tearDown methods</li>; <li><a href=""https://github.com/ipython/ipython/commit/c7a9470e540392c575aac46c3ee5cf4fe5123eb1""><code>c7a9470</code></a> Add some regression tests for this change</li>; <li><a href=""https://github.com/ipython/ipython/commit/fd34cf5f1f6e243243c738c6e0cf62eb682c4d68""><code>fd34cf5</code></a> Swallow potential exceptions from showtraceback()</li>; <li>Additional commits viewable in <a href=""https://github.com/ipython/ipython/compare/7.31.1...8.10.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ipython&package-manager=pip&previous-version=7.31.1&new-version=8.10.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2085:2524,Depend,Dependabot,2524,https://qutip.org,https://github.com/qutip/qutip/pull/2085,1,['Depend'],['Dependabot']
Integrability,t__.pxd.; Compiling qutip/core/data/norm.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/sode/_sode.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/_brtools.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/properties.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/adjoint.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/kron.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/pow.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/base.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/piqs/_piqs.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/reshape.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/inner.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/cy/_element.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/31] Cythonizing qutip/core/_brtools.pyx; [ 2/31] Cythonizing qutip/core/cy/coefficient.pyx; [ 3/31] Cythonizing qutip/core/cy/math.p,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:8638,depend,depends,8638,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['depends']
Integrability,ta/properties.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/adjoint.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/kron.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/pow.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/base.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/piqs/_piqs.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/reshape.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/inner.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/cy/_element.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/31] Cythonizing qutip/core/_brtools.pyx; [ 2/31] Cythonizing qutip/core/cy/coefficient.pyx; [ 3/31] Cythonizing qutip/core/cy/math.pyx; [ 4/31] Cythonizing qutip/core/data/add.pyx; [ 5/31] Cythonizing qutip/core/data/base.pyx; [ 6/31] Cythonizing qutip/core/data/csr.pyx; [ 7/31] Cythonizing qutip/core/data/dense.pyx; [ 8/31] Cythonizing qutip/core/data/dia.pyx; [ 9/31] Cythonizing qutip/core/data/dispatch.pyx; [10/31] Cythonizing qutip/core/data/matmul.pyx; [11/31] Cythonizing qutip/core/data/mul.pyx; [12/31] Cythonizing qutip/core/data/norm.pyx; [13/31] Cythonizing qutip/core/data/permute.pyx; [14,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:9111,depend,depends,9111,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['depends']
Integrability,ta/properties.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/integrator/explicit_rk.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/inner.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/kron.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/base.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/csr.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/permute.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/pow.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/trace.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/adjoint.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/piqs/_piqs.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:6525,depend,depends,6525,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['depend'],['depends']
Integrability,"tack tests with setUp and tearDown methods</li>; <li><a href=""https://github.com/ipython/ipython/commit/c7a9470e540392c575aac46c3ee5cf4fe5123eb1""><code>c7a9470</code></a> Add some regression tests for this change</li>; <li><a href=""https://github.com/ipython/ipython/commit/fd34cf5f1f6e243243c738c6e0cf62eb682c4d68""><code>fd34cf5</code></a> Swallow potential exceptions from showtraceback()</li>; <li>Additional commits viewable in <a href=""https://github.com/ipython/ipython/compare/7.31.1...8.10.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=ipython&package-manager=pip&previous-version=7.31.1&new-version=8.10.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2085:2670,depend,dependabot,2670,https://qutip.org,https://github.com/qutip/qutip/pull/2085,1,['depend'],['dependabot']
Integrability,"tained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H with single expect operator ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=True) ... ok; > > > mcsolve_f90: check for correct dtypes (mc_avg=False) ... ok; > > > mesolve: cavity-qubit interaction, no dissipation ... ok; > > > mesolve: cavity-qubit without interaction, decay ... ok; > > > mesolve: cavity-qubit with interaction, decay ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 5.72e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126:2757,depend,dependent,2757,https://qutip.org,https://github.com/qutip/qutip/issues/126,1,['depend'],['dependent']
Integrability,"te(ann_operators):; H_r += (w[i] - drive_w) * a.dag() * a. H_int = 0; for i in range(len(ann_operators)-1):; H_int += J[i] * (ann_operators[i].dag() * ann_operators[i+1] + ann_operators[i+1].dag() * ann_operators[i]). H_d = -1j * drive_amp * (ann_operators[0] - ann_operators[0].dag()). H = H_r + H_int + H_d. c_ops = [np.sqrt(kappa)*ann_operators[0], np.sqrt(kappa)*ann_operators[-1]]. rho_ss = steadystate(H, c_ops). a_out = np.sqrt(kappa) * expect(ann_operators[-1], rho_ss); t.append(np.sqrt(kappa) * a_out/drive_amp). print(""J = "", np.array(J)/(2 * np.pi)); print(""w = "", np.array(w)/(2 * np.pi)); print(""kappa = "", kappa/2/np.pi); t = np.array(t); plt.plot(detuning_list/2/np.pi, 20 * np.log10(np.abs(t))); plt.xlabel(""Detuning (GHz)""); plt.ylabel(""|S21|(dB)""); plt.ylim(-10,0.01); # plt.xlim(-2, 2); plt.grid(); ```. ### Code Output. ```shell; {; 	""name"": ""ValueError"",; 	""message"": ""Provided dimensions do not match the data: (65536, 65536) vs (17, 17)"",; 	""stack"": ""---------------------------------------------------------------------------; ValueError Traceback (most recent call last); Cell In[2], line 39; 35 H = H_r + H_int + H_d; 37 c_ops = [np.sqrt(kappa)*ann_operators[0], np.sqrt(kappa)*ann_operators[-1]]; ---> 39 rho_ss = steadystate(H, c_ops); 41 a_out = np.sqrt(kappa) * expect(ann_operators[-1], rho_ss); 42 t.append(np.sqrt(kappa) * a_out/drive_amp). File /opt/anaconda3/envs/trial_env/lib/python3.11/site-packages/qutip/solver/steadystate.py:177, in steadystate(A, c_ops, method, solver, **kwargs); 175 kwargs.pop(\""power_eps\"", 0); 176 kwargs.pop(\""sparse\"", 0); --> 177 return _steadystate_direct(A, kwargs.pop(\""weight\"", 0),; 178 method=solver, **kwargs); 180 elif method == \""power\"":; 181 # Remove unused kwargs, so only used and pass-through ones are included; 182 kwargs.pop(\""weight\"", 0). File /opt/anaconda3/envs/trial_env/lib/python3.11/site-packages/qutip/solver/steadystate.py:246, in _steadystate_direct(A, weight, **kw); 243 rho_ss = _data.column_unstack(stea",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2386:2072,message,message,2072,https://qutip.org,https://github.com/qutip/qutip/issues/2386,1,['message'],['message']
Integrability,"te0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamiltonian', ...),; ('add-c_op', ...),; # possible examples of API commands; ]); except StopIteration:; pass; ```; That's not super user friendly, but it _is_ nicely re-entrant. You'd have a single object you can copy and branch off, and QuTiP would be able to update the relevant objects ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1671,rout,routine,1671,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['rout'],['routine']
Integrability,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13066,integrat,integrate,13066,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,4,['integrat'],"['integrate', 'integrator']"
Integrability,"ted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work well but they need to be removed for the new signature candidate (`f(t, **args)`). Also you cannot remove / fix to a constant them once declared. Since they are not used/working yet, now is the time to change to something better. I could see 2 other options:; - reserved keys: `args = {""state_vec"":psi0}`, this will always be the state (np.array) if available.; -- collapse are less practical this way.; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136:1389,depend,depend,1389,https://qutip.org,https://github.com/qutip/qutip/issues/1136,1,['depend'],['depend']
Integrability,tensor contract on sparse matrix,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883:7,contract,contract,7,https://qutip.org,https://github.com/qutip/qutip/pull/883,1,['contract'],['contract']
Integrability,"tents/lib/python2.7/distutils/dist.py"", line 953, in run_commands; > self.run_command(cmd); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/dist.py"", line 972, in run_command; > cmd_obj.run(); > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 163, in run; > _build_ext.build_ext.run(self); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 337, in run; > self.build_extensions(); > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/Cython/Distutils/build_ext.py"", line 171, in build_extensions; > self.build_extension(ext); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/command/build_ext.py"", line 496, in build_extension; > depends=ext.depends); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/ccompiler.py"", line 574, in compile; > self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); > File ""/Applications/Canopy.app/appdata/canopy-1.5.4.3105.macosx-x86_64/Canopy.app/Contents/lib/python2.7/distutils/unixccompiler.py"", line 122, in _compile; > raise CompileError, msg; > ImportError: Building module qutip.cy.spmatfuncs failed: [""CompileError: command 'gcc' failed with exit status 1\n""]; > import numpy as np; > ; > from qutip import *; > Traceback (most recent call last):; > File """", line 1, in ; > File ""/Users/rjmagya/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/qutip/init.py"", line 62, in ; > qutip.settings.ipython = False; > AttributeError: 'module' object has no attribute 'settings'; > ; > ######################; > ; > This seems similar to the build error in Installation on OS X with Homebrew script error #348.; > ; > Is this a bug in quti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/382#issuecomment-148179436:4204,depend,depends,4204,https://qutip.org,https://github.com/qutip/qutip/issues/382#issuecomment-148179436,1,['depend'],['depends']
Integrability,"thanks Dani, I think if you encode the problem in a more standard qutip structure the dependence on the small frequencies disappears;; ```; d = destroy(2).dag(); L_s = liouvillian(0*d.dag()*d, [np.sqrt(Gamma_l) *d, np.sqrt(Gamma_r) *d.dag()]); rho_ss = steadystate(L_s); I_s = Gamma_r * sprepost(d.dag(),d); current, noise, skw = third_cumulant(L_s, rhoss=rho_ss, J_ops=[I_s], I_ops=[I_s], sparse=True, method=""pinv""); ```. So I would prefer to revert the pseudo_inverse change (which is there originally to catch a different issue with the noise exploding). But nice example! this would make a great test I think. For the third_cumulant itself, maybe better to combine with the existing countstat_current_noise function, and provide the third cumulant, and support J_ops!=I_ops, as options?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607:86,depend,dependence,86,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2134515607,1,['depend'],['dependence']
Integrability,"thanks for the comment, I didn't know about `qutip.propagator`. > Lots of people have successfully used QuTiP already as part of reinforcement learning protocols - I've worked with at least a couple. cool, can i learn more about this from you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660472157:152,protocol,protocols,152,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660472157,2,['protocol'],['protocols']
Integrability,thanks. can you also please run:; ```; import qutip; qutip.about(); ```; and copy here the message?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-717351448:91,message,message,91,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-717351448,1,['message'],['message']
Integrability,"the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2007,depend,depend,2007,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['depend'],['depend']
Integrability,the structure of the states returned are different. A subtle difference is mcsolve returns a representation of state wrapped with one more square bracket.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/330#issuecomment-90325080:117,wrap,wrapped,117,https://qutip.org,https://github.com/qutip/qutip/issues/330#issuecomment-90325080,1,['wrap'],['wrapped']
Integrability,"thon-pillow/Pillow/commit/cae5ac495badd7c7ecfad8223a08f55f5d2eaacb""><code>cae5ac4</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5924"">#5924</a> from radarhere/cves</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/ed4cf7813777ad8478cac46f448bc45416a2a99e""><code>ed4cf78</code></a> CVEs TBD</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/d7f60d1d5a746eb01d4cb3c7fb05b6593f46b0f5""><code>d7f60d1</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5923"">#5923</a> from radarhere/imagemath_eval</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/8531b01d6cdf0b70f256f93092caa2a5d91afc11""><code>8531b01</code></a> Restrict builtins for ImageMath.eval</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/1efb1d9fabd1dfdbf7982035eca0dae7306abef1""><code>1efb1d9</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5922"">#5922</a> from radarhere/releasenotes</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/f6c78713a491764dfac576f6c42127755f2c62b3""><code>f6c7871</code></a> Added release notes for <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5919"">#5919</a>, <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5920"">#5920</a> and <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a></li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/032d2dc3658f94718109068ac70799313e440754""><code>032d2dc</code></a> Update CHANGES.rst [ci skip]</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/baae9ec4b67c68e3adaf1208cf54e8de5e38a6fd""><code>baae9ec</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a> from radarhere/jpeg_eoi</li>; <li><a href=""https://github.com/python-pillow",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:14553,depend,dependabot,14553,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"thub.com/kjd/idna/commit/d516b874c3388047934938a500c7488d52c4e067""><code>d516b87</code></a> Update Github actions/checkout to v4</li>; <li><a href=""https://github.com/kjd/idna/commit/c095c75943413c75ebf8ac74179757031b7f80b7""><code>c095c75</code></a> Merge branch 'master' into dev</li>; <li><a href=""https://github.com/kjd/idna/commit/60a0a4cb61ec6834d74306bd8a1fa46daac94c98""><code>60a0a4c</code></a> Fix typo in GitHub Actions workflow key</li>; <li><a href=""https://github.com/kjd/idna/commit/5918a0ef8034379c2e409ae93ee11d24295bb201""><code>5918a0e</code></a> Merge branch 'master' into dev</li>; <li>Additional commits viewable in <a href=""https://github.com/kjd/idna/compare/v3.4...v3.7"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=idna&package-manager=pip&previous-version=3.4&new-version=3.7)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2392:4127,depend,dependabot-security-updates,4127,https://qutip.org,https://github.com/qutip/qutip/pull/2392,1,['depend'],['dependabot-security-updates']
Integrability,"thub.com/numpy/numpy/commit/143d45fff3ed9e051bdeef7bdb4df38025ea7d1c""><code>143d45f</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/19269"">#19269</a> from charris/backport-19228</li>; <li><a href=""https://github.com/numpy/numpy/commit/d80e4738f781a1d206bbc04a2e863299e5f2e104""><code>d80e473</code></a> BUG: Removed typing for == and != in dtypes</li>; <li>Additional commits viewable in <a href=""https://github.com/numpy/numpy/compare/v1.19.5...v1.21.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.19.5&new-version=1.21.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1767:4908,depend,dependabot,4908,https://qutip.org,https://github.com/qutip/qutip/pull/1767,1,['depend'],['dependabot']
Integrability,"thub.com/python-pillow/Pillow/commit/e42238637651f191c2fc6e3f4024348c126e0ccc""><code>e422386</code></a> Add release notes for Pillow 8.3.2</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/08dcbb873217874eee0830fc5aaa1f231c5af4fa""><code>08dcbb8</code></a> Pillow 8.3.2 supports Python 3.10 [ci skip]</li>; <li>Additional commits viewable in <a href=""https://github.com/python-pillow/Pillow/compare/8.2.0...8.3.2"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=pillow&package-manager=pip&previous-version=8.2.0&new-version=8.3.2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:9330,depend,dependabot-automerge-start,9330,https://qutip.org,https://github.com/qutip/qutip/pull/1654,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,"thub.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit TIFF strip size when saving with LibTIFF <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5514"">#5514</a> [<a href=""https://github.com/kmilos""><code>@​kmilos</code></a>]</li>; <li>Allow ICNS save on all operating systems <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4526"">#4526</a> [<a href=""https://github.com/newpanjing""><code>@​newpanjing</code></a>]</li>; <li>De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4989"">#4989</a> [<a href=""https://github.com/gofr""><code>@​gofr</code></a>]</li>; <li>Do not use background or transparency index for new color <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5564"">#5564</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Simplified code <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5315"">#5315</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Replaced xml.etree.ElementTree <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5565"">#5565</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>8.3.2 (2021-09-02)</h2>; <ul>; <li>; <p>CVE-2021-23437 Raise ValueError if color specifier is too long; [hugovk, radarhere]</p>; </li>; <li>; <p>Fix 6-byte OOB read in FliDecode; [wiredfool]</p>; </li>; <li>; <p>Add support for Python 3.10 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5569"">#5569</a>, <a href=""https://github-redirect.dependabot.com/python-pillow/P",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:3736,depend,dependabot,3736,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['depend'],['dependabot']
Integrability,"tifi/commit/1fc808626a895a916b1e4c2b63abae6c5eafdbe3""><code>1fc8086</code></a> Bump peter-evans/create-pull-request from 6.0.4 to 6.0.5 (<a href=""https://redirect.github.com/certifi/python-certifi/issues/288"">#288</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/certifi/python-certifi/compare/2023.07.22...2024.07.04"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=certifi&package-manager=pip&previous-version=2023.7.22&new-version=2024.7.4)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2483:3445,Depend,Dependabot,3445,https://qutip.org,https://github.com/qutip/qutip/pull/2483,1,['Depend'],['Dependabot']
Integrability,"tip.qeye(2))); array([[0.84147098+0.j, 0. +0.j],; [0. +0.j, 0.84147098+0.j]]); ```; Alternatively, if people _really_ want to be able to use ufuncs on `Qobj`, it is possible to define `__array_ufunc__` in such a way that we allow only some `ufuncs` to operate. Doing this leaves us susceptible to problems interacting with other libraries that implement this, though, beacuse whichever class has the highest `__array_priority__` gets to dictate what makes sense. Unless there's a really clear _need_ for this, I don't think it's a good idea. For completeness, the rest of this comment is stuff I find out while researching. ## The `__array__()` and `__array_wrap__()` methods. These have been special methods understood by numpy since at least 1.3 (2009 - the oldest docs still on scipy.org), and I imagine long before then too. `__array__` is mentioned (and still is) in the documentation of `np.array`, which is unchanged since 2009 and says that its argument should be; > An array, any object exposing the array interface, an object whose `__array__` method returns an array, or any (nested) sequence. and `__array_wrap__` is like the reverse - it's for coercing numpy arrays back into this class. If we were to keep `__array__` in `Qobj`, we should also implement `__array_wrap__` for coercion back (something that isn't currently implemented). At the time and up to inclusively 1.19, the presence of `__array__` caused otherwise scalar types passed alone to `np.array` to return the output of `input.__array__(*args, **kwargs)`, instead of becoming a 0D numpy array (like `np.array(1)` does). Taken purely alone, that could make sense as something we implement. However, this also implies that `Qobj` should fulfil the numpy ufunc interface; `Qobj` would be a container for data such that operations like `np.sin` is the elementwise sin, or (most notably) `np.multiply` is the *elementwise* multiplication. Our `Qobj` _does not_ fulfil the ufunc interface:; 1. elementwise operations don't make s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:3198,interface,interface,3198,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['interface'],['interface']
Integrability,"tochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/723:2534,depend,depends,2534,https://qutip.org,https://github.com/qutip/qutip/issues/723,1,['depend'],['depends']
Integrability,"tps://github.com/pallets/jinja/commit/5c8a10522421270f66376a24ec8e0d6812bc4b14""><code>5c8a105</code></a> Make nested-trans-block exceptions nicer (<a href=""https://redirect.github.com/pallets/jinja/issues/1918"">#1918</a>)</li>; <li><a href=""https://github.com/pallets/jinja/commit/19a55db3b411343309f2faaffaedbb089e841895""><code>19a55db</code></a> Make nested-trans-block exceptions nicer</li>; <li><a href=""https://github.com/pallets/jinja/commit/716795349a41d4983a9a4771f7d883c96ea17be7""><code>7167953</code></a> Merge pull request from GHSA-h5c8-rqwp-cp95</li>; <li><a href=""https://github.com/pallets/jinja/commit/7dd3680e6eea0d77fde024763657aa4d884ddb23""><code>7dd3680</code></a> xmlattr filter disallows keys with spaces</li>; <li>Additional commits viewable in <a href=""https://github.com/pallets/jinja/compare/3.1.2...3.1.3"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=jinja2&package-manager=pip&previous-version=3.1.2&new-version=3.1.3)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2291:3420,depend,dependency-name,3420,https://qutip.org,https://github.com/qutip/qutip/pull/2291,1,['depend'],['dependency-name']
Integrability,"tput. It now does the snapshot: compute the expectation values, save the state, compute trajectories average, etc. . `Evolver` is qutip's ODE solver interface: the states are `Data` object and the function is `QovjEvo`(or `QobjEvoFunc`). There are multiple type of evolver wrapping different scipy's ode solver and a few of our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that hand",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1316,integrat,integrate,1316,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['integrat'],['integrate']
Integrability,"tring and notebook):. ```; ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs); ```. where `dynamps` is a list of pre-computed dynamical maps to learn from, `rho0` is the initial state, `times` are the times at which to find the solution etc. The ""memory cascade"" implementation however, diverges a bit from this standard. In general I think it will be hard to have a kind of unified interface for different types of non-Markovian solvers, because unlike the Markovian case, there is no unified theoretical approach, and different solvers work in quite different ways. For the ""memory cascade"" implementation I chose a more object oriented style for the interface. The user first creates a `MemoryCascade` object, storing all the relevant parameters, and subsequently calls class methods to runs simulations. I personally like this style, and I think it is a general style that could be used across a great variety of solvers. I could however in addition write a function with a more `mesolve`-like interface. It can't, however, be identical, as there are several special arguments that has to be given. There is also a separate class method that computes output field correlation functions, and I kind of like that the various methods are collected together in a class, instead of having multiple different functions that all have to be called with a long list of arguments. I therefore suggest the style used in the `memorycascade` module as a style that can be used for new solvers going forward. In general there will be a class with a name reflecting the solver, and this class has methods for doing various types of simulations. The two non-Markov solvers I have implemented are of course closely related to my own line of current research. The ""memory cascade"" method is something I have developed, and the main motivation for me to implement the TTM was that it can be used very nicely in conjunction with the ""memory cascade"" method (see the notebooks). Going",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/405:2955,interface,interface,2955,https://qutip.org,https://github.com/qutip/qutip/pull/405,1,['interface'],['interface']
Integrability,"tructure of dimensions objects are going to change in 5.0 (though the list structure will still work). This should even give you more freedom, if you need it - I've got some plans for vastly improved handling of restricted-entry Hilbert spaces (basically spaces that are small embeddings into a larger space that's all 0).; - I am very strongly against accepting this (like I said above):. > Oh, one thing that I'd like to suggest we _don't_ do: use this interface to _implicitly_ create `Qobj` inside our functions.; ; To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. You can see that it didn't work as intended, because they've had to add `__array_function__` and other additional methods on top to start to make it work, and it's still not perfect - even `scipy.sparse` have/had problems implementing them. While it might work in your particular case, making sure that nothing funny happens in the abstract across _all_ possible implementors of the interface while still having it do something useful is a very tricky problem, as evidenced by Numpy. Any conversion is going to be lossy for some people (perhaps not you, but it will be for others), and that means the behaviour for users will be surprising in some cases. In my opinion, if we're going to have a `__qutip_qobj__` interface, the interface should be defined for one operation only, and should never be called implicitly. I'm not entirely close-minded to alternate views here, but given the problems Numpy had (whose team I have no doubt are much smarter than I am), I'm really not enthusiastic about any implicit conversions. I really do appreciate the interest, and I _am_ keen to let us have better compatibility with the rest of the community, but there are a lot of design concerns that we're going to want to work on our side first - I just want to caution you in case you're trying to work towards a PR, because I'm not close to being happy to accept one, yet",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:2301,interface,interface,2301,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,2,['interface'],['interface']
Integrability,"ttps://github-redirect.dependabot.com/python-pillow/Pillow/issues/5588"">#5588</a>; [kmilos, radarhere]</p>; </li>; <li>; <p>Updates for <code>ImagePalette</code> channel order <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5599"">#5599</a>; [radarhere]</p>; </li>; <li>; <p>Hide FriBiDi shim symbols to avoid conflict with real FriBiDi library <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5651"">#5651</a>; [nulano]</p>; </li>; </ul>; <h2>8.3.1 (2021-07-06)</h2>; <ul>; <li>; <p>Catch OSError when checking if fp is sys.stdout <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5585"">#5585</a>; [radarhere]</p>; </li>; <li>; <p>Handle removing orientation from alternate types of EXIF data <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5584"">#5584</a>; [radarhere]</p>; </li>; <li>; <p>Make Image.<strong>array</strong> take optional dtype argument <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5572"">#5572</a>; [t-vi, radarhere]</p>; </li>; </ul>; <h2>8.3.0 (2021-07-01)</h2>; <ul>; <li>; <p>Use snprintf instead of sprintf. CVE-2021-34552 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5567"">#5567</a>; [radarhere]</p>; </li>; <li>; <p>Limit TIFF strip size when saving with LibTIFF <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5514"">#5514</a>; [kmilos]</p>; </li>; <li>; <p>Allow ICNS save on all operating systems <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4526"">#4526</a>; [baletu, radarhere, newpanjing, hugovk]</p>; </li>; <li>; <p>De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4989"">#4989</a>; [gofr, radarhere]</p>; </li>; <li>; <p>Replaced xml.etree.ElementTree <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5565"">#5565</a>; [rad",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:5894,depend,dependabot,5894,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['depend'],['dependabot']
Integrability,"ttps://github.com/python-pillow/Pillow/commit/2a93aba5cfcf6e241ab4f9392c13e3b74032c061""><code>2a93aba</code></a> Use strncpy to avoid buffer overflow</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/a670597bc30e9d489656fc9d807170b8f3d7ca57""><code>a670597</code></a> Update CHANGES.rst [ci skip]</li>; <li>Additional commits viewable in <a href=""https://github.com/python-pillow/Pillow/compare/10.2.0...10.3.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=pillow&package-manager=pip&previous-version=10.2.0&new-version=10.3.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:15729,depend,dependabot-automerge-start,15729,https://qutip.org,https://github.com/qutip/qutip/pull/2381,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,"ub-redirect.dependabot.com/python-pillow/Pillow/issues/5565"">#5565</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/master/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>8.3.2 (2021-09-02)</h2>; <ul>; <li>; <p>CVE-2021-23437 Raise ValueError if color specifier is too long; [hugovk, radarhere]</p>; </li>; <li>; <p>Fix 6-byte OOB read in FliDecode; [wiredfool]</p>; </li>; <li>; <p>Add support for Python 3.10 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5569"">#5569</a>, <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5570"">#5570</a>; [hugovk, radarhere]</p>; </li>; <li>; <p>Ensure TIFF <code>RowsPerStrip</code> is multiple of 8 for JPEG compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5588"">#5588</a>; [kmilos, radarhere]</p>; </li>; <li>; <p>Updates for <code>ImagePalette</code> channel order <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5599"">#5599</a>; [radarhere]</p>; </li>; <li>; <p>Hide FriBiDi shim symbols to avoid conflict with real FriBiDi library <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5651"">#5651</a>; [nulano]</p>; </li>; </ul>; <h2>8.3.1 (2021-07-06)</h2>; <ul>; <li>; <p>Catch OSError when checking if fp is sys.stdout <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5585"">#5585</a>; [radarhere]</p>; </li>; <li>; <p>Handle removing orientation from alternate types of EXIF data <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5584"">#5584</a>; [radarhere]</p>; </li>; <li>; <p>Make Image.<strong>array</strong> take optional dtype argument <a href=""https://github-redirect.dependabot.com/python-pillow/Pillo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:4922,depend,dependabot,4922,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['depend'],['dependabot']
Integrability,"ub.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Only use ASCII characters in C source file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6691"">#6691</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Release Python GIL when converting images using matrix operations <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6418"">#6418</a> [<a href=""https://github.com/hmaarrfk""><code>@​hmaarrfk</code></a>]</li>; <li>Added ExifTags enums <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6630"">#6630</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not modify previous frame when calculating delta in PNG <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6683"">#6683</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added support for reading BMP images with RLE4 compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6674"">#6674</a> [<a href=""https://github.com/npjg""><code>@​npjg</code></a>]</li>; <li>Decode JPEG compressed BLP1 data in original mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6678"">#6678</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>pylint warnings <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6659"">#6659</a> [<a href=""https://github.com/marksmayo""><code>@​marksmayo</code></a>]</li>; <li>Added GPS TIFF tag info <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6661"">#6661</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added conversion between RGB/RGBA/RGBX a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:3514,depend,dependabot,3514,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"ues/286"">#286</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/4a9569a3eb58db8548536fc16c5c5c7af946a5b1""><code>4a9569a</code></a> Bump actions/checkout from 4.1.2 to 4.1.4 (<a href=""https://redirect.github.com/certifi/python-certifi/issues/287"">#287</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/1fc808626a895a916b1e4c2b63abae6c5eafdbe3""><code>1fc8086</code></a> Bump peter-evans/create-pull-request from 6.0.4 to 6.0.5 (<a href=""https://redirect.github.com/certifi/python-certifi/issues/288"">#288</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/certifi/python-certifi/compare/2023.07.22...2024.07.04"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=certifi&package-manager=pip&previous-version=2023.7.22&new-version=2024.7.4)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2483:3123,depend,dependabot-security-updates,3123,https://qutip.org,https://github.com/qutip/qutip/pull/2483,1,['depend'],['dependabot-security-updates']
Integrability,"ues/6693"">#6693</a>; [cgohlke]</p>; </li>; <li>; <p>Fixed set_variation_by_name offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6445"">#6445</a>; [radarhere]</p>; </li>; <li>; <p>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a>; [cgohlke]</p>; </li>; <li>; <p>Release Python GIL when converting images using matrix operations <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6418"">#6418</a>; [hmaarrfk]</p>; </li>; <li>; <p>Added ExifTags enums <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6630"">#6630</a>; [radarhere]</p>; </li>; <li>; <p>Do not modify previous frame when calculating delta in PNG <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6683"">#6683</a>; [radarhere]</p>; </li>; <li>; <p>Added support for reading BMP images with RLE4 compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6674"">#6674</a>; [npjg, radarhere]</p>; </li>; <li>; <p>Decode JPEG compressed BLP1 data in original mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6678"">#6678</a>; [radarhere]</p>; </li>; <li>; <p>Added GPS TIFF tag info <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6661"">#6661</a>; [radarhere]</p>; </li>; <li>; <p>Added conversion between RGB/RGBA/RGBX and LAB <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6647"">#6647</a>; [radarhere]</p>; </li>; <li>; <p>Do not attempt normalization if mode is already normal <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6644"">#6644</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/d594f4cb8dc47fb0c69ae58d9fff86faae4515bd""><cod",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:12278,depend,dependabot,12278,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"ugovk</code></a>]</li>; <li>Use title for display in ImageShow <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5788"">#5788</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix for PyQt6 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5775"">#5775</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>9.0.0 (2022-01-02)</h2>; <ul>; <li>; <p>Restrict builtins for ImageMath.eval(). CVE-2022-22817 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5923"">#5923</a>; [radarhere]</p>; </li>; <li>; <p>Ensure JpegImagePlugin stops at the end of a truncated file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a>; [radarhere]</p>; </li>; <li>; <p>Fixed ImagePath.Path array handling. CVE-2022-22815, CVE-2022-22816 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5920"">#5920</a>; [radarhere]</p>; </li>; <li>; <p>Remove consecutive duplicate tiles that only differ by their offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5919"">#5919</a>; [radarhere]</p>; </li>; <li>; <p>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#5901</a>; [radarhere]</p>; </li>; <li>; <p>Limit quantized palette to number of colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5879"">#5879</a>; [radarhere]</p>; </li>; <li>; <p>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a>; [radarhere]</p>; </li>; <li>; <p>When",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:10671,depend,dependabot,10671,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,uild wheel; Compiling qutip/core/_brtensor.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/vector.pxd.; Compiling qutip/core/_brtools.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/sode/ssystem.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/cy/_element.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/expect.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/matmul.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/mul.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg/cython_blas.pxd.; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/properties.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/integrator/explicit_rk.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/inner.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/l,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:5279,depend,depends,5279,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['depend'],['depends']
Integrability,"uild_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an error:; `gcc: error trying to exec '/usr/lib/gcc/x86_64-linux-gnu/4.8/cc1plus': execv: Argument list too long`. After killing the kernel, open the notebook again...Everything is ok...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697:4968,depend,depends,4968,https://qutip.org,https://github.com/qutip/qutip/issues/697,1,['depend'],['depends']
Integrability,"ulano</code></a>]</li>; <li>Fix memory leaks related to text features <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6330"">#6330</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Use double quotes for version check on old CPython on Windows <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6695"">#6695</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>GHA: replace deprecated set-output command with GITHUB_OUTPUT file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6697"">#6697</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Upload fribidi.dll to GitHub Actions <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6532"">#6532</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fixed set_variation_by_name offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6445"">#6445</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Windows build improvements <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6562"">#6562</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix malloc in _imagingft.c:font_setvaraxes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6690"">#6690</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Only use ASCII characters in C source file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6691"">#6691</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Release Python GIL when converting images using mat",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:2038,depend,dependabot,2038,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"uld be to generate these with a (costly) Lindblad equation in a large Hilbert space, and use the TTM to extrapolate to larger times. My code is not quite ready for a pull request yet (due to this issue amongst other things), but when it is I would also like to discuss the structure of such a package. I guess it is best to leave that to when I have a pull request ready though. For now I have a local modified version of the `_mesolve_const` function that allows a superoperator in place of `rho0`. The necessary modification is actually only to the function implementing the ""right hand side"" (RHS) of the differential equation, as this now needs to implement a matrix-matrix multiplication instead of a matrix-vector multiplication. For illustration purposes I will attach a code for a modified `_mesolve_const` below, that does the job, but the RHS is not implemented in cython. I think implementing this feature in qutip should be relatively straight forward, but possibly a bit tedious since it there are so many different dispatch functions from `mesolve` depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions. Please let me know what you think about implementing this in qutip. Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/384:2137,depend,depending,2137,https://qutip.org,https://github.com/qutip/qutip/issues/384,2,['depend'],"['dependence', 'depending']"
Integrability,"ule to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularly effective for operations that can be divided into independent, smaller tasks.; - **Compatibility**: Ensured that the enhancements are backward-compatible with existing code by modifying only the internal execution strategy of the `correlation_2op_1t` function and by maintaining the original API signature.; - **Performance Considerations**: The parallel implementation can significantly reduce computation times, particularly for larger systems or longer `taulist` arrays, by leveraging multiple CPU cores concurrently. ### Conclusion. The enhancements to the `correlation_2op_1t` function in QuTiP are designed to harness the capabilities of modern multi-core processors, ther",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:1974,Integrat,Integration,1974,https://qutip.org,https://github.com/qutip/qutip/pull/2395,2,['Integrat'],"['Integrated', 'Integration']"
Integrability,"ull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/20680"">#20680</a> from charris/backport-20663</li>; <li><a href=""https://github.com/numpy/numpy/commit/794b36f7e1bf2a8c42774ab0db86a74bd32f674b""><code>794b36f</code></a> Update armccompiler.py</li>; <li><a href=""https://github.com/numpy/numpy/commit/d93b14e3d7abaa1d837825e51671f817788e120f""><code>d93b14e</code></a> Update test_public_api.py</li>; <li><a href=""https://github.com/numpy/numpy/commit/7662c0789cc6a70d5ad4d950ee2e95f3afef7df6""><code>7662c07</code></a> Update <strong>init</strong>.py</li>; <li><a href=""https://github.com/numpy/numpy/commit/311ab52488a7d096ac3bc4c2de0fdae17ecd13ef""><code>311ab52</code></a> Update armccompiler.py</li>; <li>Additional commits viewable in <a href=""https://github.com/numpy/numpy/compare/v1.21.0...v1.22.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.21.0&new-version=1.22.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` wi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:5162,depend,dependency-name,5162,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['depend'],['dependency-name']
Integrability,"um]). np.real(R.full()). tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). plt.show(). output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]); ```. The code runs fine until the last line which gives the following response:; ```; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-1-79f7f2013969> in <module>; 35 plt.show(); 36; ---> 37 output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, [ohmic_spectrum]). ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\bloch_redfield.py in brmesolve(H, psi0, tlist, a_ops, e_ops, c_ops, args, use_secular, sec_cutoff, tol, spectra_cb, options, progress_bar, _safe_mode, verbose); 196; 197 if _safe_mode:; --> 198 _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args); 199; 200 # check for type (if any) of time-dependent inputs. ~\Anaconda3\envs\qutip-env\lib\site-packages\qutip\solver.py in _solver_safety_check(H, state, c_ops, e_ops, args); 945 _structure_check(Hdims, Htype, _temp_state); 946 else:; --> 947 raise Exception('Invalid td-list element.'); 948 if do_tests:; 949 _structure_check(Hdims, Htype, _temp_state). Exception: Invalid td-list element.; ```. Output of version_table(); ```; Software	Version; QuTiP	4.5.0; Numpy	1.18.1; SciPy	1.4.1; matplotlib	3.1.3; Cython	0.29.15; Number of CPUs	4; BLAS Info	INTEL MKL; IPython	7.13.0; Python	3.8.1 (default, Mar 2 2020, 13:06:26) [MSC v.1916 64 bit (AMD64)]; OS	nt [win32]; Sun Mar 29 21:11:12 2020 GMT Daylight Time; ```. Other examples (like this one https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/brmesolve.ipynb ) run without errors.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1223:1964,depend,dependent,1964,https://qutip.org,https://github.com/qutip/qutip/issues/1223,1,['depend'],['dependent']
Integrability,"umerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass a `QobjEvo` Liouvillian as the first argument. As long as you make sure you give each thread a distinct copy of the input Liouvillian, `mesolve` itself doesn't access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6118,integrat,integrators,6118,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['integrat'],['integrators']
Integrability,"updated OS from High Sierra to Mojave, plus some other updates in scipy and numpy, and reinstalled conda, so I am curious to see if these speedups are machine independent, which would be great. My specs; ```; Software	Version; QuTiP	4.4.0.dev0+e1639f73; Numpy	1.16.4; SciPy	1.2.1; matplotlib	3.1.0; Cython	0.29.8; Number of CPUs	2; BLAS Info	INTEL MKL; IPython	7.5.0; Python	3.7.3 (default, Mar 27 2019, 16:54:48) [Clang 4.0.1 (tags/RELEASE_401/final)]; OS	posix [darwin]; Mon Jun 10 21:16:02 2019 JST; ```; Some details:; In cell 6 of development-ssesolver-new-methods, the running time went from over 160 seconds to 6 seconds (x25 speedup). Total run time in cell 21 is now down to 14.22s from 79.46s, cell 24/25 of is now 1.4 seconds down from 14.22s in `smesolve`. `ssesolve` in cell 4 is down from 164.50s to 11.06s. Cell 6 is down to 11.48s from 250s. The next cell checking all solver methods in `ssesolve` is down from 80s to 24s. In the notebook with new smesolve methods, cell 11 with multiple time dependence in sc_ops now runs in 69s instead of 171s. . Also, the benchmarking of the different methods now reads; ```; {'solver': 'euler-maruyama'}; Total run time: 0.21s; Total run time: 0.25s; Total run time: 0.30s; Total run time: 0.38s; Total run time: 0.45s; Total run time: 0.55s; Total run time: 0.67s; Total run time: 0.81s; {'solver': 'platen'}; Total run time: 0.70s; Total run time: 0.90s; Total run time: 1.13s; Total run time: 1.15s; Total run time: 1.41s; Total run time: 1.66s; Total run time: 2.03s; Total run time: 2.47s; {'solver': 'pc-euler'}; Total run time: 0.38s; Total run time: 0.46s; Total run time: 0.58s; Total run time: 0.70s; Total run time: 0.84s; Total run time: 1.00s; Total run time: 1.26s; Total run time: 1.49s; {'solver': 'milstein'}; Total run time: 0.31s; Total run time: 0.39s; Total run time: 0.46s; Total run time: 0.56s; Total run time: 0.70s; Total run time: 0.84s; Total run time: 1.05s; Total run time: 1.24s; {'solver': 'milstein-imp'}; Total r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:1618,depend,dependence,1618,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,2,['depend'],['dependence']
Integrability,"upport <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7234"">#7234</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed deleted file from codecov.yml and increased coverage threshold <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7232"">#7232</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed support for 32-bit <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7228"">#7228</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use --config-settings instead of deprecated --global-option <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7171"">#7171</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Better C integer definitions <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6645"">#6645</a> [<a href=""https://github.com/Yay295""><code>@​Yay295</code></a>]</li>; <li>Fixed finding dependencies on Cygwin <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7175"">#7175</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved checks in font_render <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7218"">#7218</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Change <code>grabclipboard()</code> to use PNG compression on macOS <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7219"">#7219</a> [<a href=""https://github.com/abey79""><code>@​abey79</code></a>]</li>; <li>Added PyPy 3.10 and removed PyPy 3.8 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7216"">#7216</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added in_place argument to ImageOps.exif_transpose() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7092"">#7092</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</cod",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:3661,depend,dependencies,3661,https://qutip.org,https://github.com/qutip/qutip/pull/2237,1,['depend'],['dependencies']
Integrability,"ure (except ones which use `*args` or `**kwargs`), even if not all of the arguments are data-layer types. At definition, the creator of the `Dispatcher` says which input arguments are meant to be dispatched on, and whether the output should be dispatched on, and all other arguments are passed through like normal. #### Implementation details. The backing specialisations can be found in `Dispatcher._specialisations`, and the complete lookup table is in `Dispatcher._lookup`. These are marked as private, because messing around with them will almost certainly cause the dispatcher to stop working. Only one specialisation needs to be defined for a dispatcher to work with _all_ data types known by `data.to`. We achieve this because `data.to` guarantees that all possible conversions between data types will exist, so `data.Dispatcher` can always convert its inputs into those which will match one of its known specialisations. Within the initialisation of the data layer, we use a ""magic"" `_defer` keyword argument to `add_specialisations` to break a circular dependency. This is because the ""type"" modules `data.csr` and `data.dense` depend on some mathematical modules (e.g. `add` and `matmul`) to provide the `__add__` and similar methods on the types. For ease of development we want the dispatchers to be defined in the same modules that all the specialisations are (though this is not at all necessary), but the dispatchers require `data.to` to be populated with the types before specialisations can be added. The `_defer` keyword here just defers the building of the lookup table until an explicit call to `Dispatcher.rebuild_lookup()`, breaking the cycle. The user will never need to do this, because by the time they receive the `Dispatcher` object, `data.to` is already initialised to a minimum degree. #### Efficiency notes. The specialisations returned by the `__getitem__` lookups are not significantly faster than just calling the dispatcher directly, because the bulk of the heavy lif",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338:16336,depend,dependency,16336,https://qutip.org,https://github.com/qutip/qutip/pull/1338,1,['depend'],['dependency']
Integrability,"urity Policy (<a href=""https://redirect.github.com/certifi/python-certifi/issues/222"">#222</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/c211ef482a01aff5f1bc92c4128bfa0c955f4a01""><code>c211ef4</code></a> Set up permissions to github workflows (<a href=""https://redirect.github.com/certifi/python-certifi/issues/218"">#218</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/2087de5d0aa1d472145fc1dbdfece3fe652bbac5""><code>2087de5</code></a> Don't let deprecation warning fail CI (<a href=""https://redirect.github.com/certifi/python-certifi/issues/219"">#219</a>)</li>; <li><a href=""https://github.com/certifi/python-certifi/commit/e0b9fc5c8f52ac8c300da502e5760ce3d41429ec""><code>e0b9fc5</code></a> remove paragraphs about 1024-bit roots from README</li>; <li>Additional commits viewable in <a href=""https://github.com/certifi/python-certifi/compare/2022.12.07...2023.07.22"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=certifi&package-manager=pip&previous-version=2022.12.7&new-version=2023.7.22)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel m",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2205:2582,Depend,Dependabot,2582,https://qutip.org,https://github.com/qutip/qutip/pull/2205,2,"['Depend', 'depend']","['Dependabot', 'dependabot-badges']"
Integrability,"urllib3/urllib3/commit/d25cf83bbae850a290fe34ed1610ae55c0558b36""><code>d25cf83</code></a> [1.26] Fix invalid test_ssl_failure_midway_through_conn</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/25cca389496b86ee809c21e5b641aeaa74809263""><code>25cca38</code></a> [1.26] Fix test_ssl_object_attributes</li>; <li>Additional commits viewable in <a href=""https://github.com/urllib3/urllib3/compare/1.26.14...1.26.17"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=urllib3&package-manager=pip&previous-version=1.26.14&new-version=1.26.17)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2236:5467,depend,dependabot-automerge-start,5467,https://qutip.org,https://github.com/qutip/qutip/pull/2236,2,['depend'],"['dependabot-automerge-end', 'dependabot-automerge-start']"
Integrability,utility.pxd.; Compiling qutip/core/cy/_element.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/expect.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/matmul.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/mul.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg/cython_blas.pxd.; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/properties.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/integrator/explicit_rk.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/inner.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/kron.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/base.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/csr.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/s,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:5736,depend,depends,5736,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['depend'],['depends']
Integrability,utip/core/data/dispatch.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/__init__.pxd.; Compiling qutip/core/data/expect.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/_brtensor.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/permute.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/matmul.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/trace.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/norm.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/sode/_sode.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/_brtools.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/properties.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/adjoint.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/kron.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/pow.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__i,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:7716,depend,depends,7716,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['depends']
Integrability,"utip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/spmath.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/heom.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/math.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/cy/spconvert.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/ptrace.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/testing.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/control/cy_grape.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; [ 1/12] Cythonizing qutip/control/cy_grape.pyx; [ 2/12] Cythonizing qutip/cy/graph_utils.pyx; [ 3/12] Cythonizing qutip/cy/heom.pyx; [ 4/12] Cythonizing qutip/cy/interpolate.pyx; [ 5/12] Cythonizing qutip/cy/math.pyx; [ 6/12] Cythonizing qutip/cy/ptrace.pyx; [ 7/12] Cythonizing qutip/cy/sparse_utils.pyx; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/state/partition1/local-scratch/kilian/16342884/pip-build-7c5rN_/qutip/setup.py"", line 216, in <module>; ext_modules = cythonize(EXT_MODULES),; File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1016, in cythonize; cythonize_one(*args); File ""/home/kilian/qutip/lib/python2.7/site-packages/Cython/Build/Dependencies.py"", line 1138, in cythonize_one; ra",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/723:2807,depend,depends,2807,https://qutip.org,https://github.com/qutip/qutip/issues/723,1,['depend'],['depends']
Integrability,"v1.19.5...v1.21.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.19.5&new-version=1.21.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself); - `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language; - `@de",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1767:5094,Depend,Dependabot,5094,https://qutip.org,https://github.com/qutip/qutip/pull/1767,9,"['Depend', 'depend']","['Dependabot', 'dependabot']"
Integrability,"v1.21.0...v1.22.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=numpy&package-manager=pip&previous-version=1.21.0&new-version=1.22.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself); - `@dependabot use these labels` will set the current labels as the default for future PRs for this repo and language; - `@de",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:5712,Depend,Dependabot,5712,https://qutip.org,https://github.com/qutip/qutip/pull/1940,9,"['Depend', 'depend']","['Dependabot', 'dependabot']"
Integrability,"ve to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator = _mesolve_process_instructions(instructions, integrator); ```; and a call to `mesolve` would be like; ```python; solver = mesolve(H, rho0, times, c_ops); try:; result = next(solver); while True:; next_control = krotov.get_next_control(result.time, result.state); result = solver.send([; ('update-arguments', {'control': next_control}),; ('update-hamilt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:1436,integrat,integrator,1436,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['integrat'],['integrator']
Integrability,"ver-package=qutip qutip; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input list of Qobj ... ok; td_brmesolve: passes all brmesolve tests ... ok; td_brmesolve: time-dependent a_ops ... ok; td_brmesolve: time-dependent a_ops tuple of strings ... ok; td_brmesolve: time-dependent a_ops tuple interp ... ok; td_brmesolve: time-dependent a_ops & c_ops interp ... ok; td_brmesolve: non-Hermitian e_ops check ... ok; td_brmesolve: states check ... ok; td_brmesolve: split ops #1 ... ok; td_brmesolve: split ops #2 ... ok; td_brmesolve: split ops, Cubic_Spline td-terms ... ok; td_brmesolve: split ops, multiple ... ok; td_brmesolve: Hamiltonian args ... ok; BR Tools : zheevr ... ok; BR Tools : dense operator to eigenbasis ... ok; BR Tools : vector to eigenbasis ... ok; BR Tools : eigvector to fockbasis ... ok; BR Tools : vector roundtrip transform ... ok; BR Tools : Diagonal liouvillian mult ... ok; BR Tools : cop_super_mult ... ok; BR Tools : br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear in",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576:1209,depend,dependent,1209,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-539853576,2,['depend'],['dependent']
Integrability,"verOptions(atol=1e-5):; opt = SolverOptions(store_state=True); opt['progress_bar'] = False; print(opt). progress_bar : False; store_state : True; method : 'bdf'; atol : 1e-5; ...; ```; The option can also be initialized from a dict or another options instance, it will make a copy. I added the capacity to add a safety check when setting an options. It is only used for `use_cython` which will error when trying to set it to `True` without cython installed. Otherwise, it will fail when trying to use the options. *Solver's options*; Each solver has it's option class (SeOptions, MeOptions, etc.) with only needed keys.This somewhat feel overkill since they are all the some for now, until mcsolve is merged. Each integrator also has an associated options and the solver options contain an integrator options. Conversion between options type will raise an error. When creating a solver options, it read the `method` key and setup a matching integrator options. Thus only the keys used by the solver or integrator are defined in the instance. This allow adding new integrator with their own options without adding complexity to the solver options. It can be used as such:; ```; opt = SolverOptions(method='lsoda'); opt['progress_bar'] = False; opt.ode['max_order_ns'] = 10; ```; To make it work smoothly, each integrator must be associated to only one method thus `zvode` was split between `adams` and `bdf`. There is also a generic `Options` class that accept any keys used by integrator or solver and can be converted to any specific solver options:; ```; Options(futur_cupy_ode_specific_options=True) # Will work; Options(not_an_options=True) # Error; # For most solver:; __solve(..., opt=Options()); ```; Once options are associated to a solver, they are frozen:; ```; opt = SeOptions(); solver = SeSolver(..., opt); opt['...'] = ... # Ok, but solver has a copy and is unaffected.; solver.options['...'] = ... # Error; solver.options = opt; ```; This is because changing options without the solver ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1812:1867,integrat,integrator,1867,https://qutip.org,https://github.com/qutip/qutip/pull/1812,1,['integrat'],['integrator']
Integrability,"w this is quite an old OS and Python version, but that's what I have available. Numpy 1.24 should be supported in Python 3.8.10. ### Code to Reproduce the Bug. ```shell; $ python3 -m venv /tmp/test-venv. $ source /tmp/test-venv/bin/activate. $ pip install --upgrade pip; Collecting pip; Using cached pip-24.0-py3-none-any.whl (2.1 MB); Installing collected packages: pip; Attempting uninstall: pip; Found existing installation: pip 20.0.2; Uninstalling pip-20.0.2:; Successfully uninstalled pip-20.0.2; Successfully installed pip-24.0. $ pip list; Package Version; ------------- -------; pip 24.0; pkg_resources 0.0.0; setuptools 44.0.0. $ pip install qutip; Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Installing build dependencies ... done; Getting requirements to build wheel ... done; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. ### Code Output. _No response_. ### Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Coll",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:1380,depend,dependencies,1380,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['dependencies']
Integrability,"w/Pillow/issues/5859"">#5859</a>; [radarhere]</p>; </li>; <li>; <p>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a>; [radarhere]</p>; </li>; <li>; <p>Added rounding when converting P and PA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5824"">#5824</a>; [radarhere]</p>; </li>; <li>; <p>Improved putdata() documentation and data handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5910"">#5910</a>; [radarhere]</p>; </li>; <li>; <p>Exclude carriage return in PDF regex to help prevent ReDoS <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5912"">#5912</a>; [hugovk]</p>; </li>; <li>; <p>Fixed freeing pointer in ImageDraw.Outline.transform <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5909"">#5909</a>; [radarhere]</p>; </li>; <li>; <p>Added ImageShow support for xdg-open <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5897"">#5897</a>; [m-shinder, radarhere]</p>; </li>; <li>; <p>Support 16-bit grayscale ImageQt conversion <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5856"">#5856</a>; [cmbruns, radarhere]</p>; </li>; <li>; <p>Convert subsequent GIF frames to RGB or RGBA <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5857"">#5857</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/82541b6dec8452cb612067fcebba1c5a1a2bfdc8""><code>82541b6</code></a> 9.0.0 version bump</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/cae5ac495badd7c7ecfad8223a08f55f5d2eaacb""><code>cae5ac4</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5924"">#5924</a> from radarhere/cves</li>; <li><a href=""ht",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:12797,depend,dependabot,12797,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"w</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=certifi&package-manager=pip&previous-version=2022.12.7&new-version=2023.7.22)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself); You can disable automated security fix PRs for this repo from the [Security Alerts page](https://github.com/qutip/qutip/network/alerts). </details>",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2205:3875,depend,dependabot,3875,https://qutip.org,https://github.com/qutip/qutip/pull/2205,8,"['Depend', 'depend']","['Dependabot', 'dependabot', 'dependency']"
Integrability,"was the dimension; 2) V(x) = 0.5*(x-3)**2 --> H_1 = displace(dim,3)*H_0*(displace(dim,3).dag()) I also found the same eigenvalues [0.5,1.5,2.5...] which seems normal because the HO is just shifted on the right of the x axis and its shape doesn't change. But when I tried V(x) = 0.5*(x-3)**2+x --> H_2 = H_1 + position(dim) with dim = 8 for example, I found the following eigenvalues :; [-1.94563502 0.44017316 2.61960688 4.31137988 4.99244818 6.16377699; 7.35499586 8.06325407] . ; The problem is that the first eigenvalues have really decreased which seems not logical because with the x added, the potential should be slightly higher. I also use in parallel the PySlise package for Python which enables to solve Schödinger equation and finds eigenfunctions and eigenvalues and it gives me :; [ 3.01788 4.11151 5.32044 6.63324 8.02437 9.47380 10.96801 12.49776 ] (it was giving the good results for 1) and 2)); So I don't understant why qutip doesn't give me the same result, I know I use two different methods; qutip is just finding eigenvalues of a matrix and PySlise solve differential equations but when I don't use displacement operator both always give the same result. I tried to write the displacement operator my self with the create & destroy operators and the Glauber formula because I noticed that the commutation relations were not respected cause of the truncation but I didn't work. If anyone has any ideas I would be very grateful, I have already spent a lot of time looking and I am getting desperate.; I thank you for reading my message, I apologize for any spelling mistakes that may remain in my message, (I am in bachelor and English is not my native language); . **To Reproduce**; ```python; import qutip as qtp; import numpy as np; H = qtp.displace(8,3)*qtp.num(8)*(qtp.displace(8,3).dag())+0.5*qtp.qeye(8)+qtp.position(8); print(H.eigenenergies()); ```; The terminal out put is; ```; [-1.94563502 0.44017316 2.61960688 4.31137988 4.99244818 6.16377699; 7.35499586 8.06325407]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1597:2005,message,message,2005,https://qutip.org,https://github.com/qutip/qutip/issues/1597,2,['message'],['message']
Integrability,"we can sidestep some of these issues by improving library code which creates `Qobj` instances. Operations like `Qobj.__add__` already know exactly what the output dimensions are, what the the type must be, and other things like if Hermiticity has been preserved. We move away from the outdated style of; ```python; out = Qobj(); out.data = left.data + right.data; out.dims = left.dims; ...; ```; to one which passes _all_ the information in one go:; ```python; out = Qobj(left.data + right.data,; copy=False,; dims=left.dims,; type=left.type,; isherm=left._isherm and right._isherm); ```; This is more verbose, but significantly faster. With no other changes to the code, doing this can save around one-quarter of the overhead on several `Qobj` operations. Moving to the new data-layer types also gets large improvements in instantiation time. This is fine, except for matrix multiplication of tensor structures. In these, like in the example above, the matrix multiplication can cause tensor structures to contract, and so they then become incompatible with their previous Hilbert spaces. If we instead maintain a _list_ of `'type'` and introduce a `'scalar'` type, such objects can sensibly be broadcast back up to the correct size when needed, treating the spaces containing as identities of the correct dimension. I envisage that this may have some nice use-cases within `qip`, for example a gate on a single qubit could be represented by a two-by-two matrix with all other dimensions scalars, rather than requiring the whole Hilbert space to be represented all the time. Optimisations can be done using only the required elements of the subspace, and only broadcast up to the full representation once at the end. Further, we can ease the burden of parsing the dimensions in the first place. I haven't fully attempted this yet so I don't have full details on this, but I imagine there is some internal information we can keep after a single parsing pass that will make other operations simpler. Th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320:8629,contract,contract,8629,https://qutip.org,https://github.com/qutip/qutip/issues/1320,1,['contract'],['contract']
Integrability,"wever, evolving the system with ""mesolve"" function of QuTiP (which uses either Adams or BDF methods) and Runge-Kutta gives different results. My code has time dependent Hamiltonians and collapse operators. For demonstration purposes I wrote a simple code which deals with the master equation of a time-dependent harmonic oscillator of mass and frequency equal to 1. The jump operator is the position operator times a time-dependent coefficient. . ```python; import numpy as np; import scipy as sp; from qutip import *; ; tend = 5; tvec = np.linspace(0,tend,1000); ω1 = 1 #initial frequency; ω2 = 2 #final frequency; gamma = 1 #dissipation rate; ; def omg_fun(t, args): #time-dependent frequency; s = t/tend; ω_t = ω1 + 10*(ω2-ω1)*s**3 - 15*(ω2-ω1)*s**4 + 6*(ω2-ω1)*s**5; return ω_t; ; def col_fun(t, args): #time dependent collapse operator coefficient; return np.sqrt(gamma * np.exp(-t)); ; def omg_fun_rk(t): #time-dependent frequency for RK45; s = t/tend; ω_t = ω1 + 10*(ω2-ω1)*s**3 - 15*(ω2-ω1)*s**4 + 6*(ω2-ω1)*s**5; return ω_t; ; def col_fun_rk(t): #time dependent collapse operator coefficient for RK45; return np.sqrt(gamma * np.exp(-t)); ; N=10; m = 1 #mass; ħ = 1; x = np.sqrt(ħ/(2*m*ω1))*(create(N)+destroy(N)) #position operator; p = 1j*np.sqrt((ħ*m*ω1)/2)*(create(N)-destroy(N)) #momentum operator; H = [(p**2)/(2*m), [(1/2)*m*x**2,omg_fun]]; c_ops = [[x,col_fun]]; rho_init = fock_dm(N,1); rhot_vec = mesolve(H,rho_init,tvec,c_ops); rhot_qutip = rhot_vec.states[-1]; ; #Right hand side of the master equation; def rhs(ρ,H,gamma,op):; c_op = np.sqrt(gamma)*op; res = -1j*(H*ρ - ρ*H)+(1/2)*(2*c_op*ρ*c_op.dag()-ρ*c_op.dag()*c_op-c_op*c_op.dag()*ρ); return res; ; #Runge-Kutta Solver; def rksolver(ρ,dt,H,gamma,op):; k1 = rhs(ρ,H,gamma,op); k2 = rhs(ρ+(dt/2)*k1,H,gamma,op); k3 = rhs(ρ+(dt/2)*k2,H,gamma,op); k4 = rhs(ρ+dt*k3,H,gamma,op); rho = ρ+dt*(k1+2*k2+2*k3+k4)/6; return rho; ; dt = tvec[1]-tvec[0]; for i in range(len(tvec)):; H_rk = (p**2)/(2*m) + (1/2)*m*x**2*omg_fun_rk(tvec[i]);",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733:1093,depend,dependent,1093,https://qutip.org,https://github.com/qutip/qutip/issues/1733,2,['depend'],['dependent']
Integrability,which demonstrates that time-dependent expressions with multiple terms are not properly handled (missing parentheses),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/216:29,depend,dependent,29,https://qutip.org,https://github.com/qutip/qutip/pull/216,1,['depend'],['dependent']
Integrability,"whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/mul.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg/cython_blas.pxd.; Compiling qutip/core/data/csr.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/solver/sode/ssystem.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/cy/math.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/core/data/ptrace.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4933,depend,depends,4933,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['depend'],['depends']
Integrability,"will be clear that the fault is in the downstream implementors of the API. I'm concerned from a user's perspective. QuTiP has a wide user base, and we're beyond the stage where ""iterate fast and break things"" is ok for us (though of course it's fine and even good for pre-stable libraries, to avoid getting weighed down). We've got to be concerned with backwards and forwards compatibility; what if a user wants to install and use QuTiP and a different library in the same environment _without_ using them together, but can't even have them coexist because of version incompatibilities in optional conversion features? That's frustrating for users, even though it's not really anybody's fault. Bugging developers is fine when people want to use packages that are still maintained, but I'm sure we've all come up against times in research when you get to trying out a package to do one specific thing that's been abandoned for a while. Again, this certainly isn't an unsolvable problem: having versioning in the interface API is one solution to some of these problems. ---. For greater discussion, here's an alternate approach: instead of objects defining `__qutip_qobj__`, instead we expose an entry-point `qutip.Qobj.register_conversion_function(converter, type, priority, version=None)`, and downstream libraries register functions rather than defining methods on their classes. The logic inside the `Qobj` constructor remains approximately the same as what you suggest. I think TensorFlow does something a little more similar to this? (I'm not very familiar with it at all.). Advantages of this over a `__qutip_qobj__` magic method:; - Users aren't limited to what libraries define for them, but can add their own conversions or override library ones if they don't like them. I actually see this as being closer to Julia's dispatch, or Rust's `impl for`.; - It doesn't involve weird namespacing, or anything like that, and doesn't require downstream classes to carry around additional slots. It's l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:4959,interface,interface,4959,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,2,['interface'],['interface']
Integrability,"with the proxy.</p>; <p>In cases where Requests receives a redirect response, it previously reattached; the <code>Proxy-Authorization</code> header incorrectly, resulting in the value being; sent through the tunneled connection to the destination server. Users who rely on; defining their proxy credentials in the URL are <em>strongly</em> encouraged to upgrade; to Requests 2.31.0+ to prevent unintentional leakage and rotate their proxy; credentials once the change has been fully deployed.</p>; <p>Users who do not use a proxy or do not supply their proxy credentials through; the user information portion of their proxy URL are not subject to this; vulnerability.</p>; <p>Full details can be read in our <a href=""https://github.com/psf/requests/security/advisories/GHSA-j8r2-6x86-q33q"">Github Security Advisory</a>; and <a href=""https://nvd.nist.gov/vuln/detail/CVE-2023-32681"">CVE-2023-32681</a>.</p>; </li>; </ul>; <h2>v2.30.0</h2>; <h2>2.30.0 (2023-05-03)</h2>; <p><strong>Dependencies</strong></p>; <ul>; <li>; <p>⚠️ Added support for urllib3 2.0. ⚠️</p>; <p>This may contain minor breaking changes so we advise careful testing and; reviewing <a href=""https://urllib3.readthedocs.io/en/latest/v2-migration-guide.html"">https://urllib3.readthedocs.io/en/latest/v2-migration-guide.html</a>; prior to upgrading.</p>; <p>Users who wish to stay on urllib3 1.x can pin to <code>urllib3&lt;2</code>.</p>; </li>; </ul>; <h2>v2.29.0</h2>; <h2>2.29.0 (2023-04-26)</h2>; <p><strong>Improvements</strong></p>; <ul>; <li>Requests now defers chunked requests to the urllib3 implementation to improve; standardization. (<a href=""https://redirect.github.com/psf/requests/issues/6226"">#6226</a>)</li>; <li>Requests relaxes header component requirements to support bytes/str subclasses. (<a href=""https://redirect.github.com/psf/requests/issues/6356"">#6356</a>)</li>; </ul>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/psf/requests/blob/mai",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2164:1743,Depend,Dependencies,1743,https://qutip.org,https://github.com/qutip/qutip/pull/2164,1,['Depend'],['Dependencies']
Integrability,wrong propagator when using rhs_reuse with different time-dependent function,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/18:58,depend,dependent,58,https://qutip.org,https://github.com/qutip/qutip/issues/18,1,['depend'],['dependent']
Integrability,"x_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; pandas 2.0.3 requires numpy>=1.20.3; python_version < ""3.10"", but you have numpy 1.17.3 which is incompatible.; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-70.0.0 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/_brtensor.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/vector.pxd.; Compiling qutip/core/_brtools.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:3604,depend,dependency,3604,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['depend'],['dependency']
Integrability,y.pxd.; Compiling qutip/core/cy/math.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libc/math.pxd.; Compiling qutip/core/cy/coefficient.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/dense.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/reshape.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/project.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/dispatch.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/__init__.pxd.; Compiling qutip/core/data/ptrace.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/Cython/Includes/libcpp/utility.pxd.; Compiling qutip/core/data/norm.pyx because it depends on /tmp/pip-build-env-t_hh31dy/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; [ 1/31] Cythonizing qutip/core/_brtensor.pyx; [ 2/31] Cythonizing qutip/core/_brtools.pyx; [ 3/31] Cythonizing qutip/core/cy/coefficient.pyx; [ 4/31] Cythonizing qutip/core/cy/math.pyx; [ 5/31] Cythonizing qutip/core/data/add.pyx; [ 6/31] Cythonizing qutip/core/data/base.pyx; [ 7/31] Cythonizing qutip/core/data/csr.pyx; [ 8/31] Cythonizing qutip/core/data/dense.pyx; [ 9/31] Cythonizing qutip/core/data/dia.pyx; [10/31] Cythonizing qutip/core/data/dispatch.pyx; [11/31] Cythonizing qutip/core/data/matmul.pyx; [12/31] Cythonizing qutip/core/data/mul.pyx; [13/31] Cythonizing qutip/core/data/norm.pyx; [14/31] Cythonizing qutip/core/data/reshape.pyx; [15/31] Cythonizing qutip/core/data/tidyup.pyx; [16/31] Cythonizing qutip/piqs/_piqs.pyx; [17/31] Cythonizing qutip/co,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:8838,depend,depends,8838,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['depend'],['depends']
Integrability,"ypeError Traceback (most recent call last); <ipython-input-116-e35e17a7e3ab> in <module>(); 6 [],; 7 [],; ----> 8 progress_bar=True). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar); 319 types.BuiltinFunctionType, partial)):; 320 res = _sesolve_func_td(H, rho0, tlist,; --> 321 e_ops, args, options, progress_bar); 322 else:; 323 res = _sesolve_const(H, rho0, tlist,. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar); 565 #; 566 return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; --> 567 dims=psi0.dims); 568 ; 569 . /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/sesolve.py in _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, state_norm_func, dims); 656 ; 657 if t_idx < n_tsteps - 1:; --> 658 r.integrate(r.t + dt[t_idx]); 659 ; 660 progress_bar.finished(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in integrate(self, t, step, relax); 406 self._y, self.t = mth(self.f, self.jac or (lambda: None),; 407 self._y, self.t, t,; --> 408 self.f_params, self.jac_params); 409 except SystemError:; 410 # f2py issue with tuple returns, see ticket 1187. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/scipy/integrate/_ode.py in run(self, f, jac, y0, t0, t1, f_params, jac_params); 863 args = ((f, jac, y0, t0, t1) + tuple(self.call_args) +; 864 (f_params, jac_params)); --> 865 y1, t, istate = self.runner(*args); 866 if istate < 0:; 867 warnings.warn(self.__class__.__name__ + ': ' +. /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/qutip/cy/spmatfuncs.pyx in qutip.cy.spmatfuncs.cy_ode_psi_func_td (qutip/cy/spmatfuncs.c:4445)(). /home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/505:1658,integrat,integrate,1658,https://qutip.org,https://github.com/qutip/qutip/issues/505,1,['integrat'],['integrate']
Integrability,"​cgohlke</code></a>]</li>; <li>Release Python GIL when converting images using matrix operations <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6418"">#6418</a> [<a href=""https://github.com/hmaarrfk""><code>@​hmaarrfk</code></a>]</li>; <li>Added ExifTags enums <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6630"">#6630</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not modify previous frame when calculating delta in PNG <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6683"">#6683</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added support for reading BMP images with RLE4 compression <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6674"">#6674</a> [<a href=""https://github.com/npjg""><code>@​npjg</code></a>]</li>; <li>Decode JPEG compressed BLP1 data in original mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6678"">#6678</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>pylint warnings <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6659"">#6659</a> [<a href=""https://github.com/marksmayo""><code>@​marksmayo</code></a>]</li>; <li>Added GPS TIFF tag info <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6661"">#6661</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added conversion between RGB/RGBA/RGBX and LAB <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6647"">#6647</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not attempt normalization if mode is already normal <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6644"">#6644</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed seeking to an L frame in a GIF ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:3957,depend,dependabot,3957,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Integrability,"​kmilos</code></a>]</li>; <li>Use the Windows method to get TCL functions on Cygwin <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5807"">#5807</a> [<a href=""https://github.com/DWesl""><code>@​DWesl</code></a>]</li>; <li>Changed error type to allow for incremental WebP parsing <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5404"">#5404</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#5901</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Ensure that BMP pixel data offset does not ignore palette <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5899"">#5899</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit quantized palette to number of colors <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5879"">#5879</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use latin1 encoding to decode bytes <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5870"">#5870</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed palette index for zeroed color in FASTOCTREE quantize <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5869"">#5869</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>When saving RGBA to GIF, make use of first transparent palette entry <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5859"">#5859</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pass SAMPLEFORMAT to libtiff <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5848"">#5848</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code><",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:2735,depend,dependabot,2735,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['depend'],['dependabot']
Integrability,"​radarhere</code></a>]</li>; <li>If first GIF frame has transparency for RGB_ALWAYS loading strategy, use RGBA mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6592"">#6592</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Round box position to integer when pasting embedded color <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6517"">#6517</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed EXIF prefix when saving WebP <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6582"">#6582</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pad IM palette to 768 bytes when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6579"">#6579</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added DDS BC6H reading <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6449"">#6449</a> [<a href=""https://github.com/ShadelessFox""><code>@​ShadelessFox</code></a>]</li>; <li>Added support for opening WhiteIsZero 16-bit integer TIFF images <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6642"">#6642</a> [<a href=""https://github.com/JayWiz""><code>@​JayWiz</code></a>]</li>; <li>Raise an error when allocating translucent color to RGB palette <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6654"">#6654</a> [<a href=""https://github.com/jsbueno""><code>@​jsbueno</code></a>]</li>; <li>Moved mode check outside of loops <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6650"">#6650</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added reading of TIFF child images <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6569"">#6569</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code><",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:7420,depend,dependabot,7420,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['depend'],['dependabot']
Modifiability," = f_energies. F:\Anaconda3\lib\site-packages\qutip\floquet.py in floquet_modes(H, T, args, sort, U); 98 if U is None:; 99 # get the unitary propagator; --> 100 U = propagator(H, T, [], args); 101 ; 102 # find the eigenstates for the propagator. F:\Anaconda3\lib\site-packages\qutip\propagator.py in propagator(H, t, c_op_list, args, options, unitary_mode, parallel, progress_bar, **kwargs); 181 output = sesolve(H2, psi0, tlist, [],; 182 args=args, _safe_mode=False,; --> 183 options=Options(normalize_output=False)); 184 for k, t in enumerate(tlist):; 185 u[k] = sp_reshape(output.states[k].data, (N, N)). F:\Anaconda3\lib\site-packages\qutip\sesolve.py in sesolve(H, rho0, tlist, e_ops, args, options, progress_bar, _safe_mode); 153 elif n_str > 0:; 154 res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; --> 155 progress_bar); 156 ; 157 elif isinstance(H, (types.FunctionType,. F:\Anaconda3\lib\site-packages\qutip\sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 432 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 433 '<string>', 'exec'); --> 434 exec(code, globals()); 435 config.tdfunc = cy_td_ode_rhs; 436 . F:\Anaconda3\lib\site-packages\qutip\sesolve.py in <module>(). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/854:4860,config,config,4860,https://qutip.org,https://github.com/qutip/qutip/issues/854,1,['config'],['config']
Modifiability," > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would have to become nested too (at least conceptually)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:1321,flexible,flexible,1321,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005,1,['flexible'],['flexible']
Modifiability," For context, debian builds packages against generic libblas.so (libblas-dev package). The various optimised BLAS implementations are supposed to be binary compatible, such that the system administrator can install the preferred implementation for use at runtime (the identity of libblas.so is controlled using debian's alternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; define_macros = [('HAVE_CBLAS', None)]; blas_opt_inf",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:1266,config,config,1266,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['config']
Modifiability," I do `import qutip as qt`, a different error occurs:; ```; AttributeError Traceback (most recent call last); <ipython-input-8-ea74e5ab1d35> in <module>; 1 # Evolve the system, request the solver to call process_rho at each time step.; 2 ; ----> 3 qt.mesolve(h_t, psi0, taulist, [], process_rho, args). ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 216 if not use_mesolve:; 217 return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; --> 218 progress_bar=progress_bar, _safe_mode=_safe_mode); 219 ; 220 if isket(rho0):. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in sesolve(H, psi0, tlist, e_ops, args, options, progress_bar, _safe_mode); 135 ; 136 res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; --> 137 progress_bar, dims=psi0.dims); 138 if e_ops_dict:; 139 res.expect = {e: res.expect[n]. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt, progress_bar, dims); 360 if expt_callback:; 361 # use callback method; --> 362 output.expect.append(e_ops(t, Qobj(cdata, dims=dims))); ...; ---> 16 evals_mat[idx[0],:] = qt.real(evals); 17 ; 18 # find the overlap between the eigenstates and psi. AttributeError: module 'qutip' has no attribute 'real'; ```. ### Code to Reproduce the Bug. [This notebook](https://nbviewer.ipython.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb). ### Code Output. _No response_. ### Expected Behaviour. Evolve the system without incurring any error. ### Your Environment. ```shell; QuTiP Version: 4.7.0; Numpy Version: 1.20.1; Scipy Version: 1.6.2; Cython Version: 0.29.30; Matplotlib Version: 3.3.4; Python Version: 3.7.7; Number of CPUs: 72; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1930:3267,Evolve,Evolve,3267,https://qutip.org,https://github.com/qutip/qutip/issues/1930,1,['Evolve'],['Evolve']
Modifiability," `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help windows users.; - Added a `reduce_func` input. Presently the map function is saving all results and the average, std, etc. are only computed at the end. There was no real advantage in saving only average values since all trajectories were in memory at the end of the map. But users expected lower memory usage when asking for only the results average.; - Added `timeout` options to the map, when passed, no error is raised but obtained results are returned. This allow to ask for 30s worth of trajectories instead of fixing a number. **Related issues or PRs**; Build on top of the #1407",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:2417,evolve,evolver,2417,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['evolve'],['evolver']
Modifiability," a given fixed Hermitian matrix and $\rho(T)$ is a time-evolved quantum state under given Hamiltonian and time interval $[0,T]$. You can also think about this as maximizing trace overlap between two quantum states, if we set $O$ to be another density matrix. I've used all three different fidelitycomputers, but apparently all of them failed to optimize the cost function properly. I'd appreciate it much if anyone can help me understanding what I've been doing wrong! I attached a simple example code below with explanations:. 1. First, I initialized setups such as defining Hamiltonian, initial state, and target observable $O$. Then by creating `create_pulse_optimizer` as follows, I defined/initialized the dynamics as `dyn` with some randomly chosen initial amps. I tried all possible choices of `fid_type`. (see code below). <img width=""977"" alt=""grape_example1"" src=""https://user-images.githubusercontent.com/55151494/170385354-f7efe678-11fc-47de-afa7-ac77359bb5e0.png"">. 2. I then ran the optimization using GRAPE and reported its results. As shown below and in particular the very last line of the figure, the cost function I wanted to estimate is just $0$, whereas my task wants to maximize $\text{Tr}(O\rho)$. While testing several things, I changed $O$ to a ket vector (e.g. $|00>$) and it worked very well. So in principle, I thought the code should work properly as we can think of $O$ being a quantum state (e.g. $|00><00|$). . <img width=""1013"" alt=""grape_2"" src=""https://user-images.githubusercontent.com/55151494/170385858-eeddb7fb-f821-4057-8503-ee2a52e27805.png"">; <img width=""968"" alt=""grape_3"" src=""https://user-images.githubusercontent.com/55151494/170385868-7816a7ee-cc90-4dba-83dd-3304cd2404d8.png"">. I'd be great if someone points out what I'm missing here. One of my guesses of why this is happening is perhaps because we evolve a ket statevector while the target observable is in full matrix form. If so though, I'm not sure how to cure this problem. Thank you in advance!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1900:1931,evolve,evolve,1931,https://qutip.org,https://github.com/qutip/qutip/issues/1900,1,['evolve'],['evolve']
Modifiability," are supposed to be binary compatible, such that the system administrator can install the preferred implementation for use at runtime (the identity of libblas.so is controlled using debian's alternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; define_macros = [('HAVE_CBLAS', None)]; blas_opt_info:; define_macros = [('NO_ATLAS_INFO', 1), ('HAVE_CBLAS', None)]; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:1377,config,config,1377,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['config']
Modifiability," br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (tau) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (Qobj) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (OO) ... ok; control.pulseoptim: Hadamard gate gradient check ... ok; control.pulseoptim: QFT gate with linear initial pulses ... ok; control.pulseoptim: QFT gate with linear initial pulses (bounds) ... ok; control: data dumping ... ok; control: unitarity checking (via dump) ... ok; control.pulseoptim: state-to-state transfer ... ok; control.pulseoptim: state-to-state transfer (Qobj) ... ok; control.pulseoptim: amplitude damping channel ... ok; control.pulseoptim: coupled oscillators (symplectic dynamics) ... ok; control.pulseoptim: Hadamard gate using CRAB algorithm ... ok; control.pulseoptim: Hadamard gate (loading config from file) ... ok; control.pulsegen: Check periodic control functions ... ok; control.pulseoptim: Hadamard gate with fixed and time varying drift ... ok; control.pulseoptim: Hadamard gate with fixed and time varying ctrls ... ok; correlation: legacy me and es for oscillator in coherent initial state ... ok; correlation: comparing me and es for oscillator in coherent initial state ... ok; correlation: comparing me and mc for driven oscillator in fock state ... ok; correlation: legacy me and es for oscillator in steady-state ... ok; correlation: comparing me and es for oscillator in steady-state ... ok; correlation: legacy spectrum from es and pi methods ... ok; correlation: comparing spectrum from es and fft methods ... ok; correlation: comparing spectrum from es and pi methods ... ok; correlation: comparing TLS emission corr., H td (str-list td format) ... ok; correlation: comparing TLS emission corr., H td (np-list td format) ... ok; correlation: comparing TLS emission ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:4447,config,config,4447,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,2,['config'],['config']
Modifiability," branch (using `pip install --pre qutip`). ### Code to Reproduce the Bug. ```shell; from qutip import * ; import numpy as np. s_00 = tensor(basis(2,0), basis(2,0)); P_00 = s_00 * s_00.dag(); e_ops = [ ; lambda t, state: (state.ptrace([0,1]) * P_00).tr() ; ]. tlist = np.linspace(0, 2*np.pi, 50); res = mesolve(tensor(identity(2), identity(2), identity(3)),; tensor(P_00, thermal_dm(3,0.1)), ; tlist, ; [],; e_ops); ```. ### Code Output. ```shell; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-1-49ed87444849> in <module>; 9 ; 10 tlist = np.linspace(0, 2*np.pi, 50); ---> 11 res = mesolve(tensor(identity(2), identity(2), identity(3)),; 12 tensor(P_00, thermal_dm(3,0.1)),; 13 tlist,. 1 frames; /usr/local/lib/python3.9/dist-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 242 func(0., v, *ode_args) + v; 243 ; --> 244 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 245 progress_bar, dims=rho0.dims); 246 res.num_collapse = len(c_ops). /usr/local/lib/python3.9/dist-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 517 for m in range(n_expt_op):; 518 if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; --> 519 output.expect[m][t_idx] = e_ops[m](t, rho_t); 520 continue; 521 output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,. UnboundLocalError: local variable 'rho_t' referenced before assignment; ```. ### Expected Behaviour. no error. ### Your Environment. ```shell; QuTiP Version: 4.7.1; Numpy Version: 1.22.4; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.5.3; Python Version: 3.9.16; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/local/lib/python3.9/dist-packages/qutip; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2118:1700,variab,variable,1700,https://qutip.org,https://github.com/qutip/qutip/issues/2118,1,['variab'],['variable']
Modifiability," coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(expects[-1], variable); ```. Output:; ```; 20.0%. Run time: 0.03s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.05s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.08s. Est. time left: 00:00:00:0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1845,variab,variable,1845,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability," coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(expects[-1], variable); ```. Output:; ```; 20.0%. Run time: 0.03s. Est. time left: 00:00:00:00; 40.0%. Run t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1752,variab,variable,1752,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability," compare the expectation value at the end of the simulation which is at time t = 1. . #First code:. import qutip; import numpy as np; options = qutip.Options(); options.nsteps = 100000; args = {'omega':1000}; time_grid = 1000; timelist = np.linspace(0, 1, time_grid); omegatlist = np.cos(args['omega']*timelist); H = qutip.QobjEvo([qutip.sigmax(),omegatlist], tlist= np.array(np.linspace(0, 1, time_grid), dtype=np.float64)); state = qutip.basis(2, 0).proj(); times = np.linspace(0, 1, 2); result = qutip.mesolve(H,state,times,[],qutip.sigmaz(),args=args,options=options); print(result.expect[0][1]). #Second code: ; import qutip; import numpy as np; options = qutip.Options(); options.nsteps = 100000; args = {'omega':1000}; time_grid = 1000; tlist = np.linspace(0, 1, time_grid); omegatlist = np.cos(args['omega']*tlist); H = [qutip.sigmax(),omegatlist]; state = qutip.basis(2, 0).proj(); times = tlist; result = qutip.mesolve(H,state,times,[],qutip.sigmaz(),args=args,options=options); print(result.expect[0][999]). The first code gives a value of 0.9999989185418086 and the second one returns a value of 0.9999989289570258. So, the two results are not exactly the same. For the above analytic Hamiltonian, the result seems to differ by a small decimal number. However for the non-analytic Hamiltonian that I am actually using, the result can differ by six orders of magnitude. May I know why there is a difference in the results obtained from the two methods above? Is it because when QobjEvo is used, the mesolve routine actually does not sample enough time grid points when it evolves the Hamiltonian (i.e., it does not sample all the time_grid points which is time_grid = 1000 as provided above)? If so, may you kindly tell me how to rectify this problem?. As per my original question, I would like the first code to give the same the expectation value of the operator at the final time as is in the second code but without having to evaluate the expectation value of the operator at all time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-808726734:1924,evolve,evolves,1924,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-808726734,1,['evolve'],['evolves']
Modifiability," frame <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7521"">#7521</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Handle disposing GIF background from outside palette <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7515"">#7515</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Seek past the data when skipping a PSD layer <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7483"">#7483</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>ImageMath: Inline <code>isinstance</code> check <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7623"">#7623</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Update actions/upload-artifact action to v4 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7619"">#7619</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Import plugins relative to the module <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7576"">#7576</a> [<a href=""https://github.com/deliangyang""><code>@​deliangyang</code></a>]</li>; <li>Translate encoder error codes to strings; deprecate <code>ImageFile.raise_oserror()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7609"">#7609</a> [<a href=""https://github.com/bgilbert""><code>@​bgilbert</code></a>]</li>; <li>Updated readthedocs to latest version of Python <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7611"">#7611</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support reading BC4U and DX10 BC1 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6486"">#6486</a> [<a href=""https://github.com/REDxEYE""><code>@​REDxEYE</code></a>]</li>; <li>Optimize ImageStat.Stat.extrema <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7593"">#7593</a> [<a href=""https://github.com/flo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:6355,plugin,plugins,6355,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['plugin'],['plugins']
Modifiability," function `compute_single_tau_correlation` to handle the computation for a single tau. This function manages the setup of the quantum system, computes the correlation for its specific tau, and handles any exceptions that may occur, logging them accordingly.; - **Resource Management**: Used the `cpu_count` from the `os` module to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularly effective for operations that can be divided into independent, smaller tasks.; - **Compatibility**: Ensured that the enhancements are backward-compatible with existing code by modifying only the internal execution strategy of the `correlation_2op_1t` function and by maintaining the original API signature.; - **Performance Considerations**: The parallel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:1699,Extend,Extended,1699,https://qutip.org,https://github.com/qutip/qutip/pull/2395,1,['Extend'],['Extended']
Modifiability," if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build, not PEP517 build); INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```. ### Additional Context. PEP517 support is new for Debian. It is possible the pybuild build tool needs to be adapted to handle setup.py options like `--with-openmp` in the context of PEP517. But I've tried to pose the issue here in terms of the underlying python3 build commands without needing to consider pybuild as such. Is there a different way in which `--with-openmp` should be configured when using a PEP517 build?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:1688,config,configured,1688,https://qutip.org,https://github.com/qutip/qutip/issues/1875,3,"['adapt', 'config']","['adapted', 'configured']"
Modifiability," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1371:1119,flexible,flexible,1119,https://qutip.org,https://github.com/qutip/qutip/issues/1371,1,['flexible'],['flexible']
Modifiability," least, sesolve seems ok). Key feature of ENR states is that dims and shape do not match, which can cause issues if dims and not shape are used in various operations. Chatted with @hodgestar and in this case we think we pinned it down to iadd in QobjEvo creating an identity matrix based on the dims and not the shape. https://github.com/qutip/qutip/blob/afd160bce00df522b9bcb0f856bc06d63296998d/qutip/core/cy/qobjevo.pyx#L459. though perhaps other issues could arise. ### Code to Reproduce the Bug. ```shell; from qutip import *; import numpy as np; N = 4 # number of cavities; M = 2 # number of cavity states; dims = [M] * N; #The number of excitations in the chain; excitations = 1 # total number of excitations; initial_excitiations = 1 # initial number of excitations; #Construct ENR operators and states. d = enr_destroy(dims, excitations); psi0 = enr_fock(dims, excitations, [initial_excitiations if m == 1 else 0 for m in range(N)]). H = sum([dd.dag() * dd for dd in d]). # coupling between cavities; e_ops = [dd.dag() * dd for dd in d]; c_ops = [0.01 * dd for dd in d]; times = np.linspace(0, 250, 1000); result = mesolve(H, psi0, times, c_ops, e_ops). #More minimal failure can be found with running this instead of mesolve:; H=QobjEvo(H); QobjEvo(H+0); ```. ### Code Output. ```shell; line 24, in <module>; QobjEvo(H); File ""qutip/core/cy/qobjevo.pyx"", line 196, in qutip.core.cy.qobjevo.QobjEvo.__init__; File ""qutip/core/cy/qobjevo.pyx"", line 757, in genexpr; File ""/home/neill/anaconda3/envs/qutip5dev/lib/python3.11/site-packages/qutip-5.0.0.dev0+nogit-py3.11-linux-x86_64.egg/qutip/core/qobj.py"", line 134, in out; return method(self, other); ^^^^^^^^^^^^^^^^^^^; File ""/home/neill/anaconda3/envs/qutip5dev/lib/python3.11/site-packages/qutip-5.0.0.dev0+nogit-py3.11-linux-x86_64.egg/qutip/core/qobj.py"", line 408, in __add__; return Qobj(_data.add(self._data, other._data),; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""qutip/core/data/dispatch.pyx"", line 583, in qutip.core.data.dispatc",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2122:1094,coupling,coupling,1094,https://qutip.org,https://github.com/qutip/qutip/issues/2122,1,['coupling'],['coupling']
Modifiability," module is small and very focussed. 2. Exactly - it's more of an internal type. Currently `Qobj` converts the underlying data object to dense `ndarray` and prints it for its `repr` method - I don't have any plans to change that, so `Qobj` will still be full and user-facing. My `CSR` repr actually just tells you the same information that `scipy.sparse.csr_matrix` does, just in a slightly more Python-looking form. 3. Yes, in some form or another. Perhaps we could talk about the best way to do that in a future meeting?. 4. `PyDataMem_NEW` isn't actually a Python routine, it's a numpy one, but that's largely irrelevant. The Python equivalent is `cpython.mem.PyMem_Malloc` and family. The reason I don't use the latter in general is because sometimes `PyMem_Malloc` allocates into Python-reserved stack-space, and if we subsequently pass the pointer to numpy, it will try to free it and cause a segfault. The reason for using `malloc` and `free` here is mostly just because there was a comment in the code I copied it from saying that raw `malloc` and `free` were slightly faster for allocating heap space to be released within the same function, so I just did what they did. I can change it - it's not important. When allocating space that _may_ be passed to numpy, I always use `PyDataMem_NEW` (or friends). 5. That's a mistake - I meant to take out that ability in `matmul_csr` because it's just asking for trouble (the user won't know how much space to allocate, and we're basically just asking for a segfault). I did `matmul_csr` first, and I hadn't decided yet exactly what I was doing. 6. Yeah, I'm going to add additional `imul`, `ineg` and `idiv` routines as dispatched operations. 7. LAPACK/BLAS as far as we can. I've no pretense to being able to write faster code than hardware-specific optimised stuff for matrices. I haven't actually written most of the numerical code in this PR either - it's just ported from current `qutip`, with the variable names changed to be more descriptive.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648270004:2803,variab,variable,2803,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648270004,2,['variab'],['variable']
Modifiability," our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help wind",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1630,evolve,evolver,1630,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['evolve'],['evolver']
Modifiability," since it there are so many different dispatch functions from mesolve depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions.; > ; > Please let me know what you think about implementing this in qutip.; > ; > Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?; > ; > import scipy; > ; > from qutip.mesolve import _generic_ode_solve; > from qutip.superoperator import liouvillian, mat2vec; > from qutip.settings import debug; > ; > if debug:; > import inspect; > ; > def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; > progress_bar):; > """"""; > Evolve the super-operator `E0` using an ODE solver, for constant ; > Liouvillian; > """"""; > ; > ```; > if debug:; > print(inspect.stack()[0][3]); > ; > """"""; > #; > # check initial state; > #; > if isket(rho0):; > # if initial state is a ket and no collapse operator where given,; > # fall back on the unitary schrodinger equation solver; > if len(c_op_list) == 0 and isoper(H):; > return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; > progress_bar); > ; > # Got a wave function as initial state: convert to density matrix.; > rho0 = ket2dm(rho0); > """"""; > ; > #; > # check initial value; > #; > if not E0.issuper:; > raise TypeError(""Argument 'E0' should be a super-operator""); > ; > #; > # construct liouvillian; > #; > if opt.tidy:; > H = H.tidyup(opt.atol); > ; > L = liouvillian(H, c_op_list); > ; > #; > # setup integrator; > #; > initial_vector = mat2vec(E0.full()).ravel(); > # r = scipy.integrate.ode(cy_ode_rhs); > r = scipy.integrate.ode(_rhs); > # r.set_f_params(L.data.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/384#issuecomment-150751174:3247,Evolve,Evolve,3247,https://qutip.org,https://github.com/qutip/qutip/issues/384#issuecomment-150751174,1,['Evolve'],['Evolve']
Modifiability," support. pyproject.toml was introduced in QuTiP 4.6.0 to allow PEP517 build without (directly) using setup.py. But the `--with-openmp` option that previously worked with a setup.py build does not seem to be compatible with a PEP517 build. The problem shows up in the Debian build of the qutip package. Debian provides its own tool (pybuild from the dh-python package) to manage the build of python packages. PEP517 is relatively new, so by default pybuild uses setup.py if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build, not PEP517 build); INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:1046,plugin,plugin-pyproject,1046,https://qutip.org,https://github.com/qutip/qutip/issues/1875,1,['plugin'],['plugin-pyproject']
Modifiability," tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 10",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/888:2910,config,config,2910,https://qutip.org,https://github.com/qutip/qutip/issues/888,1,['config'],['config']
Modifiability," value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(expects[-1], variable); ```. Output:; ```; 20.0%. Run time: 0.03s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.05s. Es",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1766,Variab,Variable,1766,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['Variab'],['Variable']
Modifiability," version 3.2.0 can not run testing in my mac system OS X EI Capitan. When I try:; `$ python3 -c ""import qutip.testing as qt; qt.run()""`; I get the follow message:; ; > ---; > ; > Ran 0 tests in 0.000s; 2. However, the testing.py and the folder 'tests' exist. I can run the test in the 'tests' folder one-by-one. For example, when I run:; `$ sudo python3 test_mesolve.py`; I get; ; > .....................; > Ran 21 tests in 48.167s; > ; > OK; 3. `sudo` is needed here for permission. For example, when I run: ; `$ python3 test_mesolve.py`; I get a set of the following error message. > # .....E...E.E...E..E..; > ## ERROR: mesolve: time-dependence as array with super as init cond; > ; > Traceback (most recent call last):; > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/nose/case.py"", line 198, in runTest; > self.test(*self.arg); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/tests/test_mesolve.py"", line 638, in testMETDDecayAsArray; > out1 = mesolve(H, psi0, tlist, c_op_list, []); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 277, in mesolve; > progress_bar); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/mesolve.py"", line 661, in _mesolve_list_str_td; > cgen.generate(config.tdname + "".pyx""); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 116, in generate; > self.file(filename); > File ""/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/qutip-3.2.0.dev0-py3.5-macosx-10.6-intel.egg/qutip/cy/codegen.py"", line 78, in file; > self.file = open(filename, ""w""); > PermissionError: [Errno 13] Permission denied: 'rhs165050.pyx'",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/445:1508,config,config,1508,https://qutip.org,https://github.com/qutip/qutip/issues/445,1,['config'],['config']
Modifiability, we should remove it*; - [x] Decide what to do about the `renorm` argument to the old `HSolverDL`. Do we add it to the new BoFiN one?; - [x] Decide what to do about the `stats` argument. I'm planning to just add a note telling people to use `pyinstrument` if they need to profile their code.; - [x] Make HSolverDL use a bath instead of having the Matsubara calculation burried inside the solver.; - [x] Add Pade coefficient calculator somewhere? Maybe also as a bath?; - [x] Clean up the interfaces of `BosonicHEOMSolver` and `FermionicHEOMSolver`.; - [x] Whatever else we discover along the way.; - [x] Keep just the gather_op mode of RHS construction.; - [x] Split bath classes out into their own module.; - [x] Add underdamped spectral density bath. **Follow up PRs (i.e. before 4.7)**; - [x] Add Lorentzian fermionic bath (#1726); - [x] Convert the extension BoFiN documentation and into an extensive QuTiP guide (this PR already adds the docs but under qutip/nonmarkov/bofin/docs -- this allows the preservation of the original BoFiN commits) (#1724); - [x] Convert the BoFiN examples into QuTiP example notebooks (https://github.com/qutip/qutip-notebooks/pull/132/).; - [ ] Add MKL support to the dynamics solver. **Possible future work (i.e. look like great ideas but might never happen)**; - [ ] Use hermiticity relation from Schinabeck's PhD to half the number of ADOs stored in the fermionic bath.; - [ ] Possibly add support for time-dependent bath properties (e.g. altering the chemical potential of a Fermionic bath).; - [ ] Option to include time-dependent exponent coupling operators (Q); - [ ] Option to include time-dependent exponent coefficients (c_k's and v_k's); - [ ] Possibly add a means for automatically generating bath exponents for a given spectral density function. **Related issues or PRs**; None currently. **Changelog**; Imported BoFiN (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601:2655,coupling,coupling,2655,https://qutip.org,https://github.com/qutip/qutip/pull/1601,1,['coupling'],['coupling']
Modifiability,"## Changelog; The changelog file is present in `qutip/qutip-doc`. This means that for each new release, the maintainers need to go through the merged PRs and update the file accordingly. . I propose introducing a copy of the changelog file, which would simplify maintenance: each contributor could update their own contribution without opening a PR in the separate repository, which often does not happen. A message of a basic template with checklist could be prompted in the PR for itself. . ## PR template; To prompt these actions, just like for the changelog, [a template](https://help.github.com/en/github/committing-changes-to-your-project/creating-a-commit-with-multiple-authors) with suggested checklist could be made in the PRs. . ## Repositories refactoring ; Actually, this is all part of a wider problem for which the `qutip-doc` does not get well updated in general. In Qutip 4.5.0 I added a lot of missing elements to `functions.rst` and `classes.rst` in the api-doc. Moreover, the User guide is seldom updated. Maybe, moving the `qutip-doc` repository in the main `qutip/qutip` repository could help in this regard.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1172:755,refactor,refactoring,755,https://qutip.org,https://github.com/qutip/qutip/issues/1172,1,['refactor'],['refactoring']
Modifiability,"### Bug Description. I'm trying to follow [this tutorial](https://nbviewer.ipython.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb) with the current version of qutip, but ran into a bug in `mesolve`. If I do `from qutip import *` at the start of the notebook, the following error occurs:; ```; NameError Traceback (most recent call last); <ipython-input-9-d038ca745718> in <module>; 1 # Evolve the system, request the solver to call process_rho at each time step.; 2 ; ----> 3 mesolve(h_t, psi0, taulist, [], process_rho, args). ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 216 if not use_mesolve:; 217 return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; --> 218 progress_bar=progress_bar, _safe_mode=_safe_mode); 219 ; 220 if isket(rho0):. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in sesolve(H, psi0, tlist, e_ops, args, options, progress_bar, _safe_mode); 135 ; 136 res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; --> 137 progress_bar, dims=psi0.dims); 138 if e_ops_dict:; 139 res.expect = {e: res.expect[n]. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt, progress_bar, dims); 360 if expt_callback:; 361 # use callback method; --> 362 output.expect.append(e_ops(t, Qobj(cdata, dims=dims))); ...; ---> 11 H = qt.qobj_list_evaluate(h_t, tau, args); 12 ; 13 # find the M lowest eigenvalues of the system. NameError: name 'qt' is not defined; ```. If I do `import qutip as qt`, a different error occurs:; ```; AttributeError Traceback (most recent call last); <ipython-input-8-ea74e5ab1d35> in <module>; 1 # Evolve the system, request the solver to call process_rho at each time step.; 2 ; ----> 3 qt.mesolve(h_t, psi0, taulist, [], process_rho, args). ~/anaconda3/envs/fda/lib/python3.7/site-packages/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1930:433,Evolve,Evolve,433,https://qutip.org,https://github.com/qutip/qutip/issues/1930,1,['Evolve'],['Evolve']
Modifiability,"### Bug Description. In `qutip.qobjevo.compile`, on line 1646, the `.pyx` file created by qutip is registered into the global variable `coeff_files` containing a `_file_list` object using the method `coeff_files.add(file_)`. The `add` method appends a `.pyx` extension on line 60 to the string `file_`; ```; self.files += [file_ + "".pyx""]; ```; However, the `file_` string generated by `_compiled_coeffs` already has the file extension, judging from the return value of `qutip.qobjevo_codegen._import_str`, on line 54; ```; return coeff_obj, try_file + ext; ```; I believe this causes `coeff_files.clean()` on line 1697 of `qutip.qobjevo.compile` to not delete the `.pyx` files after the cython class has been loaded. ### Code to Reproduce the Bug. ```shell; import qutip as qt; qt.sesolve([qt.identity(2), [qt.sigmax(), 'sin(t)']], qt.basis(2, 0),; tlist=[0, 2]); ```. ### Code Output. ```shell; creates the file cqobjevo_compiled_coeff_6095589624050.pyx in the working directory.; ```. ### Expected Behaviour. The `.pyx` file in the working directory should be deleted. ### Your Environment. ```shell; QuTiP Version: 4.7.2; Numpy Version: 1.25.2; Scipy Version: 1.11.2; Cython Version: 0.29.36; Matplotlib Version: 3.7.2; Python Version: 3.10.12; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2231:126,variab,variable,126,https://qutip.org,https://github.com/qutip/qutip/issues/2231,1,['variab'],['variable']
Modifiability,"### Bug Description. Might just be me mis-using the new 5.X branch of Qutip. I get a memory error when upgrading to the new branch. It appears to fail when performing self._to_dm(state) for each state. My states are vectors of length 800 - so it runs out of memory. Is it possible to request the solver only stores the wavefunction at each timestep? I want the wavefunction for each trajectory for each timestep. Alternatively one could introduce a new ""proj"" data storage to make this more efficient. ### Code to Reproduce the Bug. ```shell; result = qutip.ssesolve(; hamiltonian_qobj,; initial_state_qobj,; times.times,; sc_ops=sc_ops,; e_ops=[],; options={; ""method"": ""euler"",; ""progress_bar"": ""enhanced"",; ""store_states"": True,; ""keep_runs_results"": True,; ""improved_sampling"": False,; ""dt"": times.delta_t / times.fundamental_n,; },; ntraj=n_trajectories, # cspell:disable-line; ); ```. ### Code Output. ```shell; File ""..."", line 270, in solve_stochastic_schrodinger_equation; result = qutip.ssesolve(; ^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\stochastic.py"", line 461, in ssesolve; return sol.run(; ^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\multitraj.py"", line 198, in run; map_func(; File ""...\.venv\Lib\site-packages\qutip\solver\parallel.py"", line 122, in serial_map; remaining_ntraj = reduce_func(result); ^^^^^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\result.py"", line 645, in add ; op(trajectory); File ""...\.venv\Lib\site-packages\qutip\solver\result.py"", line 519, in _reduce_states; accu + self._to_dm(state); ~~~~~^~~~~~~~~~~~~~~~~~~~; File ""...\.venv\Lib\site-packages\qutip\core\qobj.py"", line 134, in out; return method(self, other); ^^^^^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\core\qobj.py"", line 408, in __add__ ; return Qobj(_data.add(self._data, other._data),; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""qutip\\core\\data\\dispatch.pyx"", line 392, in qutip.core.data.dispatch.Dispatcher.__call__; File """,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2299:698,enhance,enhanced,698,https://qutip.org,https://github.com/qutip/qutip/issues/2299,1,['enhance'],['enhanced']
Modifiability,"### Bug Description. Power spectrum of the resonator-qubit (2-level system) system does not show two peaks based on the state of the qubit. Qubit is prepared either in the ground or excited state before the density matrix equation of the coupled system is solved and then the power spectrum is computed off of steady state solution. ### Code to Reproduce the Bug. ```shell; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr); ```. ### Code Output. _No response_. ### Expected Behaviour. The power spectrum does show vacuum Rabi splitting, which is fine. However, if the qubit is prepared in the ground state or the excited state, the spectrum does not shift based on the state of the qubit. ### Your Environment. ```shell; qutip v 4.6; python v 3.9; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1806:554,coupling,coupling,554,https://qutip.org,https://github.com/qutip/qutip/issues/1806,1,['coupling'],['coupling']
Modifiability,"### Bug Description. SciPy 1.8 deprecated importing functions from many submodules of scipy.sparse. For example, `scipy.sparse.sputils`. QuTiP fastsparse implementation accessing many of these functions because it extends scipy's sparse matrix support. It would be good to avoid as many of these deprecated imports as we can. Note that SciPy 1.8 is the first SciPy to support Python 3.10. ### Code to Reproduce the Bug. ```shell; python -X dev -c ""import qutip""; ```. ### Code Output. ```shell; <frozen importlib._bootstrap>:914: ImportWarning: PyxImporter.find_spec() not found; falling back to find_module(); /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `upcast` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `upcast_char` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `to_native` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `isdense` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `isshape` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastspar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1823:214,extend,extends,214,https://qutip.org,https://github.com/qutip/qutip/issues/1823,1,['extend'],['extends']
Modifiability,### Bug Description. Some files are missing `__all__` and leaking variables. ### Code to Reproduce the Bug. ```shell; import qutip.measurement; qt.measurement.np; ```. ### Code Output. ```shell; <module 'numpy' from 'miniconda3/lib/python3.10/site-packages/numpy/__init__.py'>; ```. ### Expected Behaviour. Only user facing qutip functions should be available. ### Your Environment. ```shell; QuTiP Version: 5.0.0.dev0; ```. ### Additional Context. `__all__` is missing in: ; - `qutip/measurements.py`; - `qutip/solve/piqs.py`; - `qutip/core/semidefinite.py`; which contain users facing functions.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2101:66,variab,variables,66,https://qutip.org,https://github.com/qutip/qutip/issues/2101,1,['variab'],['variables']
Modifiability,"### Bug Description. The Chi representation of channels is introduced in the documentation using an orthonormal basis, which happens to be the {Eye(2), Pauli matrices} / sqrt(2) for the case of a qubit. ; However, the implementation in the code uses an unnormalized one, yielding wrong results. In the file [superops_reps.py](https://github.com/qutip/qutip/blob/master/qutip/core/superop_reps.py), the variable _SINGLE_QUBIT_PAULI_BASIS is defined as:; ```; _SINGLE_QUBIT_PAULI_BASIS = (; identity(2).to(_data.CSR),; sigmax().to(_data.CSR),; sigmay().to(_data.CSR),; sigmaz().to(_data.CSR),; ); ```. ### Code to Reproduce the Bug. ```shell; import numpy as np; import qutip as qu. #Let's compute the chi matrix for F(rho) = -i[H, rho] for one qubit ; #We define the channel F(rho) = A_1 rho B^dag_1 + A_2 rho B^dag_2; #where ; #A_1 = -iH, B^dag_1 = Id(2) ; #A_2 = Id(2), B^dag_2 = iH. #With an example Hamiltonian. delta = 0.127; Omega = 0.5; H = qu.Qobj(np.array([[delta, Omega/2], [Omega/2, 0]])). print(H). #We define the Pauli basis as G = (Id(2), sigmax(2), sigmay(2), sigmaz(2))/np.sqrt(2). G = np.array([qu.identity(2), qu.sigmax(), qu.sigmay(), qu.sigmaz()])/np.sqrt(2). #The chi matrix is computed as: chi[i][j] = sum_k Tr(G[i]@A[k]) Tr(G[j]@B^dag[k]). chi = np.zeros([4, 4], dtype=np.complex64); for i in range(4):; for j in range(4):; chi[i,j] = np.trace(G[i]@A[0])*np.trace(G[j]@Bdag[0]) + np.trace(G[i]@A[1])*np.trace(G[j]@Bdag[1]); ; print(chi). #If we compare with the method from qutip, we see that the latter is off by a factor of 2. print(qu.to_chi(qu.liouvillian(H))); ```. ### Code Output. ```shell; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0.127 0.25 ]; [0.25 0. ]]; [[0.+0.j 0.+0.5j 0.+0.j 0.+0.127j]; [0.-0.5j 0.+0.j 0.+0.j 0.+0.j ]; [0.+0.j 0.+0.j 0.+0.j 0.+0.j ]; [0.-0.127j 0.+0.j 0.+0.j 0.+0.j ]]; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2259:402,variab,variable,402,https://qutip.org,https://github.com/qutip/qutip/issues/2259,1,['variab'],['variable']
Modifiability,"### Bug Description. The ReadTheDocs build fails with:; ```; gcc -pthread -B /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/compiler_compat -Wno-unused-result -Wsign-compare -DNDEBUG -fwrapv -O2 -Wall -fPIC -O2 -isystem /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include -fPIC -O2 -isystem /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include -fPIC -I/home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include/python3.10 -c _configtest.c -o _configtest.o; _configtest.c:2:10: fatal error: mpi.h: No such file or directory; 2 | #include <mpi.h>; | ^~~~~~~; ```; See https://readthedocs.org/projects/qutip/builds/23361676/ for the full build log (not sure if this is publicly visible -- if not, I can add QuTiP admins as maintainers on readthedocs.org if they give me their username). The QuTiP ReadTheDocs configuration is at: https://github.com/qutip/qutip/blob/master/.readthedocs.yaml. Probably this can be fixed by adding an appropriate dependency to https://github.com/qutip/qutip/blob/master/doc/rtd-environment.yml. ### Code to Reproduce the Bug. ```shell; Attempt to build the documentation on ReadTheDocs.; ```. ### Code Output. ```shell; gcc -pthread -B /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/compiler_compat -Wno-unused-result -Wsign-compare -DNDEBUG -fwrapv -O2 -Wall -fPIC -O2 -isystem /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include -fPIC -O2 -isystem /home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include -fPIC -I/home/docs/checkouts/readthedocs.org/user_builds/qutip/conda/master/include/python3.10 -c _configtest.c -o _configtest.o; _configtest.c:2:10: fatal error: mpi.h: No such file or directory; 2 | #include <mpi.h>; | ^~~~~~~; ```. ### Expected Behaviour. ReadTheDocs builds successfully. ### Your Environment. ```shell; QuTiP version: master branch; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2317:891,config,configuration,891,https://qutip.org,https://github.com/qutip/qutip/issues/2317,1,['config'],['configuration']
Modifiability,"### Bug Description. The documentation of mesolve states that lists of callback functions can be passed in the parameter e_ops:. > A list of operators as Qobj and/or callable functions (can be mixed) or a single callable function. For operators, the result’s expect will be computed by [qutip.expect](https://qutip.org/docs/latest/apidoc/functions.html#module-qutip.expect). For callable functions, they are called as f(t, state) and return the expectation value. A single callback’s expectation value can be any type, but a callback part of a list must return a number as the expectation value. However, I find that passing a callback function in a list e_ops = [my_callback] gives an exception:. > UnboundLocalError: local variable 'rho_t' referenced before assignment. By contrast, I find that passing a callback function directly as e_ops = my_callback does not cause an issue. This is important because I am unable to pass lists of callback functions which, according to the documentation, I should be able to do. ### Code to Reproduce the Bug. ```shell; # Imports ; import qutip as qt; import numpy as np. # System parameters; w = 1; kappa = 0.1; # Size of the Hilbert space; n_max = 10; # Annihilation operator; a = qt.destroy(n_max); # Callback function; my_callback = lambda t, rho_t : rho_t.purity(). # Hamiltonian; H = w * a.dag() * a; # Initial state; psi_0 = ( qt.fock(n_max, 0) + qt.fock(n_max, 1) ) / np.sqrt(2); rho_0 = qt.ket2dm( psi_0); # Integration times; times = np.linspace(0, 2/kappa, 5000); # Collapse operators; c_ops = [np.sqrt(kappa) * a]; # Observables to compute; e_ops = [my_callback]. # Solve the master equation; output = qt.mesolve(H, rho_0, times, c_ops, e_ops); ```. ### Code Output. ```shell; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); Cell In[17], line 29; 26 e_ops = [my_callback]; 28 # Solve the master equation; ---> 29 output = qt.mesolve(H, rho_0, times, c_ops, e_ops); 31",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2189:725,variab,variable,725,https://qutip.org,https://github.com/qutip/qutip/issues/2189,1,['variab'],['variable']
Modifiability,"### Bug Description. The rendering of the process matrix looks weird in qutip-v5, The bottom of the bars behind is on top of the lower bars in front of it. (This is a CNOT gate with some errors); ![image](https://github.com/qutip/qutip/assets/12125783/970923af-e361-4cdf-a573-32b477ede6e5). Maybe the order of the bar rendering is reversed during the last refactoring of the plotting library?. ### Code to Reproduce the Bug. ```python; import numpy as np; import qutip. # Create a noisy CNOT gate; IZ = qutip.tensor([qutip.qeye(2), qutip.sigmaz()]); gate = qutip.gates.cnot(); noisy_gate = (-2.j * np.pi*(IZ/8/20)).expm() @ gate; fid = qutip.average_gate_fidelity(noisy_gate, qutip.gates.cnot()); print(f""noisy CNOT fidelity {fid}""). # Plot process matrix; op_basis = [[qutip.qeye(2), qutip.sigmax(), qutip.sigmay(), qutip.sigmaz()]] * 2; chi = qutip.qpt(qutip.to_super(noisy_gate), op_basis); qutip.qpt_plot_combined(; chi, lbls_list=[[""i"", ""x"", ""y"", ""z""]] * 2, title=""Process Matrix""; ); ```. ### Code Output. ```; noisy CNOT fidelity 0.9987669334932512; ```; ![image](https://github.com/qutip/qutip/assets/12125783/bc6ce1b4-e3ad-4c6c-988f-a3701e238ebe). ### Expected Behaviour. The bars should be rendered correctly. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: 1.26.4; Scipy Version: 1.12.0; Cython Version: None; Matplotlib Version: 3.8.3; Python Version: 3.11.8; Number of CPUs: 40; BLAS Info: Generic; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2400:356,refactor,refactoring,356,https://qutip.org,https://github.com/qutip/qutip/issues/2400,1,['refactor'],['refactoring']
Modifiability,"### Bug Description. This bug is related to the one explained in #1829. After setting to False the `auto_tidyup` variable in settings, `mesolve` still calls `tidyup` and sets to 0 all values lower than 1e-12. The following code is from a [QuTiP example](https://qutip.org/docs/latest/guide/dynamics/dynamics-time.html#function-based-time-dependence), but removing the collapse operators and multiplying the constant hamiltonian with a very small value (and changing the time vector accordingly). More specifically, I create two different hamiltonians by multiplying `H0` by 1e-12 and 1e-13 respectively. After computing the `mesolve` for both hamiltonians, one can see that in the second case all values have been set to 0. . ### Code to Reproduce the Bug. ```shell; from qutip import basis, tensor, qeye, destroy, num, mesolve, settings; import numpy as np. settings.auto_tidyup = False. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). t = np.linspace(-15, 15 * 1e11, 10) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). H_0 = [H0 * 1e-12, [H1, H1_coeff]]; H_1 = [H0 * 1e-13, [H1, H1_coeff]]; output_1 = mesolve(H_0, psi0, t, e_ops=[ada]); output_2 = mesolve(H_1, psi0, t, e_ops=[ada]); print(output_1.expect[0]); print(output_2.expect[0]); ```. ### Code Output. ```shell; [0. 0.48307748 0.87367156 0.3158159 0.03202178 0.64420957; 0.8108019 0.1667205 0.12343592 0.77580413]; [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]; ```. ### Expected Behaviour. The second print should NOT have been all 0s. ### You",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1831:113,variab,variable,113,https://qutip.org,https://github.com/qutip/qutip/issues/1831,1,['variab'],['variable']
Modifiability,"### Bug Description. When initializing an `EnhancedTextProgressBar` object the `__init__` method is calling the `start` method of it's super class instead of it's own. When then using `update` (without calling `start` manually again) there will be an `AttributeError` because `width` is not getting initialized by `__init__`. ### Code to Reproduce the Bug. ```shell; from qutip.ui.progressbar import *. n = 10; a = EnhancedTextProgressBar(n); # a.start(n); for i in range(n):; a.update(i); a.finished(); ```. ### Code Output. ```shell; Traceback (most recent call last):; File ""C:\Users\Name\Desktop\qutip_bug.py"", line 6, in <module>; a.update(i); File ""C:\Users\Name\AppData\Local\Programs\Python\Python311\Lib\site-packages\qutip\ui\progressbar.py"", line 96, in update; all_full = self.width - 2; ^^^^^^^^^^; AttributeError: 'EnhancedTextProgressBar' object has no attribute 'width'; ```. ### Expected Behaviour. Proper initialization of the `width` attribute by `EnhancedTextProgressBar.__init__`. ### Your Environment. ```shell; QuTiP Version: 4.7.1; Numpy Version: 1.24.2; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.7.1; Python Version: 3.11.0; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```. ### Additional Context. Currently in master the `__init__` for both `TextProgressBar` and `EnhancedTextProgressBar` have been commented out and made to just pass. See https://github.com/qutip/qutip/blob/af49884aa1db47a980626ac00adfe83277d8d261/qutip/ui/progressbar.py#L66 and https://github.com/qutip/qutip/blob/af49884aa1db47a980626ac00adfe83277d8d261/qutip/ui/progressbar.py#L94. I would suggest making them both call their own `start` method to omit an additional call of start by the user right after initialization. This would also make both classes be in line with the usage suggested by the docstring of `BaseProgressBar.` Otherwise I would suggest to include the call to start in said docstr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2148:43,Enhance,EnhancedTextProgressBar,43,https://qutip.org,https://github.com/qutip/qutip/issues/2148,4,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"### Bug Description. When setting `CoreOptions(default_dtype)` I expect all quantum objects to inherit the specified dtype. States and operators defined in states.py and operators.py do so but some functions return other data types. like `eigenstates()`. This can lead to some unexpected behavior (and very inefficient code). Seems like a good first issue for someone to go around and find functions where this should be enforced and do so? . Alternatively, would forcing CoreOptions(default_dtype) to be used in `Qobj` creation itself be easier? Though I kinda feel it might cause secondary problems, like if you wanted largely to use a default dtype but then have special cases where you don't, etc etc. ### Code to Reproduce the Bug. ```shell; with CoreOptions(default_dtype=""CSR""):; H = sigmaz() + sigmax(); print(H.eigenstates()[1][0].data); ```. ### Code Output. ```shell; Dense(shape=(2, 1), fortran=True); ```. ### Expected Behaviour. Return sparse states. ### Your Environment. ```shell; QuTiP Version: 5.0.0a2; Numpy Version: 1.26.0rc1; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.6.3; Python Version: 3.11.7; Number of CPUs: 28; BLAS Info: Generic; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328:95,inherit,inherit,95,https://qutip.org,https://github.com/qutip/qutip/issues/2328,1,['inherit'],['inherit']
Modifiability,"### Bug Description. `UnboundLocalError: local variable 'rho_t' referenced before assignment` is thrown when `mesolve` is used with callable `e_ops`. Note, it seems to be fixed on the 5.x branch (using `pip install --pre qutip`). ### Code to Reproduce the Bug. ```shell; from qutip import * ; import numpy as np. s_00 = tensor(basis(2,0), basis(2,0)); P_00 = s_00 * s_00.dag(); e_ops = [ ; lambda t, state: (state.ptrace([0,1]) * P_00).tr() ; ]. tlist = np.linspace(0, 2*np.pi, 50); res = mesolve(tensor(identity(2), identity(2), identity(3)),; tensor(P_00, thermal_dm(3,0.1)), ; tlist, ; [],; e_ops); ```. ### Code Output. ```shell; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-1-49ed87444849> in <module>; 9 ; 10 tlist = np.linspace(0, 2*np.pi, 50); ---> 11 res = mesolve(tensor(identity(2), identity(2), identity(3)),; 12 tensor(P_00, thermal_dm(3,0.1)),; 13 tlist,. 1 frames; /usr/local/lib/python3.9/dist-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 242 func(0., v, *ode_args) + v; 243 ; --> 244 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 245 progress_bar, dims=rho0.dims); 246 res.num_collapse = len(c_ops). /usr/local/lib/python3.9/dist-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 517 for m in range(n_expt_op):; 518 if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; --> 519 output.expect[m][t_idx] = e_ops[m](t, rho_t); 520 continue; 521 output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,. UnboundLocalError: local variable 'rho_t' referenced before assignment; ```. ### Expected Behaviour. no error. ### Your Environment. ```shell; QuTiP Version: 4.7.1; Numpy Version: 1.22.4; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.5.3; Python Version: 3.9.16; Number of CPUs: 2; BLAS Info: OPENBLAS;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2118:47,variab,variable,47,https://qutip.org,https://github.com/qutip/qutip/issues/2118,1,['variab'],['variable']
Modifiability,"### Bug Description. qutip has functions to detect the available of BLAS libraries. For instance on my system (debian unstable), `python3 -c ""import qutip; qutip.about()""` reports; ```; BLAS Info: OPENBLAS; ```. However, I think the logic behind BLAS Info is not robust. For context, debian builds packages against generic libblas.so (libblas-dev package). The various optimised BLAS implementations are supposed to be binary compatible, such that the system administrator can install the preferred implementation for use at runtime (the identity of libblas.so is controlled using debian's alternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:746,config,configuration,746,https://qutip.org,https://github.com/qutip/qutip/issues/2053,4,['config'],"['config', 'configuration']"
Modifiability,"### Bug Description. qutip keeps configuration (e.g. for openmp) in a config file handled in configrc.py. The default location is in the home dir, with; https://github.com/qutip/qutip/blob/d2f1ed57d13bd35055d72f3f6b3418c962491bd9/qutip/configrc.py#L36; setting the dir to `~/.qutip` and; https://github.com/qutip/qutip/blob/d2f1ed57d13bd35055d72f3f6b3418c962491bd9/qutip/configrc.py#L38; setting the config file to `~/.qutip/qutiprc`. This forces Linux distributions to do more work when building in a chroot. For instance Debian build chroots set the ""home"" directory to `/nonexistent`, and then building docs fails with; ```; PermissionError: [Errno 13] Permission denied: '/nonexistent'; ```; since it can't create `/nonexistent/.qutip`. In practice that's not a great problem since when building docs for the package, we can set `HOME=$BUILDDIR` to place the config location in the build dir (which is writable) instead of `/nonexistent`. However there is a standardized location for config files which might be worth considering instead. The freedesktop.org specification at https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html identifies locations for config and data files. Config files can be located under (one of) `$XDG_CONFIG_DIRS` for system configuration, or under `$XDG_CONFIG_HOME` for user configuration. ### Code to Reproduce the Bug. _No response_. ### Code Output. _No response_. ### Expected Behaviour. In python XDG is accessible from the xdg package (in debian, the python3-xdg package). So the XDG equivalent of ; ```; qutip_conf_dir = os.path.join(os.path.expanduser(""~""), '.qutip'); ```; could be done with; ```; from xdg import XDG_CONFIG_HOME; ...; qutip_conf_dir = os.path.join(XDG_CONFIG_HOME, '.qutip'); ```; A more sophisticated method could be set up to also check XDG_CONFIG_DIRS instead (XDG_CONFIG_HOME is the first entry in the list defined in XDG_CONFIG_DIRS). ### Your Environment. ```shell; QuTiP Version: 4.7.0; ```. ### Additional Conte",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876:33,config,configuration,33,https://qutip.org,https://github.com/qutip/qutip/issues/1876,8,['config'],"['config', 'configrc', 'configuration']"
Modifiability,"### Bug Description. setup.py manages a `--with-openmp` build option to provide openmp support. pyproject.toml was introduced in QuTiP 4.6.0 to allow PEP517 build without (directly) using setup.py. But the `--with-openmp` option that previously worked with a setup.py build does not seem to be compatible with a PEP517 build. The problem shows up in the Debian build of the qutip package. Debian provides its own tool (pybuild from the dh-python package) to manage the build of python packages. PEP517 is relatively new, so by default pybuild uses setup.py if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:625,plugin,plugin-pyproject,625,https://qutip.org,https://github.com/qutip/qutip/issues/1875,2,['plugin'],['plugin-pyproject']
Modifiability,"### Describe the Issue!. By building QuTiP 5 with:; ```; python -m build \; --wheel \; --config-setting=""--global-option=--with-idxint-64""; ```; one can use 64-bit integer indices. Currently this is only documented in the changelog. We should also write a short guide on it, perhaps. It might also be worthwhile adding a CI build for the 64-bit index case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2278:89,config,config-setting,89,https://qutip.org,https://github.com/qutip/qutip/issues/2278,1,['config'],['config-setting']
Modifiability,"### Describe the Issue!. Dysolve algorithm proposed in paper [""Fast and differentiable simulation of driven quantum systems""](https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.3.033266) by Ross Shillito et.al, ; behaves much faster than standard numerical integrators in time-evolve driven quantum systems. ; Is there any plan to implement it in the qutip, or it has been implemented in qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2394:295,evolve,evolve,295,https://qutip.org,https://github.com/qutip/qutip/issues/2394,1,['evolve'],['evolve']
Modifiability,"### Describe the Issue!. Hi, ; in QuTiP 5 I don' t have to compile `QobjEvo` manually. That's great! ; Since the `compile()` function is removed in QuTiP 5, all code that was written in version 4 breaks.; Maybe, we could add an empty `compile()` function with a deprecation warning, to allow users to adapt before we completely remove it.; @Ericgig, what do you think?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1949:301,adapt,adapt,301,https://qutip.org,https://github.com/qutip/qutip/issues/1949,1,['adapt'],['adapt']
Modifiability,"### Describe the Issue!. Hi,; I‘m tring to simulate the population dynamics and polarization evolution in a system where a ladder-type three-level system interacts with an ultrafast pulse.; ![image](https://github.com/qutip/qutip/assets/103415418/6a5c57f6-32ec-4c87-b0e1-22a5b4df5d7a); And this is the Hamiltonian I want to simulate.; ![image](https://github.com/qutip/qutip/assets/103415418/eb81196d-49ba-4f87-84c7-34880bd1c81f); But I didn't get the expected results, the system always stays at ground state. . I suspect that I failed to simulate the right model, especially for the modeling of the three-level model. Because I had tried to remove the pulse and simulate the dynamics of excited three-level system, but still it didn't evolve. . So I think first I need advice for the right modelling of three-level system, then go to the light-matter interaction. I'm looking forward to your generous advice. Thanks. The scripts for my model and my model without pulse are attached. The model without pulse:. ```python; from qutip import * # for quantum dynamics; import numpy as np # for numerical manipulations; from matplotlib import pyplot as plt. #%% Parameters; hbar = 0.658211951 # in eV fs. E1 = 0; E2 = 1.722 # eV; E3 = 3.426 # eV. t_fwhm = 80 # [fs]; t0 = 2*t_fwhm; tlist= np.linspace(0,5*t0,800) # [fs]; #%% Construct Hamiltonian; one, two, three = three_level_basis(); sig11 = one * one.dag(); sig22 = two * two.dag(); sig33 = three * three.dag(); sig13 = one * three.dag(); sig23 = two * three.dag(); sig12 = one * two.dag(). H = E1*sig11+E2*sig22+E3*sig33. # collapse operators; gamma2 = 0.006/hbar; gamma3 = 0.006/hbar. c1 = gamma2*sig22; c2 = gamma3*sig33; c_ops = [c1,c2]. rho0 = sig22. e_ops = [sig11,sig22,sig33]. output = mesolve(H,rho0,tlist,c_ops,e_ops); plt.plot(tlist, output.expect[0],label = r""$\rho_{11}$""); plt.plot(tlist, output.expect[1],label = r""$\rho_{22}$""); plt.plot(tlist, output.expect[2],label = r""$\rho_{33}$""); plt.legend(); ```; The model with pulse:; ```pyt",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2355:737,evolve,evolve,737,https://qutip.org,https://github.com/qutip/qutip/issues/2355,1,['evolve'],['evolve']
Modifiability,"### Describe the Issue!. Hi. I'm using ```mesolve``` to evolve a system under a double-well(DW) potential. By varying *zeta* from -1 to larger values, the DW starts to form after *zeta* exceeds 0. The way zeta changes in time is determined by a *ramp function*. Giving the solver a ```tlist``` it's expected that the solver evolves the system from ```tlist[0]``` to ```tlist[-1]```. Oddly the solver doesn't pick the final time:; ```python; import numpy as np; from qutip import *. # constants. gamma = 2.65e-08 #dim.less. # problems's variables. zeta_i = -1 # initial zeta value; dim = 50. # Initial and Final Hamiltonians. b = destroy(dim); H0 = -(1 / 4) * (b - b.dag())**2; H1 = -(1 / 4) * (b + b.dag())**2; H2 = gamma * (b + b.dag())**4. # Hamiltonian of system with a DW potential; def H_DW(zeta, dim):; b = destroy(dim); H0 = -(1 / 4) * (b - b.dag())**2; H1 = -(1 / 4) * (b + b.dag())**2; H2 = +gamma * (b + b.dag())**4; return H0 + np.sign(zeta) * H1 / 0.25 + np.sqrt(np.abs(0.25 * zeta))**(-3) * H2. # Coefficients. def H1_coeff(t,args):; zeta = args['zeta']; return np.sign(zeta) / 0.25. def H2_coeff(t,args):; zeta = args['zeta']; return np.sqrt(np.abs(0.25 * zeta))**(-3). def H0t(t,args):; global zeta_stored; zeta = args['zeta']; zeta_stored = zeta; print('t =',t); print('zeta =',zeta,'\n'); return H0 + H1_coeff(t,args) * H1 + H2_coeff(t,args) * H2. # Function Based Hamiltonians or Liouvillians. def H_iso(t, args):; return H0t(t, args). def L_iso(t, args):; args['zeta'] = rampFunc(t); H = H_iso(t, args); return qutip.liouvillian(H, []). # Auxiliary Functions and Constants. def zetaLin(t):; global z_f, z_i, tt_f, tt_i; slope = (z_f - z_i) / (tt_f - tt_i); return slope * (t - tt_i) + z_i; # other ramp functions go here; # ... # set ramp function: this function chages zeta in time (linearly, sinusoidaly, ...). def set_rampFunction(rampFunction):; global rampFunc; if rampFunction == 'sin':; rampFunc = zetaSin; elif rampFunction == 'linear':; rampFunc = zetaLin; ; ; ############",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1821:56,evolve,evolve,56,https://qutip.org,https://github.com/qutip/qutip/issues/1821,3,"['evolve', 'variab']","['evolve', 'evolves', 'variables']"
Modifiability,"### Describe the Issue!. I'm trying to follow the [CRAB / pulse optimizer tutorial](https://github.com/qutip/qutip-notebooks/blob/master/examples/control-pulseoptim-CRAB-QFT.ipynb) but realize that my Hamiltonian takes a slightly different form than the control form (""H_c"") they use. They use a list of QObjs w/ variable amplitude, whereas my Hamiltonian has the following term which seems challenging to input:. $$ ; f_j(t) (a_j e^{-i \phi_j(t)} - a^\dagger_j e^{i \phi_j(t)}); $$. Even for $j \in [1]$ only, how can I make it so that this term has two controls, one which controls the amplitude and one which controls the phase?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2297:313,variab,variable,313,https://qutip.org,https://github.com/qutip/qutip/issues/2297,1,['variab'],['variable']
Modifiability,"### Describe the Issue!. The document of QuTiP said installing from the source code by `python setup.py install --with-openmp` doesn't support for macOS. But this is actually easy to deal with. . Step 1. Install GNU GCC and OpenMP from home-brew; ``; $ brew install gcc libomp; ``. Step 2. Export environment CC CXX instead of `/usr/bin/gcc` by `/usr/local/bin/gcc-13`; ``; $ export CC=`which gcc-13`; $ export CXX=`which g++-13`; ``. Now it is worked in my environment that `python setup.py build --with-openmp` generates a OpenMP edition QuTiP. And as for INTEL MKL supporting info, the judgment for macOS is different, you can find the way [here](https://mruss.dev/2020/04/23/numpy-mkl/) to get this information rather than `hasattr(config,'mkl_info')`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2274:736,config,config,736,https://qutip.org,https://github.com/qutip/qutip/issues/2274,1,['config'],['config']
Modifiability,"### Describe the Issue!. qutip mesolve gives me different population evolve depending on that initial state is state vector or density matrix. And, in some situation, it gives me negative population. It doesn't make sense... Does anyone encounter this problem?. Population evolvement with State vector as initial state; ![image](https://github.com/qutip/qutip/assets/105193507/f4857bde-cade-4fac-ad31-33edc7d93b63). Pupulation evolvement with Density matrix as initial state; ![image](https://github.com/qutip/qutip/assets/105193507/d3e82af0-e0d7-43fa-8844-b68887c9a394). Here is my code: I'm just producing Rabi oscillation by applying microwave whose frequency is the difference between eigenenery［1］ and eigenenergy［0］. ```; import qutip as qt; import numpy as np; import matplotlib.pyplot as plt. # Constants (G or us). Sx, Sy, Sz = qt.jmat(1); S0 = qt.qeye(3). ge = 2 * np.pi * -2.8 # rad MHz/G. B = 60 # G; theta = 0 # degree; Bx = B * np.sin(np.pi * theta / 180); Bz = B * np.cos(np.pi * theta / 180). def H_GS():; D = 2 * np.pi * 2870 # rad MHz; H_D = D * (Sz**2 - 2/3 * S0); H_B = ge * (Bx * Sx + Bz * Sz); H_GS = H_D + H_B; return H_GS. ee, ev = H_GS().eigenstates(). def evolve_test():; H_MW = ge * Sx; def H_MW_coeff(t, args):; omega = ee[1] - ee[0]; Omega = 1/0.1/ge; return Omega * np.cos(omega * t); H = [H_GS(), [H_MW, H_MW_coeff]]; psi0 = qt.basis(3, 0); rho0 = qt.ket2dm(qt.basis(3, 0)); rhoe = qt.ket2dm(qt.basis(3, 0)); t = np.linspace(0, 4, 4 * 1000); result = qt.mesolve(H, rho0, t, progress_bar=True); states = result.states; popm = [qt.expect(rhoe, state) for state in states]; plt.plot(t, popm); plt.show(); return 0. evolve_test(); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2229:69,evolve,evolve,69,https://qutip.org,https://github.com/qutip/qutip/issues/2229,3,['evolve'],"['evolve', 'evolvement']"
Modifiability,"### Discussed in https://github.com/qutip/qutip/discussions/2255. <div type='discussions-op-text'>. <sup>Originally posted by **shiv6510** November 2, 2023</sup>; Hi, I am encountering some strange dynamics with mesolve that I don't understand. I have a simple hamiltonian of a harmonic oscillator with resonant frequency of 5 GHz. If I evolve the initial state (|0> + |1>)/sqrt(2) under the system hamiltonian (no time dependence) I would expect the expectation values of the |0> and |1> to stay at 0.5. (Amplitudes of eigenstates should not change). . However, when I plot the expectation values, I see a splitting of overtime, where the expectation value of |0> grows linear over time and |1> shrinks linearly with time. Looking through the forums, I figured it was an issue with the ode solver but playing around with the options (max_steps, rtol, atol, etc.) only changes the rate at which the expectation value drops (or grows); it doesn't get rid of the splitting. Any insight into this problem would be of great help :). Code:; ***********************************************************************; import matplotlib.pyplot as plt; from numpy import *; from scipy.optimize import fsolve; from qutip import *. a = destroy(20); wr = 5 # GHz; H = wr * a.dag() * a. e_nrgs, e_states = H.eigenstates(). psi0 = (e_states[0] + e_states[1]).unit(); wait_time = 2000; t_list = arange(0,wait_time+0.02, 0.01). options = Options(max_step=1/(wr * 100)); output = sesolve(2 * pi * H, ; psi0, ; t_list, ; e_ops=[e_states[0].proj(), e_states[1].proj()], ; args=None,; options=options,; progress_bar=True); ***********************************************************************. Plot:. plt.plot(t_list, output.expect[0], color='red', label='<0>'); plt.plot(t_list, output.expect[1],label='<1>'); plt.xlabel('Time[ns]'); plt.ylabel('Expectation Value'); plt.legend(); plt.show(). <img width=""840"" alt=""image"" src=""https://github.com/qutip/qutip/assets/43760523/c55016b4-5fbc-4032-b8e0-d143152250bb"">. </div>",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2258:337,evolve,evolve,337,https://qutip.org,https://github.com/qutip/qutip/issues/2258,1,['evolve'],['evolve']
Modifiability,"### Objective; The primary objective was to improve the computational efficiency of the `correlation_2op_1t` function in QuTiP. This function computes two-time correlations for quantum systems, which is computationally intensive, especially for large systems or long time arrays. The goal was to enhance performance by parallelizing these computations. ### Enhancements Overview. 1. **Parallel Computing**:; - **Implementation**: Utilized Python’s `concurrent.futures` module, specifically `ProcessPoolExecutor`, to parallelize the computation of correlation values over different tau values (`taulist`). Each tau value computation is independent of others, making this a suitable case for parallel execution.; - **Function Splitting**: Created a helper function `compute_single_tau_correlation` to handle the computation for a single tau. This function manages the setup of the quantum system, computes the correlation for its specific tau, and handles any exceptions that may occur, logging them accordingly.; - **Resource Management**: Used the `cpu_count` from the `os` module to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing T",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:296,enhance,enhance,296,https://qutip.org,https://github.com/qutip/qutip/pull/2395,2,"['Enhance', 'enhance']","['Enhancements', 'enhance']"
Modifiability,"### Problem Description. Currently the most time consuming part of making releases is managing the change log (#1055 , #1108, #1533). In addition to the time taken, the release manager is often poorly placed to write change log entries for the PRs involved (the PRs might have been merged some time ago, and the release manager might not have been the author). ### Proposed Solution. [Towncrier](https://pypi.org/project/towncrier/) is a Python package used by Python itself and many other libraries to manage the change log. I propose that we configure towncrier and ensure that each PR adds a towncrier entry. This includes:; - [x] Add suitable towncrier configuration to the respository.; - [x] Update the release documentation with instructions for using towncrier to update the change log.; - [x] Update the development documentation to include the requirement to add towncrier entries for each PR.; - [x] Update the GitHub PR template to mention the requirement to add a towncrier entry.; - [x] Add a check to the GitHub action tests workflow that checks that a towncrier entry was added. ### Alternate Solutions. There are a few other tools that do similar things to towncrier, and we could use one of those instead if they are better. I would recommend that we not roll our own solution. The problem is fairly simple, but writing and documenting our own solution and fixing the inevitable bugs is a lot of work. Plus, I would prefer to have a solution that has already made choices that work, rather than us having to make all of those choices ourselves. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1894:544,config,configure,544,https://qutip.org,https://github.com/qutip/qutip/issues/1894,2,['config'],"['configuration', 'configure']"
Modifiability,"### Problem Description. From version 5.0, the subpackage `qutip.qip` will be removed and replaced by a separate package `qutip-qip`. To make it easier for others to migrate from 4.7 to 5.0, we can set up `qutip-qip` as an optional plug-in for qutip, so that if `qutip-qip` is installed, the `qutip.qip` name space can be used as before. ### Expected behaviour; - If only `qutip` is installed, importing `qutip.qip` will raise an `ImportError` with instruction for installing `qutip_qip`.; - If `qutip-qip` is installed, using `qutip.qip` will automatically use the `qutip_qip` namespace, with no difference in the user interface.; - Update `setup.cfg` so that `pip install qutip[qip]` will automatically install `qutip_qip`. E.g. the following should work if `qutip`-5.0 and `qutip-qip` are both installed; ```python; # The following should be the same; from qutip.qip.circuit import QubitCircuit; from qutip_qip.circuit import QubitCircuit; ```. ### Proposed Solution. See https://github.com/qutip/qutip/discussions/1500 for ideals on the implementation. **Note: The implementation should be done against the `dev.major` branch of qutip.**",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1893:232,plug-in,plug-in,232,https://qutip.org,https://github.com/qutip/qutip/issues/1893,1,['plug-in'],['plug-in']
Modifiability,"### Problem Description. Hello, I am recently using `qt.propagator ` to calculate the time evolution of states with collapse operators. I am having memory usage problem due to qutip's matrix conversion.; This matrix conversion is especially memory intensive when performing propagator calculation with collapse operators. Current qutip propagator uses numpy array to store the **raw calculation data**.; `u = np.zeros([N * N, N * N, len(tlist)], dtype=complex)`. Qutip then converts matrices at each time list t at the end of this function.; ```; if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; ```. This conversion effectively requires the same memory usage as ""u"".; This behavior is problematic when raw results `u` consumes a lot of memory.; I would be happy if there is an optional argument to skip `Qobj(u[k])` process. ### Proposed Solution. Add a feature to select if qt.propagator performs conversion to Qobj or just return numpy array.; Rewrite the code of ""qutip/propagator.py"" around line 221 something like. ```; if not skip_qutip_conversion:; out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; else:; out = u; return out; ```. ### Alternate Solutions. _No response_. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2312:1062,Rewrite,Rewrite,1062,https://qutip.org,https://github.com/qutip/qutip/issues/2312,1,['Rewrite'],['Rewrite']
Modifiability,"### Problem Description. I'm wondering if it's possible to use `mesolve` to find the evolution of an arbitrary operator in the Heisenberg picture, where the operators carry all of the time dependence, and thus evolve according to the _adjoint_ Lindblad equation. For some operator $O$, the coherent part is $+i [H,O]$ and the dissipator for a collapse operator $L$ is $L^\dagger O L - \frac{1}{2} L^\dagger L O - \frac{1}{2} O L^\dagger L $.; In particular, I was wondering if there is a way to ""hack"" mesolve to do this without any modification, such as using $-O$ instead of $O$ so that it matches the coherent Schrodinger picture evolution $-i [H,O]$ that `mesolve` does, but I'm not sure about the dissipator. Using $L^\dagger$ instead of $L$ would also change the anticommutator term, which actually shouldn't change between the two pictures. Is there a sneaky way of making this work without too much modification? Otherwise, perhaps this would be a good feature to add?. ### Proposed Solution. Instructions on how to use `mesolve` to solve for the time evolution of an operator in the Heisenberg (not Schrodinger) picture, or an extension of `mesolve` to allow for this, possibly through an option in the function call like `picture=True` which defaults to Schrodinger but if False uses the Heisenberg picture. ### Alternate Solutions. _No response_. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2160:210,evolve,evolve,210,https://qutip.org,https://github.com/qutip/qutip/issues/2160,1,['evolve'],['evolve']
Modifiability,"### Problem Description. The `improved_sampling` option was recently added to `mcsolve`. It might also be useful to have in `nm_mcsolve`, but adaptations to the code are required to make it work. Currently, we have disabled this option for the `NonMarkovianMCSolver`, see [PR 2234](https://github.com/qutip/qutip/pull/2234). Since `NonMarkovianMCSolver` inherits from `MCSolver`, one might expect this option to work ""out of the box"". The technical reason why it does not is that `nm_mcsolve` calculates the value of an influence martingale, which is factored into the calculation of expectation values in the custom result class `NmmcResult`. If `improved_sampling` is enabled, the result class `McResultImprovedSampling` is used instead, which is not aware of the martingale. ### Proposed Solution. Both the improved sampling algorithm and `nm_mcsolve` give trajectories a *weight*. In the former case, the weight is related to the probability of the trajectory without jumps; in the latter case it is the influence martingale. I imagine it might be useful to give `McResult` itself the capability to handle weighted trajectories. ; This capability would be useful for one additional purpose: if we want to allow mixed initial conditions for `mcsolve` in the future. In this case, the trajectories would need to be weighted with a correction factor, because the fraction $f_i$ of trajectories starting in a state $i$ will generally not be equal to the corresponding eigenvalue $p_i$ of the density matrix $\rho = \sum p_i |i \rangle\langle i|$. (Hence, the correction factor would be $p_i / f_i$.). If people think this would be useful (including the mixed initial states), I will try to implement this proposal once I can find some time to do so. ### Alternate Solutions. Alternatively, we could leave things as they are now and not support the improved sampling for `nm_mcsolve`. Another less invasive option would be copying the improved sampling algorithm to `nm_mcsolve` (adding a `NmmcResultIm",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2235:142,adapt,adaptations,142,https://qutip.org,https://github.com/qutip/qutip/issues/2235,2,"['adapt', 'inherit']","['adaptations', 'inherits']"
Modifiability,"### Problem Description. The options that can be passed to the solvers are not entirely clear by looking at the documentation. For example:; ![image](https://github.com/qutip/qutip/assets/57414022/2c36d3a5-ca7b-42aa-86d2-cc6f273ed115); Does not show the explicit options even thought it refers to them in the parameter documentation. For comparison, SESolver does show the options. This I assume is because the options are inherited from SESolver. But this is not clear either by looking at `MESolver`'s rendered documentation.; ![image](https://github.com/qutip/qutip/assets/57414022/0d8d7a4d-6326-4d1a-a25e-d67264906f85). When using `help(MESolver)` the documentation of the class is much clearer but perhaps too verbose for the online documentation. ### Proposed Solution. I would suggest we render the options property explicitly for each solver. I would also consider rendering the documentation related to the `run` method. If not, we should render at least `Solver` documentation which does not seem to be listed in the class API documentation for solvers. Affected solvers:; - [ ] MESolver; - [ ] SMESolver; - [ ] SSESolver; - [ ] NonMarkovianMCSolver. ### Alternate Solutions. _No response_. ### Additional Context. The documentation was taken from qutip 5.0 ""ReadTheDocs"".",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2163:423,inherit,inherited,423,https://qutip.org,https://github.com/qutip/qutip/issues/2163,1,['inherit'],['inherited']
Modifiability,"### Problem Description. `ssesolve` is slow when used with the ""euler-maruyama"" solver and a large number of sparse noise oprators. ### Proposed Solution. Qutip should take into account sparsity in sc_ops when used with the ""euler-maruyama"" solver. ### Alternate Solutions. _No response_. ### Additional Context. I'm currently using `qutip.ssesolve`, however for my application I require a large number of independent noise operators. This currently causes the solver to run very slowly, however in theory increasing the number of operations should only result in a small overhead if the underlying matrix is sparse. If I add together all matrices it runs much quicker. Is this something that has already been addressed in the 5.0 refactor? I am potentially interested in making a pr to fix this but I don't want to waste effort on something which is already fixed or undesirable",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298:731,refactor,refactor,731,https://qutip.org,https://github.com/qutip/qutip/issues/2298,1,['refactor'],['refactor']
Modifiability,"#1249 should be reviewed and merged before this (because if it needs changed, then this PR has to be rebased on top of it), but also I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063:236,refactor,refactor,236,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315063,1,['refactor'],['refactor']
Modifiability,"#1347 changed the setup of the tests, but it went unnoticed (sorry!) that the Python version wasn't set correctly; we've been silently testing everything against python-latest since then. That wasn't an issue as long as Python 3.8 was the latest, but the release of Python 3.9 (and the fact we haven't rebuilt a binary distribution of QuTiP for 3.9) caused all Linux builds to break. Mac builds were unaffected because they set `$_PYTHON_VERSION` to a string literal. The Linux Python version was not set correctly because it attempted to set it to the definition of `$TRAVIS_PYTHON_VERSION` _as defined during the `env` stage of the Travis build_. Unfortunately, this environment variable isn't defined until after that stage, which caused us to pass an empty constraint on the Python version to conda, resulting in us getting the latest version. This moves this part of the environment setup into the pre-install phase so `TRAVIS_PYTHON_VERSION` is now set, and guards it with a conditional so the mac builds can still neatly override the standard setup. **Changelog**; Fix Python version setting in CI tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1381:681,variab,variable,681,https://qutip.org,https://github.com/qutip/qutip/pull/1381,1,['variab'],['variable']
Modifiability,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6497,refactor,refactoring,6497,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['refactor'],['refactoring']
Modifiability,"(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; --> 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename; 126 . ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. ------------------------------------------------------; Software	Version:; QuTiP	4.5.0; Numpy	1.18.1; SciPy	1.4.1; matplotlib	3.1.3; Cython	0.29.15; Number of CPUs	4; BLAS Info	INTEL MKL; IPython	7.12.0; Python	3.7.6 (default, Jan 8 2020, 20:23:39) [MSC v.1916 64 bit (AMD64)]; OS	nt [win32]; Sat May 02 19:27:58 2020 ???? (?W???); -------------------------------------------------------",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1244:2474,variab,variable,2474,https://qutip.org,https://github.com/qutip/qutip/issues/1244,1,['variab'],['variable']
Modifiability,"(target). numpy_fidelity = np.abs(np.vdot(final_state.full(), target_state.full())); qutip_good_fidelity = np.abs((final_state.dag() * target_state)[0, 0]); qutip_bad_fidelity = qutip.fidelity(final_state, target_state); print('Correct: {}'.format(numpy_fidelity)); print('Still correct: {}'.format(qutip_good_fidelity)); print('Wrong: {}'.format(qutip_bad_fidelity)). # Correct: 0.9999999999849929; # Still correct: 0.9999999999849929; # Wrong: 1.0000000026189553; ```. The problem is clearly in the fact that you compute the fidelity of ket states by converting them into density matrices and using the general formula:; https://github.com/qutip/qutip/blob/564c987bdca385ae179730d0aad7b0d1e624e14d/qutip/metrics.py#L88-L113. This is fine in general, but can be very inefficient for large states, and is less numerically stable. An easy solution is to just compute the fidelity as the inner product when both states are kets. Moreover, the general formula might also be improvable: consider the following example (which uses the variables defined in the previous snippet):. ```; final_dm = qutip.ket2dm(final_state); target_dm = qutip.ket2dm(target_state); sqrt_final_dm = final_dm.sqrtm(); sqrt_target_dm = target_dm.sqrtm(); eig_vals = (sqrt_final_dm * target_dm * sqrt_final_dm).eigenenergies(); bad_fid = np.sqrt(eig_vals[eig_vals > 0]).sum(). prod_sqrt = (sqrt_final_dm * sqrt_target_dm); better_fid = scipy.linalg.svdvals(prod_sqrt.full()).sum(). print('bad fid: {}'.format(bad_fid)); print('better fid: {}'.format(better_fid)). # bad fid: 1.000000072436338; # better fid: 0.9999999999849937; ```; Here, I'm proceeding similarly to what qutip currently does, by converting to dms and then applying the general formula. However, I compute the general fidelity by summing the singular values of $\sqrt\rho \sqrt\sigma$, instead of summing the square roots of the eigenvalues of $\sqrt\sigma \rho \sqrt\sigma$. Mathematically, this is equivalent, and in this particular case does at least give a ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/925#issuecomment-542318121:1439,variab,variables,1439,https://qutip.org,https://github.com/qutip/qutip/issues/925#issuecomment-542318121,2,['variab'],['variables']
Modifiability,"* import + sesolve. * psi in args part 1. * psi in args part 2. * state in args part3. * dyn args test1. * dyn args test2. * args debug. * ready for tests. * s/mesolve pass tests. * mcsolve rework. * mcsolve rework part 2. * mcsolve cython cleaning. * mcsolve working. * mcsolve cython as object. * mcsolve pass all test. * automated test almost passing. * pass all tests. * docs and cleaning. * diag ok. * clean propagator. * clean propagator 2. * clean floquet. * clean floquet 2. * mcsolve serial_map bugfix. * object args bug correction. * dense cQobjEvo bugfix. * spliting PR. * merge priority correction. * merge priority correction. * mcsolve based on qoevo. * better rouchon citation. * final state avg?. * faster postprocessing. * final_state average flag. * final state runs as property. * Some patches for qip.Gate (#995). * remove repetitive assignment. * move description to class def. Doc won't show it if it's under __init__. * check invalid input for targets and control. * all must be integer. * NotImplemented is not callable, use NotImplementedError. * add whitespace. * refactor. * format correction",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1043:1090,refactor,refactor,1090,https://qutip.org,https://github.com/qutip/qutip/pull/1043,1,['refactor'],['refactor']
Modifiability,"* imports first except. ```from qutip.qobj import *```. then we can remove the numpy and scipy checks but numpy is still used to setup pyximport in . ```; # Setup pyximport ; import pyximport; os.environ['CFLAGS'] = '-O2 -w -ffast-math'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}); del pyximport; ```. Then we can move the section regarding multiprocessing to some appropiate place. Currently it is used in the following files. Can we put the multiprocessing stuff in a file called `multiprocessing_config.py` and run it to get the settings in `__init__` at all the places where we need multiprocessing.; ```; /Users/shahnawaz/dev/qutip/qutip/__init__.py:; 33 from __future__ import division, print_function, absolute_import; 34 import os; 35: # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; 36 if 'OPENBLAS_MAIN_FREE' not in os.environ:; 37 os.environ['OPENBLAS_MAIN_FREE'] = '1'; ..; 149 # cpu/process configuration; 150 #; 151: import multiprocessing; 152 ; 153 # Check if environ flag for qutip processes is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:1003,config,configuration,1003,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,2,['config'],['configuration']
Modifiability,"**Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [x] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [x] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description. **Description**. I am adding an efficient module for calculating the wave function that uses a recurrence for it in Cython, and I am applying one of its functions in the update method of the HarmonicOscillatorWaveFunction class in the distribution.py module. This module is an adaptation of one of the modules from the package I developed for efficient wave function calculation: Fast Wave. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2553:1609,adapt,adaptation,1609,https://qutip.org,https://github.com/qutip/qutip/pull/2553,1,['adapt'],['adaptation']
Modifiability,"**Checklist**; This rewrite the stochastic solver to use the class interface. - `smesolve`, `ssesolve` have been rewritten to match other solver with matching class interface `SMESolver`, `SSESolver`. The main change is that the options used to be passed as keywords (`**kwargs`) and are now passed as an options dict.; - `m_ops` and `dW_factors` are properties of the classes, but not available to overwrite through the function interface. ; - The multiples end condition (`target_tol`, `timeout`) are added.; - The `solver` keyword is now `method` options, as it is in other solver.; - The method that was referring the homodyne or heterodyne detection is now the `heterodyne` keyword. ie before `method=""heterodyne""` now `heterodyne=True`.; - The default integration method is now `rouchon`, instead of `taylor1.5`. ie the method coming from a physic paper and not a mathematics textbook. . - The stochastic integration methods have been spitted in smaller chunk instead of the huge classes in _stochastic.pyx. I kept most methods, only skipping the taylor order 2.0 method. The python interface is kept very similar to the `Integrator` as `SIntegrator`, the main difference being that `set_state` and `get_state` use an extra random number generator with the time and state. The integration methods are usually 5%~10% slower than they where for medium size problems (shape ~100). Most method are computed the same way as before, but the rouchon method no longer use super operator, but keep the density matrix as a matrix and not an oper-ket. - The derivative computation for used by the integration method has also been split into multiple functions and made only available for `smesolve`. For there methods to be valid, the each diffusion contribution must commute. For `smesolve`, this means that each `sc_ops` must commute, as documented. For `ssesolve`, each `sc_ops` must not only commute, but also commute with other `sc_ops`'s adjoint, this last part being missing from v4's documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2131:20,rewrite,rewrite,20,https://qutip.org,https://github.com/qutip/qutip/pull/2131,1,['rewrite'],['rewrite']
Modifiability,"**Describe the bug**. Running tests for qutip 4.6.2, on linux (Debian unstable), all tests pass successfully, but overall tests return error code 1, which would be treated as test failure. For instance, running tests via `python3 -c ""import qutip.testing; qutip.testing.run()""`; ```; ============================= test session starts ==============================; platform linux -- Python 3.9.2, pytest-6.0.2, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3.9; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/home/drew/projects/misc/build/qutip/.pybuild/cpython3_3.9_qutip/build-test/.hypothesis/examples'); rootdir: /home/drew/projects/misc/build/qutip; plugins: cov-2.10.1, mpi-0+unknown, doctestplus-0.9.0, remotedata-0.3.2, asyncio-0.14.0, filter-subpackage-0.1.1, arraydiff-0.3, astropy-header-0.1.2, hypothesis-5.43.3, openfiles-0.5.0, xvfb-1.2.0; collecting ... collected 1996 items / 67 deselected / 1 skipped / 1928 selected. qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-real_hermitian] PASSED [ 0%]; qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-imaginary_hermitian] PASSED [ 0%]; qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-complex_hermitian] PASSED [ 0%]. ...; qutip/tests/test_wigner.py::test_wigner_fft_comparse_ket PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_fft_comparse_dm PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_clenshaw_iter_dm PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]XIO: fatal IO error 0 (Success) on X server "":1029""; after 201 requests (201 known processed) with 4 events remaining.; ```. As far as I can tell this XIO error is related to the xvfb module (pytest-xvfb) used to manage graphical tests without display. Some relevant discussion is found at https://github.com/The-Compiler/pytest-xvfb/issues/11 . They",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:704,plugin,plugins,704,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['plugin'],['plugins']
Modifiability,"**Describe the bug**; I'm trying to get the spectrum of a qubit inside a cavity. For certain values of coupling it works, but for others not. I think this is a problem of tolerance for small numbers, i have set `qutip.settings.auto_tidyup = False` and `qutip.settings.atol = 1e-100`. **To Reproduce**; When it doesn't work it returns:; ```; <ipython-input-3-eaf63cc10951> in do_spectrum(eta, T, w_l, lowfilter); 88 #####################; 89 ; ---> 90 spec_cavity = spectrum(H_d, w_l, c_ops, Am_O, Ap_O); 91 spec_qubit = spectrum(H_d, w_l, c_ops, Sm_O, Sp_O); 92 . ~/.local/lib/python3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1388:103,coupling,coupling,103,https://qutip.org,https://github.com/qutip/qutip/issues/1388,1,['coupling'],['coupling']
Modifiability,"**Describe the bug**; Source tarball taken from PyPI https://pypi.org/project/qutip/ fails without git:; ```; ===> Configuring for py38-qutip-4.6.0; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""setup.py"", line 231, in <module>; options = process_options(); File ""setup.py"", line 45, in process_options; options = _determine_version(options); File ""setup.py"", line 127, in _determine_version; git_out = subprocess.run(; File ""/usr/local/lib/python3.8/subprocess.py"", line 493, in run; with Popen(*popenargs, **kwargs) as process:; File ""/usr/local/lib/python3.8/subprocess.py"", line 858, in __init__; self._execute_child(args, executable, preexec_fn, close_fds,; File ""/usr/local/lib/python3.8/subprocess.py"", line 1704, in _execute_child; raise child_exception_type(errno_num, err_msg, err_filename); FileNotFoundError: [Errno 2] No such file or directory: 'git'; ```. git shouldn't be required because PyPI != GitHub and it is expected to be just a directory and not a cloned git repository.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1514:115,Config,Configuring,115,https://qutip.org,https://github.com/qutip/qutip/issues/1514,1,['Config'],['Configuring']
Modifiability,"**Describe the issue**; I am using the EnhancedTextProgressBar to track progress of an mesolve calculation in a jupyter notebook. Sometimes it works as expected; occasionally (it doesn't seem to be deterministic), I get an extra progress after the updating progress bar that does not delete, so that when the mesolve is complete, I see this: ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00[*********70%**** ] Elapsed 1.79s / Remaining 00:00:00:00. Instead of just ; > [Total run time: 2.55s] Elapsed 2.55s / Remaining 00:00:00:00. If I run the same thing repeatedly, sometimes I'll get the extra status (at different elapsed times), sometimes I'll get two extras, sometimes I'll get none. The longer the calculation takes, the more likely it is that I'll get one or more of these, it seems. . This is not a super huge problem, but just curious if there's any way to fix it! . Thanks,; Emma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1229:39,Enhance,EnhancedTextProgressBar,39,https://qutip.org,https://github.com/qutip/qutip/issues/1229,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"**Describe the issue**; I tried to Execute the code ""Time-dependent master equation: Landau-Zener transitions"" in QuTiP HP's Example notebooks(http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/landau-zener.ipynb) ,and I get the following error message. ; Could someone help please?. Error message:; ---------------------------------------------------------------------------; UnboundLocalError Traceback (most recent call last); <ipython-input-7-f9c1fc837f05> in <module>; 1 start_time = time.time(); ----> 2 p_ex = qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, ""dynamics""); 3 print('dynamics: time elapsed = ' + str(time.time() - start_time)). <ipython-input-5-8172adafcb2d> in qubit_integrate(delta, eps0, A, omega, gamma1, gamma2, psi0, tlist, option); 33 if option == ""dynamics"":; 34 # evolve and calculate expectation values; ---> 35 output = mesolve(H, psi0, tlist, c_op_list, [sm.dag() * sm], H_args); 36 ; 37 return output.expect[0]. ~\Anaconda3\lib\site-packages\qutip\mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). ~\Anaconda3\lib\site-packages\qutip\mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). ~\Anaconda3\lib\site-packages\qutip\qobjevo.py in compile(self, code, matched, dense, omp); 1557 self.args,; 1558 self.dynamics_args,; -> 1559 self.tlist); 1560 coeff_files.add(file_); 1561 self.coeff_files.append(file_). ~\Anaconda3\lib\site-packages\qutip\qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); 123 coeff_obj, filename = _import_str(code, ""cqobjevo_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1244:840,evolve,evolve,840,https://qutip.org,https://github.com/qutip/qutip/issues/1244,1,['evolve'],['evolve']
Modifiability,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1289:226,config,configuration,226,https://qutip.org,https://github.com/qutip/qutip/pull/1289,2,['config'],"['configrc', 'configuration']"
Modifiability,"**Description**. In the recently released numpy 1.22.0 the `__config__` attribute for the; published wheels (at least on the linux platforms I'm using) have; removed the `blas_opt_info` attribute and are instead publishing; identical information in the `blas_ilp64_opt_info` attribute. Running; qutip with the latest numpy release on these platforms was causing an; attribute error when `_blas_info()` is called as; `numpy.__config__.blas_opt_info` doesn't exist in the installed numpy.; This commit fixes this by first checking if the new name exists and; using that to get the blas opt info, and then trying the name available; in previous releases. This should maintain compatibility with older; numpy releases but fix the issue when running with 1.22.0. **Changelog**. Fix compatibility with numpy configuration in numpy's 1.22.0 release",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1752:802,config,configuration,802,https://qutip.org,https://github.com/qutip/qutip/pull/1752,1,['config'],['configuration']
Modifiability,"**Description**. Reviewed and fixed the apidoc.; - Fixed the internal references: link to `Qobj`, `QobjEvo`, etc. All reference in the apidoc work if the target exist.; Reference to `Coefficient`, `Data`, `data.to` are still broken since they are note included in api.; - I changed the parameter specification to use `default: ` everywhere. `default=` does not look good for string in HTML since string are closed twice. `{}` was also used but it's also used for a set of choice: `str {""dense"", ""sparse""}`. Even if we don't keep this format, uniformity will help change it later.; - Added `optional` and `default` when missing.; - List the set of valid choice when appropriate.; - Improved solver's options rendering.; - Changed \`...\` to \``...\`` in many places. The later is italic and does not highlight the content much.; - Made some method / variable private. Added / removed some entry in the api.; - Fixed formatting issues. Also fixed broken / moved external link (using `make linkcheck`). Link to paper sometime fail with automated check but link work from browser. I removed some links in HEOM for mkl that did not work and I could not find a replacement. In a future PR, we should restructure the apidoc. Have to large files, one for classes and one for function does not scale well to the size of the project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2264:849,variab,variable,849,https://qutip.org,https://github.com/qutip/qutip/pull/2264,1,['variab'],['variable']
Modifiability,"**Description**. The aim of this project is to enhance the capabilities of qutip's HEOM implementation by introducing a set of tools that offer the option to simulate arbitrary spectral densities or correlation functions. . To achieve this the main idea is to fit our wanted spectral density by a set of underdamped Drude-Lorentz spectral densities or correlation functions. The idea is that the user will supply his desired spectral density or correlation function and the tools will automatically do the fit and construct the corresponding HEOM bath. Guesses ffor the fit and the number of terms will be decided automatically if the user does not specify them. To decided on the number of terms, we will used the normalized root mean square error as a measure of the goodness of the fit. . I also added functions to bosonic bath to quickly obtain the correlation function, power spectrum and spectral density for the existing bosonic baths . **Note**. Those tests fail because mpmath is not in the requirements, it is needed because the scipy version of the Rienmann zeta function doesn't take complex arguments (https://github.com/scipy/scipy/issues/9182). **Related issues or PRs**. The Qutip tutorial notebooks are updated to show this new functionality in (https://github.com/qutip/qutip-tutorials/pull/72)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2260:47,enhance,enhance,47,https://qutip.org,https://github.com/qutip/qutip/pull/2260,1,['enhance'],['enhance']
Modifiability,**Description**; - Improve the documentation and use more understandable variable names.; - Add mcsolve as an optional solver for `Processor`; - The figure plotted by ``Processor.plot_pulse`` now has a better look; ![Figure_1](https://user-images.githubusercontent.com/12125783/80918476-7efdd880-8d65-11ea-8ff1-8e573cd1b3e6.png). **Changelog**; A few updates to the device simulator,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1245:73,variab,variable,73,https://qutip.org,https://github.com/qutip/qutip/pull/1245,1,['variab'],['variable']
Modifiability,"**Description**; - Integrate scheduler into the compiler. The compiler can now schedule quantum gates to reduce the duration of the compiled pulses.; - Improve the structure and readability of the `Compiler` class. The compiler class was separated for clarity when the `Processor` class was built upon old code in `qutip.qip`. But it has never been opened as a public API. This PR improves the readability and, most importantly, makes it easier for users to customize the compiler class.; - Add a map `pulse_dict` between the pulse label and the indices in `Processor`, so that customizing class becomes much easier. **Files description**; - `scheduler.py` is moved to compiler folder and split to two files : `instruction.py` and `scheduler.py` for clarity.; - Changes in `gatecompiler.py`, `cavityqedcompiler.py` and `spinchaincompiler.py` are for integrating the scheduler.; - Others are adaptations. **Changelog**; Integrate the scheduler into the compiler",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444:891,adapt,adaptations,891,https://qutip.org,https://github.com/qutip/qutip/pull/1444,1,['adapt'],['adaptations']
Modifiability,"**Description**; - Update versions in requirements.txt; - Update the contributor list and add Paul to the developers team.; - I used the list generated by git, thus only authors of merged commit in `master` are present, with their `git.config` name instead of github name.; - Unified changelog title format.; - Before towncrier, the title used `Version X.X.X`, which was changed to `QuTiP X.X.X`. ; - Also the title formating (`+++`) was not caught as a section and did not appear into the table of content.; - Removed the gallery: it was empty zip files.; - Removed the `qutip_tree` image. It was fancy, but useless and was still at 4.6.; - Improved look of the apidoc.; - Ensure each property take a line, not side by side.; - Added type hints aliases (`DimensionsLike`, ...); - Added support for aliases in more files (`import annotations`); - Split long signature into multiple lines, one per parameter. We have some long signature, made longer with type hints, this make them a lot more readable. (The readthedocs style was not great for that, so it was patched in site.ccs.); - Another options would be not to include the hints in the signature of the apidoc, they are already listed in each entry of the parameter section.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2523:236,config,config,236,https://qutip.org,https://github.com/qutip/qutip/pull/2523,1,['config'],['config']
Modifiability,**Description**; Adaptation of PR #2283 to qutip 5: using `np.tensordot` instead of a triple loop. Co-authored with [Rafael Haenel](https://github.com/rafaelha),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2284:17,Adapt,Adaptation,17,https://qutip.org,https://github.com/qutip/qutip/pull/2284,1,['Adapt'],['Adaptation']
Modifiability,"**Description**; Add a function that list all dispatched functions and their specialization.; It automatically adapt to new data-layer and dispatched functions.; Only show pure specialization: `solve[Dense, Dense]` not `solve[CSR, Dense]`. I also register 2 specializations that were created, but not registered. Example:; ```; >>> from qutip.core.data.dev_utils import specialisation_table; >>> specialisation_table(). Output only specialisation; |Dispatched function | JaxArray | CSR | Dense |; |zeros | True | True | True |; |identity | True | True | True |; |diag | True | True | True |; |one_element | True | True | True |; ...; Binary specialisation; |Dispatched function | JaxArray | CSR | Dense |; |add | True | True | True |; |sub | True | True | True |; |matmul | True | True | True |; |multiply | True | True | True |; |kron | True | True | True |; |solve | False | False | True |; ...; ```. This could also go into a notebook if it fit better there.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2132:111,adapt,adapt,111,https://qutip.org,https://github.com/qutip/qutip/pull/2132,1,['adapt'],['adapt']
Modifiability,"**Description**; Add a new options that control where the `default_dtype` is taken into account: `default_dtype_range` (feel free to propose better name.); It has 3 possible values:; - ""creation"": At `Qobj` creation functions, behaviour we presently have.; - ""missing"": Missing specialization will output that type: `Dense + Jax` is not defined so will default to that type.; - ""full"": Every operations return that type: `Dense + Dense` would convert the result to the `default_dtype`. Unary operations will also convert the output type. It could break some functions that explicitly set the date type such as `steadystate` or `HEOM`... Also added control of the created format in `Qobj.__init__`: added `dtype`, when the initial data is a list of list, use `default_dtype`, with `""full""` also use `default_dtype`. Only using the default value with list normally is so solver states are not converted automatically which would slow the solver unexpectedly. . I am looking into creating alias for a group of data layer. This would allow to set the default to jax and jaxdiag at once. Used with `""full""`, this would ensure only jax compatible data layers are used while not forcing the sparcity. This would hopefully make `""full""` usable. **Related issues or PRs**; #2328",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519:1146,layers,layers,1146,https://qutip.org,https://github.com/qutip/qutip/pull/2519,1,['layers'],['layers']
Modifiability,**Description**; Add inherited members (properties and methods) in the API docs for the solvers mentioned in the issue.; Add inheritance of these solvers showing from which base classes they inherit. **Related issues or PRs**; fixes #2163,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2167:21,inherit,inherited,21,https://qutip.org,https://github.com/qutip/qutip/pull/2167,3,['inherit'],"['inherit', 'inheritance', 'inherited']"
Modifiability,"**Description**; Adds a --with-idxint-64 compilation option for building with 64-bit integer indices in the data layer. (Alternative to #1727); Instead of using a compile time environment variable, it contains files for both 32 and 64 int and choose at setup which to use. This way has the advantage that cython can keep track of the version used and recompile all file depending on it when changed.; With compile time environment variable, you can have file compiled with different type of int and only get error when trying to use them. Also 'cimporting' data is simpler since you don't need to define the variable. However, changing all the import location made diff a lot bigger than #1727. `qutip.settings.install['intsize']` will return 32 or 64 depending on the size of int used. **Changelog**; Added a compilation option for compiling with 64-bit integer.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1874:188,variab,variable,188,https://qutip.org,https://github.com/qutip/qutip/pull/1874,3,['variab'],['variable']
Modifiability,"**Description**; Allow V5 to accept customization of point colors as it did in V4. To keep the changes implemented in V5, I have created a new variable to store the colors that are applied to the points (_inner_point_color_), so in total we now have three variables:. _inner_point_color_: Defined as an argument in the _add_points_ function, this variable takes precedence over the others.; _point_color_: This variable stores a list of colors, reminiscent of V4, and is utilized when _inner_point_color_ is not specified.; _point_default_color_: A list of colors that serves as the default when neither of the other variables is defined. **Related issues or PRs**; fix #1974",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308:143,variab,variable,143,https://qutip.org,https://github.com/qutip/qutip/pull/2308,5,['variab'],"['variable', 'variables']"
Modifiability,"**Description**; As presented in #1722, the docstring of the states and operators functions are not consistent. This change the docstring so that _Number of basis states in Hilbert space_ is used everywhere, instead of _fock states_ or _vector states_. This set the variable names as:; - Single Hilbert space function : `N`; - Multiple Hilbert space function: `dimensions`; - Number of qubits: `N_qubit`. Added support for `dimensions` input to take `Space` object.; Added sanity check in dimensions object.; Added `scalar_like` method to dimensions object. In transform any dims `[[2, 3], [2, 3]]` to it's scalar with same structure `[[1, 1], [1, 1]]`.; Added another input parameter to qzero to create rectangular operator `qzero([2],[3]).dims == [[2], [3]]`. **Related issues or PRs**; fix #1184, replace #2075",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2289:266,variab,variable,266,https://qutip.org,https://github.com/qutip/qutip/pull/2289,1,['variab'],['variable']
Modifiability,**Description**; Clean-up of the point method in the `Bloch` class. This PR does not add any new feature but it does:; - Improve readability and logic in the point methods for the Bloch class. ; - Extended test coverage of the point methods.; - Now add_points raises error if the arguments `points` or `meth` are wrong. **Changelog**; Clean-up of the point methods in the `Bloch` class.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1909:197,Extend,Extended,197,https://qutip.org,https://github.com/qutip/qutip/pull/1909,1,['Extend'],['Extended']
Modifiability,"**Description**; Enables use of `mcsolve` and `nm_mcsolve` with mixed initial conditions. Added functions `run_mixed` to the MCSolver and NonMarkovianMCSolver classes. Instead of an initial pure state, these functions take either a density matrix or a list of `(psi_i, p_i)` where `psi_i` are pure initial states and `p_i` are the weights for the average over the initial states. In the latter case, the `ntraj` parameter can be a list specifying the number of trajectories to be used for each initial state. The trajectories automatically obtain correction weights if the fraction of trajectories starting in `psi_i` does not match `p_i`. The functions `mcsolve` and `nm_mcsolve` take either a pure state or a density matrix as the initial state, and call either `run` or `run_mixed` of the solver, respectively. The stochastic solvers also inherit the `run_mixed` functions, but I don't know if there is any use case for that. The most complicated issue here was the combination of a mixed initial state with ""improved sampling"". In this case, run_mixed first runs the no-jump trajectories for all initial states (potentially using `parallel_map` etc) and then runs all other trajectories (using `parallel_map` again, this means that there are two progress bars...). **Todo**; - [X] Please add tests to cover your changes if applicable.; - [x] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [x] Include the changelog in a file named: `doc/changes/<PR number>.<type>`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2437:842,inherit,inherit,842,https://qutip.org,https://github.com/qutip/qutip/pull/2437,1,['inherit'],['inherit']
Modifiability,"**Description**; I changed __mul__ behaviour following the discussion of issue #1607. However, the implementation details differ slightly from what was discussed there. The current behaviout of `__mul__(self, other)` is:; - If other is a `Qobj`: dispatch to `__matmul__`; - If not try dipatching to mul and return `NotImplemented` if `TypeError` is returned.; - The dispatcher now gets `other` instead of `complex(other)`. This is more flexible and allows specialisations to handle arbitrary scalar like objects (something extremely useful for qutip-tensorflow).; - Infer hermiticity and unitarity when possible trying complex(other). `__rmul__` now directly dispatches to `__mul__`. Any necessary check (casting to complex included) is done in `__mul__`. _No_ changes were required to `mul_dense` and `mul_csr` as `add_dense(data, value=np.array(1))` works. It internally tries `complex(np.array(1))` which is guaranteed to work. This is something I was very happy to find as I do not think that specialisations should return `NotImplemented` (although they still can if required). **Related issues or PRs**; Fixes issue #1611 . **Changelog**. - Qobj `__mul__` now handles consistently right and left multiplications of an arbitrary python object.; - `__mul__` is now more flexible passing `other` to the dispatcher instead of `complex(other)`.; - `qobj*np.array([1,2])` and `qobj*np.array([1,2])` (or any other numpy array that does not represent an scalar) now raise TypeError. This change is not backwards compatible (!!). _Edit: changed changelog and description_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620:436,flexible,flexible,436,https://qutip.org,https://github.com/qutip/qutip/pull/1620,2,['flexible'],['flexible']
Modifiability,"**Description**; I found the description for unitary, non-dissipative time evolution a bit confusing as the text always referred to `mesolve` while the examples used `sesolve`. I adapted the text to `sesolve` for that section and introduced `mesolve` only in the next section. **Related issues or PRs**; understanding the docs. **Changelog**; Improve documentation on solving for unitary dynamics by making the use of sesolve and mesolve in the code examples more consistent with the text, and by making the text clearer.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1921:179,adapt,adapted,179,https://qutip.org,https://github.com/qutip/qutip/pull/1921,1,['adapt'],['adapted']
Modifiability,"**Description**; In #1812, I worked on removing the tree structure of option and having options per solver instead of having them together.; This way, we don't need to pass `mcsolve` specific options to `mesolve`, etc. and it makes it simpler to know which options are used by which solver. That PR is getting quite large and went through multiple revision, so I am replacing it with two smaller ones. In this PR, I simplify the options in core. `install` options are put back into `settings`, these are most options that the user cannot change, such as the presence of mkl or running in `ipython`. The exceptions is the location of the .qutip folder which is a setting but can be changed. Most of these settings are properties of the object and only computed when being called instead of at import in `__init__.py`. . `CoreOptions` and `CompilationOptions` are now both made from a simpler `QutipOptions` class instead of the `optionsclass` which generated many method at import. Some options have been moved around: `debug`, `log_handler`, `colorblind_safe` and `use_cython` has been moved to `CoreOptions`. Since instance of `CoreOptions` cannot be passed to functions using it. It supports context:; ```; with CoreOptions(auto_tidyup=False):; op = sparse1 + sparse2; ```; and global options change using:; ```; qutip.settings.core['atol'] = 1e-6; ```. `CompilationOptions` instance must be passed to `coefficient` to be used. `configrc` was removed. It was used to store settings in a file that would be read when importing qutip. This was mainly used to store the openmp threshold. Without openmp, we don't have any settings to store between sessions. Some test related to mkl had to be fixed, it seems that they were always skipped before these changes. **Related issues or PRs**; Replace #1812. **Changelog**; Simplify settings and core options.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1924:1431,config,configrc,1431,https://qutip.org,https://github.com/qutip/qutip/pull/1924,1,['config'],['configrc']
Modifiability,"**Description**; In #2314, it was found that Qobj creation functions could return an unexpected dtype for incomplete data layers.; For example if `mul` specialization is missing `scale * basis(..., dtype)` would not return a Qobj using dtype.; I reviewed functions in states.py, operators.py and random_object.py.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2321:122,layers,layers,122,https://qutip.org,https://github.com/qutip/qutip/pull/2321,1,['layers'],['layers']
Modifiability,"**Description**; Introducing support for multiple coupling operators in `fmmesolve`. Additionally, I fixed the bug with the rate integration as described in #1961. . **Related issues or PRs**; #1961",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1962:50,coupling,coupling,50,https://qutip.org,https://github.com/qutip/qutip/pull/1962,1,['coupling'],['coupling']
Modifiability,"**Description**; Make `choi_to_kraus` rely on eigenstate solver for Hermitian matrices if the Choi matrix is Hermitian. Basically, this adapts what is done in qutip 5, while waiting for its release. **Related issues or PRs**; #2263",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2276:136,adapt,adapts,136,https://qutip.org,https://github.com/qutip/qutip/pull/2276,1,['adapt'],['adapts']
Modifiability,"**Description**; Make and upgrade a few class commonly used by solvers. All solver's core is a loop that progress between time in `tlist` and take a snapshot of the state at these time. The work of this loop have been moved to 2 classes: `Result` and `Evolver`. . `Result` was previously just a container of the solver output. It now does the snapshot: compute the expectation values, save the state, compute trajectories average, etc. . `Evolver` is qutip's ODE solver interface: the states are `Data` object and the function is `QovjEvo`(or `QobjEvoFunc`). There are multiple type of evolver wrapping different scipy's ode solver and a few of our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:252,Evolve,Evolver,252,https://qutip.org,https://github.com/qutip/qutip/pull/1409,5,"['Evolve', 'evolve']","['Evolver', 'EvolverScipyZvode', 'evolver']"
Modifiability,"**Description**; Make changes so enable autodiff with `jax` or `tensorflow`:; - In `QobjEvo`, `Elements`, `Coefficient`: `t` is a python object instead of a double as is coefficient output.; This allows to pass jax traced variable or tensorflow's scalar tensor.; - QobjEvo's elements attribute are accessible and new methods `QobjEvo._getstate`, `QobjEvo._restore`.; Used by jax layer to register `QobjEvo` as a pytree.; - Allow subproject to add their own coefficient.; This allow to make a coefficient that can jit well or can be differentiated. `FuncCoefficient` without type restriction could mostly work, but there are some issues with registering them as a pytree or pickling.; - In CoreOptions, an options for the default data type is added:; When not specified, each `Qobj` creation function keeps its default.; ```; with CoreOptions(default_dtype=""jax""):; obj = qeye(N); assert isinstance(obj.data, JaxArray); ```; - Add `QobjEvo.to_list` to restore the list format of the `QobjEvo`. **Related issues or PRs**; Replace #1816",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2015:222,variab,variable,222,https://qutip.org,https://github.com/qutip/qutip/pull/2015,1,['variab'],['variable']
Modifiability,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1288:366,adapt,adapted,366,https://qutip.org,https://github.com/qutip/qutip/pull/1288,1,['adapt'],['adapted']
Modifiability,**Description**; Refactor Qutip.Qip.Circuit.solve_gates as a dispatch-like method for assigning different functions and make the QubitCircuit module more commutable.; These changes make it easier for maintenance and provide a clearer workflow. **Changelog**; Refactor Qutip.Qip.Circuit.solve_gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1226:17,Refactor,Refactor,17,https://qutip.org,https://github.com/qutip/qutip/pull/1226,2,['Refactor'],['Refactor']
Modifiability,"**Description**; Remove coercion of coefficient values to complex in `Coefficient` and `QobjEvo` allowing to use `tf.Variable` as coefficient to enable auto-differentiation to be used in solver.; It is build on top of #1644 since it include integration method using our data object. Coefficient creation is no longer hard coded, but use a dict of `type: callable`, each type is associated to a function that create a coefficient, allowing to add support for other coefficient types per project such as qutip-tensorflow. Also, function based coefficient no longer cast to complex, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:117,Variab,Variable,117,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['Variab'],['Variable']
Modifiability,"**Description**; Replacing the v4 solver for v5's one as the default solver in dev.major is still a ~40 files PR, so I am making the transition in block, starting by propagator and scattering. **propagator.py:**; The function call the new solver and remove some options:; - batch: useless since __solve can evolve a propagator.; - parallel: Could still be useful, until we restore openmp support for data-layer, but should be managed by the data layer in v5.; - progress_bar: Now in options.; This result in a much simpler function. Add a new class `Propagator`, which replace the `Evolver` in scattering.; Like solver classes, it split the setup and utilization:; ```; U = Propagator(H); psi_t = U(t) @ psi_0; psi_t2 = U(t2, t) @ psi_t; ```; It save previous calls for efficiency, somewhat support `args`. It's not a `QobjEvo`, to support propagators with 2 times, but can be made one. **scattering.py:**; - `Evolver` replaced by the previous `Propagator`.; - matrix-matrix product are replaced by matrix-vector product in photon scattering computation.; - Do no create a `Qobj` to extract one value from an array.; This result in a speed up of about 5 times faster for even small (N=10) operators. **Changelog**; Rework propagator to use v5 solver and add a Propagator class.; Optimize scattering functions",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1792:307,evolve,evolve,307,https://qutip.org,https://github.com/qutip/qutip/pull/1792,3,"['Evolve', 'evolve']","['Evolver', 'evolve']"
Modifiability,"**Description**; Rewrite `mcsolve` as a class for dev.major. Main addition:; - `MultitrajSolver` class as a base class for solver computing trajectory from a seed: it uses custom ; - It uses custom integrator using a generator which `MultitrajSolver` provide. ; - Stepping run one trajectory at a time.; - Use numpy.random new interface with `SeedSequence` and `Generator`.; - `run` can end on number of trajectories reached, timeout reached, or error bars on expectation values under a certain tolerance.; - `McSolver` class for mcsolve class interface.; - Support closed and open system. For open systems. `H` must be a Liouvillian. The `c_ops` are computed stochasticly and are used for collapse. Dissipation terms to be used in a deterministic way can be added as Lindblad dissipators to the liouvillian.; - McSolver's results include the photocurrent.; - McSolver need a layer between the solver interface and the integrator. In #1710, this was a trajectory solver, but here I use a pseudo integrator. This makes `MultitrajSolver` easier to use with stochastic which need custom integrator and thus a trajectory solver did very little. Other fixes:; - `MultiTrajResult` keep the `dtype` of expect.; - `MultiTrajResult` can merge instance with no states stored. **Related issues or PRs**; Replace #1710",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1972:17,Rewrite,Rewrite,17,https://qutip.org,https://github.com/qutip/qutip/pull/1972,1,['Rewrite'],['Rewrite']
Modifiability,"**Description**; Rewrite `mcsolve` using class as was done for `sesolve` and `mesolve` in #1700. This add new capacities to `mcsolve`:; - `measurement` and `photocurrent` are added to result making the `photocurrent_..solve` function redundant.; - The `H` input can be a super operator, allowing to do evolution with some collapse operator being treated democratically and some with discrete jumps (as was done in `photocurrent_mesolve`.; - Result are compiled at the end of each trajectories. Previously the result of each trajectories would be stored until the end of the map function, even if only the average are desired, making it quite memory inefficient, see #1667.; - New end condition are added. `mcsolve` can run for a desired number of trajectories, a desired time or the expectation values have converged within a desired tolerance (computed using jackknife re-sampling). ; - Stepping capacities have been added. However, collapse are not available this way, so it's still open to improvement. Other changes include reworking `MultitrajResults`, it was added in a previous PR but was not used. Also the 2 versions: trajectories stored or averaged are merged. **Related issues or PRs**; Follow up to #1700 . **Changelog**; Rewrite mcsolve with a class approach.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1710:17,Rewrite,Rewrite,17,https://qutip.org,https://github.com/qutip/qutip/pull/1710,2,['Rewrite'],['Rewrite']
Modifiability,"**Description**; Rewrite steadystate to use data layer function. - The number of method have been reduced to 4 and are now distinct algorithm for the steadystate computation.; - The solver used to solve linear equation is distinct from the method. `iterative-gmres` is not `method=""direct"", solver=""gmres""`. (The solver will still work for backward compatibility.); - Optional parameter to pass to the linear equation solver are no longer included in a default dict, but passed through `**kw`. This leave 8 optional parameter purely for steadystate.; - Info have been removed, this was interesting, but bloating the code. `steadystate_floquet` and `pseudo_inverse` are also rewritten using calls to the data layer.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2031:17,Rewrite,Rewrite,17,https://qutip.org,https://github.com/qutip/qutip/pull/2031,1,['Rewrite'],['Rewrite']
Modifiability,"**Description**; Rewrite the main solvers with a more object approach.; The `Solver` class manage inputs and create the system (-i*H, liouvillian, ...).; The `Evolver` (#1409 do the evolution for each time in tlist.; The computation of `e_ops` and storing of states is done by the `Result` class. Updated function are moved from qutip/solve to qutip/solver. - The [..]solve function are matched with a [..]Solver class.; ```; solver = MeSolver(H, c_ops, times=..., options=..., args=..., e_ops=...); solver.run(rho, tlist). solver.start(rho, t0); solver.step(t1); ```; This remove the `rhs_reuse` options and come with a step function. The step function always return the state (it does not compute e_ops). . - Dynamic_args / feedback is no longer merged with normal args but entered in a `feedback_args` solver argument.; The input format is `feedback_args = {key: ""Qobj""}` will have args[key] be updated with the state as a Qobj at each system call.; ( no longer the magic keyword method). - With the class interface, array coefficient times are given independently from the `tlist`. - `mcsolve` result include the photocurrent, removing the need of `photocurrent_sesolve`.; - `MeMcSolver` (in progress) could replace `photocurrent_mesolve`. It does the save computation using Monte-Carlo algorithm.; - `mcsolve` code that compute collapse was moved from cython to python. I did not benchmark the effect on the speed, be expect it to be small and the overall evolution to be faster with improvement in the map function (do not need to store every states before computing average) and `Evolver` (better backstep for adam method).; ; - `SteadyState` use a `SteadyStateOptions` instead of a bunch of kwargs. **Related issues or PRs**; Build from #1409.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1455:17,Rewrite,Rewrite,17,https://qutip.org,https://github.com/qutip/qutip/pull/1455,3,"['Evolve', 'Rewrite']","['Evolver', 'Rewrite']"
Modifiability,"**Description**; Scipy 1.12 rename a variable in linalg solver: `tol` to `rtol` and raise a deprecation warning with the old name.; Scipy 1.11 does not accept `rtol`. This parameter is passed thought `**kwargs` in steadystate and is not used elsewhere, so only the test need to be updated.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2301:37,variab,variable,37,https://qutip.org,https://github.com/qutip/qutip/pull/2301,1,['variab'],['variable']
Modifiability,"**Description**; Since merging #2497, mkl tests on windows fails from segfault.; I am not sure of the source of the error:; Since the library was not found before the PR, the bug can have been there for a long time, but the tests passed in #2497.; Just settings mkl to verbose is enough for the tests to passes... I don't think relying on the verbose options is a good idea so I made it unable to find mkl on windows for this PR. We will need to find a more reliable way to use it, `ctypes` does not look at the header file so it guess the types from our call. Maybe some version of mkl are 32 bit and other 64 bit and we are not adapting. [pydiso](https://github.com/simpeg/pydiso) looks promising.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2529:630,adapt,adapting,630,https://qutip.org,https://github.com/qutip/qutip/pull/2529,1,['adapt'],['adapting']
Modifiability,"**Description**; The `dataclass` inspired tree structure options we have in `dev.major` is more complex than needed.; The tree structure allow to split `mcsolve` specific options from the other, but they are still present in those passed to `sesolve` etc. This redo options using normal class inheritance. ; `install` options are put back into `settings`, these are most options that the user cannot change, such as the presence of mkl or running in `ipython`. The exceptions is the location of the .qutip folder which is a setting but can be changed. The base for the options is a dict with fixed keys and default values. As before, options can be set as keywork at initialization or when setting items. The default can be changed using context (mainly for tests) or setting items at the class:. ```; SolverOptions['method`] = 'bdf' # Set default method ; with SolverOptions(atol=1e-5):; opt = SolverOptions(store_state=True); opt['progress_bar'] = False; print(opt). progress_bar : False; store_state : True; method : 'bdf'; atol : 1e-5; ...; ```; The option can also be initialized from a dict or another options instance, it will make a copy. I added the capacity to add a safety check when setting an options. It is only used for `use_cython` which will error when trying to set it to `True` without cython installed. Otherwise, it will fail when trying to use the options. *Solver's options*; Each solver has it's option class (SeOptions, MeOptions, etc.) with only needed keys.This somewhat feel overkill since they are all the some for now, until mcsolve is merged. Each integrator also has an associated options and the solver options contain an integrator options. Conversion between options type will raise an error. When creating a solver options, it read the `method` key and setup a matching integrator options. Thus only the keys used by the solver or integrator are defined in the instance. This allow adding new integrator with their own options without adding complexity to the solve",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1812:293,inherit,inheritance,293,https://qutip.org,https://github.com/qutip/qutip/pull/1812,1,['inherit'],['inheritance']
Modifiability,"**Description**; The `improved_sampling` option was recently added to the `MCSolver`. `NonMarkovianMCSolver` extends `MCSolver` and can therefore be called with `improved_sampling=True`. Without this PR, it would then silently return wrong results. The technical reason is that `nm_mcsolve` calculates the value of an influence martingale, which is factored into the calculation of expectation values in the custom result class `NmmcResult`. If `improved_sampling` is enabled, `McResultImprovedSampling` is used instead. I here only disable the `improved_sampling` option for `nm_mcsolve` and print a warning if a user tries to use it. I have created a new issue to discuss ways to implement the improved sampling for `nm_mcsolve`. **Related issue**; https://github.com/qutip/qutip/issues/2235",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2234:109,extend,extends,109,https://qutip.org,https://github.com/qutip/qutip/pull/2234,1,['extend'],['extends']
Modifiability,"**Description**; The fix pertains to `add_gate` behaviour when multiple insertion indices are supplied. Prior to the proposed fix, the insertion loop doesn't take into account the fact that inserting an element in the gates list, modifies the indices in the original list, whereas the caller of `add_gate` supplies a list of indices, with positions with respect to the indices in the original list. Additionally, the PR removes unused variables and unused function (that has also not been imported). **Related issues or PRs**; Fixes #1497. **Changelog**; Fixed add_gate behavior when inserting a gate at multiple indices.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1892:435,variab,variables,435,https://qutip.org,https://github.com/qutip/qutip/pull/1892,1,['variab'],['variables']
Modifiability,"**Description**; The mkl finding was sometime missing the library even when available.; Sometime the library can has a version number in the file name:; `libmkl_rt.so.2`, `mkl_rt.2.dll`, with or without a symbolic link to the version less name.; Also it ouly look for it if it's found in numpy's config, but the module mkl is available an could be installed even if numpy does not link to it. Our use using ctypes does not require numpy to be using it to work. So I changed the lookup function to look for the library without checking is numpy uses it. I also added a new setting, `settings.mkl_lib_location`, which is not read only and allow users to enter the path to their mkl implementation. We only look inside the python library path, this would allow to use libraries installed at the OS level. Also fixed a bug in mkl spsolve with scipy 1.14 that was missed since mkl tests were skipped. **Related issues or PRs**; fix #2496",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2497:296,config,config,296,https://qutip.org,https://github.com/qutip/qutip/pull/2497,1,['config'],['config']
Modifiability,"**Description**; The more flexible base class adds:. - a list of state processors that store the state or e_ops values (but could also do other things); - a ``_post_init`` method that allows a result sub-class to override what processors are configured; - helper methods ``_store_state``, ``_store_final_state``, ``_pre_copy`` and ``_e_op_func`` that sub-classes can override if they use states that are not ``Qobj``.; - a ``.e_ops`` attribute that stores a dictionary of ``ExpectOP`` instances where ``.e_ops[k](t, state)`` will calculate the expected value and ``.e_ops[k].op`` returns the original object used to create the e_op.; - a ``.e_data`` attribute that store the ``.expect`` values as a dictionary rather than a list, so that ``.e_data[k]`` is ``.expect[i]``. Other changes:. - the normalization of states is now performed in the base solver class, rather than in results.; - the solver ``stats`` passed to the results are now *only for that solver .run call* rather than being a strange record of everything the solver has done so far.; These allow:. - The HEOM solver to implement a ``HEOMResult`` class and use the base solver ``.run`` method.; - The normalization of states to be applied when using the ``.step()`` solver method.; - Consistently expose ``.expect`` and a list of results (consistent with QuTiP 4 and useful when turning expectation values into a numpy array); - Provide a dictionary of expectation values via ``.e_data`` so that when e_ops are supplied as a dictionary, the results can be accessed by the same keys, e.g. ``.e_data[""nice-name""]``.; - Possibly allow the MC result classes to be refactored more easily. **Related issues or PRs**; - #1889 -- I think we could implement this PR more easily on top of the refactored result class.; - #1869 -- the v5 HEOM Solver can use much more of the base solver and results class with these changes . **Todo**; - [X] I would like to add more tests for the base result class, but it would be good to get a +1 on the general",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907:26,flexible,flexible,26,https://qutip.org,https://github.com/qutip/qutip/pull/1907,2,"['config', 'flexible']","['configured', 'flexible']"
Modifiability,**Description**; This PR changes the filename `qutip.bib` to `CITATION.bib` to enable GitHub's [citation support](https://github.blog/2021-08-19-enhanced-support-citations-github/). **Changelog**; Rename qutip.bib to CITATION.bib to enable GitHub's citation support.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1662:145,enhance,enhanced-support-citations-github,145,https://qutip.org,https://github.com/qutip/qutip/pull/1662,1,['enhance'],['enhanced-support-citations-github']
Modifiability,"**Description**; This PR implements and tests a new version of `process_fidelity`.; The new version follows the definition in Gilchrist et al., Physical Review A 71, 062310 (2005). **Related issues or PRs**; Discussion at https://github.com/qutip/qutip/issues/1703.; I previously submitted a similar PR at https://github.com/qutip/qutip/pull/1708, targeting `master`. ; This PR targets `dev.major` rather than `master` because existing functionality is changed, and contains improvements following @Ericgig 's suggestions. I have also adapted the tests to match the style of the tests in `dev.major`. Addresses part 2 of https://github.com/qutip/qutip/issues/1703. **Changelog**; Implement and test a new version of `process_fidelity` (https://github.com/qutip/qutip/issues/1703)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1712:535,adapt,adapted,535,https://qutip.org,https://github.com/qutip/qutip/pull/1712,1,['adapt'],['adapted']
Modifiability,"**Description**; This PR introduces support for different numerical backends in entropy.py. By leveraging dynamic backend selection, we enable compatibility with both NumPy and JAX. **Related issues or PRs**; This PR builds upon the groundwork laid in PR #2461, further extending the capability of dynamic backend selection.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2462:270,extend,extending,270,https://qutip.org,https://github.com/qutip/qutip/pull/2462,1,['extend'],['extending']
Modifiability,"**Description**; This is a refactor of the changes from https://github.com/qutip/qutip/pull/1712. Previously, the logic which extracts the dimensions of the input and output Hilbert spaces of the involved quantum channels was spread out throughout `process_fidelity` and `_process_fidelity_to_id`. This PR collects it in a new private function `core.metrics._hilbert_space_dims`. This will also allow reducing `average_gate_fidelity` to `process_fidelity` (in a future PR) as explained in https://qiskit.org/documentation/stubs/qiskit.quantum_info.average_gate_fidelity.html, without having to re-implement extracting the dimensions. **Related issues or PRs**; Part of the work on https://github.com/qutip/qutip/issues/1703. **Changelog**; refactor process_fidelity using new function _hilbert_space_dims",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1748:27,refactor,refactor,27,https://qutip.org,https://github.com/qutip/qutip/pull/1748,2,['refactor'],['refactor']
Modifiability,"**Description**; This is imports [BoFiN](https://github.com/tehruhn/bofin/) into QuTiP with the intention of replacing `qutip.nonmarkov.heom` with `qutip.nonmarkov.bofin` in 4.7 (where `qutip.nonmarkov.heom` will be a thin wrapper around the new, better HEOM solvers) and completely replacing `qutip.nonmarkov.heom` in 5.0. The strategy used was to import the BoFiN history (52 commits) without the examples and their data files into `qutip/nonmarkov/bofin` and then to proceed to tidy things up from there. Specifically I imported the branch from https://github.com/tehruhn/bofin/pull/7 which has @nwlambert's work on the `HSolverDL` replacement. **Todo**; - [x] Add more exhaustive tests.; - [x] Address or silence CodeClimate issues.; - [x] Remove the many assigned but unused variables.; - [x] Add better tests that new `HSolverDL` is compatible with the existing `HSolverDL`.; - [x] Replace the existing `HSolverDL` with the new one.; - [x] Decide what to do with `heom.HEOMSolver`. Should it stay as it is? Be incorporated into BoFiN? Be Removed? *-- Neil and I decided we should remove it*; - [x] Decide what to do about the `renorm` argument to the old `HSolverDL`. Do we add it to the new BoFiN one?; - [x] Decide what to do about the `stats` argument. I'm planning to just add a note telling people to use `pyinstrument` if they need to profile their code.; - [x] Make HSolverDL use a bath instead of having the Matsubara calculation burried inside the solver.; - [x] Add Pade coefficient calculator somewhere? Maybe also as a bath?; - [x] Clean up the interfaces of `BosonicHEOMSolver` and `FermionicHEOMSolver`.; - [x] Whatever else we discover along the way.; - [x] Keep just the gather_op mode of RHS construction.; - [x] Split bath classes out into their own module.; - [x] Add underdamped spectral density bath. **Follow up PRs (i.e. before 4.7)**; - [x] Add Lorentzian fermionic bath (#1726); - [x] Convert the extension BoFiN documentation and into an extensive QuTiP guide (this PR ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601:780,variab,variables,780,https://qutip.org,https://github.com/qutip/qutip/pull/1601,1,['variab'],['variables']
Modifiability,"**Description**; This issue regards defining how to properly structure the main code of the repository [krylovsolver](https://github.com/emilianomfortes/krylovsolver) to merge it into quip and provide it as a new solver. **Possible solution**; We have created a temporary branch in the original repository labeled [qutip](https://github.com/emilianomfortes/krylovsolver/tree/qutip), on which the algorithm code styling has been adapted to follow a similar one based on qutip (i.e. using [sesolve.py](https://github.com/qutip/qutip/blob/master/qutip/sesolve.py)). The analogous file to sesolve.py can be found at [PyKrylovsolver/krylovsolve.py](https://github.com/emilianomfortes/krylovsolver/blob/qutip/PyKrylovsolver/krylovsolve.py). **Additional context**; [Krylovsolver](https://github.com/emilianomfortes/krylovsolver) has been developed via the Unitary-fund [grants](https://unitary.fund/grants.html) program.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1668:428,adapt,adapted,428,https://qutip.org,https://github.com/qutip/qutip/issues/1668,1,['adapt'],['adapted']
Modifiability,**Description**; This pull request introduces a new `NumpyBackend `class that enables dynamic selection of the numpy_backend used in `qutip`. The class facilitates switching between different numpy implementations ( `numpy` and `jax.numpy` mainly) based on the configuration specified in the `settings.core` dictionary. . Made changes in `entropy` and `metrics` to make them `jax` enabled,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2490:261,config,configuration,261,https://qutip.org,https://github.com/qutip/qutip/pull/2490,1,['config'],['configuration']
Modifiability,**Description**; This sets up the towncrier utility to manage the changelog. - Add suitable towncrier configuration to the respository.; - Update the release documentation with instructions for using towncrier to update the change log.; - Update the development documentation to include the requirement to add towncrier entries for each PR.; - Update the GitHub PR template to mention the requirement to add a towncrier entry.; - Add a check to the GitHub action tests workflow that checks that a towncrier entry was added. **Related issues or PRs**; #1894. **Changelog**; See doc/changes/1927.doc,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927:102,config,configuration,102,https://qutip.org,https://github.com/qutip/qutip/pull/1927,1,['config'],['configuration']
Modifiability,"**Description**; Two small bugs crept in in the conversion of the steady_state solver in the HEOM method to QuTiP v5. Firstly, the system state was returned without Fortran ordering (so it was effectively returned transposed), and the line which was supposed to enforce hermiticity used a conj() instead of an adjoint() so it just deleted the imaginary parts of the off-diagonals instead. . I think none of the notebooks or tests were sensitive to these two compounding issues, but it is fairly easy to make an example which is. This is also added as a rudimentary test, comparing output of the long-time dynamics to the steadystate. I didn't include any parameters to change in that test, but can do so if its useful. As a comment, the steady-state solver could probably be written to be more like the standard steadystate solver. But maybe better that is done alongside an effort to make the heom solver more data-layer flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2333:922,flexible,flexible,922,https://qutip.org,https://github.com/qutip/qutip/pull/2333,1,['flexible'],['flexible']
Modifiability,"**Description**; Update HEOM for v5. Other changes:; - This resulted in a bit of a refactor of the Result class (#1907); - I found a few places where QobjEvo did not correctly set `.type` and fixed those (they were breaking the HEOM tests). Todos and questions:; - [X] Should HierarchyADOsState store ado_state as a Data object rather than a numpy array? (it can't be stored as a Data object because the ADOs have shape `n_ado, n, n` and the Data layer only supports 2-d arrays).; - [X] How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). (implemented); - [X] What should be done with the steady_state method? I guess it can just stay. Should other solvers also have this? (it should just stay, I think); - [x] Recheck the time-dependent case. (I also simplified the time-dependent case so that the Liouvillian is never added and so doesn't have to be subtracted off).; - [X] The HEOM can't really take new QObjEvo arguments each time `run` is called because calculating the RHS again is quite expensive. Maybe something can be done? (implemented -- passing new args to .run is now supported); - [X] In the base solver the new options seem to be set after retrieving the integrator -- is this right? (fixed); - [X] Compare performance to the HEOM in 4.7. (looks faster, yay!); - [X] We could also implement `.start()` and `.step()` for the HEOMSolver. Not quite sure of the use case yet though. (implemented and tested -- the implementation came for free after sorting out having .run inherit from the base solver).; - [x] Add some direct tests for the QobjEvo type errors that have been fixed.; - [x] Moved solver into `qutip.solver.heom`. . **Related issues or PRs**; - One of the todos from #1850; - In #1907 the Result class was changed largely to support extension by the HEOMSolver. **Changelog**; Update HEOM for v5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869:83,refactor,refactor,83,https://qutip.org,https://github.com/qutip/qutip/pull/1869,2,"['inherit', 'refactor']","['inherit', 'refactor']"
Modifiability,"**Description**; Update correlation functions to use v5 solvers.; The interface remain the mostly the same, I only made a few changes:; - Support for mcsolve as a back-end is removed. It was very slow, had a low precision and the saved memory is not as useful as it was 10 years ago. Removing it simplify the code a lot, but i can add it back if there is demand for it.; - Time-dependent Hamiltonian no longer support numpy array format: some correlation have 2 times list: `tlist` and `taulist`. It was not clear which one was to be used when using that format. `QobjEvo` input are supported, so building it before passing it to the correlation function is the way to go.; - `a_op`, `b_op`, `c_op` can be `QobjEvo`. Spectrum functions have been moved to their own file, but are mostly unchanged. I added `correlation_3op` which work as other correlation functions, but take a `Solver` instead of an Hamiltonian and `c_ops`. This allows any solver able to evolve density matrices to be used (`BRSolver`, `HEOMSolver`). It is only one function that support it directly: adding support of `Solver` to existing function would make the interface quite complicated, and changing it would break a lot of code and calling them using `H` is useful. . Fixed a small bugs in brmesolve and heom. I added data type option for the eigen solver of the diag integrator as it would otherwise sometime fail with cases in correlation (system and state not hermitian.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1997:956,evolve,evolve,956,https://qutip.org,https://github.com/qutip/qutip/pull/1997,1,['evolve'],['evolve']
Modifiability,**Description**; Update the superop reps tests to use pytest and parameterized tests. Thank you for contributing these @MrRobot2211. **Related issues or PRs**; - Originally submitted as part of #1491 which also added support for rectangular superops. **Changelog**; Update the superop reps tests to use pytest and parameterized tests. Contributed by @MrRobot2211),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1825:65,parameteriz,parameterized,65,https://qutip.org,https://github.com/qutip/qutip/pull/1825,2,['parameteriz'],['parameterized']
Modifiability,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1297:277,config,configuration,277,https://qutip.org,https://github.com/qutip/qutip/pull/1297,1,['config'],['configuration']
Modifiability,"**Description**; When I released QuTiP 4.6.1 I forgot to update the version number in the documentation configuration, `conf.py`. This PR updates `conf.py` to read the version and release from the `VERSION` file in an attempt to remove the possibility of such mistakes in future releases. I've also deleted the `doc/sphinxext/requirements.txt` which appears to be no longer necessary. **Changelog**; Read documentation version and release from the VERSION file.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1546:104,config,configuration,104,https://qutip.org,https://github.com/qutip/qutip/pull/1546,1,['config'],['configuration']
Modifiability,"**Description**; `actions/upload-artifact@v4` and `actions/download-artifact@v4` have breaking change cause the 5.0.3 release to miss wheels on pypi. Different jobs in one workflow can't create artifacts with the same name. ; Download artifact only download artifact from one job without the proper options.; (https://github.com/actions/upload-artifact/issues/478). I also updated cibuildwheel version, we did it in qutip-5.0.X to build wheels for py3.12, but did not push it yet to master. I also merged the jobs to publish or pypi and testpypi, only some environment variables changed and they could get out of synchronization. Lastly I added a check that all wheels are available before uploading to pypi. With 5.0.3's first try, only linux's wheel were published,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2477:569,variab,variables,569,https://qutip.org,https://github.com/qutip/qutip/pull/2477,1,['variab'],['variables']
Modifiability,"**Description**; `countstat.py` does not depend on solver, however it has a **F** maintainability score on codeclimate.; This clean the code to make it more readable, running codeclimat locally, there are not issues left.; Also added a call using the pseudo inverse method in the test. **Changelog**; Make `countstat.py`'s code more readable.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1794:82,maintainab,maintainability,82,https://qutip.org,https://github.com/qutip/qutip/pull/1794,1,['maintainab'],['maintainability']
Modifiability,"**Description**; refactor with fstring to format string to make code more Pythonic. **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](http://qutip.org/docs/latest/development/contributing.html); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the documentation in the `doc` folder, and the [notebook](https://github.com/qutip/qutip-tutorials). Feel free to ask if you are not sure.; - [ ] Include the changelog in a file named: `doc/changes/<PR number>.<type>` 'type' can be one of the following: feature, bugfix, doc, removal, misc, or deprecation (see [here](http://qutip.org/docs/latest/development/contributing.html#changelog-generation) for more information). Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2281:17,refactor,refactor,17,https://qutip.org,https://github.com/qutip/qutip/pull/2281,1,['refactor'],['refactor']
Modifiability,"**Is your feature request related to a problem? Please describe.**. Sometimes qutip.mesolver generate `rhs_**.pyx` or `cqobjevo_compiled_coeff_**.pyx` files.; According to the docstring of `solver.Options` and `rhs_generate`, I guess rhs-things relate to string-format time-dependent Hamiltonian, but I couldn't find description about such files. I didn't know even a meaning of 'rhs' (abbreviation?).; So I suggest to add documents about them. Especially, I have the following question:; - Can I pickle the solver result with a single and portable format?. Saving solver result with pickle module, and loading it sometimes fail, for example:; (I'm so sorry I haven't reproduce this behavior with simplest code, so the following is a dummy-code); ```; out = mesolve(...); with open(filename, 'wb') as f:; pickle.dump(out, f); ```; ```; Exception ignored in: <function QobjEvo.__del__ at 0x7f9e406f4310>; Traceback (most recent call last):; File ""/home/mizuno.kosuke/venvs/default/lib/python3.8/site-packages/qutip/qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-22-e4ad332ebfe3> in <module>; 2 p_json = Path(filename); 3 with p_json.with_suffix('.result.pkl').open('rb') as f:; ----> 4 res = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_877182617539010'; ```; Note: I used pickle module instead of `qsave/qload`. I guess it's no difference because `qsave` uses pickle module internally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1684:540,portab,portable,540,https://qutip.org,https://github.com/qutip/qutip/issues/1684,1,['portab'],['portable']
Modifiability,"**Is your feature request related to a problem? Please describe.**; A lot of issues in test fail seem to arise from random objects (as well as low-level math in MKL and/or cython issues). . **Describe the solution you'd like**; There are several options at hand. . ### stick to pytest and be creative; A possible fix in testing may be to add randomly generated data that then is pointed at or fix seeds.; **Pros**: fast (?); **Cons**: technical debt. ### pytest-randomly plugin; [pytest-randomly](https://github.com/pytest-dev/pytest-randomly) is a pytest plugin that addresses this kind of issues. It allows to control `random.seed`, rather than `numpy.random.seed`. ; **Pros**: pytest plugin, supports doctest. ; **Cons**: not super popular, not designed for numpy; ; ### property-based testing with Hypothesis; Hypothesis is a library that aims at changing the way tests are designed, allegedly: it should go from testing an instance to designing a test that applies to a domain of instances ([property-based testing](https://hypothesis.works/)). It is not super clear to me right now. ; It contains various randomness-related features, including a [seed function](https://hypothesis.readthedocs.io/en/latest/reproducing.html#hypothesis.seed). **Pros**: sounds powerful and clever, popular and growing, well documented, more robust even beyond this randomness problems.; **Cons**: radical change of testing framework (?), steep learning curve (?), overkill (?). I also admit I used nose until recently / used with pytest tests thought for nose, without taking advantage of pytest full power.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268:471,plugin,plugin,471,https://qutip.org,https://github.com/qutip/qutip/issues/1268,3,['plugin'],['plugin']
Modifiability,"**Is your feature request related to a problem? Please describe.**; I noticed that QuTiP got a C in the [Code Climate Report](https://codeclimate.com/github/qutip/qutip) in terms of readability and maintainability. Also, apart from the FIXMEs and the TODOs, there's many pep8 related issues (which can be fixed easily). I understand that this is not top priority stuff, but it might help in the long run. **Additional context**; For example, in the file `qutip/qip/compiler/cavityqedcompiler.py`, the functions ; `sqrtiswap_compiler` and `iswap_compiler` are very similar, and under sqrtiswap_compiler, it says to use iswap_compiler instead. In the same file `rz_compiler()` and `rx_compiler()` have the exact same code barring a string ""sz"" and ""sx"" which could be; passed as an argument.; [link to the report for this file](https://codeclimate.com/github/qutip/qutip/qutip/qip/compiler/cavityqedcompiler.py/source#issue-99d25ce9cdbd1dc34f5899352286755d)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729:198,maintainab,maintainability,198,https://qutip.org,https://github.com/qutip/qutip/issues/1729,1,['maintainab'],['maintainability']
Modifiability,"**Is your feature request related to a problem? Please describe.**; I would like to check the behavior of the parameter `index` in the function `QubitCircuit.add_gate()`. In `qutip.qip.QubitCircuit.add_gate()`, there is a optional `list` type attribute called index.; This seems to be used to insert gates in the middle of the gate list (`qutip.qip.QubitCircuit.gates`).; The corresponding code is shown below.; ```; for position in index:; num_mes = (sum(isinstance(op, Measurement) for op; in self.gates[:position])); gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); self.gates.insert(position, gate); ```; In this code, if `index` contains two or more elements, then the insert positions would be shifted one by one.; Is this an expected behavior?. In the current code, the positions in `index` would not indicate the original positions during the insertion loop. (e.g. When we want to insert a gate `A` to `gates=[B0,B1,B2,B3,B4,B5]` in `index=[0,2,3]`, then the output gate list would be `gates=[A,B0,A,A,B1,B2,B3,B4,B5]`, not `gates=[A,B0,B1,A,B2,A,B3,B4,B5]`.). In addition, the variable `num_mes` is unused throughout the code. **Describe the solution you'd like**; If this is not the expected behavior, and if the expected behavior is like the latter gate list in the former example, then we can fix this part into:. ```; gate = Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label,; classical_controls=classical_controls,; control_value=control_value); for i, position in enumerate(sorted(index)):; self.gates.insert(position + i, gate); ```. **Additional context**; This issue is also mentioned in the PR #1489 .",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497:1205,variab,variable,1205,https://qutip.org,https://github.com/qutip/qutip/issues/1497,1,['variab'],['variable']
Modifiability,"**Is your feature request related to a problem? Please describe.**; Some quantum computing libraries (e.g.: pyGSTi) use the Pauli basis for Liouville space, as opposed to QuTiP's column-stacking basis, making it difficult to interoperate between the two. **Describe the solution you'd like**; A new pair of functions `super_to_superpauli` and `superpauli_to_super` for converting between these representations. (`qutip.visualization.hinton` already includes `super_to_superpauli` as a private function, but this could potentially be exposed to user code.). **Describe alternatives you've considered**; - Extend metadata for `kind='super'` Qobj instances to store Liouville space basis information, including col-stacking and Pauli as special cases and possibly including row-stacking or other common conventions as well.; - Possible names other than `superpauli` for conversion functions, such as `super_to_pauli_basis` or `super_from_pauli_basis`.; - Adding new methods `Qobj.to_superbasis(self, basis: str = 'pauli')` and `@classmethod Qobj.from_superbasis(cls, basis: str = 'pauli')` rather than adding more to the global namespace for the QuTiP package.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1664:604,Extend,Extend,604,https://qutip.org,https://github.com/qutip/qutip/issues/1664,1,['Extend'],['Extend']
Modifiability,"**Is your feature request related to a problem? Please describe.**; Traditionally in Hinton diagrams, any positive number is represented by a fully white square, while any negative number is represented by a fully black square. In the current implementation of `qutip.visualization.hinton`, however, each square is shaded such that numbers close to zero are represented by colors close to gray. While it is nice to be able to use shaded colormaps of this form, traditional Hinton diagrams (that is, thresholded at zero) can be easier to read when some elements that are close to zero can still have significant impact. **Describe the solution you'd like**; A `config` option or keyword argument that would allow using a threshold at zero. **Additional context**; Current Hinton diagram implementation (with colorblind safe mode turned off):. ![image](https://user-images.githubusercontent.com/31516/124228221-bb8ba800-dac0-11eb-8fc4-047ed79ecb1d.png). Current Hinton diagram implementation (with colorblind safe mode turned on):. ![image](https://user-images.githubusercontent.com/31516/124228374-fa216280-dac0-11eb-9e5c-095c1fd10373.png). Examples with thresholded colors (https://arxiv.org/pdf/1509.03770.pdf):. ![image](https://user-images.githubusercontent.com/31516/124228283-dcec9400-dac0-11eb-9067-7870f3dddf95.png); ![image](https://user-images.githubusercontent.com/31516/124228321-e970ec80-dac0-11eb-9006-c535f21c6f9b.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1595:660,config,config,660,https://qutip.org,https://github.com/qutip/qutip/issues/1595,1,['config'],['config']
Modifiability,"**Summary of what was done:**. - Changes in floquet_master_equation_rates to make it faster.; - Corrected transposition errors in _floquet_master_equation_tensor_ and changes to make it faster. I also removed a line so that the ME is solved in the interaction picture, this implies a different basis change in the _floquet_markov_mesolve_ function.; - Correction in _floquet_markov_mesolve_. As explained in the point above, the Floquet-Markov ME was not being solved in the interaction picture, therefore I modified _floquet_master_equation_tensor_ and modified the basis change in _floquet_markov_mesolve_. This modification requires an additional variable in the entry of _floquet_markov_mesolve_ which can not be chosen by default. For the moment, if this variable is not given and _floquet_basis=False_, then the density matrix or expectation values are returned in the interaction picture, in the computational basis, and a warning message is sent. ; - Added integration options in: _floquet_modes, floquet_modes_t, floquet_modes_table, floquet_states_t, floquet_modes_t, floquet_wavefunction_t, fsesolve, floquet_master_equation_rates, fmmesolve_; - Added test functions to verify the dissipative dynamics:; a) Compare _fmmesolve_ and _mesolve_ for the cases: (NO drive but dissipation) and (Drive but NO dissipation); b) Compare numerical and analytical matrix elements for a driven-dissipative TLS with RWA. There are some places where the code could be modified to optimize the running time, especially in the basis change in _floquet_markov_mesolve_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949:650,variab,variable,650,https://qutip.org,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949,2,['variab'],['variable']
Modifiability,", build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_ext; > customize UnixCCompiler; > customize UnixCCompiler using build_ext; > building 'qutip.cy.spmatfuncs' extension; > compiling C sources; > C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c'; > extra options: '-w -ffast-math -O3 -march=native -funroll-loops'; > gcc: qutip/cy/src/zspmv.c; > qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:4185,config,config,4185,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['config'],['config']
Modifiability,", especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with semantic versioning, and would keep this module's structure consistent with QuTiP in both pre-refactor v4.X and post-ref",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2687,refactor,refactorings,2687,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactorings']
Modifiability,", multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, multiprocessing, and; 35 tidyup functionality, etc.; 36 """"""; ```. Can the `pyximport` be dealt in a similar way by having a pyximport_config.py and running it from all the places which needs C compilation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2497,config,config,2497,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,2,['config'],['config']
Modifiability,", which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because I now install _all_ optional dependencies in most runners, so slightly more gets tested than before. Currently there's also a slowdown on several machines because `cvxpy` doesn't build many wheels, and none at all for Linux, on `pip`. I install all our dependencies except BLAS/LAPACK stuff that way, since it's easiest to read out the dependencies like that. We can potentially save some build time (maybe ~3 minutes?) if we install that from conda-forge instead. I also fixed a minor point of how environment variables are read within `setup.py` (in the end I didn't actually use the new behaviour in the action, but I did during testing), and added a warning filter on dnorm tests to account for a deprecated Numpy alias being used within `cvxpy` code. Also of note: this [should allow us to have commits that skip the testing stages](https://github.blog/changelog/2021-02-08-github-actions-skip-pull-request-and-push-workflows-with-skip-ci/) (though possibly not codeclimate). You should be able to put `[skip ci]` in the commit message to avoid it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:2512,variab,variables,2512,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['variab'],['variables']
Modifiability,",1,0,phi,step_dot,v); 7 a_0.append(temp); 8 sum_0 = 0. <ipython-input-27-8ed9b415bc26> in connection(alpha2, n_state, w, phi, step, v); 33 H = [H_static,[H_dynamic_0,str0],[H_dynamic_1,str1],[H_dynamic_2,str2],[H_dynamic_3,str3]]; 34 t_list = np.linspace(0,(alpha1_end - alpha1_0)/v,step); ---> 35 result = mesolve(H,psi0,t_list,[],args = {'alpha2':alpha2,'phi':phi,'v':v}); 36 psi = result.states; 37 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 335 elif n_str > 0:; 336 res = _sesolve_list_str_td(H, rho0, tlist,; --> 337 e_ops, args, options, progress_bar); 338 elif isinstance(H, (types.FunctionType,; 339 types.BuiltinFunctionType, partial)):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 420 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 421 '<string>', 'exec'); --> 422 exec(code, globals()); 423 config.tdfunc = cy_td_ode_rhs; 424 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in <module>(). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697:1465,config,config,1465,https://qutip.org,https://github.com/qutip/qutip/issues/697,1,['config'],['config']
Modifiability,- Bug in use of NUM_THREADS env variable; - Bug in storing collapse times and collapse operators in Result class,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/202:32,variab,variable,32,https://qutip.org,https://github.com/qutip/qutip/pull/202,1,['variab'],['variable']
Modifiability,"- I agree that renaming the _inner_point_color variable is a good idea. - The case you mention of black point_color with style 'l' also occurs in V4 and is solved by defining the variable as a list, e.g., ['black'] (which also works with the changes I proposed). So basically I assumed it was an expected use case. - I asked this question about style 's' plotting two colors in issue #1974, since we are given the same colors for style 's' and 'm', and Neil suggested leaving it as is. The docstring in the add_points function already tells you to give a single color for style 's' and a list of colors for style 'm'. - The error you get using style 'm' with two colors is that you need to specify a color for each point (you have to pass to the function a list of colors of the same length as the length of the points). In view of this, I don't know which approach you prefer to apply, as it depends on the expected use case. Given that the code works, perhaps the priority would be to specify the expected use while defining as part of issue #1913 the modifications you consider appropriate (although maybe someone will catch it earlier if you define it as a new issue).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672:47,variab,variable,47,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1916739672,2,['variab'],['variable']
Modifiability,"- Moved functions that enhance matplotlib (colormaps, normalizations; etc.) to new module. Module is imported with try-except statement since; functions require matplotlib which may or may not be present.; - Updated wigner_cmap to allow for custom colors that can be defined in; any format acceptable to the Matplotib.colors.ColorConverter.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/249:23,enhance,enhance,23,https://qutip.org,https://github.com/qutip/qutip/pull/249,1,['enhance'],['enhance']
Modifiability,"- One can get a 10-40%+ speed enhancement on the core spmv and spmvpy functions by moving to c-code and intrinsics on SSE3 compatible processors. The biggest gains come on platforms that use clang (e.g. OSX) where the speedups are in the 40% or higher range compared to the current Cython based method. GCC seems to be better suited to compile Cython code, so the gains are only 10-20% there.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551:30,enhance,enhancement,30,https://qutip.org,https://github.com/qutip/qutip/pull/551,1,['enhance'],['enhancement']
Modifiability,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/279:117,adapt,adapted,117,https://qutip.org,https://github.com/qutip/qutip/pull/279,1,['adapt'],['adapted']
Modifiability,"-based-time-dependence), but removing the collapse operators and multiplying the constant hamiltonian with a very small value (and changing the time vector accordingly). More specifically, I create two different hamiltonians by multiplying `H0` by 1e-12 and 1e-13 respectively. After computing the `mesolve` for both hamiltonians, one can see that in the second case all values have been set to 0. . ### Code to Reproduce the Bug. ```shell; from qutip import basis, tensor, qeye, destroy, num, mesolve, settings; import numpy as np. settings.auto_tidyup = False. ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). t = np.linspace(-15, 15 * 1e11, 10) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). H_0 = [H0 * 1e-12, [H1, H1_coeff]]; H_1 = [H0 * 1e-13, [H1, H1_coeff]]; output_1 = mesolve(H_0, psi0, t, e_ops=[ada]); output_2 = mesolve(H_1, psi0, t, e_ops=[ada]); print(output_1.expect[0]); print(output_2.expect[0]); ```. ### Code Output. ```shell; [0. 0.48307748 0.87367156 0.3158159 0.03202178 0.64420957; 0.8108019 0.1667205 0.12343592 0.77580413]; [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]; ```. ### Expected Behaviour. The second print should NOT have been all 0s. ### Your Environment. ```shell; QuTiP Version: 4.6.3; Numpy Version: 1.22.3; Scipy Version: 1.8.0; Cython Version: None; Matplotlib Version: 3.5.1; Python Version: 3.10.2; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1831:1320,coupling,coupling,1320,https://qutip.org,https://github.com/qutip/qutip/issues/1831,1,['coupling'],['coupling']
Modifiability,". **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 physics-related occurrences: ; - `Evolver` (in this module), which is not exported and which I might rename to `_Evolver` (this is necessary to be a class for cacheing purposes); - `Cubic_Spline`, which only has __init__ and __call__ methods, and thus could (should?) be refactored into a function (this class also doesn't interact with `QObj`s, so one could argue that it is not physics-related); - `eseries`, which represents an exponential expansion of `QObj`s and thus refers to something at least loosely physical; - `QObj`, which is the basic representation of a physical object; - This would mean that the proposed `PhotonScatterer` class would be the **only** exported occurrence of using a class to represent computations related to a `QObj`. I think there are points to be made for both sides, but I'm not sure that having a few extra helper functions or requiring slightly shorter function calls would be worth introducing what seems to me to be a big inconsistency in the use of functions vs. classes in QuTiP. Once again, thank you @sahmed95 for your suggestions to this module and I look forward to hearing everyone's thoughts on the main issue of c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:4421,Evolve,Evolver,4421,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,2,"['Evolve', 'refactor']","['Evolver', 'refactored']"
Modifiability,". The current list syntax allows for invalid dimensions to be represented such as `[2, 1]` (should be `[[2], [1]]`, probably). These sorts of failures cannot be represented in the new system. Similarly, `[[2], [1], [1]]` cannot be represented as the `Map` constructor will take only two arguments. ### Problems this does not immediately solve. Since QuTiP uses matrices to represent linear algebra objects, we tie ourselves to working in some particular basis. For example, it is invalid to add a vector in the Pauli-Z basis to one in the Pauli-X basis by element-wise addition, but QuTiP has no way of knowing if this is what the user is doing, and will simply allow it because the dimensions will match. This is still the case if the user used `Qobj.transform` to get from one to the other; it is one case where we have to trust that the user is doing the right thing, rather than enforcing correctness. In the future, the system proposed here could be extended to enforce this; the `dims` parameter would be renamed `basis`, and some unique identifier would be attached to each `Space` object. This would allow us to safely define basis-transformation ""operators""; they would have the dimensions object `Map(State(2, 'paulix'), State(2, 'pauliz'))`, or something to that effect. In #1320, I mentioned the possibility of a new `'scalar'` type object. Here, this is effectively the `Field` subtype. There is a choice to be made whether `Compound(Field, Field)` should be `Field` (implicit contraction of 1D spaces), or whether we should keep track of ""missing"" spaces. The missing spaces are useful in principle in QIP settings for defining local operations on subsets of the whole system, but right now we do not have the mathematics backend to implement this completely. For now, I propose we keep track of all the missing spaces; it allows this extension in the future, with no cost right now. ### Implementation details. All objects will be completely immutable, and all their construction argume",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421:5958,extend,extended,5958,https://qutip.org,https://github.com/qutip/qutip/issues/1421,1,['extend'],['extended']
Modifiability,".github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications.**. **4. Non-profit Support.**. ### 1. Code of Conduct. The Contributor Covenant [Code of Conduct](ht",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1373:5584,enhance,enhancements,5584,https://qutip.org,https://github.com/qutip/qutip/issues/1373,1,['enhance'],['enhancements']
Modifiability,"/a>]</li>; <li>Removed unused INT64 definition <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7180"">#7180</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Updated xz to 5.4.3 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7136"">#7136</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed saving TIFF multiframe images with LONG8 tag types <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7078"">#7078</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not set size unnecessarily if image fails to open <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7056"">#7056</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed unused code <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7210"">#7210</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed unused variables <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7205"">#7205</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed signedness comparison warning <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7203"">#7203</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed combining single duration across duplicate APNG frames <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7146"">#7146</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Remove temporary file when error is raised <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7148"">#7148</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not use temporary file when grabbing clipboard on Linux <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7200"">#7200</a> [<a href=""https://github.com/radarhere""><code>@​r",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:6461,variab,variables,6461,https://qutip.org,https://github.com/qutip/qutip/pull/2237,1,['variab'],['variables']
Modifiability,"/pygments/pygments/issues/2383"">#2383</a>)</p>; </li>; <li>; <p>diff: Support normal diff syntax, as opposed to unified diff syntax (<a href=""https://redirect.github.com/pygments/pygments/issues/2321"">#2321</a>)</p>; </li>; <li>; <p>GLSL, HLSL:</p>; <ul>; <li>Support line continuations in preprocessor code (<a href=""https://redirect.github.com/pygments/pygments/issues/2350"">#2350</a>)</li>; <li>Improve preprocessor directive handling (<a href=""https://redirect.github.com/pygments/pygments/issues/2357"">#2357</a>)</li>; </ul>; </li>; <li>; <p>LilyPond: minor update of builtins</p>; </li>; <li>; <p>PHP: support attributes (<a href=""https://redirect.github.com/pygments/pygments/issues/2055"">#2055</a>, <a href=""https://redirect.github.com/pygments/pygments/issues/2347"">#2347</a>, <a href=""https://redirect.github.com/pygments/pygments/issues/2360"">#2360</a>), fix anonymous classes without; parameters (<a href=""https://redirect.github.com/pygments/pygments/issues/2359"">#2359</a>), improve lexing of variable variable syntax (<a href=""https://redirect.github.com/pygments/pygments/issues/2358"">#2358</a>)</p>; </li>; <li>; <p>Python:</p>; <ul>; <li>Add missing builtins (<a href=""https://redirect.github.com/pygments/pygments/issues/2334"">#2334</a>)</li>; <li>Fix inconsistent lexing of <code>None</code> (<a href=""https://redirect.github.com/pygments/pygments/issues/2406"">#2406</a>)</li>; </ul>; </li>; <li>; <p>Rebol/Red: Don't require script headers (<a href=""https://redirect.github.com/pygments/pygments/issues/2348"">#2348</a>, <a href=""https://redirect.github.com/pygments/pygments/issues/2349"">#2349</a>)</p>; </li>; <li>; <p>Spice: Update keywords (<a href=""https://redirect.github.com/pygments/pygments/issues/2336"">#2336</a>)</p>; </li>; <li>; <p>SQL+Jinja (<code>analyse_text</code> method): Fix catastrophic backtracking (<a href=""https://redirect.github.com/pygments/pygments/issues/2355"">#2355</a>)</p>; </li>; <li>; <p>Terraform: Add <code>hcl</code> alias (<a href=""https://red",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2201:3891,variab,variable,3891,https://qutip.org,https://github.com/qutip/qutip/pull/2201,4,['variab'],['variable']
Modifiability,"1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> ab",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/888:2955,config,config,2955,https://qutip.org,https://github.com/qutip/qutip/issues/888,1,['config'],['config']
Modifiability,10.9-x86_64-3.7/qutip/legacy; copying qutip/legacy/bloch_redfield.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/legacy; copying qutip/legacy/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/legacy; creating build/lib.macosx-10.9-x86_64-3.7/qutip/cy/openmp; copying qutip/cy/openmp/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy/openmp; copying qutip/cy/openmp/bench_openmp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy/openmp; copying qutip/cy/openmp/utilities.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy/openmp; package init file 'qutip/cy/openmp/src/__init__.py' not found (or not a regular file); running egg_info; writing qutip.egg-info/PKG-INFO; writing dependency_links to qutip.egg-info/dependency_links.txt; writing requirements to qutip.egg-info/requires.txt; writing top-level names to qutip.egg-info/top_level.txt; reading manifest file 'qutip.egg-info/SOURCES.txt'; reading manifest template 'MANIFEST.in'; writing manifest file 'qutip.egg-info/SOURCES.txt'; copying qutip/configspec.ini -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/cy/br_tensor.cpp -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/br_tensor.pyx -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/brtools.cpp -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/brtools.pxd -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/brtools.pyx -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/brtools_checks.cpp -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/brtools_checks.pyx -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/checks.cpp -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/checks.pyx -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/complex_math.pxi -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/cqobjevo.cpp -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/cy/cqobjevo.pxd -> build/lib.macosx-10.9-x86_64-3.7/qutip/cy; copying qutip/c,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404:17948,config,configspec,17948,https://qutip.org,https://github.com/qutip/qutip/issues/1404,1,['config'],['configspec']
Modifiability,"3 = qt.brmesolve([[qt.qeye(2), ""exp(-t)""]], qt.qeye(2), [0, 1], a_ops=[[qt.qeye(2), decay_spline]]) # error; sol4 = qt.brmesolve([[qt.qeye(2), decay_spline]], qt.qeye(2), [0, 1], a_ops=[[qt.qeye(2), decay_spline]]) # error; ```. On the cases it gives an error (sol3, sol4), it is `Exception: Invalid a_td_term.` from br_codegen.py (`aop_td_funcs()`).; Note that the Cubic_Spline representation works perfectly fine for the Hamiltonian part (e.g. sol2). It also appears to work fine if specifying `c_ops`. **Expected behavior**; My understanding from the documentation regarding time-dependent objects is that the Cubic_Spline representation should work for brmesolve at all argument positions, where appropriate (not just the Hamiltonian and c_ops). For example, at the above URL, we have: <br/>; ""When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present."" <br/>. If my understanding is incorrect and brmesolve can not accept Cubic_Spline objects, it means it is currently impossible to use this function with non-analytic functions (i.e. only ones we can write out explicitly such as 'exp(-w)'), and seems a major drawback (considering all other solvers in QuTiP are more flexible in what can be accepted to specify time-dependence). **Your Environment**; QuTiP Version: 4.6.2; Numpy Version: 1.18.1; Scipy Version: 1.4.1; Cython Version: 0.29.24; Matplotlib Version: 3.1.3; Python Version: 3.7.6; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1624:2628,flexible,flexible,2628,https://qutip.org,https://github.com/qutip/qutip/issues/1624,1,['flexible'],['flexible']
Modifiability,"3.8/site-packages/qutip/correlation.py in spectrum(H, wlist, c_ops, a_op, b_op, solver, use_pinv); 541 ; 542 if solver == ""es"":; --> 543 return _spectrum_es(H, wlist, c_ops, a_op, b_op); 544 elif solver == ""pi"":; 545 return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv). ~/.local/lib/python3.8/site-packages/qutip/correlation.py in _spectrum_es(H, wlist, c_ops, a_op, b_op); 1185 ; 1186 # correlation; -> 1187 corr_es = expect(a_op, es); 1188 ; 1189 # covariance. ~/.local/lib/python3.8/site-packages/qutip/expect.py in expect(oper, state); 75 ; 76 elif isinstance(oper, Qobj) and isinstance(state, eseries):; ---> 77 return _single_eseries_expect(oper, state); 78 ; 79 elif isinstance(oper, (list, np.ndarray)):. ~/.local/lib/python3.8/site-packages/qutip/expect.py in _single_eseries_expect(oper, state); 130 out = eseries(); 131 ; --> 132 if isoper(state.ampl[0]):; 133 out.rates = state.rates; 134 out.ampl = np.array([expect(oper, a) for a in state.ampl]). IndexError: index 0 is out of bounds for axis 0 with size 0; ```. **Expected behavior**; The expecter behavior is the normal returns of the spectrum, as it happens with other values of coupling. **Your Environment**; ```; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, and Boxi Li; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.2; Numpy Version: 1.18.3; Scipy Version: 1.4.1; Cython Version: 0.29.21; Matplotlib Version: 3.2.1; Python Version: 3.8.5; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/alberto/.local/lib/python3.8/site-packages/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1388:1736,coupling,coupling,1736,https://qutip.org,https://github.com/qutip/qutip/issues/1388,1,['coupling'],['coupling']
Modifiability,"5 seems also fine for me. We default to the dense solver when all the eigenvalues are required, even if `sparse=True` and we then raise a Warning explaining why we do this and how to stop the warning. IIf I understood it correctly, 3 would be raising an Error instead of a warning, which may be a little bit more annoying for someone that just wants the code to work (?). I am fine with both though and I think they could be suitable issues for a ""medium"" level ""good_first_issue"" (if that makes sense 😅 ). 1 and 4 seem indeed too much work right now (but perhaps they can be tackled in the future). 2 may actually be separate an enhacement, that could be useful for some specific scenarios (?). But maybe it is best to wait for when this scenario is present to actually motivate the enhancement (?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858:784,enhance,enhancement,784,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472647858,1,['enhance'],['enhancement']
Modifiability,"517. Any PEP 517-complaint installation and build process will now _enforce_ the presence of `numpy`, `scipy` and `cython` (and `setuptools`) before attempting the build, so no more need for attempted import guards.; - packages are now discovered rather than explicitly stated, using standard `setuptools` machinery; - Cython extension modules are now discovered rather than explicitly stated, using globbing; - version information is now stored in a single-line file `VERSION`. This is mostly for CI reasons; it's much easier to parse and override at the CI level when it's a single file, rather than attempting `sed s/.../.../ setup.py` or something crazy like that. The validity of the version string is tested by regex.; - local version information is now _always_ appended, even if `git` isn't present - the local version is just then ""nogit"" rather than the git shorthash; - `setup.py` gained a new `--release` flag or environment variable `CI_QUTIP_RELEASE`; the only effect right now is to suppress the local identifier on the version information, replacing the old `ISRELEASED` boolean flag in the code. ### Notes on the wheels. Currently I build only for CPython. I haven't tried to build pypy wheels, but we _may_ support it - Cython does in theory, but I think complex numbers and raw pointers aren't handled completely smoothly, and we make heavy use of both. We get `manylinux1` builds for Linux, which is the oldest `manylinux` spec. This can be updated in the future, but I'm not sure I see a need; all our heavy mathematical lifting is either done by custom code (which is mostly immune) or BLAS/LAPACK (which we link to dynamically), so I don't think there's much to be gained. I don't know if the macOS images will run on the new M1 chips, but if not, there's not much that can be done there until GitHub Actions adds the necessary cross-compilation headers and libraries to their CI. ### Examples. You can see the result of this upload on the testing PyPI server: https://test.pyp",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429:2682,variab,variable,2682,https://qutip.org,https://github.com/qutip/qutip/pull/1429,2,['variab'],['variable']
Modifiability,7/qutip; copying qutip/fastsparse.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/graph.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/stochastic.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/simdiag.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/random_objects.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/semidefinite.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/about.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/visualization.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/tensor.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/rcsolve.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/distributions.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/hardware_info.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/floquet.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/configrc.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/orbital.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/ipynbtools.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/lattice.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/subsystem_apply.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/superoperator.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/qobjevo_codegen.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/topology.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/piqs.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/sparse.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/settings.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/qobj.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/interpolate.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/qobjevo.py -> build/lib.macosx-10.9-x86_64-3.7/qutip; copying qutip/mcsolve.py -> bu,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404:3372,config,configrc,3372,https://qutip.org,https://github.com/qutip/qutip/issues/1404,1,['config'],['configrc']
Modifiability,"739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/assets/78165605/f8217060-dbff-4012-bf63-98750744e93f width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/e4e7be6c-6883-4cf5-a71f-1542aea1be75 width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/e6292945-a742-4a10-b434-86b462044049 width=30% height=30%> . And as we can see after the changes, the 'l' style plotting is as expected and the 'm' style plotting has all the colors we defined:. <img src=https://github.com/qutip/qutip/assets/78165605/67fc3442-ad19-45c2-955e-5a7df85217db width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/4d87cee0-c3c8-46d6-989b-50fac85ec0cd width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/83c8cac0-f12e-4af4-96df-4be972b485d4 width=30% height=30%>",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:1904,variab,variables,1904,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617,2,['variab'],"['variable', 'variables']"
Modifiability,"99&gt;</code>__)</li>; <li>Fix IDNA handling of '\x80' byte (<code>[#2901](https://github.com/urllib3/urllib3/issues/2901) &lt;https://github.com/urllib3/urllib3/issues/2901&gt;</code>__)</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/urllib3/urllib3/commit/c9016bf464751a02b7e46f8b86504f47d4238784""><code>c9016bf</code></a> Release 1.26.17</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/01220354d389cd05474713f8c982d05c9b17aafb""><code>0122035</code></a> Backport GHSA-v845-jxx5-vc9f (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3139"">#3139</a>)</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/e63989f97d206e839ab9170c8a76e3e097cc60e8""><code>e63989f</code></a> Fix installing <code>brotli</code> extra on Python 2.7</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2e7a24d08713a0131f0b3c7197889466d645cc49""><code>2e7a24d</code></a> [1.26] Configure OS for RTD to fix building docs</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/57181d6ea910ac7cb2ff83345d9e5e0eb816a0d0""><code>57181d6</code></a> [1.26] Improve error message when calling urllib3.request() (<a href=""https://redirect.github.com/urllib3/urllib3/issues/3058"">#3058</a>)</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/3c0148048a523325819377b23fc67f8d46afc3aa""><code>3c01480</code></a> [1.26] Run coverage even with failed jobs</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/d94029b7e2193ff47b627906a70e06377a09aae8""><code>d94029b</code></a> Release 1.26.16</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/18e92145e9cddbabdf51c98f54202aa37fd5d4c8""><code>18e9214</code></a> Use trusted publishing for PyPI</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/d25cf83bbae850a290fe34ed1610ae55c0558b36""><code>d25cf83</code></a> [1.26] Fix invalid test_ssl_failure_midway_through_conn</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/25cca3894",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2236:3674,Config,Configure,3674,https://qutip.org,https://github.com/qutip/qutip/pull/2236,1,['Config'],['Configure']
Modifiability,":thought_balloon: Can you follow [the rationale of the Python enhancement proposal 203](https://www.python.org/dev/peps/pep-0203/#rationale ""Proposal for augmented assignments"") (from 2000-07-13)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972611843:62,enhance,enhancement,62,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972611843,1,['enhance'],['enhancement']
Modifiability,"; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ================================================================================================================================== test session starts ===================================================================================================================================; platform linux -- Python 3.12.1, pytest-7.4.4, pluggy-1.3.0 -- /usr/bin/python3.12; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/home/drew/projects/misc/build/.hypothesis/examples')); rootdir: /home/drew/projects/misc/build/qutip; plugins: remotedata-0.4.1, asyncio-0.20.3, filter-subpackage-0.1.2, doctestplus-1.1.0, flaky-3.7.0, arraydiff-0.6.1, xvfb-3.0.0, astropy-0.11.0, mpi-0.6, astropy-header-0.2.2, cov-4.1.0, mock-3.12.0, openfiles-0.5.0, hypothesis-6.92.2; asyncio: mode=Mode.STRICT; collected 3269 items / 3233 deselected / 36 selected . qutip/tests/test_brmesolve_td.py::test_time_dependent_spline_in_c_ops FAILED [ 2%]; qutip/tests/test_brmesolve_td.py::test_split_operators_maintain_answer[_2_tuple_split] FAILED [ 5%]; qutip/tests/test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[string] FAILED [ 8%]; qutip/tests/test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[numpy] FAILED [ 11%]; qutip/tests/test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[function] PASSED [ 13%]; qutip/tests/test_krylovsolve.py::TestKrylovSolve::test_04_simple_check_states_e_ops_H_sho PASSED [ 16%]; qutip/tests/test_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293:4914,plugin,plugins,4914,https://qutip.org,https://github.com/qutip/qutip/issues/2293,1,['plugin'],['plugins']
Modifiability,"; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._boot",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1099,config,config,1099,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['config'],['config']
Modifiability,"<blockquote>; <h2>10.2.0 (2024-01-02)</h2>; <ul>; <li>; <p>Add <code>keep_rgb</code> option when saving JPEG to prevent conversion of RGB colorspace <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7553"">#7553</a>; [bgilbert, radarhere]</p>; </li>; <li>; <p>Trim glyph size in ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7669"">#7669</a>, <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7672"">#7672</a>; [radarhere, nulano]</p>; </li>; <li>; <p>Deprecate IptcImagePlugin helpers <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7664"">#7664</a>; [nulano, hugovk, radarhere]</p>; </li>; <li>; <p>Allow uncompressed TIFF images to be saved in chunks <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7650"">#7650</a>; [radarhere]</p>; </li>; <li>; <p>Concatenate multiple JPEG EXIF markers <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7496"">#7496</a>; [radarhere]</p>; </li>; <li>; <p>Changed IPTC tile tuple to match other plugins <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7661"">#7661</a>; [radarhere]</p>; </li>; <li>; <p>Do not assign new fp attribute when exiting context manager <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7566"">#7566</a>; [radarhere]</p>; </li>; <li>; <p>Support arbitrary masks for uncompressed RGB DDS images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7589"">#7589</a>; [radarhere, akx]</p>; </li>; <li>; <p>Support setting ROWSPERSTRIP tag <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7654"">#7654</a>; [radarhere]</p>; </li>; <li>; <p>Apply ImageFont.MAX_STRING_LENGTH to ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7662"">#7662</a>; [radarhere]</p>; </li>; <li>; <p>Optimise <code>ImageColor</code> using <code>functools.lru_cache</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7657"">#7657</a>; [hugovk]<",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:10915,plugin,plugins,10915,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['plugin'],['plugins']
Modifiability,"<blockquote>; <h2>v1.22.0</h2>; <h1>NumPy 1.22.0 Release Notes</h1>; <p>NumPy 1.22.0 is a big release featuring the work of 153 contributors; spread over 609 pull requests. There have been many improvements,; highlights are:</p>; <ul>; <li>Annotations of the main namespace are essentially complete. Upstream; is a moving target, so there will likely be further improvements,; but the major work is done. This is probably the most user visible; enhancement in this release.</li>; <li>A preliminary version of the proposed Array-API is provided. This is; a step in creating a standard collection of functions that can be; used across application such as CuPy and JAX.</li>; <li>NumPy now has a DLPack backend. DLPack provides a common interchange; format for array (tensor) data.</li>; <li>New methods for <code>quantile</code>, <code>percentile</code>, and related functions. The; new methods provide a complete set of the methods commonly found in; the literature.</li>; <li>A new configurable allocator for use by downstream projects.</li>; </ul>; <p>These are in addition to the ongoing work to provide SIMD support for; commonly used functions, improvements to F2PY, and better documentation.</p>; <p>The Python versions supported in this release are 3.8-3.10, Python 3.7; has been dropped. Note that 32 bit wheels are only provided for Python; 3.8 and 3.9 on Windows, all other wheels are 64 bits on account of; Ubuntu, Fedora, and other Linux distributions dropping 32 bit support.; All 64 bit wheels are also linked with 64 bit integer OpenBLAS, which should fix; the occasional problems encountered by folks using truly huge arrays.</p>; <h2>Expired deprecations</h2>; <h3>Deprecated numeric style dtype strings have been removed</h3>; <p>Using the strings <code>&quot;Bytes0&quot;</code>, <code>&quot;Datetime64&quot;</code>, <code>&quot;Str0&quot;</code>, <code>&quot;Uint32&quot;</code>,; and <code>&quot;Uint64&quot;</code> as a dtype will now raise a <code>TypeError</code>.</p>; <p>(<a h",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:1199,config,configurable,1199,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['config'],['configurable']
Modifiability,"> ; > ; > @thangleiter can you try with the dependencies (cython numpy scipy nose matplotlib)? What Python are you using and what OS?. I am building (and running) the Docker image from Windows 10 1803 Education. The image itself is based on Alpine Linux (see [https://github.com/ContinuumIO/docker-images/tree/master/miniconda3](url)) and runs Python 3.7.1 (or lower, depending on the qutip version's requirements). Explicitly installing the dependencies also results in an `Illegal Instruction`. The dockerfile for reference:; ```dockerfile; FROM continuumio/miniconda3. RUN conda config --append channels conda-forge && conda update -y --quiet conda && conda install -y --quiet qutip cython numpy scipy nose matplotlib; ```. Edit: Some further investigation revealed that the crash also happens in the WSL Ubuntu shell with miniconda manually installed and Python 3.6 and 3.7. It doesn't crash with the same setup and Python 3.5, however. Edit 2: Installing via pip or from source works with Python 3.7 and qutip 4.3.1, so the problem is definitely the conda package.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-480771908:582,config,config,582,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-480771908,1,['config'],['config']
Modifiability,"> ; > ; > Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems.; > ; > Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook.; > ; > Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See [qutip/qutip-notebooks#100](https://github.com/qutip/qutip-notebooks/issues/100); > ; > One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in #1092, using [loky](https://loky.readthedocs.io).; > ; > In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence.; > ; > If the freeze is indeed caused by spawn-multiprocessing, the problem _should_ also show up on Windows. Is anyone running Windows able to reproduce this?. Windows doesn't have 'fork' at all, if we want to make parallel_map work under windows, we have to find ways to 'spawn' efficiently.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416:212,inherit,inheriting,212,https://qutip.org,https://github.com/qutip/qutip/issues/1202#issuecomment-683628416,2,"['inherit', 'variab']","['inheriting', 'variables']"
Modifiability,"> @arnelg What if we add a variable `shape` also to the `_super_tofrom_choi`, `choi_to_kraus`, and `kraus_to_choi` functions?; > In that way, if `shape=None` the function uses the old code, while if `shape=""rectangular""` it implements the new version of the code. I don't think this is a good idea. The ""square"" case is really just a special case of ""rectangular"", and there is no reason the user should need to specify that it is square or not through an additional argument; this information is already there by looking at the `Qobj` in question. The code as submitted already correctly handles a square input (as before), so why create a separate code path? Also by sticking to one code path we ensure that if there is an error, it only needs to be fixed once. > Moreover, for the sake of completeness, I think this option should be implemented also in the Stinespring and $\chi$ representation.; > Commenting the docstring on this issue could help the user, even if these are private functions.; > I have been reviewing this with @nathanshammah. Yeah good point. I will have a look at this together with @joshcombes. (It is fine to accept the current pull request, and we can open another one for further improvements, however.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-565329722:27,variab,variable,27,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-565329722,1,['variab'],['variable']
Modifiability,"> @hodgestar I gave it a first read. Thank you!. > I would suggest the split the `bofin.py` file and move out the `Bath` to make it less heavy. I've been thinking of splitting the file up a bit too but have been waiting until I was ready to replace heom.py. The Bath and Bath exponent classes could possibly be separated from the solver and solver support classes. > The interface for `Bath` seems quite hard to use. An expansion of the correlation function is useful for the solving, but I feel we should have more helper function for the user. There are three tiers of bath classes:. * Bath: Low-level. One gets to specify exactly the exponents one wants by hand.; * BosonicBath and FermionicBath: Mid-level. Flexible but one has to specify the expansion coefficients.; * DrudeLorentzBath and DrudeLorentzPadeBath: High-level. Support for specific bath models. I discussed having a class that would automatically fit a correlation function with Niell, and he has experiment with that but it's bit tricky to make it work well in a generic way. E.g. For the DrudeLorentz bath there is a divergence in the exponent series at t = 0 which makes it hard to fit numerically. We'd like to add more generic support in future, but the current approach provides all the functionality of the existing HSolverDL and is sufficiently flexible to implement many more higher-level Bath classes easily in the future.; ; > Are `BathExponent` needed? I don't see why there is one object for each term and not one object for the whole decomposition. BathExponent its just a holder for all of the information associated with an expansion term. Three issues with treating whole expansions as one object are:. * some exponents contribute to two expansions (e.g. the RI exponent type); * some exponents are paired (e.g. the + and - types); * having exponents within expansions makes dealing with the hierarchy a mess because one has to have lists of lists of exponents with relationships between them and ADO labels would ha",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005:711,Flexible,Flexible,711,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-964982005,1,['Flexible'],['Flexible']
Modifiability,"> According to the error message; > ; > ```; > WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); > WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); > ```; > ; > That should be the error source. Lets use; > ; > ```; > .. automodule:: qutip.core.gates; > :members: ...; > ```; > ; > first and see if it works. Thank you, lets try that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661:128,inherit,inheritance,128,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148458661,2,['inherit'],['inheritance']
Modifiability,"> Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses).; > ; > Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument. I addressed Simon's question. Also, I tried different solver options in mesolve including solver type, nsteps, relative and absolute tolerence, etc ... Also for RK45 I tried to change the parameters in order to see if the solutions coincide. They didn't. I don't know if there exists an analytically solvable problem in which both Hamiltonian and dissipation operators are time dependent, but if there is such a problem, then I can use it as a benchmark in order to compare QuTiP and RK45.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248:216,adapt,adaptive,216,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986665248,1,['adapt'],['adaptive']
Modifiability,"> Do we have any tests for whether the isherm and isunitary preserving logic is correct?. We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214:506,extend,extend,506,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-892862214,1,['extend'],['extend']
Modifiability,"> General comment about plotting on the Bloch sphere:; > ; > QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are _not_ required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix.; > ; > There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested.; > ; > I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now.; > ; > I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling.; > ; > My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though. Thanks a lot, Simon (@hodgestar). My modification to the bloch.py follows what you have suggested. ; Also, the code can plot arcs inside and outside the bloch sphere too, and the line segment can be drawn between any two points. And the inputs have to be in cartesian coordinates.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018:985,flexible,flexible,985,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934360018,2,['flexible'],['flexible']
Modifiability,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:1456,layers,layers,1456,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192,2,['layers'],['layers']
Modifiability,"> I added ipython to the testing workflow. Let me know if it should have been included somewhere else. Hmm. I don't like adding random dependencies into the workflow config. On the other hand, this is specific to IPython. Maybe we can add an ""ipython"" section in `setup.cfg` and add that to `full`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238:166,config,config,166,https://qutip.org,https://github.com/qutip/qutip/pull/1918#issuecomment-1146092238,1,['config'],['config']
Modifiability,"> I solved this by adding C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\ to the PATH variable. I don't know why, but setting the PATH variable does not work for me :(; I was using VS2017 before installing qutip. It was recommended that qutip should work with VS2015 on windows. So I uninstalled VS2017 and reinstalled VS2015. I guess something went wrong in this process, but I haven't figured out what it is.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1026#issuecomment-506745768:98,variab,variable,98,https://qutip.org,https://github.com/qutip/qutip/issues/1026#issuecomment-506745768,2,['variab'],['variable']
Modifiability,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:1146,evolve,evolver,1146,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667,2,['evolve'],['evolver']
Modifiability,"> I'm going to change the Clifford group tests a little, and rebase the typo fix commit into the general refactor before this one should be merged. Sure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402:105,refactor,refactor,105,https://qutip.org,https://github.com/qutip/qutip/pull/1251#issuecomment-626315402,1,['refactor'],['refactor']
Modifiability,"> It's very clean, I really like the `set & set` and reusing the classes. Thanks!. > But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. I'm open to modifying the check for QuTiP v4 functions, but I would like to keep the check simple. To quote the Zen of Python, ""If the implementation is hard to explain, it's a bad idea."". :). > Also what should; > ; > ```; > def f(t, w, a=1):; > return a; > ; > coeff = coefficient(f, args={'w':1}); > coeff.replace_arguments(a=2)(0); > ```; > ; > give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?. I think this works fine already in this branch. `a` is included in `_f_arg_names`, so it can be specified via `.replace_arguments(...)` but since it has a default it can also be left out.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390:199,variab,variable,199,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894670390,2,['variab'],['variable']
Modifiability,"> Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?. That sounds great, but I don't think it's required if it turns into a rabbit hole.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558:143,rewrite,rewrite,143,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829623558,1,['rewrite'],['rewrite']
Modifiability,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:606,enhance,enhancement,606,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845,1,['enhance'],['enhancement']
Modifiability,"> Seems to me that the whole thing should first decide the kind of gate, then loop over only the necessary qubits - that'd be both more efficient and easier to read. I feel the same. Indeed it is just something I encountered when writing the doc. I guess this structure to make use of similarity among those gates. Many have one control and one target. Those gates work well. SWAP just happens to not be one of this... Also, ISWAP doesn't work very well if it acts on qubits not next to each other. The gates need to be classified better. Maybe completely rewrite it at some point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-781976727:556,rewrite,rewrite,556,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-781976727,1,['rewrite'],['rewrite']
Modifiability,"> There is no agreement on how this should be handled yet. It's been removed from `dev.major` with the plan to restore it before the release, but the exact interface is not fixed. It certainly will not be some special keyword in args. It could be a special value, or a special parameter / method for the solver class. Actually having a method in the solver class seems better, I suppose this is why we are going towards Solvers from the simple `mesolve` function. I am going to try and rewrite my example using the Solver class. We can probably get away with having this functionality only in the new Solver class --- benefit of a major release I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/947#issuecomment-1142213362:486,rewrite,rewrite,486,https://qutip.org,https://github.com/qutip/qutip/issues/947#issuecomment-1142213362,2,['rewrite'],['rewrite']
Modifiability,"> This randomly failing test appears again. It is really getting annoying. I copied the error message from Travis bellow:; > ; > ```; > =================================== FAILURES ===================================; > ___________________________ test_MCSimpleConstStates ___________________________; > @pytest.mark.slow; > def test_MCSimpleConstStates():; > ""Monte-carlo: Constant H with constant collapse (states)""; > N = 10 # number of basis states to consider; > a = destroy(N); > H = a.dag() * a; > psi0 = basis(N, 9) # initial state; > kappa = 0.2 # coupling to oscillator; > c_op_list = [np.sqrt(kappa) * a]; > tlist = np.linspace(0, 10, 100); > mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; > options=Options(average_states=True)); > assert_(len(mcdata.states) == len(tlist)); > assert_(isinstance(mcdata.states[0], Qobj)); > expt = expect(a.dag() * a, mcdata.states); > actual_answer = 9.0 * np.exp(-kappa * tlist); > avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > > assert_equal(avg_diff < mc_error, True); > E AssertionError: ; > E Items are not equal:; > E ACTUAL: False; > E DESIRED: True; > ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; > ----------------------------- Captured stdout call -----------------------------; > 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; > 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; > 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; > 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; > 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; > 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; > 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; > 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; > 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; > 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; > Total run time: 20.34s; > ---------- covera",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896:557,coupling,coupling,557,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607478896,1,['coupling'],['coupling']
Modifiability,"> We do have a few tests, see for instance `test_QobjUnitaryOper` which I modified in this PR to track a few more cases. Perfect. Thank you!. > However, the current tests are not very exhaustive. For example, they do not really ensure that hermiticity is inferred in the operation. some rethinking of these tests may be beneficial but I would prefer leaving that for another PR. Should I open an issue to remember this or do you prefer if I extend these tests in this PR?. Happy to leave this for another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207:441,extend,extend,441,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-893430207,1,['extend'],['extend']
Modifiability,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:67,config,config,67,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649,5,"['Config', 'config', 'variab']","['ConfigLocation', 'config', 'variable']"
Modifiability,"> also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; > Expected outcomes; >; > - More devices defined in the qutip.qip.device module. At the moment,; > we have two models: spin chain and cavity QED. We would like to include; > some other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in qutip.qip.device and; > qutip.qip.compiler; > - Refactoring the circuit compiler to allow simple pulse scheduling,; > e.g. Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages; > or commonly used language e.g. through quantum assembly language (qasm); >; > ------------------------------; >; > Also, the last outcomes have some overlap with the last project. Although; > I also find this circuit importation very important, I guess two projects; > should not have overlap if they are both selected.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67E",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:2576,Refactor,Refactoring,2576,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,1,['Refactor'],['Refactoring']
Modifiability,"> by calculating the `qutip.propagator` we are actually solving `qutip.sesolve` for `N` basis states. Yes, propagator returns the unitary matrix of the evolution. For large system, this will be much slower than `sesolve`. Roughly speaking, `sesolve` evolves only the given initial state while propagator all the `N` basis. From a very inaccurate estimation, if you want to evolve more than `N` initial states with the same Hamiltonian, `propagator` will be a better choice. However, you might also need a bigger memory to save the unitary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660506344:250,evolve,evolves,250,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660506344,2,['evolve'],"['evolve', 'evolves']"
Modifiability,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:53,plugin,plugins,53,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005,2,['plugin'],['plugins']
Modifiability,"> thanks for the comment, I didn't know about `qutip.propagator`; > ; > > Lots of people have successfully used QuTiP already as part of reinforcement learning protocols - I've worked with at least a couple; > ; > cool, can i learn more about this from you?. Sorry, I don't have much experience in it myself - you'll be reading about the methods in papers/lecture note by people smarter than me. We have some tutorial notebooks about optimal control using the QuTiP optimal control package here: http://qutip.org/tutorials.html#optimal-control, which you may be able to adapt to your use case. I believe there are components in there that you can subclass so that the optimiser is RL-based rather than using standard BFGS or something else.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1323#issuecomment-660475258:570,adapt,adapt,570,https://qutip.org,https://github.com/qutip/qutip/issues/1323#issuecomment-660475258,2,['adapt'],['adapt']
Modifiability,>… are part of why `a = a + 5` is not equivalent to `a += 5` …. Different development views are involved here for the interpretation of “equivalence”.; How will the design goals evolve further for selected software areas? :thinking:,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972782553:178,evolve,evolve,178,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972782553,1,['evolve'],['evolve']
Modifiability,"@BOBO1997 Sorry I forgot about your proposal above. - What is the proposed behaviour of gate insertion? I guess you mean that, in the current code, if one inserts more than one gates, the length of the list is modified during the loop. This makes the definition of `position` tricky. Is this what you mean?. - About the syntax sugar, this sounds nice indeed. However, there might be a rather big refactor in `QubiCircuit` in the near future. I had a proposed refactor of `QubiCircuit` https://github.com/qutip/qutip-qip/discussions/15 (This is a separate repo in qutip org. Big new features in qip will most likely happen there). Although no one is working on that yet. I feel like this change will be much easier to implement after that refactor?. In any case, they should be in a different PR as they don't relate to this topic of FREDKIN.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1489#issuecomment-817748955:396,refactor,refactor,396,https://qutip.org,https://github.com/qutip/qutip/pull/1489#issuecomment-817748955,3,['refactor'],['refactor']
Modifiability,@BassemSafieldeen thank you for addressing this enhancement. It would be nice to find out what's broken with pytest.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/972#issuecomment-482167982:48,enhance,enhancement,48,https://qutip.org,https://github.com/qutip/qutip/pull/972#issuecomment-482167982,1,['enhance'],['enhancement']
Modifiability,"@Chasmiccoder I agree with @BoxiLi that we don't want to do a big refactor, especially of the older 4.6 and 4.7 releases. I would like to add some code style checkers like `pyflakes` , `black` (or `blue`) and `isort` to our CI system on the `dev.major` branch, initially excluding all the files and then slowly including more and more files in the checks as we fix them. I'm going to close this issue for now, but if you would like to tackle adding, e.g., `pyflakes` to `dev.major` that would be awesome.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604:66,refactor,refactor,66,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982600604,1,['refactor'],['refactor']
Modifiability,"@Darshil9120 I actually don't know what the ""correct"" fix should be. The links are actually correct in the documentation source, but Jekyll, which is used to generate qutip.org, ignore folders with leading underscores, so they underscores need to be removed from the folders and the links to them. There is a script https://github.com/qutip/qutip.github.io/ called `docs/remove_leading_underscore.py` that does this. I'm inclined to close this issue for now unless since we have a solution, but I'm happy to reopen it if someone has a good concrete suggestion (I think change the Sphinx defaults is a bit of a mess, but maybe we could configure Jekyll to not ignore some specific folders -- e.g. all folders with leading underscores that are under the docs folder).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1531#issuecomment-1100139852:635,config,configure,635,https://qutip.org,https://github.com/qutip/qutip/issues/1531#issuecomment-1100139852,1,['config'],['configure']
Modifiability,"@Ericgig After reading the following comment in `setup.cfg`; ```; ; This uses ConfigParser's string interpolation to include all the above; ; dependencies into one single target, convenient for testing full builds.; ```; I changed my mind a bit about the role of `full`. It seems that the intention of full is to install everything for testing and development, so it makes sense for the ipython dependency to be included there. After I changed my mind, I just cherry-picked Asier's merge commit for #1918 to master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169:78,Config,ConfigParser,78,https://qutip.org,https://github.com/qutip/qutip/pull/1970#issuecomment-1207180169,1,['Config'],['ConfigParser']
Modifiability,"@Ericgig Do you think it's a good idea to add the br_solver as an option for the correlation functions? If so, there a plan to make selecting a solver more flexible in QuTiP v5? I found https://github.com/qutip/qutip/projects/6#card-72925447 which suggest there might be, but I don't know the full plan.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/884#issuecomment-983858798:156,flexible,flexible,156,https://qutip.org,https://github.com/qutip/qutip/pull/884#issuecomment-983858798,1,['flexible'],['flexible']
Modifiability,"@Ericgig I am now trying to use pytest's parametrize feature which allows us to parametrize input to test functions variable by variable. I was able to successfully rewrite some tests which use `yield`, but this one (`test_trunc_neg`) in particular throws an error. Could you please run the following self sufficient snippet locally and inform me if there is anything wrong with the values in this example?? Thanks for the tip about yield, that might indeed be what is wrong. ```; from qutip import *; import numpy as np; import pytest; from numpy.testing import (assert_equal, assert_, assert_almost_equal,; run_module_suite). @pytest.mark.parametrize(""method"", ['clip', 'sgs']); @pytest.mark.parametrize(""qobj"", [rand_dm(5), Qobj(np.diag([1.1, -0.1])),; rand_unitary(3)*Qobj(np.diag([1.1, 0, -0.1]))*rand_unitary(3).dag()]); @pytest.mark.parametrize(""expected"", [None, Qobj(np.diag([1.0, 0.0])),; rand_unitary(3)*Qobj(np.diag([1.0, 0.0, 0.0]))*rand_unitary(3).dag()]); def test_trunc_neg(method, qobj, expected):; ""Checks trunc_neg in several different cases.""; pos_qobj = qobj.trunc_neg(method=method); assert(all([energy > -1e-8 for energy in pos_qobj.eigenenergies()])); assert_almost_equal(pos_qobj.tr(), 1); if expected is not None:; assert_almost_equal(pos_qobj.data.todense(), expected.data.todense()); ```. Also, I would like to rewrite all the tests which use `yield` in this format, would that be okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013:116,variab,variable,116,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-571008013,4,"['rewrite', 'variab']","['rewrite', 'variable']"
Modifiability,"@Ericgig I changed the variable names. In the example file one small change has to be made. For changing the b.point_color after points are added, we will have to set b.point_color = [colors] instead of b.point_colors = list(colors). b.point_color is a list of list of points. https://github.com/rajathshetty20/misc/blob/master/bloch_sphere_with_colorbar.ipynb",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1315#issuecomment-667491189:23,variab,variable,23,https://qutip.org,https://github.com/qutip/qutip/pull/1315#issuecomment-667491189,1,['variab'],['variable']
Modifiability,@Ericgig I have implemented the enhancement required please have a look.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098:32,enhance,enhancement,32,https://qutip.org,https://github.com/qutip/qutip/issues/1722#issuecomment-1415691098,1,['enhance'],['enhancement']
Modifiability,"@Ericgig I've kept the WIP label, but this is ready for a first review. I think I'm made the HEOM look as much like the base solver as I can without having to modify the base solver a bit. Perhaps we can meet up tomorrow on Discord to discuss options. I'm also happy to merge this as is and adapt the solver more in another PR (assuming tests still pass and documentation still builds with my latest commits).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887:291,adapt,adapt,291,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1101587887,1,['adapt'],['adapt']
Modifiability,"@Ericgig any tips how to locally run `pycodestyle` linter so that it follows same settings as `codeclimate`? When I run it locally it show way more warnings than `codeclimate`, seems a lot more restrictive. I'm sure some sort of configuration is missing. I checked the [contribution guide](https://qutip.org/docs/latest/development/contributing.html) but this particular matter is not detailed. If you explain how to run linter locally I would be happy to also update the docs and document it for the future contributors.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661:229,config,configuration,229,https://qutip.org,https://github.com/qutip/qutip/pull/1655#issuecomment-925558661,2,['config'],['configuration']
Modifiability,"@Ericgig, I see. Thank you so much! I had the impression that v5 would change something related to the calculation of density matrices being more flexible. But all in order now. Thank you!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549:146,flexible,flexible,146,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1584158549,1,['flexible'],['flexible']
Modifiability,"@Krastanov I don't quite understand. Are you use the **nested-list method**? If so, can you tell me how you expanding and rewriting/reordering by hand of the c_ops so that you can list them one by one in the nested-list method? If you can rewriting/reordering them, why cannot you do the same thing for `mcsolve`?. @jrjohansson In the first reply you mentioned that. > Yes, it is not the same thing. You need to rewrite it manually so that each collapse operator contribute on standard lindblad form. . May I ask how to rewrite it manually so that each collapse operator contribute on standard lindblad form so that I can implement complicated time-dependent collapse operator in the **nested-list method**?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/223#issuecomment-223872353:412,rewrite,rewrite,412,https://qutip.org,https://github.com/qutip/qutip/issues/223#issuecomment-223872353,2,['rewrite'],['rewrite']
Modifiability,"@Lala5th Thank you for reporting this. It looks like the issue is just hat `mesolve` calculates the `size` variable incorrectly for a flat array and the following diff removes the segfault for me:. ```diff; diff --git a/qutip/mesolve.py b/qutip/mesolve.py; index f6527299..25e9f3cd 100644; --- a/qutip/mesolve.py; +++ b/qutip/mesolve.py; @@ -435,6 +435,8 @@ def _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt,; output.solver = ""mesolve""; output.times = tlist; size = rho0.shape[0]; + if rho0.shape[1] == 1:; + size = int(np.sqrt(size)); ; initial_vector = rho0.full().ravel('F'); ```. I agree that we should not segfault. Probably the minimal patch is to raise an exception if `rho0.shape[0] != rho0.shape[1]`. If you agree, I can open a small PR (or you can if you would like to).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291:107,variab,variable,107,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021275291,1,['variab'],['variable']
Modifiability,"@MartinSandeCosta, free feel to complete the tests in the way you want. However, maybe it is good to discuss a bit with @jakelishman? Since there is a refactoring of `qutip/tests/test_gates.py` in #1181. A lot of change in this test might make it hard to resolve two PRs later. Besides, it is better to leave a more detailed description in the PR. As the template indicated:; ```; **Description**; Describe here the proposed change. **Related issues or PRs**; Please mention the related issues or PRs here. If the PR fixes an issue, use the keyword fix/fixes/fixed followed by the issue id, e.g. fix #1184. **Changelog**; Give a short description of the PR in a few words. This will be shown in the QuTiP change log after the PR gets merged.; For example: ; Fixed error checking for null matrix in essolve.; Added option for specifying resolution in Bloch.save function.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156:151,refactor,refactoring,151,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607803156,1,['refactor'],['refactoring']
Modifiability,"@OliverLunt, ; The problem lies in the adaptative step of the ode solver. Since nothing happen at first, the step become so long that it jump over the change in the on_off signal...; You can do:; ```; opt = qt.Options(); opt.max_step = 0.5; output = mesolve(H, psi0, tlist, c_ops=c_ops, e_ops=e_ops, options=opt); ```; To limit the step size and it will work as expected. . I am not sure why sesolve (used when no c_ops are given) have smaller step size. It seems to be something in the scipy solver.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/898#issuecomment-430306233:39,adapt,adaptative,39,https://qutip.org,https://github.com/qutip/qutip/issues/898#issuecomment-430306233,1,['adapt'],['adaptative']
Modifiability,"@ajgpitch Thanks for your thoughts on the classes vs. functions matter. I generally agree with @sahmed95 that refactoring this (and many other QuTiP modules) into a more object-oriented class-based structure would be healthy for the ongoing development of QuTiP. . I began rewriting this module into a class this morning, but as I started coding, I realized that this does introduce one major complication which could limit usefulness, which is that class methods do not play well with Python multithreading/multiprocessing. If you look in the example notebook in [my `qutip-notebooks` PR](https://github.com/qutip/qutip-notebooks/pull/58), there are several instances where I create a 1- or 2-line helper function to multiprocess a parameter search of `scattering_probability` using `multiprocessing.pool.starmap`. . In my experience, implementing a parallelized parameter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more diffi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:110,refactor,refactoring,110,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactoring']
Modifiability,"@alipedram01 It looks like we've understood the cause of the issue -- i.e. your RK45 solver just doesn't converge for this problem. That's probably not unexpected -- I see to remember reading on Wikipedia that the implicit Runga-Kutta methods have small regions of convergence relative to explicit or adaptive methods. Closing this for now, but thank you for taking a look and please feel free to continue the discussion if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164:301,adapt,adaptive,301,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-1005605164,1,['adapt'],['adaptive']
Modifiability,"@arnelg What if we add a variable `shape` also to the `_super_tofrom_choi`, `choi_to_kraus`, and `kraus_to_choi` functions?; In that way, if `shape=None` the function uses the old code, while if `shape=""rectangular""` it implements the new version of the code.; Moreover, for the sake of completeness, I think this option should be implemented also in the Stinespring and $\chi$ representation.; Commenting the docstring on this issue could help the user, even if these are private functions.; I have been reviewing this with @nathanshammah.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-547716872:25,variab,variable,25,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-547716872,1,['variab'],['variable']
Modifiability,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:1340,flexible,flexible,1340,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,2,['flexible'],['flexible']
Modifiability,"@cgranade Thank you for the detailed write-up. I have some questions below. I have my own ideas of answers to some of these questions, but I'd like to hear yours. * What do you see as the primary drivers for this new feature?; * What is the advantage of this over using the existing superoperator representations?; * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?; * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?; * How do you see the various mathematical operations working?. Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised. @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927694147:1191,evolve,evolve,1191,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927694147,1,['evolve'],['evolve']
Modifiability,@drew-parsons I'll leave #1875 open until we've sorted out why the `--config-setting=--global-option=--with-openmp` isn't working in some cases.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340:70,config,config-setting,70,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219947340,1,['config'],['config-setting']
Modifiability,"@elfring The first line of the PEP `There are two main reasons for adding this feature to Python: simplicity of expression, and support for in-place operations` and the `in-place operations` mentioned are part of why `a = a + 5` is not equivalent to `a += 5` (as Jake took the time to demonstrate). I'm closing the issue, but feel free to continue the discussion here & thank you for suggesting an enhancement to QuTiP and please feel free to suggest others.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767:398,enhance,enhancement,398,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972730767,2,['enhance'],['enhancement']
Modifiability,"@gautierronan Thanks Ronan for this useful contribution. It looks good to me. I was discussing something similar with a colleague back in October, so I am going to see if I can get them to test it too.; On the subject of testing... this will need tests to be added before it can be merged. Please see https://github.com/qutip/qutip/blob/master/qutip/tests/test_control_pulseoptim.py; Ideally it would also have an example notebook. See https://github.com/qutip/qutip-notebooks/blob/master/examples/control-pulseoptim-Hadamard.ipynb for example. It could either have new notebook, or one could be extended to show this feature.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095:596,extend,extended,596,https://qutip.org,https://github.com/qutip/qutip/pull/1369#issuecomment-754707095,1,['extend'],['extended']
Modifiability,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:336,coupling,coupling,336,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548,4,['coupling'],['coupling']
Modifiability,"@hodgestar any updates on merging this, I'm hoping to extend some of this functionality!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-626381159:54,extend,extend,54,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-626381159,1,['extend'],['extend']
Modifiability,"@hodgestar, ; I adapted the `MultiTrajResult` to the new `Result` format, and I have some changes to the `Result` class that I want to do:; - I changed the `Result.__init__` to move setting the `e_ops` in `_post_init`: `MultiTrajResult` can't use them and needed to remove the related state processors.; - `add` was overwritten, but we could use it if we add a `_early_finish_check`: a processor that return the estimated quantity of work remaining. Parallel map will stop computing trajectories when it get under 0. I think we could have it in `Result`: it could be interesting to have with `mesolve` with the options to stop when the steady state is reached, etc. Then if times when added in a state processor, I could use `add` without overloading. Are you Ok with me going for it or do you prefer to keep `Result` as is?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173:16,adapt,adapted,16,https://qutip.org,https://github.com/qutip/qutip/pull/1889#issuecomment-1156962173,1,['adapt'],['adapted']
Modifiability,"@hodgestar, to make it work with HEOM, I had to change `step` to return `rho` directly, (controlled by the `store_ados` options). Could you take a look and tell me if you are fine with this approach. Also, do you know a `Bath` configuration that would result in evolution similar to `mesolve` so we could use it in tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120:227,config,configuration,227,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1258539120,1,['config'],['configuration']
Modifiability,"@jakelishman , I think it is ready for a review. . There a lot of `TODOs` in the code from the before times, and a general refactor is probably needed since most of the representations are working on the assumption that the channels admit equal right and left tensors:; ![formula](https://render.githubusercontent.com/render/math?math=A_{\alpha}%20=%20B_{\alpha}) . ; This PR at least allows for different left and right tensor in the Stinespring representation, thus completing the `FIXME` in the original tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046:123,refactor,refactor,123,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831514046,1,['refactor'],['refactor']
Modifiability,"@jakelishman, Equivalent change but with different implementation have been made in `dev.,major`. Here setting variable are directly in the module, but in v5 they are in a `Settings` object. Adding the object was a big change for major.; Maybe cherry-picky commits from master to `dev-major` would be easier.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1289#issuecomment-779252394:111,variab,variable,111,https://qutip.org,https://github.com/qutip/qutip/pull/1289#issuecomment-779252394,1,['variab'],['variable']
Modifiability,"@matteoacrossi Thanks! I don't know that I have much particular advice, other than ""let's try debug the failing tests one at a time"". Maybe pick one of the `test_driven_cavity` ones, because I'm not quite sure how `ValueError: Invalid preconditioning method` can get raised when it succeeds on other platforms. Maybe it is a bug that isn't completely related to the M1?. Are you familiar with pdb? Running just the one test using pytest and `pytest --pdb` will allow to explore the stack trace and see the values of variables in each stack frame, and hopefully figure out what went wrong. Another first step is just to fix the line `raise ValueError(""Invalid preconditioning method."")` to be `raise ValueError(f""Invalid preconditioning method: {ss_args['method']!r}."")` so that the error messages gives more of a hint of what the invalid method name was.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325:516,variab,variables,516,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007285325,1,['variab'],['variables']
Modifiability,"@nathanshammah ; I expect it to be easy to use as an integrator:; ` _evolve_krylov_tlist` is essentially the `run`, `time_evolution` is `integrate`.; The interface just need to be adapted.; It would work well with `sesolve` and `mcsolve`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939:180,adapt,adapted,180,https://qutip.org,https://github.com/qutip/qutip/pull/1644#issuecomment-908484939,1,['adapt'],['adapted']
Modifiability,"@nathanshammah @ajgpitch @Ericgig @quantshah ; Thanks a lot for the feedback and patience. I have fixed the variable names issue, hopefully. I can make time these days. Please advise the next steps.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-568178589:108,variab,variable,108,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-568178589,2,['variab'],['variable']
Modifiability,"@nathanshammah I've merged in master, waiting for builds to complete. The code climate error is seems largely unrelated to this PR (the PR adds a tiny snippet of code that is similar to 4 other existing pieces of code). I'm happy to refactor this a bit if someone makes a suggestion, but the code climate error seems overly zealous to me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090#issuecomment-581037319:233,refactor,refactor,233,https://qutip.org,https://github.com/qutip/qutip/pull/1090#issuecomment-581037319,1,['refactor'],['refactor']
Modifiability,"@nathanshammah: Sure. An assumption had previously been hard-coded into various conversion functions between super-operator representations that the input and output Hilbert spaces for the superoperator have the same dimension. An example is `_super_tofrom_choi` which converts between Liouville and Choi matrix representations, for example the line:. ``sqrt_shape = int(sqrt(data.shape[0]))``. This enhancement removes these assumptions and instead looks at the input and ouput dimensions of the `Qobj`s, which is stored in the `dims` attribute, to correctly convert in the case when the input and output dims are different. It's needed in all sorts of applications. Since the failing tests are unrelated to this pull request, it is merge ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594:400,enhance,enhancement,400,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-541953594,1,['enhance'],['enhancement']
Modifiability,"@nonhermitian mentioned something about being able to move the pyximport bit to somewhere in the dynamic C building workflow. Now that would be a real bonus. Say we have some (probably Windows) users who have not managed to configure a working C compiler, but have installed from a conda package or some other wheel like thing, then they would be able to use everything except the string format time-dependent stuff. ; This is also discussed in #448",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-269725490:224,config,configure,224,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-269725490,1,['config'],['configure']
Modifiability,"@paulsbrookes Thanks very much for the fix. We have PR #815 that has been awaiting merge for a long time, which also has other enhancements. Please feel free to comment on #815",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/915#issuecomment-434060283:127,enhance,enhancements,127,https://qutip.org,https://github.com/qutip/qutip/pull/915#issuecomment-434060283,1,['enhance'],['enhancements']
Modifiability,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:753,extend,extended,753,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428,2,"['evolve', 'extend']","['evolve', 'extended']"
Modifiability,"@sahmed95 thank you very much. 2018-02-21 11:53 GMT+09:00 Shahnawaz Ahmed <notifications@github.com>:. > This is ready for a review. I incorporated the changes and the pep8 fixes.; > We still might go for a change in the name for the module as piqs and the; > class as Dicke to follow the naming in the paper. There are some more; > tests that we would like to add today.; >; > However, for the rest of it, things remain the same. Since the is_diagonal; > feature is more general, I could open a PR to include that as a Qobj; > property. Otherwise, this function will only be used once we add the; > enhancement diagonal_solver which can solve for some special classes of; > Hamiltonians. But that is for later.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/753#issuecomment-367197236>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AN5ffJy5kuOEnKCIxLH-GjbhKdmP8mHsks5tW4UrgaJpZM4PgbIo>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-367222920:600,enhance,enhancement,600,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-367222920,1,['enhance'],['enhancement']
Modifiability,"@sbisw002 All contributions to QuTiP must follow the pep8 standard. You should read https://www.python.org/dev/peps/pep-0008/, especially the section on naming conventions. I see @nathanshammah has made some specific comments along these lines, but there are too many examples to begin to comment on them. But in general, we like descriptive names for variables. One exception we have to pep8 is that we allow some use of capital letters in variable names, but only at the start, as this relates well to the corresponding mathematics. We reserve these for operators and matrices (in the mathematical sense), so for instance `H` is ok for a Hamiltonian, but `N` is not okay for an integer. `H_cell` is also fine, but `cellH` or `cell_H` is not. All caps are not to be used for anything. If you wish to abbreviate 'periodic boundary condition', then `pbc` would be ok as a local variable, but not as an attribute name, `period_bnd_cond` would be good. I am sorry if this seems a little late in the day, but this is covered in https://github.com/qutip/qutip/wiki/QuTiP-Development-Guidelines and this document https://github.com/qutip/qutip-doc/blob/master/qutip_dev_contrib.md was linked in our GSoC page. Coding standards are *very* important, it where quality begins.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-533771943:352,variab,variables,352,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-533771943,3,['variab'],"['variable', 'variables']"
Modifiability,"@tehruhn and I found that trying to install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1371:873,flexible,flexible,873,https://qutip.org,https://github.com/qutip/qutip/issues/1371,1,['flexible'],['flexible']
Modifiability,"A few comments and questions. 1. Why are file separated by function and not by datatype? So adding a new datatype will result in modification im a lot of file making support (PR evaluation) harder.; 2. `__repr__` return a very clean output in `Qobj`. `CSR`'s is quite simple. This is because data layers are never meant to be printed directly?; 3. For solver states, we mostly use Fortran ordered array, not C ordered. Will you support both?; 4. In matmul, you use `malloc`, `calloc`, `free`. It is better to use the python PyDataMem_NEW. I never had any issue, but there can be some on windows: https://github.com/numpy/numpy/issues/8253; 5. `mat_mul` can be used inplace, but no `add_csr`. ; 6. It would be good to have inplace multiplication with a scalar instead of always making a copy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648255315:297,layers,layers,297,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648255315,2,['layers'],['layers']
Modifiability,"A few people have been asking for this again recently. ; I have produced this new PR, rather than apply #396, as its a bit simpler and more flexible. It is a bit more memory consumptive, but probably a small percentage of the whole. It's also based an recent pull. . No notebook as yet, as I will wait for feedback from those who requested it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/506:140,flexible,flexible,140,https://qutip.org,https://github.com/qutip/qutip/pull/506,1,['flexible'],['flexible']
Modifiability,"According to the error message; ```; WARNING: invalid signature for automodule ('qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:'); WARNING: don't know which module to import for autodocumenting 'qutip.core.gates\n :members:\n :show-inheritance:\n :imported-members:' (try placing a ""module"" or ""currentmodule"" directive in the document, or giving an explicit module name); ```; That should be the error source. Lets use; ```; .. automodule:: qutip.core.gates; :members: ...; ```; first and see if it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542:118,inherit,inheritance,118,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148414542,2,['inherit'],['inheritance']
Modifiability,Adapt qutip 4.7 for matplotlib 3.8,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2243:0,Adapt,Adapt,0,https://qutip.org,https://github.com/qutip/qutip/pull/2243,1,['Adapt'],['Adapt']
Modifiability,Adapt to download / upload artifacts v4,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2476:0,Adapt,Adapt,0,https://qutip.org,https://github.com/qutip/qutip/pull/2476,2,['Adapt'],['Adapt']
Modifiability,Add `.pre-commit-config.yml`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1742:17,config,config,17,https://qutip.org,https://github.com/qutip/qutip/issues/1742,1,['config'],['config']
Modifiability,Add a more flexible base result class for v5.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907:11,flexible,flexible,11,https://qutip.org,https://github.com/qutip/qutip/pull/1907,1,['flexible'],['flexible']
Modifiability,"Add new ODE integration methods:; `vern7`, `vern9` and `diag`. Verner 's methods are high order Runge-Kutta method with variable step size and dense output. (http://people.math.sfu.ca/~jverner/). Having our own qutip's implementation allow the state to be a qutip data-layer, instead of numpy arrays, which could be useful for gpu or auto differentiation. . `diag` method diagonalize a constant system and solve it analytically, similar to what `essolve` did.; The states are numpy arrays since we don't have vectorized functions for our data layer. Benchmark of these method are included with those of #1643.; Verner method tend to be faster than `adams` method for smaller systems and `diag` is also very fast. For a diff with #1643, see https://github.com/Ericgig/qutip/pull/5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1644:120,variab,variable,120,https://qutip.org,https://github.com/qutip/qutip/pull/1644,1,['variab'],['variable']
Modifiability,Added division by scalar to be more flexible.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1994:36,flexible,flexible,36,https://qutip.org,https://github.com/qutip/qutip/pull/1994,1,['flexible'],['flexible']
Modifiability,Added functions for expanding 1 and 2 qubit gates to larger qubit spaces. Added optional arguments to all gate functions for configuring the gates to operate in a such a N-qubit space.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/103:125,config,configuring,125,https://qutip.org,https://github.com/qutip/qutip/pull/103,1,['config'],['configuring']
Modifiability,"Added new logging and settings support, started refactoring debugs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248:48,refactor,refactoring,48,https://qutip.org,https://github.com/qutip/qutip/pull/248,1,['refactor'],['refactoring']
Modifiability,"Additionally, from looking through your comments it appears that something; definitely went weird with formatting and/or merging. I'll comb back; through and make to fix any of these issues before I request a re-review. On Wed, Jun 28, 2023, 3:43 PM Eric Giguère ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; > ⬇️ Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839:443,variab,variable,443,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612047839,2,['variab'],['variable']
Modifiability,"Ah great! Thanks! So I probably used parameterization with the circuit in a non-recommended way. The source code is correct, there is just something wrong with the test. I'll try coming up with a solution for that test later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880:37,parameteriz,parameterization,37,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007381880,1,['parameteriz'],['parameterization']
Modifiability,"Ah, this is the confluence of two bugs, unfortunately. As an immediate workaround, you should be able to set the environment variable `CI_QUTIP_RELEASE=1` before running `pip` (assuming it propagates the env), and it should build without an error. The two bugs:; 1. building in ""release mode"" isn't the default; on CI to build the wheels we set a release-mode flag, but the sdist can't tell. That's what the environment variable above does. I'll have to think a little about how we'll do versioning. This bug slipped in in #1465, where the primary concern was getting wheels built, and I didn't notice that the sdist wouldn't build in release mode.; 2. `git` isn't meant to be required - in dev mode, it should just get to the string ""nogit"". That error is actually within a `try/except` block, except it only catches `subprocess.SubprocessError`, when it should catch both `subprocess.SubprocessError` and `OSError`. Thanks for the report.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042:125,variab,variable,125,https://qutip.org,https://github.com/qutip/qutip/issues/1514#issuecomment-829931042,2,['variab'],['variable']
Modifiability,"Allow rerunning of dnorm tests, refactor test_metrics.py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490:32,refactor,refactor,32,https://qutip.org,https://github.com/qutip/qutip/pull/1490,1,['refactor'],['refactor']
Modifiability,"Also, instead of adding a third entry to the nested list characterizing the time-dependence, I think the real and imag parts should be in the [1] list entry as a tuple. That way, all of the time-dependence is in a single list item. We may in the future want to add additional items to the list (e.g. on-off times for the time-dependent terms.). I also think that we should get some feedback from @ajgpitch and @cgranade. Chris has some experience with opencl, and he probably is bette suited for feedback than myself. . Another question would be the issue of maintainability. If, for some reason, you are unable to address bug issues or incompatibilities with future QuTiP versions, then can we support this large code submission without having authored it ourselves. For instance, the mcsolve_f90 routine has largely been non-maintained since Arne added it years ago.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-259879928:559,maintainab,maintainability,559,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-259879928,2,['maintainab'],['maintainability']
Modifiability,"Also, we can ""solve"" the testing issue by forcing the environment variable `QUTIP_NUM_PROCESSES=2` before importing QuTiP, I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865:66,variab,variable,66,https://qutip.org,https://github.com/qutip/qutip/issues/1470#issuecomment-808299865,1,['variab'],['variable']
Modifiability,"Also: I don't think CodeClimate actually supports skipping the tests when we call it as an action like this. We'd have to set it up to run on CI runner under our control (e.g. on GitHub Actions), and then configure a method of skipping tests within that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927:205,config,configure,205,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826814927,1,['config'],['configure']
Modifiability,"An additional algorithm has been added. The existing GRAPE algorithm remains the default; The CRAB algorithm was developed at the University of Ulm; The main difference is that it reduces the number of optimisation variables by defining the control pulses by expansions of basis functions, where the variables are the coefficients. Typically a Fourier series is chosen, i.e. the variables are the Fourier coefficients. Therefore it does not need to compute an explicit gradient. By default it uses the Nelder-Mead method for fidelity error minimisation. Further explanation is given in the comments. Significant changes were required to many of the classes in order to support another alg option in a tidy way.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/338:215,variab,variables,215,https://qutip.org,https://github.com/qutip/qutip/pull/338,3,['variab'],['variables']
Modifiability,"As I mentioned in the discussion of #90, I think it would make more sense to add this information in Qobj.superrep rather than allowing Qobj.type to have more values, because for some purposes it is sufficient to know if Qobj is a superoperator or not, and it would be a lot easier and more maintainable to add new types of superoperator represenations if we don't have to make changes in many places in the code (which check if Qobj.type is a superoperator)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/88#issuecomment-37779597:291,maintainab,maintainable,291,https://qutip.org,https://github.com/qutip/qutip/issues/88#issuecomment-37779597,1,['maintainab'],['maintainable']
Modifiability,"As mentioned in the previous post I also played with rtol value, but it didn't help. Concerning your question, yes when the pulse is off, I have a zero Hamiltonian and the system stays in the initial state, which is fine, the weird thing however is that apparently the system stays in the initial state even when the pulse is on. Basically, I get as a result that the system stays in the initial state for all times. Did you try to run the code on your machine? Maybe it's the issue of my packages configuration?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/771#issuecomment-338260622:498,config,configuration,498,https://qutip.org,https://github.com/qutip/qutip/issues/771#issuecomment-338260622,1,['config'],['configuration']
Modifiability,"As reported by Dan Hu on the mailing list, the cython code generated by Codegen fails to compile if args contains complex valued variables. The following minimal example reproduces the problem:. ```; from qutip import *; a = destroy(10); H0 = a.dag() * a; #H = [H0, [a.dag(), 'exp(1j * w * t) '], [a, 'exp(-1j * w * t)']]; args = {'w': 1} # works ; H = [H0, [a.dag(), 'exp(delta * t) '], [a, 'exp(-delta * t)']]; args = {'delta': 1j} # fails; mesolve(H, basis(10, 2), linspace(0, 10, 100), [a], [], args=args); ```. The error from the cython code is:. ```; spmvpy(data1, idx1, ptr1, vec, np.exp(-delta * t), out); ^; ------------------------------------------------------------; rhs9.pyx:20:39: Invalid operand type for '-' (complex_t); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/68:129,variab,variables,129,https://qutip.org,https://github.com/qutip/qutip/issues/68,1,['variab'],['variables']
Modifiability,"As the Cognitive Complexity exceeds the allowed limit, codeclimate is suggesting for code refactoring. Should I proceed accordingly? @nathanshammah @quantshah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/979#issuecomment-487313175:90,refactor,refactoring,90,https://qutip.org,https://github.com/qutip/qutip/pull/979#issuecomment-487313175,1,['refactor'],['refactoring']
Modifiability,"Assuming Simon's point isn't just a complete answer to your question: in the general case, this is an impossible question to answer - it touches on many parts of numerical integration, such as tolerance limits and adaptive step-size methods. When you're dealing with completely arbitrary time-dependence, there's not really any one-size-fits-all approach that'll work (despite how RK45 is often taught as a magic bullet in physics courses). Here, you will likely find that your RK45 results depend strongly on how many intermediate timesteps you use, whereas QuTiP's results will be (marginally) more stable. This is because QuTiP will internally subdivide the timesteps more to achieve internal precision goals, but then only returns the results at the time points you ask for. You can increase the maximum number of allowed subdivisions by increasing the `nsteps` parameter in a `qutip.Options` object, and with the `options` keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136:214,adapt,adaptive,214,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986661136,1,['adapt'],['adaptive']
Modifiability,"At least on my macbook, the 'CFLAGS' environ variable is not set until we do so manually in init. Is this not true on other platforms? If not, then we can easily append.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265069220:45,variab,variable,45,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265069220,1,['variab'],['variable']
Modifiability,BlockRedfield-Coupling operators,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/910:14,Coupling,Coupling,14,https://qutip.org,https://github.com/qutip/qutip/issues/910,1,['Coupling'],['Coupling']
Modifiability,Bug in codegen: complex valued variables,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/68:31,variab,variables,31,https://qutip.org,https://github.com/qutip/qutip/issues/68,1,['variab'],['variables']
Modifiability,Build succeeded. Should we merge this? Or should I extend this to perhaps do more builds on 3.8 and reduce 3.7 to just the basic build? Should 3.6 be dropped or kept?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1170#issuecomment-581046004:51,extend,extend,51,https://qutip.org,https://github.com/qutip/qutip/pull/1170#issuecomment-581046004,1,['extend'],['extend']
Modifiability,"Bumps [numpy](https://github.com/numpy/numpy) from 1.21.0 to 1.22.0.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/numpy/numpy/releases"">numpy's releases</a>.</em></p>; <blockquote>; <h2>v1.22.0</h2>; <h1>NumPy 1.22.0 Release Notes</h1>; <p>NumPy 1.22.0 is a big release featuring the work of 153 contributors; spread over 609 pull requests. There have been many improvements,; highlights are:</p>; <ul>; <li>Annotations of the main namespace are essentially complete. Upstream; is a moving target, so there will likely be further improvements,; but the major work is done. This is probably the most user visible; enhancement in this release.</li>; <li>A preliminary version of the proposed Array-API is provided. This is; a step in creating a standard collection of functions that can be; used across application such as CuPy and JAX.</li>; <li>NumPy now has a DLPack backend. DLPack provides a common interchange; format for array (tensor) data.</li>; <li>New methods for <code>quantile</code>, <code>percentile</code>, and related functions. The; new methods provide a complete set of the methods commonly found in; the literature.</li>; <li>A new configurable allocator for use by downstream projects.</li>; </ul>; <p>These are in addition to the ongoing work to provide SIMD support for; commonly used functions, improvements to F2PY, and better documentation.</p>; <p>The Python versions supported in this release are 3.8-3.10, Python 3.7; has been dropped. Note that 32 bit wheels are only provided for Python; 3.8 and 3.9 on Windows, all other wheels are 64 bits on account of; Ubuntu, Fedora, and other Linux distributions dropping 32 bit support.; All 64 bit wheels are also linked with 64 bit integer OpenBLAS, which should fix; the occasional problems encountered by folks using truly huge arrays.</p>; <h2>Expired deprecations</h2>; <h3>Deprecated numeric style dtype strings have been removed</h3>; <p>Using the strings <code>&quot;Bytes0&",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:662,enhance,enhancement,662,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['enhance'],['enhancement']
Modifiability,"By (3), I meant removing the csr specialisation from the dispatched function and call the function directly when not all values are desired. When `Qobj.eigenstates` is called, the sparse operation being not available, it would defer to the dense code, no warning nor error. ; We can't fully trust `eigs_csr` as it is, so I would like to make it fully working (1) or remove it from the dispatch (3). Yes (2) can be seen as separate enhancement. For me (5) was purely documentation, a warning is fine, but when `sparse` is specified, it would use `eigh_csr` and too bad if wrong results are obtained... (3) would also mean removing the; ```; if isinstance(L.data, _data.CSR) and not sparse:; L = L.to(_data.Dense); evals, evecs = _data.eigs(L.data); ```; since they are no longer used (`spectrum.py`, `floquet.py`, `qobj.py`) and reviewing the tests cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466:431,enhance,enhancement,431,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472768466,1,['enhance'],['enhancement']
Modifiability,"Change `bloch_redfield_tensor` to be an equivalent to the `liouvillian` function.; As the former, it is now placed in core and support the both constant and time-dependant systems. (Removing the need for `br_codegen.py`). Previously, `bloch_redfield_tensor` returned the tensor in the frame where the Hamiltonian was diagonalized, now it offer the option between returning the tensor in that frame of the the lab frame. The function `brterm` as been added as the equivalent to `lindblad_dissipator`, it compute the contribution of one `a_op` of a bloch Redfielf tensor. The last user facing addition is `SpectraCoefficient`, it transform a coefficient of `t` to one of `w`. The coupling with the environment include a frequency response function which, in `brmesolve`, could be a function, string or `Cubic_Spline`, thus a `Coefficient`, but with a `w` input. `SpectraCoefficient` is to have interpolation based coefficient take the `w` input. . `QobjEvo` created by `brterm` use a custom element: `_BlochRedfieldElement` to allow faster matmul with a state. Since the operator in computed in a basis and the state is in another, having `matmul` change the state basis is usually faster than changing the operator basis. Each `_BlochRedfieldElement` of a `QobjEvo` share a `_EigenBasisTransform`, the object that does the Hamiltonian diagonalization at each call. It would be nice to support to computation of the tensor using `Data`. but it would require `ndarray.__mul__` equivalent to the dispatched function.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1651:678,coupling,coupling,678,https://qutip.org,https://github.com/qutip/qutip/pull/1651,1,['coupling'],['coupling']
Modifiability,Changed __mul__ behviour to be more flexible and consistent.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620:36,flexible,flexible,36,https://qutip.org,https://github.com/qutip/qutip/pull/1620,1,['flexible'],['flexible']
Modifiability,Checking if this got already solved by @Ericgig refactoring of stochastic solvers and `sesolve`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/867#issuecomment-532607531:48,refactor,refactoring,48,https://qutip.org,https://github.com/qutip/qutip/issues/867#issuecomment-532607531,1,['refactor'],['refactoring']
Modifiability,"Clarification of some variable naming to attempt to link with literature and also be usable without having to read the papers.; Switch to a class module. In line with recent work from @arnelg ; Moved to nonmarkov folder, as this is a non-Markovian approx method. Old file remains with deprecated function, just in case anyone was using it. This now links to the new instance method.; Many efficiency improvements (now up to 10x faster). Test added. . Will provide a notebook example soon. Then some documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/455:22,variab,variable,22,https://qutip.org,https://github.com/qutip/qutip/pull/455,1,['variab'],['variable']
Modifiability,"Cleanup API of generic solver related support classes and functions (Odeoptions -> Options, Odedata -> SolverResult, odeconfig.odeconfig -> solver.config)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/168:147,config,config,147,https://qutip.org,https://github.com/qutip/qutip/pull/168,1,['config'],['config']
Modifiability,"Commit #bea29a1 breaks some tests since it refactors some attribute names to follow PEP8 snake_case standard (i.e., qubit.qit.circuit.N ->qubit.qit.circuit.n_qubits )",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970:43,refactor,refactors,43,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603441970,1,['refactor'],['refactors']
Modifiability,"Congratulations, you have rediscovered the quantum Zeno effect :-) There is nothing wrong with qutip here, I think. You don't write what your system is exactly, but I assume something like $H=\sigma_x$ and jump operator $\sigma_-$. The effect of the environment can be thought of as measuring the system continuously, with a strength proportional to the coupling rate, which you call jump rate. Jump rate is indeed a slightly misleading (but commonly used) name. Its meaning is the reciprocal of the expected time until a jump, if the system is in the excited state. However, due to the continuous measurement and the quantum Zeno effect, the system rarely makes it to the excited state in the first place. Mathematically, where it comes from is that the deterministic trajectory evolution (between the jumps) is given not by the system Hamiltonian, but by an effective (non hermitian) Hamiltonian. In the limit of large coupling rates, this effective Hamiltonian becomes approximately diagonal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920:354,coupling,coupling,354,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2398136920,2,['coupling'],['coupling']
Modifiability,Correcting EnhancedTextProgressBar broken init,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/334:11,Enhance,EnhancedTextProgressBar,11,https://qutip.org,https://github.com/qutip/qutip/pull/334,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"Could you make 2 changes:; `verbosity=1`, it looks a lot cleaner.; The tests that ""XFAIL"" use `yield` and are skipped as it is not supported by pytest. Could you rewrite them without it. (4 in `test_qobj`, not sure if there are more.) I will be looking at the failing tests in more detail next week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549:162,rewrite,rewrite,162,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-570710549,1,['rewrite'],['rewrite']
Modifiability,"Curious cross-reference from [mdanalysis](https://github.com/MDAnalysis/mdanalysis). Their tests trigger the same error (likely again because of pytest-xvfb),; ```; XIO: fatal IO error 0 (Success) on X server "":1029""; ```; Their error is not so simple to clear, since they use the object oriented matplotlib API (e.g. using AxesSubplot `matplotlib.axes._subplots.AxesSubplot`) rather than matplotlib.pyplot. So they don't have access to `plt.close()` and `axes.cla()` doesn't prevent the error, probably for the same reason that `plt.clf()` didn't work for qutip. One point they have which is worth noting: they recommend using the environment variable `MPLBACKEND=agg` for headless CI testing. And sure enough the XIO error does not occur with mdanalysis if `MPLBACKEND=agg` is set. For qutip the `plt.close(fig)` patch is still the best (more robust) solution though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847:644,variab,variable,644,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912159847,2,['variab'],['variable']
Modifiability,"Currently QuTiP solvers are pure batch jobs. One calls a function, e.g. `mesolve`, which then runs until the state has been propagated to all requested time steps and then the function returns the result. There are a variety of use cases where having access to results as they are calculated can be useful:. * Implementing a progress bar; * Limiting how long a solver runs for; * Stopping a solver early if a steady state or other desired or undesired state is detected.; * Implementing adaptive solvers where parameters are changed depending on the current state. We're currently refactoring the QuTiP solvers for QuTiP v5, so perhaps now is a good time to consider whether this feature will see enough use to be worth the effort. Implementation options:. * The solver could call a `callback function` each time a new result becomes available.; * The solver could `yield` each time a new result becomes available.; * The solver could do something asynchronous (I think this is not worth supporting natively in QuTiP -- either of the others would allow something asynchronous to be implemented by a QuTiP users themselves if they wanted). Probably these are not mutually exclusive. To make porting easier, it should still be possible to call some solve function without a callback or yielding as one can do now. Related issues:. * qucontrol/krotov#93",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571:487,adapt,adaptive,487,https://qutip.org,https://github.com/qutip/qutip/issues/1571,2,"['adapt', 'refactor']","['adaptive', 'refactoring']"
Modifiability,"Currently qutip.control.optimize_pulse supports four formats for `oper_dtype` (i.e. its internal representation of propagators and intermediate states). The four formats and their statuses before this PR are described below:. - `numpy.ndarray`: Working.; - `Qobj`: Working, except that some dimensions were lost in Qobj construction and using sparse eigenvector decomposition was broken.; - `scipy.sparse.csr_matrix`: Broken. There was an undefined variable referenced in the code to construct the propagators. Many code paths had no explicit support for them and assumed they worked the same as ndarrays in cases where they didn't.; - `anything matrix-like`: Broken for the same reasons as `csr_matrix` above. This PR removes support for last two oper_dtypes and fixes the `Qobj` one, leaving the situation as follows:. - `numpy.ndarray`: Working.; - `Qobj`: Working.; - `scipy.sparse.csr_matrix`: No longer supported.; - `anything matrix-like`: No longer supported. Note that `Qobj` uses sparse matrices internally, so CSR matrix support is still available via the `Qobj` oper_dtype. In QuTiP v5, only `Qobj` support will be retained since `Qobj` will support both sparse and dense representations via the data layer. **Related issues or PRs**; * Fixes #1617. **Changelog**; Fix qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems).; Remove qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1621:449,variab,variable,449,https://qutip.org,https://github.com/qutip/qutip/pull/1621,1,['variab'],['variable']
Modifiability,"Currently the `qutip.measurement.measure_observable` function always uses rank-1 projectors to determine the final state after the measurement. But for obervables with degenerate eigenvalues you might just want to project the state onto a higher-dimensional eigenspace. Eg. measuring the $Z \otimes Z$ operator on the Bell state $\ket{\psi} = 1/\sqrt{2} (\ket{00} + \ket{11})$ using qutip will return either $\ket{00}$ or $\ket{11}$ despite the state being an eigenstate of the observable.; ```; import qutip as qt; import qutip.measurement as meas; import numpy as np. #Prepare Bell state; state = qt.tensor([qt.basis(2, 0)]*2) + qt.tensor([qt.basis(2, 1)]*2); state = state.unit(). # ZZ operator; op = qt.tensor([qt.sigmaz()]*2). result_eigenvalue, final_state = meas.measure(state, op). #Check that the measurement didn't change the state (because it is an eigenstate of the measurement operator); assert np.isclose(qt.fidelity(final_state, state), 1) #fails; ```. I am aware that I can get my intended behaviour by explicity passing the list of projection operators to the `measure` function, but the following enhancement would be very useful:; An option `respect_degenerate_eigenvalues=False` in `qutip.measurement.measure_observable` that groups the eigenstate projectors based on eigenvalue degeneracy. In the above example the rank-2 projectors |00><00| + |11><11| and |01><01| + |10><10| would be used and the Bell state would be preseved during a ZZ measurement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1800:1115,enhance,enhancement,1115,https://qutip.org,https://github.com/qutip/qutip/issues/1800,1,['enhance'],['enhancement']
Modifiability,"Currently, the`identity` and `qeye` functions each take lists of dims as an alternative to an integer. For instance, `qeye([2, 3])` is equivalent to `tensor(qeye(2), qeye(3))`. While convenient, this is inconsistent with `zero_oper`, `basis`, `maximally_mixed_dm`, `projection` and `zero_ket`. Would it be worth extending the shorthand used by `identity` to these functions?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/363:312,extend,extending,312,https://qutip.org,https://github.com/qutip/qutip/issues/363,1,['extend'],['extending']
Modifiability,"Dear Everyone,. Thanks for the great job with Qutip package. I am amazed by the package and how various models and techniques are implemented on it. . I have been using the time-dependent bloch-redfield solver lately and the runtime is superb when I convert all the Hamiltonian and the collapse operators to string format, and use the solver option reuse_rhs=True. I really wish I could run sweeps over the bath parameters while still retaining the original Hamiltonian without having to recompile it. It would be nice if you could extend the scope of args so that bath parameters could also be passed as arguments of the call. . The second issue is that the cython file that the brmesolver creates is missing the import scypi.spe, that is the special functions from Scipy. One needs to add the following lines to the BR_codegen:. import scipy.special as spe; cimport scipy.special as spe",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1366:532,extend,extend,532,https://qutip.org,https://github.com/qutip/qutip/issues/1366,1,['extend'],['extend']
Modifiability,"Dear qutip admin,. If I wrote the Hamiltonian in terms of analytic function (Hanalytic and Hanayticevo as shown below), I got different answers from using the discretized Hamiltonian obtained by providing the list of Hamiltonian values at discrete times (the variable H) as used previously. May I know how to rectify this problem? Below is the code. ```; import qutip; import numpy as np. fast_ts = np.linspace(0, 1, 1001); omegalist = 2.91e2*fast_ts ; fast_xs = 2.9e3*np.pi * np.cos(2*np.pi * omegalist * fast_ts); bad_interpolation_xs = np.array([fast_xs[0], fast_xs[-1]]); Hanalytic = [[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']] # New line; Hanalyticevo = qutip.QobjEvo([[qutip.sigmax(),'2.9e3*pi*cos(2*pi*2.91e2*t**2)']],tlist=fast_ts) # New line; H = qutip.QobjEvo([[qutip.sigmax(), fast_xs]], tlist=fast_ts); H_bad = [[qutip.sigmax(), bad_interpolation_xs]]; rho = qutip.basis(2, 0).proj(); times = np.array([0., 1]); e_ops = [qutip.sigmay()]; options = qutip.Options(nsteps=10_000_000, atol=1e-14, rtol=1e-12). two_times = qutip.mesolve(H, rho, times, e_ops=e_ops, options=options); many_times = qutip.mesolve(H, rho, fast_ts, e_ops=e_ops, options=options); bad_times = qutip.mesolve(H_bad, rho, times, e_ops=e_ops, options=options); analytics = qutip.mesolve(Hanalytic, rho, fast_ts, e_ops=e_ops, options=options) # New line; analyticsevo = qutip.mesolve(Hanalyticevo, rho, times, e_ops=e_ops, options=options) # New line; assert len(two_times.expect[0]) == 2; assert len(many_times.expect[0]) == 1001. print(two_times.expect[0][-1]) # -0.59736575; print(many_times.expect[0][-1]) # -0.59736575; print(bad_times.expect[0][-1]) # -4.5466086e-08; print(analytics.expect[0][-1]) # 0.00022501347976357222; print(analyticsevo.expect[0][-1]) # 0.0002250044242251665. ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720:259,variab,variable,259,https://qutip.org,https://github.com/qutip/qutip/issues/1472#issuecomment-819524720,1,['variab'],['variable']
Modifiability,"Different platforms have some subtle differences in how multiprocessing works: On linux, processes ""fork"". My basic understanding is that sub-processes are created as copies of the parent process, thus inheriting their entire state (global variables/functions). Windows, and [macOS with Python >= 3.8](https://twitter.com/raymondh/status/1180209729609420800) uses ""spawn"". There, I believe subprocesses start from blank slate, and relevant global state is injected via IPC. Sadly, limitations of the pickle protocol can cause ""spawn""-based multiprocessing to have problems. Jupyter notebooks are affected by this: you cannot use multiprocessing-map using functions defined within the notebook. . Within qutip, this definitely affects the `parallel_map` function: It currently will cause freezes on Windows (See https://qucontrol.github.io/krotov/v1.0.0/notebooks/08_example_ensemble.html). With Python 3.8, macOS is also affected by this. See https://github.com/qutip/qutip-notebooks/issues/100. One possible workaround is to use a third-party replacement for multiprocessing. An work-in-progress implementation of this is in https://github.com/qutip/qutip/pull/1092, using [loky](https://loky.readthedocs.io). In #1197, we also identified a freeze in `mcsolve` when running tests on macOS/Python 3.8. This is suspected to be an issue with spawn-based multiprocessing, although we haven't been able to determine this with complete confidence. If the freeze is indeed caused by spawn-multiprocessing, the problem *should* also show up on Windows. Is anyone running Windows able to reproduce this?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1202:202,inherit,inheriting,202,https://qutip.org,https://github.com/qutip/qutip/issues/1202,2,"['inherit', 'variab']","['inheriting', 'variables']"
Modifiability,"Directly in VS code. My launch.json looks like; ```json; 	""version"": ""0.2.0"",; 	""configurations"": [; 		{; 			""name"": ""Python: Current File"",; 			""type"": ""python"",; 			""request"": ""launch"",; 			""program"": ""${file}"",; 			""console"": ""integratedTerminal""; 		}; 	]; }; ```; When using the plt.show() command, the second window only appears after a b.render() command, but thats also necessary for any vectors I want to draw to appear.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011:81,config,configurations,81,https://qutip.org,https://github.com/qutip/qutip/issues/1616#issuecomment-883458011,1,['config'],['configurations']
Modifiability,Docstring for Variable Returns!,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1305:14,Variab,Variable,14,https://qutip.org,https://github.com/qutip/qutip/issues/1305,1,['Variab'],['Variable']
Modifiability,"Document Continuous Variables, Countstat, and Distributions Modules",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1522:20,Variab,Variables,20,https://qutip.org,https://github.com/qutip/qutip/issues/1522,1,['Variab'],['Variables']
Modifiability,"Don't worry about the tests - progress on merging the refactor is slow (though if you want to review #1249 it'll help!). Besides, these tests would probably go in `test_qubitcircuit.py` which I haven't touched yet. Add the tests here, and I'll rebase #1251 onto `master` after this is merged if it's necessary to add them to the new style. Hopefully this will be the last time!. About the merge oddness: it comes about because this PR is built on a false version of the upstream (our) `master`. As long as you apply this merge as a squash, it will actually be ok and the history will be clean. Don't apply the merge as a history-preserving merge (i.e. a regular one), because it will make the commit history confusing (and defeats the purpose of having merged #1242 as a squash). ## Unnecessary detail. The exact reason is that this commit is build on top of #1242, but this is inconsistent with the upstream `master`; because #1242 was merged as a squash, `qutip/master` and `Canoming/master` diverged at fd13ae0 (i.e. before #1242), so `git` sees commits ea1c129 to b4f75cf as ""new"" (the first three commits of this PR). However, when those commits are taken together, they make the same changes as commit 4102b99 (the one which merged #1242) in `qutip/master`. The Github ""Files changed"" dialog is a pretty-printed version of the `git` command `git diff qutip/master...Canoming/master`, which means ""show all changes on either branch since `qutip/master` and `Canoming/master` diverged"". Because they diverged before #1242 was merged, it includes those changes. The merge completes without conflict, however, because `git` is clever and recognises that the changes introduced in the two branches `qutip/master` and `Canoming/master` are identical, even though the commits are different. As a consequence, however, merging this PR without squashing it would cause commits ea1c129 to b4f75cf to suddenly appear in our commit history, which we don't want. ### If Canoming wanted to fix this (not neces",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269:54,refactor,refactor,54,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629701269,1,['refactor'],['refactor']
Modifiability,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/598:55,config,config,55,https://qutip.org,https://github.com/qutip/qutip/issues/598,2,['config'],['config']
Modifiability,"E; lapack_info:; libraries = ['lapack', 'lapack']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; language = f77; lapack_opt_info:; libraries = ['lapack', 'lapack', 'blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; language = c; define_macros = [('NO_ATLAS_INFO', 1), ('HAVE_CBLAS', None)]; include_dirs = ['/usr/local/include', '/usr/include']; Supported SIMD extensions in this NumPy install:; baseline = SSE,SSE2,SSE3; found = SSSE3,SSE41,POPCNT,SSE42,AVX,F16C,FMA3,AVX2; not found = AVX512F,AVX512CD,AVX512_SKX,AVX512_CLX,AVX512_CNL,AVX512_ICL; ```; So numpy itself marks openblas_info as NOT AVAILABLE (evidently using a build-time test, not runtime, which arguably is a pity). It seems to me that `hasattr` in qutip's BLAS support tests is returning false positives and false negatives. It indicates if the attribute was defined, even though it might be empty. Would it be better to replace; ```; hasattr(config,'openblas_info'); ```; in qutip/utilities.py with; ```; hasattr(config,'openblas_info') and config.openblas_info; ```; likewise for blas_mkl_info (not mkl_info) ?. This would be similar to numpy's own usage in `np.show_config()` (i.e. `np.__config__.py.show()`), which [uses](https://github.com/numpy/numpy/blob/3b7672ebd16982b661b8fbcabac80158662a8784/numpy/__config__.py.in#L116) `if not info_dict` to print ""NOT AVAILABLE"". ### Code to Reproduce the Bug. ```shell; import numpy; numpy.show_config(). import qutip; qutip.about(); ```. ### Code Output. ```shell; $ python3; Python 3.10.9 (main, Dec 7 2022, 13:47:07) [GCC 12.2.0] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import numpy; >>> numpy.show_config(); ...; blas_mkl_info:; NOT AVAILABLE; ...; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; ...; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; define_macros = [('HAVE_CBLAS', None)]; blas_opt",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:3784,config,config,3784,https://qutip.org,https://github.com/qutip/qutip/issues/2053,2,['config'],['config']
Modifiability,ENH: Intel MKL Sparse Enhancements,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459:22,Enhance,Enhancements,22,https://qutip.org,https://github.com/qutip/qutip/pull/459,1,['Enhance'],['Enhancements']
Modifiability,"ENH: qutip-doc refactoring, changelog, PR template",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1172:15,refactor,refactoring,15,https://qutip.org,https://github.com/qutip/qutip/issues/1172,1,['refactor'],['refactoring']
Modifiability,"Enhance: Division by zero caught in stats.calculate; New: test out files directory can now be specified using optimconfig.test_out_subdir; Enhance: makedirs used to create test_out_dir, so nested directories can be used; Enhance: missing config sections now caught and reported as warnings; New: pulsegen parameters can now be read from config file; Enhance: iter, fid_err, fid_err_grad test_out_files now appended to rather than held open",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/301:0,Enhance,Enhance,0,https://qutip.org,https://github.com/qutip/qutip/pull/301,6,"['Enhance', 'config']","['Enhance', 'config']"
Modifiability,EnhancedTextProgressBar not coherent with docstring of BaseProgressBar,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2148:0,Enhance,EnhancedTextProgressBar,0,https://qutip.org,https://github.com/qutip/qutip/issues/2148,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,EnhancedTextProgressBar occasionally printing extra statuses,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1229:0,Enhance,EnhancedTextProgressBar,0,https://qutip.org,https://github.com/qutip/qutip/issues/1229,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,Enhancement nonsquare superopreps,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098:0,Enhance,Enhancement,0,https://qutip.org,https://github.com/qutip/qutip/pull/1098,1,['Enhance'],['Enhancement']
Modifiability,"Every routine that uses multiple processes has a kwarg to change the number and if this is not set then it falls back on qutip.settings.num_cpus which is set in **init**.py. On May 2, 2014, at 1:04 PM, Robert Johansson notifications@github.com wrote:. > You can use it to select number of processes to use, right? I think it is useful if you don't want to use all processors for a calculation, although I usually use the .qutiprc configuration file for this rather than environment variables. I guess it is not really necessary but could be useful I guess.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985338:430,config,configuration,430,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985338,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"Everyone: (@ajgpitch, @BoxiLi, @Ericgig, @nathanshammah). Apologies for bumping this again. It would be good to get a strategy in place to handle a review for this. Would it be easier if I close this PR and then make a whole series of new PRs with (say) 5 files in at a time?. I'm particularly keen to get the `test_gates.py` refactor merged in, because there's seemingly quite a lot of movement in the `qip` module. If I do split the PR, then I'll rebase onto `master` so that the new tests added in #1224 are included without a merge resolution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252:326,refactor,refactor,326,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-609702252,1,['refactor'],['refactor']
Modifiability,Evolver class and utilities,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:0,Evolve,Evolver,0,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['Evolve'],['Evolver']
Modifiability,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:1798,flexible,flexible,1798,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732,2,['flexible'],['flexible']
Modifiability,Extend about,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/224:0,Extend,Extend,0,https://qutip.org,https://github.com/qutip/qutip/pull/224,1,['Extend'],['Extend']
Modifiability,Extend visualization,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/127:0,Extend,Extend,0,https://qutip.org,https://github.com/qutip/qutip/pull/127,1,['Extend'],['Extend']
Modifiability,"First of all I'm glad you could get it to run under OSX. Which OpenCL environment are you using?; - Is the failure of `test_mcsolve_cl_time_dep_h` reproducible?; - You can probably ignore the compiler warning. I assume it is related to the pragma statement. Some OpenCL implementations refuse to work without it, others give you a warning that it is unnecessary. Maybe we can omit the statement based on the platform version and hide some warning, but that would require more testing (on different platforms). At the moment there is a lot of debug information to ease testing.; - The AttributeError you get is something I have not encountered yet. If you do consider merging this branch, it is a good idea to get more people involved in testing. The code has not been reviewed and probably contains some bugs. The questions you raised concerning the maintainability are all valid. On top of that setting up OpenCL is somewhat troublesome, which makes `mcsolve_cl` a kind of experimental feature. Ultimately it is up to the maintainers of qutip to decide whether such a feature should be included. The advantage `mcsolve_cl` has over `mcsolve_f90` is that it supports some time-dependence and introduces no build dependencies. If, for some reason `mcsolve_cl` does not work, the user can always fall back to `mcsolve`. By the way, is it wise to rebase this branch all the time or only when necessary?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-260134503:850,maintainab,maintainability,850,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-260134503,1,['maintainab'],['maintainability']
Modifiability,"Firstly, just to underline @jakelishman comment. We *cannot* change the public interface unless we make a new major release. I also don't like the `.N` property, but it snuck in before my time. We could look to change this in v.5, but not before. . It seems this PR does contain some enhancements that are not part of #1209. However, @mlaguna10 did seem to make quite clear that they were already working on the issue. I believe #1209 is ready to merge, but we'll wait for @BoxiLi to confirm. . So what I suggest is that we merge #1209. @MartinSandeCosta can then merge the master into this PR and see what is left that adds to enhancement request outlined #1208. Assuming (with good reason) that there are valuable additions, then we will merge this too. Thanks everyone for contributing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-605881345:284,enhance,enhancements,284,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-605881345,4,['enhance'],"['enhancement', 'enhancements']"
Modifiability,"Following the workaround in [this stackoverflow answer](https://stackoverflow.com/a/67483317), added `autodoc_type_aliases` to the config of sphinx and added `from __future__ import annotations` where necessary. Makes it so that the docs say; ```; H: QobjEvoLike; ```; instead of; ```; H: Qobj | QobjEvo | ~qutip.typing.QEvoProtocol | tuple['Qobj', typing.Union[ForwardRef('Coefficient'), str, qutip.typing.CoeffProtocol, numpy.ndarray, scipy.interpolate._interpolate.PPoly, scipy.interpolate._bsplines.BSpline, typing.Any]] | ~typing.Sequence[~qutip.typing.QEvoProtocol | Qobj | tuple['Qobj', typing.Union[ForwardRef('Coefficient'), str, qutip.typing.CoeffProtocol, numpy.ndarray, scipy.interpolate._interpolate.PPoly, scipy.interpolate._bsplines.BSpline, typing.Any]]]; ```. (Also cleaned up imports in files I touched, and fixed a typo in Qobj type annotations.)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2436:131,config,config,131,https://qutip.org,https://github.com/qutip/qutip/pull/2436,1,['config'],['config']
Modifiability,"For 3 I meant to point that `c_ops` can be complex time-dependent systems by using 3 layers of list in its definition. We only test for list in this situation, but having the last layer as a tuple should work in `mesolve`. Tuple are not tested for nested time dependent system anywhere. If they give a different result, it's probably the wrong one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360:85,layers,layers,85,https://qutip.org,https://github.com/qutip/qutip/issues/2065#issuecomment-1410542360,1,['layers'],['layers']
Modifiability,"For Windows 10, I solved this issue by adding path to the folder that contains gswin32c.exe (e.g. C:\texlive\2019\tlpkg\tlgs\bin) to system variables. [See https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/]",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/702#issuecomment-573384624:140,variab,variables,140,https://qutip.org,https://github.com/qutip/qutip/issues/702#issuecomment-573384624,1,['variab'],['variables']
Modifiability,"For me there are three main points here:; 1. The `site.cfg` should be a global numpy configuration (or local qutip configuration); 2. I see no reason for using the `DeprecationWarning` if you change the code to read the info from the `site.cfg`, perhaps there is something I am missing? If I do `sed -i -e '/extra_/d' qutip/fortran/setup.py` it compiles fine and seems to be using the `extra_link_args`.; 3. To dynamically control the `mcf90` module you could equally do this in the `site.cfg`:. ```; [qutip]; mcf90 = False / True; ```. and just default it to `False`. I have no comments on whether this should be preferred or not, or whether you _will_ split it up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-154987547:85,config,configuration,85,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-154987547,2,['config'],['configuration']
Modifiability,"For people finding this later, this is not just because of the macOS version, but also because of your _Xcode_ version. As Xcode increases, Apple are making it harder and harder to have a sensible dev environment for command-line tools when all you care about is building for your local machine. You may find that a system include like `_ctermid.h` is missing in the future - it won't always be `limits.h` - especially with Xcode 11+. Since M1 Macs (I assume - I don't have one) ship entirely with Xcode 12, they will likely need this too. I believe even `xcode-select --install` will not always reinstate `/usr/include` any more, and the `*_headers_*.pkg` seems to not work with Xcode 11. `/usr/include` is gone, but Xcode has the correct set of includes for all platforms, so you can set your compiler's `sysroot` to the relevant SDK directory to get correct lookups. By default, the one you want will be at; ```; /Applications/Xcode.app/Contents/Developer/Platforms/MaxOSX.platform/Developer/SDKs/MacOSX.sdk; ```; The system `clang` will likely find this correctly, but if not or if you're using a separate compiler, for either `gcc` or `clang` you should pass the flag; ```bash; gcc -isysroot '/path/to/sdk' ...; ```; to find the correct includes. To automate this procedure, you may want to add that flag to your `CFLAGS` and `CPPFLAGS` environment variables. For example, you could put in your `.bashrc`; ```bash; export CFLAGS=""-isysroot '/path/to/sdk' ${CFLAGS}""; ```; to have it automatically added to all C compilations (after that file has been sourced).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-760084316:1354,variab,variables,1354,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-760084316,1,['variab'],['variables']
Modifiability,"General comment about plotting on the Bloch sphere:. QuTiP currently supports drawing either ""points"" or ""vectors"" (i.e. arrows). Both are specified as `(x, y, z)` coordinates and these are *not* required to lie on the surface of the sphere. Lying outside the sphere is perhaps a bit odd, but lying inside the sphere is a common occurrence -- e.g. when plotting sub-components of a density matrix. There is a method `add_states` that converts states into `(x, y, z)` coordinates and adds them as either points or vectors as requested. I would thus recommend being able to specify lines and arcs using either `(x, y, z)` coordinates or states and not introducing spherical coordinates right now. I'm not against duplicating some of the functionality of `add_points(..., meth=""l"")` in the new functions we add here. For one, the `meth=""l""` is not particular intuitive when looking for a function to draw lines, and, secondly, it doesn't provide particularly flexible styling. My vote is to keep the old method interfaces fairly consistent with how they are now so as not to disrupt existing uses (adding some new optional parameters or tweaking things to look better is fine), and to add a couple of new methods. Let's try not to make the internals of `Bloch` more messy though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552:956,flexible,flexible,956,https://qutip.org,https://github.com/qutip/qutip/pull/1685#issuecomment-934332552,2,['flexible'],['flexible']
Modifiability,"Good point, sorry to cause that problem, then. Is it worth keeping it at a debug or info severity instead, then? Also, should the warning after a failed import of configobj also be removed or downgraded (https://github.com/qutip/qutip/blob/4fc89ce6804324f20e84039d961ac765105a7a2e/qutip/settings.py#L98)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/465#issuecomment-210294305:163,config,configobj,163,https://qutip.org,https://github.com/qutip/qutip/pull/465#issuecomment-210294305,1,['config'],['configobj']
Modifiability,"Good point. Lets do that for the next version. On 05/01/2014 04:10 PM, Robert Johansson wrote:. > Two suggestions:; > ; > 1.; > ; > ```; > QuTiP uses an environment variable |NUM_THREADS|. We should; > probably name-space this variable, calling it |QUTIP_NUM_THREADS|; > (consistent with how other packages name their variables, like; > |MKL_NUM_THREADS| and |OPENBLAS_NUM_THREADS|. The upcoming 3.0; > release would be a good time to make this change.; > ```; > ; > 2.; > ; > ```; > Considering that QuTiP does not use thread but processes, it would; > be even better to call the variable |QUTIP_NUM_PROCESSES|.; > ```; > ; > —; > Reply to this email directly or view it on GitHub ; > https://github.com/qutip/qutip/issues/119.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41887009:165,variab,variable,165,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41887009,4,['variab'],"['variable', 'variables']"
Modifiability,"Got it to work as expected after a few changes:. * First, it seems there is an error in [Gri98] and `A` should be transposed. This can be seen as equation 251 from [Gri98] differs from equation 52 from [PRA44]. There might be another issue with a `k` factor instead of a `-k` factor, but it should not matter as long as thermal population is 0. For some unknown reason, using `A` or its transpose does not change anything on qubits systems.; * Second, `c_ops` should not be dissipation operators but operators coupling to the environment bath. Then, one should not use `a` but `a + a.dag()`. This seems to be different than the standard `mesolve` and might deserve an emphasis in the doc. [Gri98] | Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). doi:10.1016/S0370-1573(98)00022-2.; [PRA44] | R. Blümel, A. Buchleitner, R. Graham, L. Sirko, U. Smilansky, H. Walther, Phys. Rev. A 44 (1991) 4521.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/772#issuecomment-339472230:510,coupling,coupling,510,https://qutip.org,https://github.com/qutip/qutip/issues/772#issuecomment-339472230,1,['coupling'],['coupling']
Modifiability,Handle change in configuration attributes for numpy 1.22.0,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1752:17,config,configuration,17,https://qutip.org,https://github.com/qutip/qutip/pull/1752,2,['config'],['configuration']
Modifiability,"Having `Qobj * matrix` work at the moment is to make it easier to transition to the 5.x branch when it releases, since it's the current behaviour of 4.x. Once we've had a bit of time for people to make the transition, I think we should be completely removing this ""functionality"". To me, matrices aren't quantum objects; if you're working with a Numpy array, you should expect Numpy semantics to occur, i.e. Numpy should see `Qobj` as a scalar type, and broadcast against it like that. It's an implementation detail that the backing data is a matrix; the linear algebra theory certainly doesn't demand it. Raising-and-catching is slower than just having the `mul` functions return `NotImplemented`. The only implementations that would need a wrapper are our Cython-based ones, and they can both be wrapped in something like; ```python; class only_allow_numeric:; def __init__(self, inner):; self.inner = inner; def __call__(self, other):; if not isinstance(other, numbers.Number):; return NotImplemented; return self.inner(complex(other)); ; mul.add_specialisations([; (CSR, CSR, only_allow_numeric(mul_csr)),; (Dense, Dense, only_allow_numeric(mul_dense)),; ]); ```. I'm generally fine with `Variable * Qobj` only working sometimes; I think the general intent is that you'd configure the dispatchers to only allow TensorFlow data output, so it would always work for you.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027:1193,Variab,Variable,1193,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880850027,2,"['Variab', 'config']","['Variable', 'configure']"
Modifiability,"Having looked at the description of the function, that is it specifically refers to density matrices, then I would say that it does what it promises to do, and that the changes mean that it does it much better. So (now) personally I don't think we need to adapt for a pure vs pure state in this method.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134933420:256,adapt,adapt,256,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134933420,1,['adapt'],['adapt']
Modifiability,"Hello @hodgestar, we missed your last comment, but Nathan just notified us. We will get it all sorted out by wednesday at most. I leave a todolist to keep track of everything that @Ericgig mentioned. To-do. * [x] Include some tests like test_sesolve.py --> **Included tests with random Hamiltonian, ising transverse field and SHO. Both for states and expectation values. Lacking a testing example for callable e_ops**. * [x] Why <code>krylov_dim=30?</code> ? --> **There was a subtle physical reason, but we conclude its better to leave it as a free input without a predefined variable.**. * [x] <code>tolerance</code>, <code>store_states</code> and <code>store_final_state</code> --> **Changed as an Options qutip class, now tolerance is <code>Options.atol</code> property**. * [x] <code>e_ops</code> should also take a callable or list of mixed function and <code>Qobj</code> --> **Added support**. * [x] Remove support for <code>np.ndarray</code> --> **Removed for qutip cleanliness**. * [x] Assertion errors to specififc errors --> **Modified.**. * [x] Check that psi0 is a ket --> **Added**. * [x] If both <code>store_states</code> and <code>store_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.spar",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:577,variab,variable,577,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,2,['variab'],['variable']
Modifiability,"Hello! As @jakelishman described, you can help debug this issue by trying:. ```python; from qutip.cy.openmp.parfuncs import spmv_csr_openmp; ```. and reading the exception produced. I suspect that the `qutip.cy.openmp.*` packages will simply not have been compiled -- they're only built by QuTiP when ""--with-openmp"" is passed to `setup.py` and I think `conda install ... qutip` will not do that even when OpenMP is already installed. To correct this you will need to install QuTiP from source and pass `--with-openmp` yourself as described in https://qutip.org/docs/latest/installation.html?highlight=openmp#direct-setuptools-source-builds. We probably could make ""openmpi"" and ""no-openmpi"" builds for conda-forge by adapting the pattern in https://conda-forge.org/docs/maintainer/knowledge_base.html#openmp but that would require some work (and be a feature enhancement :).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1378#issuecomment-916822166:718,adapt,adapting,718,https://qutip.org,https://github.com/qutip/qutip/issues/1378#issuecomment-916822166,4,"['adapt', 'enhance']","['adapting', 'enhancement']"
Modifiability,"Hello, . I am trying to work on this enhancement. Do you think it's also a good idea to add the controlled version of the above gates? This can be done by defining a custom gate as well as given in the example (for rx) in the docs. Also, is it better if we name the gates ""X"" or ""XGATE"". I am not sure what convention the naming follows, if any. I can issue a pull request as soon as this is clarified. . Best, ; Sidhant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1208#issuecomment-601552795:37,enhance,enhancement,37,https://qutip.org,https://github.com/qutip/qutip/issues/1208#issuecomment-601552795,1,['enhance'],['enhancement']
Modifiability,"Hello, I want to solve problems in optomechanics with QuTip but I don't know which packages(mathmp, sympy,sympsi,..) must be used. please guide me about writing QuTip programs for optomechanical systems. also, I want to know in steady state, how I can plot a quantity(like variance) versus variables other than time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/507:290,variab,variables,290,https://qutip.org,https://github.com/qutip/qutip/issues/507,1,['variab'],['variables']
Modifiability,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1156:329,config,configured,329,https://qutip.org,https://github.com/qutip/qutip/issues/1156,2,['config'],"['configrc', 'configured']"
Modifiability,"Here is the newly implemented method for the `qip` module. I implemented a class `OptPulseProcessor`, which is the subclass of `circuitprocessor` in `qip.models`. It is defined by a set of Hamiltonians, usually determined by the hardware realization. It can take a `QubitsCircuit`, find the corresponding Hamiltonian representation of it (`self.load_circuit`) with `optaoptimize_pulse_unitary ` and then use these control pulses to simulate the circuit at the level of driven Hamiltonian (`self.run_state`). . A large part of it is actually more general and can be moved to circuitprocessor after I refactor `cqed `and `spinchain`. Glad to hear if you have any suggestions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1012:599,refactor,refactor,599,https://qutip.org,https://github.com/qutip/qutip/pull/1012,1,['refactor'],['refactor']
Modifiability,"Hey guys, thanks for the feedback (this is the first time I have logged in to github in about a year!).. Just some replies to Paul's comments. The method is basically general, under certain assumptions about the bath spectrum density and bath temperature, so the 'system' can, in principle, be anything. I will also do so minor tweaking so it can deal with multiple baths and correlated baths. We will add some notebooks showing different examples and explaining when its valid later. . > Why is it not possible to directly calculate expectation values other than the coupling term?. Yeah there was a list of expectation values at some point, but it disappeared while we were making edits. Thanks for the reminder. Thanks for the other points, we will fix the various issues.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103750029:568,coupling,coupling,568,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103750029,2,['coupling'],['coupling']
Modifiability,"Hi - I think I might have a solution for this issue in #1927. Setting up the utility was pretty straightforward, but I am not sure on how best to shape the process around using it. There are two issues that I foresee:; - Generating a news fragment when making a PR:; In order to reference PRs in the changelog, you have to pass the PR number to ; `towncrier create <PR number>.<change type>` ; So the process would be:; 1. Make draft PR; 2. Get PR number; 3. run towncrier create with PR number and commit & push resulting news fragment to PR; 4. Mark PR as ready. A way around this extra step is to reference the issue number, but you may not want that.; - When generating changelogs for releases, towncrier needs to be passed the version number in one of three ways (from the documentation):; - For Python 2/3 compatible projects, a __version__ in the top level package. This can be either a string literal, a tuple, or an [Incremental](https://github.com/hawkowl/incremental) version.; - Manually passing --version=<myversionhere> when interacting with towncrier.; - Defining a version option in a configuration file; Since there's no __version__ string or configuration file, I guess we would use the second option when calling `towncrier build`?. I'm not sure what the intended flow is for this and I didn't feel comfortable changing the release process, so perhaps someone can advise?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565:1101,config,configuration,1101,https://qutip.org,https://github.com/qutip/qutip/issues/1894#issuecomment-1151912565,2,['config'],['configuration']
Modifiability,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:319,refactor,refactoring,319,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393,2,"['maintainab', 'refactor']","['maintainability', 'refactoring']"
Modifiability,"Hi @Ericgig ; Thanks for investigating this so thoroughly. ; I guess it makes sense that unpacking a dict at each call is inefficient, so I think we should drop this idea. As you have suggested previously, users can always use module variables if they wish to avoid passing vars in `args`. So I think we should aim to keep it simple. I think adding `f(t)` as a signature option will be sufficient for what @goerz wanted and would be sufficient for using a Numba jit. So, my suggestion for the next major release (v5) would be that we have only two call sigs:; - `f(t, args)` (default); - `f(t)`. For now we will have to have the three (although I don't think the `rhs_with_state` is not widely used, if at all).; - `f(t, args)` (default); - `f(t)`; - `f(t, state, args)`; The default needs to remain as it is, because it is widely used. I think it makes sense to use introspection to decide which has been specified by the user, as the sig is clearly distinguishable by the number of args. So effectively we can ignore the `rhs_with_state` option, but I think we should give a deprecation warning that the `f(t, state, args)` signature will be removed in the next version. So, I think this means we can keep the new method of passing the state in the args dict. I would suggest we make it a bit more simple though. I notice that the processing of the option is a bit involved. So I suggest that any element of the `args` dict where the key is of the form `name:special_value_kind` be considered some kind of special value. If `special_value_kind` is not recognised then it should throw a `ValueError`. For now we will have the `special_value_kind` of:; - `state`: Qobj of the state at time `t`, with the correct dimensions; - `state_vec`: ndarray of state as a vector; - `expect`: I can't remember exactly what you did here. The `state_vec` will clearly be much more efficient, as this is what the ODE solver maintains. However, for completeness I think we should have the `state` option. The initial ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162:234,variab,variables,234,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162,2,['variab'],['variables']
Modifiability,"Hi @Ericgig, @jakelishman,. Thanks very much for the very helpful replies! I will try these suggestions in my application Eric!. Jake, when you say the following:; > Oh of course, I had `mcsolve` in mind as to why that couldn't be done (and in that case, my interpolation wouldn't work either because of the separation of the decay channels)... Is it that, this:; ```; def L(t, args):; H = H(t, ...); c_op = C(H, t, ...); return qutip.liouvillian(H, [c_op]). mcsolve(L, ..., c_ops=[]); ```. won't work due to `_funcrhs` treating `h_func` as a Hamiltonian always? If this is the only factor (as far as I can see), then I think I can further hack this to make callbacks work for me locally. I'm not yet sure if the numpy arrays method will work here but this is what I will strive for. Some details of my plans: I am doing dynamics simulations of quantum annealing processes. We use a certain number of qubits (between 4 and 8) biased and coupled in certain ways to produce examples of 'difficult' problems for adiabatic quantum computation, where the instantaneous energy gaps can have very small minima during evolution. The resulting ODEs appear to be 'stiff' and long evolution times are required to observe high probabilities of being in the ground state. The combination of these things appears to make solving for long evolution times very time consuming. I observed a massive speedup using `mcsolve` however. What I wish to do is include various decay channels, which in the physical systems we use, we understand to be in the 'weak coupling limit' defined by T. Albash here:; https://arxiv.org/pdf/1503.08767.pdf. Another note: A number of colleagues have found most useful the RK45 method implemented in what I understand to be 'new' ode solver scipy code `scipy.integrate.solve_ivp`. I notice that the 'dopri5' option for `scipy.integrate.ode` is likely the same thing. This is something I will play with also.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-630067552:1539,coupling,coupling,1539,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-630067552,1,['coupling'],['coupling']
Modifiability,"Hi @MartinSandeCosta, I have merged the PR of @mlaguna10. You can see now there is a few conflicts. Could you make a fresh PR including your changes based on the current master branch? . It could include:; - The controlled version of the gates; - Changes in QubitCircuit.propagator(); - Tests; and another enhancement you have related to #1208 . We shouldn't include the change of the attribution name `N` and `U_list` in this PR, as @jakelishman and @ajgpitch explained.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616:306,enhance,enhancement,306,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-607489616,1,['enhance'],['enhancement']
Modifiability,"Hi @TejasAvinashShetty, I had a try at the conda install on my machine. I had no issue:; ```; conda create -n qutip-env; conda activate qutip-env; (qutip-env): conda install cython numpy scipy nose matplotlib; (qutip-env): conda install qutip; (qutip-env): python; ""Python 3.7.3 (default, Mar 27 2019, 16:54:48); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin""; >>> from qutip import *; >>> qutip.about(); QuTiP Version: 4.3.1; Numpy Version: 1.16.3; Scipy Version: 1.2.1; Cython Version: 0.29.7; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/miniconda3/envs/qutip-env/lib/python3.7/site-packages/qutip; >>> quit(); (qutip-env): conda deactivate; conda update -n qutip-env --all; ""Collecting package metadata: done; Solving environment: done; # All requested packages already installed.""; ```; Can you please specify your machine configuration and what did you do to update the environment?. I guess I am unable to reproduce the issue unless I go back to qutip 4.2. ; Googling ""np113py36_2"", I ended up on this QuTiP Google Group thread, https://groups.google.com/forum/#!topic/qutip/BwtoyhW60jo; maybe making sure you are not in the QuTiP folder resolves the issue. . You can also activate your environment, uninstall qutip, update all the rest and then install qutip ; ```; conda activate qutip-env ; (qutip-env): conda uninstall qutip; conda update -n qutip-env --all; conda activate qutip-env ; (qutip-env): conda install qutip; ```; Another practical suggestion, not really assessing the issue, would be to create a new environment and do a fresh install.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/988#issuecomment-489419006:1013,config,configuration,1013,https://qutip.org,https://github.com/qutip/qutip/issues/988#issuecomment-489419006,1,['config'],['configuration']
Modifiability,"Hi @jakelishman you were right about the contraction, I changed the indexes as in http://qutip.org/docs/latest/guide/guide-tensor.html so that it represents a trace-like channel. On the other hand I find that mixed dimensions operator `[[m,n], [m,n ]]` appear in some of the tests that were already in place, I will try to write my thoughts on their meaning later. I am still going to refactor this a little bit more, and tell you when it is ready for review.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708:385,refactor,refactor,385,https://qutip.org,https://github.com/qutip/qutip/pull/1491#issuecomment-831049708,2,['refactor'],['refactor']
Modifiability,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:1250,flexible,flexible,1250,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386,2,['flexible'],['flexible']
Modifiability,"Hi @nonhermitian, I spent some time struggling with this as I recently shifted to macOS. This problem affects other Python installations too. I found a solution to this and if you could update it in the docs instead of the default macOS installation script, then it would be very helpful for new users. I will post the solution first and explain it below. . 1. Install a manual Python version which overrides the default Python supplied by Apple in the `usr/bin/python` path. You can check this using ```which python```. Installing using brew - . ```brew install python```. 2. Change the default Python interpreter from the one supplied by macOS in `usr/bin/python` to the user installed version in `/usr/local/bin/python`. This is explained in this [post](http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x#p1). Edit the file `/etc/paths` using ```sudo vi etc/paths``` and move the line `/usr/local/bin` to the top. This makes the user installed Python default and the packages installed by pip or brew are imported instead of the ones supplied by apple. Restart the terminal. You may need to update numpy and scipy using ```pip install numpy``` or ```pip install numpy -U```. 3. Install qutip using ```python setup.py install```. Apple has its own Python version and a few modules such as numpy and scipy come along with it which are at `/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/include/python2.7`. These modules are difficult to manage and update due to issues with permission. Hence, even if you update numpy or scipy using `pip` or `brew`, it is not detected by Python. ~~This also raises an issue later `error: could not create 'build/src.macosx-10.12-x86_64-2.7': Permission denied`~~. This solution seems better since it does not mess with the system default. Edit 1 : sudo -H is needed to install using ```sudo -H python setup.py install```. The -H tag sets the home directory as the default for installing configuration files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263745214:1963,config,configuration,1963,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263745214,1,['config'],['configuration']
Modifiability,"Hi @pschindler, thanks for reporting this! Although the eigenenstates are different for both cases (`sparse=True` and `sparse=False`) I believe that they are both equally valid since the operator has degenerated eigenvalues. The approach for the computation of the eigenstates for both `sparse=True ` and `sparse=False` is different so that may explain why you see different results. For the case that @Ericgig presented though, the eigenvalues are non-degenerated. I tracked down the issue and it is related to how we compute these eigenvalues. When we ask for all the eigenvalues what we actually do is to compute the smallest half in with one method (`scipy.sparse.linalg(which='LR')`) and the largest half with a different method (`scipy.sparse.linalg(which='SR')`). Smallest half and largest half here means relative to the _real_ part of the eigenvalue. This makes complete sense for the cases where the eigenvalues are real but unfortunately not so much sense when we only care about the imaginary part. This is what the `which` is doing, is selecting the values with smallest/largest real part. If we include a small real component the bug completely disappears:; ```; In [56]: (qutip.num(4)*(1j+0.00001)).eigenenergies(sparse=True); Out[56]:; array([1.23048985e-16-2.21177095e-16j, 1.00000000e-05+1.00000000e+00j,; 2.00000000e-05+2.00000000e+00j, 3.00000000e-05+3.00000000e+00j]); ```; Because now there is a real part to use in the ordering. The behavior of `eigenstates` is definitely wrong and one way of solving it would be to not use both `LR` and `SR` options when all the eigenvalues are required and instead chose internally just one. This would still return results ordered by their real part but at least all the eigenvalues would be present (only once). We may want to extend the behavior of `eigenstates` to not only accept `sort=low` and `sort=high` and instead have a similar behavior to the one provided by scipy and allow sorting by imaginary part or absolute value.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009:1789,extend,extend,1789,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1416862009,1,['extend'],['extend']
Modifiability,"Hi @saiyagami , your errors seem to be centered around OpenMP and parallelization stuff. It seems from the red underlined error that you do not have OpenMP installed, which shouldn't be the case since it is bundled with the Visual C/C++ compiler by default. I'd recommend you try the following, in this order:; 1. Try running the install again using the cloned repository's `setup.py` file, but this time run it as `python setup.py install --with-openmp`. Hopefully this configures things properly, and you don't see any more OpenMP related errors.; 2. If the above doesn't work, that suggests a more pathological error, in which case you probably should try using another compiler such as MinGW. Should you do so, please find more detailed instructions here : [https://stackoverflow.com/questions/11079586/getting-started-with-openmp-install-on-windows](url).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1079#issuecomment-539862401:471,config,configures,471,https://qutip.org,https://github.com/qutip/qutip/issues/1079#issuecomment-539862401,1,['config'],['configures']
Modifiability,"Hi @sarsid! I'd like to recommend that we land #1090 separately. It's a stand alone piece of work and coupling PRs together into big PRs where it can be avoided generally makes things harder to review and land. I can show you how to merge that branch into this one if you need to it make progress before #1090 lands. I would also recommend making the formatting changes you have made (I assume using black or your editor?) in a separate PR to this one. Lumping them into one PR also makes reviewing harder since one doesn't know which changes are intentional or meaningful. I'm also happy to help with this if you need!. I've started work on the docs for #1090, so hopefully it can land this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691:102,coupling,coupling,102,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691,1,['coupling'],['coupling']
Modifiability,"Hi Alex and Nathan, thanks for the suggestions, I have resolved the confliction. @ajgpitch Regarding the function `adjacent_gates`. It was there before, I just moved it around. I'm also not happy with it, but refactoring this function needs some careful analysis.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1065#issuecomment-545613325:209,refactor,refactoring,209,https://qutip.org,https://github.com/qutip/qutip/pull/1065#issuecomment-545613325,1,['refactor'],['refactoring']
Modifiability,"Hi Arne. Thanks a lot for the bug report. I'll go through the code fix it so that the qutip_gui = NONE flag is handled consistently. In the long run I think we need to refactor the code a little bit, so that GUI dependent module aren't imported at all if qutip_gui = NONE, rather that having a lot of if-else statements scattered around, but for now I'll try to make a quick fix by adding more if statements.. Rob",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/24#issuecomment-18720853:168,refactor,refactor,168,https://qutip.org,https://github.com/qutip/qutip/issues/24#issuecomment-18720853,1,['refactor'],['refactor']
Modifiability,"Hi Ben. Thanks a lot for your contribution. It's looking great!. A couple of small things:; - We try to make qutip python3 compatible, so please use python3 compatible print(...) function calls instead of print ... statements.; - Functions super_to_choi and choi_to_super seems to do the same thing, while the function names suggest complementary conversion. Is this intentional?; - I think it would be better if you move the test code from within the if **name** == '**main**' to a separate file in the examples directory, or even better as unit tests in qutip/tests/; - Avoid global import of qutip ""from qutip import *"" by only selectively importing the functions that you need (we try to do this internally in qutip to avoid circular module dependencies).; - Make relative import of qutip functions (for example from qutip.super_to_choi import super_to_choi). This is also required for python3 compatibility.; - Add an import of the main functions (for example subsystem_apply) to qutip/**init**.py ; - I would probably prefer the super_to_choi.py module be called something more general, like choi_decomposition,py (or something like that), which would reflect that it does not only contain the super_to_choi function but other related functions as well.; - Avoid printouts in choi_to_kraus function. If you want to enable debugging or diagnostic info, consider adding an optional function argument debug=False or verbose=False and print the vals and vecs variables only if the user explicitly asks for it. Otherwise, one could get an excessive amount of printouts if your code is used in a loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/22#issuecomment-18592742:1461,variab,variables,1461,https://qutip.org,https://github.com/qutip/qutip/pull/22#issuecomment-18592742,1,['variab'],['variables']
Modifiability,"Hi Boxi,. Can you please modify the projects of the Wiki page as you deem best?; All: we can also think of changing the order of them. It may be that; project #3 is deemed the most important. Best wishes,. Nathan. Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com. On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:. > I have some detail information for the GSoC 2020 project ""Error mitigation; > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > Wiki page. I post it here so if anyone finds it nice could copy it to the; > Wiki page.; >; > I add some details based on the original description:; > ------------------------------; > 1. Error mitigation in QuTiP; >; > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > quantum circuit simulator (which was a GSoC project) providing enhanced; > features for a pulse-level description of quantum circuits and noise; > models. A new class Processor and several subclasses are added to; > represent different platforms for quantum computing. They can transfer a; > quantum circuit into the corresponding control sequence and simulate the; > dynamics with QuTiP solvers. Different noise models can be added to; > qutip.qip.noise to simulate noise in a quantum device.; >; > This module is still young and many features can be improved, including; > new device models, new noise models and integration with the existing; > general framework for quantum circuits (qutip.qip.circuit). There are; > also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Request",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:949,enhance,enhanced,949,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,2,['enhance'],['enhanced']
Modifiability,"Hi Eric,; I've created a draft PR request for the changes. I did try to generate documentation according to the steps mentioned in the wiki but am faced with the following error:; ```; make html; sphinx-build -b html -d _build/doctrees . _build/html; Running Sphinx v3.5.4. Configuration error:; There is a programmable error in your configuration file:. Traceback (most recent call last):; File ""__init__.pxd"", line 942, in numpy.import_array; RuntimeError: module compiled against API version 0x10 but this version of numpy is 0xf . Check the section C-API incompatibility at the Troubleshooting ImportError section at https://numpy.org/devdocs/user/troubleshooting-importerror.html#c-api-incompatibility for indications on how to solve this problem . During handling of the above exception, another exception occurred:. Traceback (most recent call last):; File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/config.py"", line 327, in eval_config_file; execfile_(filename, namespace); File ""/home/User/miniconda3/envs/qutip-doc/lib/python3.8/site-packages/sphinx/util/pycompat.py"", line 88, in execfile_; exec(code, _globals); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 95, in <module>; _check_source_folder_and_imported_qutip_match(); File ""/home/User/Projects/QuantumStuff/qutip/doc/conf.py"", line 80, in _check_source_folder_and_imported_qutip_match; import qutip; File ""/home/User/Projects/QuantumStuff/qutip/qutip/__init__.py"", line 34, in <module>; from .core import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/__init__.py"", line 2, in <module>; from .coefficient import *; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/coefficient.py"", line 24, in <module>; from .data import Data; File ""/home/User/Projects/QuantumStuff/qutip/qutip/core/data/__init__.py"", line 3, in <module>; from . import dense, csr; File ""qutip/core/data/dense.pyx"", line 1, in init qutip.core.data.dense; File ""qutip/core/data/csr.pyx"", line 1, in i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488:274,Config,Configuration,274,https://qutip.org,https://github.com/qutip/qutip/issues/2098#issuecomment-1462271488,3,"['Config', 'config']","['Configuration', 'config', 'configuration']"
Modifiability,Hi Jake no problem. I was just asking about that particular line because I faced the same issue of readability versus properly scoping and could not get to a satisfactory solution. I was geting the variables from a global function that created a dictionary and it was not clean at all.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815068400:198,variab,variables,198,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815068400,1,['variab'],['variables']
Modifiability,"Hi Jake okey will re align and pull then and focus the other modules. Let's see if I am getting this right, is it correct style to add parameter to fixtures when they are used all along the test module, but in very specific special cases just leave the variable assignment before the test definition, like here https://github.com/jakelishman/qutip/blob/862d0de844d9d5b39f0301d0ea4c47c37d995499/qutip/tests/test_metrics.py#L126 ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359:253,variab,variable,253,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815030359,1,['variab'],['variable']
Modifiability,"Hi Kevin. Thanks for your efforts on this. However, I am not in favor of merging this PR in this form. It is way too intrusive on the old API, it would break backwarks compatibility for no good reason as I see it. Personally I don't think that the _2t and _1t names are that confusing. As you point out, _1t is still a two-time correlation function (a one-time correlation function would not be a correlation function, just a simple expectation value), but the _1t and _2t is intended to refer to the number of free time variables. Perhaps this should be explained more clearly in the docstrings, but I don't think it is worth changing the API for this reason. I would prefer if you added the new mc solvers using the current API conventions, and preferably without changing the me and es based solvers. If you want to propose a new API the correct way to do it would be:; 1. First discuss the idea, so that everyone interested could weight in on the naming of the functions, the style of parameters and arguments etc.; 2. Implement the new API without disrupting the previous API; 3. Deprecate the previous API, so that using it gives a warning (but still works!). ; 4. Then finally after a few release cycles we may drop the old API. This would not happen until qutip 4.0 (see http://semver.org/), which we do not plan to release anytime soon. Therefore, we cannot accept any PRs that with backwarks breaking API changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/218#issuecomment-53827562:521,variab,variables,521,https://qutip.org,https://github.com/qutip/qutip/pull/218#issuecomment-53827562,2,['variab'],['variables']
Modifiability,"Hi Nathan,. I can't modify the Wiki page because I'm not a maintainer of QuTiP. And it seems that there is no way to make a PR to Wiki. I can also send you the markdown source code per email like this, but I’m not sure if it works as I expected. The following is the markdown source code:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:495,enhance,enhanced,495,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,2,['enhance'],['enhanced']
Modifiability,"Hi Vutshi. Thanks a lot for this contribution! It's looking very interesting indeed. I'll be looking into the details of your code, notebook and your paper in the coming days, but from a first look it's looking great! I've been working a lot on the stochastic solvers the last few months, but it is still very much under development. The milstein method has been on my todo list for a long time, but I've not gotten around to work on it yet, so your contribution is very timely and most welcome!. I have tried to design the API in the most general way I could think of while still keeping the complexity from growing too much. Defining an SME with its RHS function, D1 and D2 functions has worked for most problems I considered so far, but I'd be happy to discuss further if this could be changed to something more flexible, like a function for calculating rho_{n+1} like you suggest. We hope to have the stochastic solver API ready and mature enough to include in the next qutip release sometime this fall, so it would be good to have these things tested and thoroughly discussed before then. But until the stochastic module is officially in the QuTiP API we still have a lot of freedom to shake things up if necessary. Also, to keep complexity and code duplication down I wanted to follow the pattern. smesolve (choose solver by argument) -> smesolve_generic -> specific method and SDE by rhs, d1, d2 selection. So it would be good if smesolve_mil and smesolve_impl in your code could be combined with smesolve, and if smesolve_implicit and smesolve_milstein could be combined with smesolve_generic, etc. That would reduce a lot of code duplication I think. Of course, if smesolve_generic needs to be changed to accommodate this that would be totally fine with me. It would be great if you could do a pull request of this to the qutip master, then we could discuss details in the PR. You'd need to rebase your branch to the current master tip though, because things already changed a bit since the v",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22011953:815,flexible,flexible,815,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22011953,1,['flexible'],['flexible']
Modifiability,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35:1224,flexible,flexible,1224,https://qutip.org,https://github.com/qutip/qutip/issues/35,1,['flexible'],['flexible']
Modifiability,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:556,variab,variables,556,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['variab'],['variables']
Modifiability,"Hi devs,. I've been running into an issue installing the most recent dev version. The _blas_info() method is throwing the following error:. ```; Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) ; [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/__init__.py"", line 174, in <module>; import qutip._mkl; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/__init__.py"", line 3, in <module>; _set_mkl(); File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/_mkl/utilities.py"", line 47, in _set_mkl; if _blas_info() == 'INTEL MKL':; File ""/Users/oliviadimatteo/tomo_test/qutip/qutip/utilities.py"", line 405, in _blas_info; if hasattr(config,'mkl_info') or any('mkl' in lib for lib in blas_info['libraries']):; KeyError: 'libraries'; ```. It seems this method was changed most recently in commit d7bb119 to include a line containing `blas_info['libraries']`. For reference I am doing a basic installation with just numpy (1.11.2), scipy (0.18.1), and cython (0.24.1), and not with any of the fortran MC stuff. I'm using Mac OSX 10.11, and Python 3.5.2. [I've also been able to successfully install using a commit from before this, a31f7fc.] . Please let me know if there is just something I've missed here. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/552:857,config,config,857,https://qutip.org,https://github.com/qutip/qutip/issues/552,1,['config'],['config']
Modifiability,"Hi, . Here's the output I get. While I've installed the BLAS libraries on my machine, I haven't 'connected' it with numpy, so maybe this is what's leading to the issue?. ```; >>> import numpy as np; >>> config = np.__config__; >>> config.show(); openblas_lapack_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; atlas_3_10_threads_info:; NOT AVAILABLE; blas_opt_info:; extra_link_args = ['-Wl,-framework', '-Wl,Accelerate']; define_macros = [('NO_ATLAS_INFO', 3), ('HAVE_CBLAS', None)]; extra_compile_args = ['-msse3', '-I/System/Library/Frameworks/vecLib.framework/Headers']; lapack_opt_info:; extra_link_args = ['-Wl,-framework', '-Wl,Accelerate']; define_macros = [('NO_ATLAS_INFO', 3), ('HAVE_CBLAS', None)]; extra_compile_args = ['-msse3']; atlas_3_10_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_threads_info:; NOT AVAILABLE; lapack_mkl_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/552#issuecomment-259646175:203,config,config,203,https://qutip.org,https://github.com/qutip/qutip/issues/552#issuecomment-259646175,2,['config'],['config']
Modifiability,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:179,variab,variable,179,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087,1,['variab'],['variable']
Modifiability,"Hi, I have an implementation of the ICM model now and as a bonus, I got an introduction to topological quantum computing as well as a nice topological quantum computing circuit viewer. I have it all in this repo - https://github.com/sahmed95/icm. It needs major refactoring, testing and there is a lot of brute code in there so please ignore it for now. I had to finish this in the span of a few days to start work on something related to the same and hence the code isn't pretty. I will work on this after finishing up my winter internship and push the commits here. An example can be found in https://github.com/sahmed95/icm/blob/master/tqc_icm/icm_example.ipynb. If this code has to go into qip, I guess I need someone with experience in this for review. How about https://github.com/alexandrupaler. The ICM paper is by him and he has implemented it in C++ in https://github.com/alexandrupaler/tqec.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-273579746:262,refactor,refactoring,262,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-273579746,1,['refactor'],['refactoring']
Modifiability,"Hi, I think it might either be an issue with your conda version or a conflict due to mixing things from the conda-forge and the default conda channel. . There are two options which you can try:. 1. Update all packages and conda by running. ```; conda update --all; ```; and then trying to reinstall qutip from the default conda repo (and not conda-forge) with. ```; conda install qutip; ```. 2. Add the conda-forge channel as priority with . ```; conda config --add channels conda-forge; ```; and then update all with; ```; conda update --all; ```; and finally installing qutip with. ```; conda install -c conda-forge qutip; ```. The last option would be to uninstall conda, install the latest Miniconda which does not install any package by default and then installing qutip from the conda-forge version with; ```; conda install -c conda-forge qutip; ```. All three suggestions should just take a couple of minutes. If you could tell me the Anaconda version, it would be very helpful (```conda --version```)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/860#issuecomment-387719222:453,config,config,453,https://qutip.org,https://github.com/qutip/qutip/issues/860#issuecomment-387719222,1,['config'],['config']
Modifiability,"Hi, This is not ready for review so I added a new tag `WIP`. The tests etc are not proper and I just wanted to get a basic version out. The latest commits are @nwlambert's code to construct the Liouvillian for the Heom. I will start refactoring things now and update the tag to `review in progress` when this is ready.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962#issuecomment-472547191:233,refactor,refactoring,233,https://qutip.org,https://github.com/qutip/qutip/pull/962#issuecomment-472547191,1,['refactor'],['refactoring']
Modifiability,"Hi, the first part for this is ready for review. A typical use case would be to generate the matrix M.; @nathanshammah I made some small changes in the names of functions.; @ajgpitch Please suggest any changes if necessary for pep8, function naming, testing or the API in general. We have the examples and ipynb notebooks that @nathanshammah wrote. Where do they go ? . Once, this is merged, there are additional helper functions to calculate operator expectations, thermal states etc which can be added. However, this forms the core of the module.; ```; from qutip.pim.dicke import *; import numpy as np; from scipy.integrate import odeint. # system parameters. N = 10; gS, gL, gD, gP, gCP = .1, .1, .1, .1, .1. # define the model; model = Pim(N, emission=gS, loss=gL, dephasing=gD, pumping=gP, collective_pumping=gCP). M = model.generate_M(). # Evolve the system according to dp/dt = M.p. rho0 = initial_dicke_state(N, (5, 5)); t = np.linspace(0, 10, 100). def generate_rhs(rho, M):; return M.dot(rho). p = odeint(generate_rhs, rho0, t, args=(M,)); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-332110217:847,Evolve,Evolve,847,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-332110217,1,['Evolve'],['Evolve']
Modifiability,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/793:19,refactor,refactoring,19,https://qutip.org,https://github.com/qutip/qutip/pull/793,2,"['Refactor', 'refactor']","['Refactoring', 'refactoring']"
Modifiability,"Hi, this is ready for review. It probably needs a lot of refactoring but I have documented all functions and provided unit tests. I made a simple script for my lab where you can specify a circuit in a text file and the outputs will be generated. You can check it out here: https://github.com/sahmed95/icm. I have an example describing the use of this module. Where do the examples go ? @ajgpitch @nonhermitian . As I mentioned, @alexandrupaler should be the right person for review. Dr. Devitt also mentioned Damian from ProjectQ (?) who could help perhaps.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-275668058:57,refactor,refactoring,57,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-275668058,2,['refactor'],['refactoring']
Modifiability,"Hi,. I think your new implementation of API should be flexible enough to incorporate any explicit scheme. The reason I think it is useful to calculate \rho_{n+1} is to apply a semi implicit method. This is what is done by Lsparse. I tried two ways of doing it. First, one can calculate (1 - (L+d1)_dt)^(-1) and apply it to to the stochastic part of the equation. Another way is to calculate the deterministic evolution expm[(L+d1)_dt] and also apply it to the stochastic part. Both of these methods work for linear deterministic part like in the homodyne detection. I've got good results with these semi-implicit methods on a problem with a few qubits. Due to a big nonlinearity for some parameters regime it really helps to apply the true deterministic evolution (or its approximation). For another regime it is better to use explicit method. In principle it should be good to adjust degree of implicitness. Anyway I'm still looking into the problem and comparing different possibilities. I hope to produce a new notebook with tests soon. This Milstein realisation is compatible in principle with the heterodyne detection. I'm not sure it is possible to express everything in terms of d1 and d2 only. The point is that I need to use derivatives of d2. I don't really see a problem to have separate RHSs for homodyne, heterodyne and photocurrent detections. I'll think a bit more about unification of homodyne and heterodyne and then I'll submit a pull request. Regarding expm for large systems. We need to calculate it only once, it works for small systems so I think it is a good option to have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22116628:54,flexible,flexible,54,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22116628,1,['flexible'],['flexible']
Modifiability,"Hi,. I was writing a simple code for a time dependent driving of a two level atom with the excited state decay and encountered the following problem: If I evolve the system using mesolve for particular time dependence of my driving field, namely if the evolution time is set to be from t = 0 to t = 3.5 in the units of 1/(Rabi frequency) and the driving is only present between t = pi/2 and t = pi, I get expected results if I do not include any collapse operators (using []), however as soon as I use the usual collapse operator corresponding to the excited state decay it gives me for all the time the initial values of the quantities. It happens even if I set the decay rate to zero! Also, mcsolve works fine in both cases.; Here is the code that I use:; ```; import numpy as np; import pylab as plt; import scipy as scipy; from qutip import *. #System parameters; Omega = 1; Gamma = 0.1. g = basis(2,0); e = basis(2,1); sgg = g * g.dag() #ground state population; see = e * e.dag() #excited state population; sge = g * e.dag() #atomic coherence sigma_ge. #Driving Hamiltonian; H1 = Omega * (sge + sge.dag()). #Time dependence of the drive; def H1_coeff(t,args):; if t > np.pi:; c =0; elif t >= np.pi/2:; c = 1; else:; c = 0; return c. #Complete Hamiltonian; H = [[H1, H1_coeff]]. #Time; tspan = np.linspace(0,3.5,500). #initial state; psi0 = g. #collapse operators; c_ops = [np.sqrt(Gamma) * sge]. #calculated expectation values; e_ops = [sgg, see]; results = mesolve(H, psi0, tspan, c_ops, e_ops). #plotting the results; fig, ax = plt.subplots(1,1); ax.plot(tspan, results.expect[0]); ax.plot(tspan, results.expect[1]); plt.show(); ```; And here is the information about the packages that I'm using; ```; QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.1; Scipy Version: 0.19.1; Cython Version: 0.26; Matplotlib Version: 2.0.2; Python Version: 3.6.2; Number of ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/771:155,evolve,evolve,155,https://qutip.org,https://github.com/qutip/qutip/issues/771,1,['evolve'],['evolve']
Modifiability,"Hi,. I'm new to the project as a user. I am trying to solve some problems involving multiple baths with Floquet formalism. Just wondering if you already implemented it in your current version? . Notice this just now in the documentation: http://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html where 'Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function.' But I think it's good and not so difficult to come up with a general solvers where multiple baths are supported by myself. Is it okay if I contribute to this as well?. Cheers,; Tianqi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1464:385,coupling,coupling,385,https://qutip.org,https://github.com/qutip/qutip/issues/1464,1,['coupling'],['coupling']
Modifiability,"Hi,. There is a [manual integration](https://github.com/qutip/qutip/blob/master/qutip/floquet.py#L602-L624) using rectangles method in `qutip.floquet` file which sometimes fail. Problem is that the number of timesteps, `nT`, is hardcoded and not accessible to the user. In my case, `nT = 100` does not seem to be enough and the integral is wrong. A quick and dirty fix is to have an extra `nT=100` keyword argument to `floquet_master_equation_rates`, so that user can overload it. Still, it does not seem to be the most efficient way of doing it. I have a quick fix I can contribute which is using `scipy.integrate.simps` instead. This requires keeping an array of values to integrate in memory (which is less memory-efficient) but I could keep `nT=100` and get the correct integral by using this method. I guess the best option would be to use [`scipy.integrate.quad`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html#scipy.integrate.quad), as it uses an adaptive algorithm. I can contribute a fix for this, just looking for feedback on the best available option :). Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/767:986,adapt,adaptive,986,https://qutip.org,https://github.com/qutip/qutip/issues/767,1,['adapt'],['adaptive']
Modifiability,"Hi,; I want to discuss 2 points about how we manage time dependent Hamiltonian, relating to the discussion started on qucontrol/krotov#56. First, presently function coefficients are defined as:; ```; def f(t, args):; return ...; ```; With `args` is a dictionary containing extra variables to pass to the function. For backward compatibility; ```; def f(t, state, args):; return ...; ```; is also accepted if the option `rhs_with_state` is set to `True`. . But there have been demand to accept more signatures: `f(t)` and `f(t, **args)`. PR #1123, when ready, should allow both signature using options. . The best signature I believe is `f(t, **args)` since it allows to use more natural function call using kwargs (`f(t, w=0, a=1)`). However, it is the slowest in the #1123 implementation (up to 10x): some items are added to `args` for internal use and they need to be filtered at each call. It could be brought to 2.5x with some work, but no better. `f(t)` is about 2x slower than `f(t, args)`. But it's less agile: if the Hamiltonian use `f(t, w1=0)`, we cannot add a c_ops using `f(t, w2=0)`, both function must accept `w1` and `w2`. `args` could just hide unused items. Which ever we choose as the main one will be 2~3x faster than the other. We can have automatic detection of the signature if we want to be fancy. Which signature do you think is better?. Second, these function can depend on the state with the option `rhs_with_state`. Thus the coefficients are `f(t, state, args)` with `state` a 1D numpy array.; When making QobjEvo, I added special `args`' keys that indicate that the value should be updated with the state: setting `args = {""val=Qobj"":psi0, ""val"":psi0}` would tell `args[""val""]` to be updated with the state at each use in the solver. The state can be obtained as Qobj, np.array or the args could be updated to be the expectation value of another Qobj.; There are some bug for it in master presently but it will work with PR #1127. Using these special keys for this work wel",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136:279,variab,variables,279,https://qutip.org,https://github.com/qutip/qutip/issues/1136,1,['variab'],['variables']
Modifiability,"Hi. I don't quite understand what you are proposing to implement, but enhancements and extensions are of course very welcome!. Edit. OK, thinking about it a bit more I think I understand what you want to accomplish. Instead of giving a single wavefunction as initial state, you want to pass a list of wavefunctions that will ack at different initial states for each trajectory? That would be a very welcome improvement.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/120#issuecomment-41975397:70,enhance,enhancements,70,https://qutip.org,https://github.com/qutip/qutip/issues/120#issuecomment-41975397,1,['enhance'],['enhancements']
Modifiability,"Hmm, it still seems to use the old travis ci configuration, where I tried to install numpy/scipy with pip without wheels. But took too long to install the dependencies that way, and the tests will probably timeout and get cancelled. In the current travis ci configuration uses pip with wheels to install numpy/scipy much faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36083480:45,config,configuration,45,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36083480,2,['config'],['configuration']
Modifiability,"Hmm, yes, that only works if you set the qutip.settings.debug to True via the configuration file.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261#issuecomment-63601247:78,config,configuration,78,https://qutip.org,https://github.com/qutip/qutip/pull/261#issuecomment-63601247,1,['config'],['configuration']
Modifiability,Hsolve enhancements - now class module,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/455:7,enhance,enhancements,7,https://qutip.org,https://github.com/qutip/qutip/pull/455,1,['enhance'],['enhancements']
Modifiability,"I agree on leaving this PR as it is. @hodgestar, I committed your suggestions and removed the `user_color` temporary variable (was not really necessary).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073:117,variab,variable,117,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1142282073,1,['variab'],['variable']
Modifiability,"I agree that is is getting a bit unwieldy with all the options to the steadystate function, many of which only have meaning for specific solvers. We should do something about that. I wouldn't favor getting rid of the steadystate function though.. It might break a lot of old code and I think it is nice to have a high-level API that is decoupled from the specific implementation (direct, interative, or something else). Currently steadystate is only dispatching to other functions, and I think that is how it is supposed to be. To solve the problem with diverging options requirements for different solvers I would suggest changing the function signature to. ```; def steadystate(A, c_ops=[], method='direct', **kwargs):; ...; if method == 'direct'; steadystate_direct(A, c_ops, **kwargs); ```. and defer all the specifics about kwargs to specific solvers (including docstrings). That would bring the default values of those options closer to where they are used and reduce duplication. It would also allow us more flexibility in maintaining a backwards compatible api, and future maintainability. It's fine with me to make _steadystate_direct and _steadystate_iterative publicly accessible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/108#issuecomment-41362284:1081,maintainab,maintainability,1081,https://qutip.org,https://github.com/qutip/qutip/issues/108#issuecomment-41362284,1,['maintainab'],['maintainability']
Modifiability,"I agree we need to be consistent, but I would also go with `matrix * Qobj` to be right and change `Qobj * array` to raise an error.; `Qobj * Qobj` can be understood as `Qobj @ Qobj` but everything else could use `mul`. If `mul` raise a `TypeError`, we can catch it and return `NotImplemented`. With this, we probably won't need to touch the `Dense` and `CSR` `mul` function and `Variable` will be passed to the `TfTensor` specialization.; The only issue I see is that sometime `Variable * Qobj` will work, other time it will not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814:379,Variab,Variable,379,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880821814,2,['Variab'],['Variable']
Modifiability,I agree with @jakelishman's general principle (and maybe we should even move the tests out of the `qutip` package for v5 still) but it's also really important to have an easy way for data layer implementations to run a comprehensive test suite *that is defined by the data layer*. I suspect that if anyone is running tests against master (i.e. what is currently dev.major) they will *want* tests to break if we add new methods. I have a slightly different proposal:. What if we create `qutip.core.data.testing` which is an explicitly exported suite of pytest classes that we intentionally expose for data layers to use? Initially the file can just import test classes from `qutip.tests.core.data`. I would also not use `__all__` in the individual test packages but instead import the test classes explicitly in `qutip.core.data.testing` so that it's 100% clear by reading just that file what the exported interface is (and adding new tests requires explicitly adding them into the exposed package).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874:605,layers,layers,605,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979884874,2,['layers'],['layers']
Modifiability,"I am getting a variety of errors when running the test scripts under OSX:; - For `test_mcsolve_cl_time_dep_h` I get ""atol could not be reached for 1 trajectories"". I am also seeing:. ""CompilerWarning: Non-empty compiler output encountered. Set the environment variable PYOPENCL_COMPILER_OUTPUT=1 to see more.; ""to see more."", CompilerWarning)"". ""AttributeError: 'NoneType' object has no attribute 'clobj__delete'; Exception ignored in: <object repr() failed>""",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-259602577:260,variab,variable,260,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-259602577,1,['variab'],['variable']
Modifiability,I am guessing that there is some issue removing td files in config. The test that you do should not be looking for a RHS file as the test is time-independent. Why this only happens on Win is an interesting question. I put up a fork that may work here:. https://github.com/nonhermitian/qutip/tree/config_reset_test. Let me know how it goes. It seemed to work on my Win7 VM. It basically removes the old td files from config every time it is not needed anymore. I am not sure why we did not do this before. It still needs to be checked that the rhs_reuse setting in the Options class still works.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/728#issuecomment-317316149:60,config,config,60,https://qutip.org,https://github.com/qutip/qutip/issues/728#issuecomment-317316149,2,['config'],['config']
Modifiability,"I am having some trouble with the function mesolve. The situation is the following: I have a collection of Hamiltonians and Jump Operators which includes 69 timesteps each, and I want to evolve a initial state to each of this timesteps. However, Qutip is returning ""Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class."". I tryied to change nsteps parameter but it just doesnt work for any value of it, no matter how big the number is. H= Hamiltonian, shape: 69,2,2; list_Jump-op= Jump operators, shape:69,2,2; time= timesteps, shape (69,); estados_val= the different states that I want to evolve on this dynamics, shape( 6,69,2,2) . Note that I am only taking the 0th element on the axis with lenght of 69. predictions=[mesolve(H,; Qobj(estados_val[i][0]),; time,list_Jump_op,options=Options(nsteps=10000000000000000)) for i in range(len(estados_val))]. The terminal out put is; /home/andrius/anaconda3/lib/python3.8/site-packages/scipy/integrate/_ode.py:1013: UserWarning: zvode: Excess accuracy requested. (Tolerances too small.); warnings.warn('{:s}: {:s}'.format(self.__class__.__name__,; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-11-0bc27bfd6f01> in <module>; 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. <ipython-input-11-0bc27bfd6f01> in <listcomp>(.0); 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605:187,evolve,evolve,187,https://qutip.org,https://github.com/qutip/qutip/issues/1605,2,['evolve'],['evolve']
Modifiability,I am not sure what you mean by too large. The dimensions are not really the issue. It is the number of nonzero elements that matter. I am also puzzled by evolution using only collapse operators. Anytime you evolve a system you need the Hamiltonian. The Liouvillian has both coherent and dissipative terms in a single operator.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/531#issuecomment-244249449:207,evolve,evolve,207,https://qutip.org,https://github.com/qutip/qutip/issues/531#issuecomment-244249449,1,['evolve'],['evolve']
Modifiability,I am now also encountering this issue when installing qutip 4.3.1 on a docker image (built from Windows). qutip 4.3.0 works without problems. Minimal docker file where qutip fails to import:. ```dockerfile; FROM continuumio/miniconda3. RUN conda config --append channels conda-forge && conda update -y --quiet conda && conda install -y --quiet qutip=4.3.1; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-480764079:246,config,config,246,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-480764079,1,['config'],['config']
Modifiability,"I am now trying to setup a developement environment using ```python setup.py develop``` and ```python setup.py build_ext --inplace``` but getting the error . ```; cy/stochastic.pyx: cannot find cimported module 'qutip.cy.spmatfuncs'; Appending qutip.cy configuration to qutip; Ignoring attempt to set 'name' (from 'qutip' to 'qutip.cy'); Appending qutip.control configuration to qutip; Ignoring attempt to set 'name' (from 'qutip' to 'qutip.control'); Traceback (most recent call last):; File ""setup.py"", line 18, in <module>; setup(**configuration(top_path='').todict()); File ""setup.py"", line 10, in configuration; if os.environ['FORTRAN_LIBS'] == 'TRUE':; File ""/usr/local/Cellar/python/2.7.12_2/Frameworks/Python.framework/Versions/2.7/lib/python2.7/UserDict.py"", line 40, in __getitem__; raise KeyError(key); KeyError: 'FORTRAN_LIBS'; ```; I have gcc and gfortran installed and I suspect this might also be due to some issue with the file paths. I will try to get a workaround and post soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263750245:253,config,configuration,253,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263750245,4,['config'],['configuration']
Modifiability,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/365:128,variab,variable,128,https://qutip.org,https://github.com/qutip/qutip/issues/365,1,['variab'],['variable']
Modifiability,"I am trying to add some `.qasm` files to the folder `qutip/qutip/tests/qasm_files/` to use during test time. I thought it would be enough to add them to the `PACKAGE_DATA` variable in `setup.py` but that does not seem to work. Any ideas on how to make sure this folder is available during testing time? Beside this part, the PR is ready for review. @nathanshammah @BoxiLi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373:172,variab,variable,172,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655893373,1,['variab'],['variable']
Modifiability,"I am trying to use `mesolve` to solve an annealing problem using density matrices. The Hamiltonian evolves with time, $H(t) = \dfrac{t}{T}H_p + (1-\dfrac{t}{T})H_d,~ 0\leq t \leq T$, and I aim to solve the corresponding master equation using qutip, $\hat{\dot{\rho}} = i\left[\hat{H},\hat{\rho}\right]$. I have been doing this with a state vector approach, and the code works fine. With my knowledge of density matrices, I would assume that I can simply replace $\ket{\psi}$ with $\hat{\rho} = \ket{\psi}\bra{\psi}$, and use this as my initial state in `mesolve`. This would obtain density matrices for `sln.states` at each time step, however this seems not to be the case. Code:; ```; from bacon import bacon; import qutip as qt; import numpy as np. #inputs into bacon; spin_coeff = [; 4.8,; 9.5,; 4.82,; ]. coupling_coeff = [; 6.4,; 0,; 6.4; ]. H_input = bacon(; 3,; spin_coeff,; coupling_coeff; ). Hd = H_input.driver(); Hp = H_input.problem(). def init_superpsn(n):; '''; n - number of qubits; '''; state = np.ones((2**n), dtype = int)/np.sqrt(2**n); state = qt.Qobj(state); return state. #forming density matrix; initial_state = init_superpsn(3) * init_superpsn(3).dag(); #commenting out this line gives a different error; #initial_state = qt.Qobj(initial_state, dims = [[[2, 2, 2], [2, 2, 2]], [[2, 2, 2], [2, 2, 2]]]). grain = 100; anneal_time = 100. # initial coefficients; def d_coeff(t,params): ; return (1-t/params[""T""]); def p_coeff(t,params):; return (t/params[""T""]). Hs = [[Hd, d_coeff], [Hp, p_coeff]]; # ""writes down"" hamiltonian at time t ; H_dyn = qt.QobjEvo(Hs,args={""T"":anneal_time}) ; # solves SE for a particular hamiltonian that we ""wrote down""; s = np.linspace(0, anneal_time, grain); sln = qt.mesolve(H_dyn, initial_state, s) ; states0 = sln.states; ```. Bacon is a class I wrote that forms $H_d$ and $H_d$ Hamiltonians using tensor products. `Hp` is ; ```; Qobj data =; [[ 31.92 0. 0. 0. 0. 0. 0. 0. ]; [ 0. 9.48 0. 0. 0. 0. 0. 0. ]; [ 0. 0. -12.68 0. 0. 0. 0. 0. ]; [ 0. 0. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1989:99,evolve,evolves,99,https://qutip.org,https://github.com/qutip/qutip/issues/1989,1,['evolve'],['evolves']
Modifiability,"I am trying to use code from User Guide's [Directly Generating an Animation section](http://qutip.org/docs/4.1/guide/guide-bloch.html?highlight=funcanimation#directly-generating-an-animation):. ```; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); ```. I get the following error:; ```; Traceback (most recent call last):; File ""bloch_test.py"", line 59, in <module>; ani.save('bloch_sphere.mp4', fps=20, clear_temp=True); TypeError: save() got an unexpected keyword argument 'clear_temp'; ```. It looks like OpenDrift may have had the same or similar issue:; https://github.com/OpenDrift/opendrift/issues/9. My hypothesis is that QuTip needs to be adapted to the newer version of Matplotlib.; According to ; ```; from qutip import *; about(); ```; I use Matplotlib version: 2.1.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/798:653,adapt,adapted,653,https://qutip.org,https://github.com/qutip/qutip/issues/798,1,['adapt'],['adapted']
Modifiability,"I am using GRAPE to identify optimal pulse sequences to produce a desired unitary, and am running into an error when I use optimize_pulse_unitary for sparse matrices of size 1296x1296 and larger. . For example, the following code works for N=2 but fails for N=>3:. ```python; import numpy as np; from qutip import *; from scipy.sparse import csr_matrix; import qutip.logging_utils as logging; logger = logging.get_logger(); #Set this to None or logging.WARN for 'quiet' execution; log_level = logging.INFO; #QuTiP control modules; import qutip.control.pulseoptim as cpo; import math. # Set parameters; chi = 2.2 * 2 * np.pi # coupling strength; N = 3 # number of cavity states; n_ts = 21 # number of discrete time steps; evo_time = 4. # Length of time; fid_err_targ = 1e-10 # Target fidelity error; max_iter = 0 # # Maximum iterations for the optimization algorithm; max_wall_time = 0 # Maximum (elapsed) time; min_grad = 1e-20 # Minimum gradient; p_type = 'SINE' # pulse type (RND|ZERO|LIN|SINE|SQUARE|SAW|TRIANGLE); f_ext = ""pulsedata.txt"" # output file. # Set operators and Hamiltonians. # operators; a = tensor(destroy(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); b = tensor(qeye(N), destroy(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); c = tensor(qeye(N), qeye(N), destroy(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); d = tensor(qeye(N), qeye(N), qeye(N), destroy(N), qeye(2), qeye(2), qeye(2), qeye(2)); sm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), destroy(2), qeye(2), qeye(2), qeye(2)); zm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), destroy(2), qeye(2), qeye(2)); tm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), destroy(2), qeye(2)); qm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), destroy(2)); P_se = tensor(qeye(N), qeye(N), qeye(N), qeye(N), basis(2, 1) * basis(2, 1).dag(), qeye(2), qeye(2), qeye(2)); P_ze = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), basis(2, 1) * basis(2, 1).d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:626,coupling,coupling,626,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['coupling'],['coupling']
Modifiability,"I completely agree with you that random tests really aren't the right way to go in general, but right now our problem is that basically QuTiP's entire testing suite is based on randomised tests, and that's an awful lot of technical debt to overcome any time soon :(. . The `dnorm` tests have historically been a huge problem, even though basically nobody's worked on `dnorm` for a long long time now (for context, see in particular #880 and #874). We don't actually even know if the failures in `dnorm` are deterministic and reproducible, although it turns out that I had a brief look into this when I joined as a GSoC student about a year ago... I don't remember doing it at all!. I know this is super inelegant and not the perfect method, but it's kind of a nasty trade-off - I don't have time to really dig into `dnorm` (a topic I know almost nothing about) to work out an appropriate solution to temperamental errors, we do want `dnorm` to be tested since we're shipping it, and the slight flakiness keeps causing us test suite failures about 1 in 10 times. I'm somewhat opposed to fixing the random seed because having the variance over several test runs does actually help us cover more ground (eventually) - fixing it to a ""known good"" seed actually seems to me to be more of a mask of potential problems than this. Of note: the pytest plugin I'm using reports the number of reruns it performed in the analysis at the bottom - they show up in a yellow alongside the ""skips"" and ""xfails"" - so it's not completely hidden. I'd love to have a property-based testing suite like hypothesis up and running - that definitely seems like the proper solution to this in the end. In the meantime, I'm open to swapping to a fixed random seed if you think that's much better - testing is one place where I'm really aware of my lack of formal experience in software engineering, so I'm basically just learning as I go.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227:1343,plugin,plugin,1343,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227,2,['plugin'],['plugin']
Modifiability,"I did some tests and ; 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian matrices) (c's version Ok); 2 - It happen when installing the scipy stack with pip but not when installing it with conda.; 3 - It depend on the problem size, 64 seems particularly bad, usually it fails on the second call.; 4 - I only got it in zheevr which is only used in `brmesolve`. But Nathan got it in other tests which use scipy's `eigh`.; 4 - It happen in scipy in the fortan version of lapack:. ```; import numpy as np; from scipy.linalg import eigh; H = random_hermitian(64); eigh(H) # Work fine; eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; ```. Possible solutions (for zheevr):. - Installing scipy with conda, the easiest solution, but not in our control.; - Finding a way to link clapack from cython. Linking scipy's one would require good knowledge of scipy internals since only one cython interface is provided. Linking to another installation of lapack, but it would require the user to install lapack or install it with qutip. Both seems wrong to me.; - For mac user, call scipy's eigh from cython i zheevr, slower but better than risking segfault.; - Have the code directly in qutip. We can adapt it from OpenBlas: https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492:1238,adapt,adapt,1238,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492,1,['adapt'],['adapt']
Modifiability,"I did that and it fixed the issue, but wouldn't it make more sense to have nnz be a directly retrievable variable of a dtype = ""CSR"" Qobj?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271:105,variab,variable,105,https://qutip.org,https://github.com/qutip/qutip/issues/2481#issuecomment-2208274271,1,['variab'],['variable']
Modifiability,"I discovered that we were missing a small bit of towncrier configuration, so I added this test that does a trial run of generating the changelog. In addition to checking that the changelog can be generated, it also outputs the draft so that reviewers can look at it if they like.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480:59,config,configuration,59,https://qutip.org,https://github.com/qutip/qutip/pull/1946#issuecomment-1170110480,1,['config'],['configuration']
Modifiability,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:905,plugin,plugins,905,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791,4,['plugin'],['plugins']
Modifiability,"I don't know if there was a macOS update or something, but my configuration has gone funny as well. I find now that using `gcc --sysroot=...` rather than `gcc -isysroot=...` (note the missing `i` and the doubled `--`) works. I'm not 100% sure why this is the case - as far as I'm aware, the only difference between `--sysroot` and `-isysroot` is just that the latter only applies to includes and the former is both libraries and includes - but it works for me right now. I must be wrong in some way about the difference. Hopefully that works for you on a temporary basis. I'm sure Apple will be along shortly to change everything else up for us again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-769204657:62,config,configuration,62,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-769204657,1,['config'],['configuration']
Modifiability,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:88,plugin,plugins,88,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422,1,['plugin'],['plugins']
Modifiability,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:834,Variab,Variable,834,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,1,['Variab'],['Variable']
Modifiability,"I get the same issue on a [Travis CI build](https://travis-ci.org/github/qutech/filter_functions/jobs/757061484) with; ```; Distributor ID:	Ubuntu; Description:	Ubuntu 16.04.6 LTS; Release:	16.04; Codename:	xenial; ```; running on `amd64` with `qutip-4.5.2` installed via `pip`. The same test config runs fine on Python 3.6 and 3.7, though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352:293,config,config,293,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-777523352,1,['config'],['config']
Modifiability,"I get this error for anything less than nsteps = 1000000 (I've tried 5000, 10000, 50000, 100000, 500000) while using mesolve to get the dynamics of the system according to the Lindblad ME.; Details - It is a two qubit model, with both qubits coupled to baths and with inter-qubit coupling present. The solution for unit time with 100 divisions takes about 10 min but for any time interval greater than 1, I keep getting this error even with nsteps = 1000000, 5000000. Anything greater than that takes >2 hours to evaluate. ```python; import numpy as np; import matplotlib as plt; from qutip import *; from cmath import *; ```; Initial State:; ```; initialstate=tensor(fock_dm(2,0),fock_dm(2,0)); ```; Hamiltonian:; ```; epsilon=1; g=0.025; sigmaplus=0.5*(sigmax()+1j*sigmay()); sigmaminus=0.5*(sigmax()-1j*sigmay()); H=0.5*epsilon*(tensor(sigmaz()+qeye(2),qeye(2))+tensor(qeye(2),sigmaz()+qeye(2))) + g*(tensor(sigmaplus,sigmaminus)+tensor(sigmaminus, sigmaplus)). ```; Jump operators:; ```; gamma1=0.1; gamma2=0.05; T1=2; T2=0.05. diss_coeff=[cmath.sqrt(gamma1*(1/exp(epsilon/T1)-1)),cmath.sqrt(gamma1*exp(epsilon/T1)*(1/exp(epsilon/T1)-1)), cmath.sqrt(gamma2*(1/exp(epsilon/T2)-1)), cmath.sqrt(gamma2*exp(epsilon/T2)*(1/exp(epsilon/T2)-1))]. diss_oper=[diss_coeff[0]*tensor(sigmaplus, qeye(2)),diss_coeff[1]*tensor(sigmaminus, qeye(2)),diss_coeff[2]*tensor(qeye(2),sigmaplus), diss_coeff[3]*tensor(qeye(2),sigmaminus)]; ```; Time steps:; ```; tlist = np.linspace(0, 1, 100); ```; Using mesolve:; ```; dynamics=mesolve(H, initialstate, tlist,diss_oper, options=Options(nsteps=10000)) ; ```; Note: nsteps=1000000 in the line above evaluates in 7 min. Ideally, I would like to solve for time in the range (0, 400) but in the worst case, time range (0,250) will do (with about 1000 divisions). But, increasing nsteps is not an option because the evaluation takes too long. Are there any changes I can make for faster evaluation?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1623:280,coupling,coupling,280,https://qutip.org,https://github.com/qutip/qutip/issues/1623,1,['coupling'],['coupling']
Modifiability,"I guess it is my turn then :) ; I looked at the `orbital` function and compared it to the scipy implementation of `sph_harm` and the results don't seem to agree. There is one detail I need for clarification: The `orbital` function uses `ket`states as input. Which component of the `ket` state should refer to which configuration of `m`? . For example, if I pass `basis(3,0)` as argument is the corresponding setting `l = 1, m = -1` or `l = 1, m = 0` or `l = 1, m = 1`? ; I am not sure what the desired assignment is. For me it makes sense to start with the smallest `m` (in the example `m=-1`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700:315,config,configuration,315,https://qutip.org,https://github.com/qutip/qutip/issues/1839#issuecomment-1082393700,1,['config'],['configuration']
Modifiability,I guess the purpose is to reduce complexity and increase maintainability. I'm not sure how should I reduce this. Separate the input check and use another private method?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1028#issuecomment-505083482:57,maintainab,maintainability,57,https://qutip.org,https://github.com/qutip/qutip/pull/1028#issuecomment-505083482,1,['maintainab'],['maintainability']
Modifiability,"I had also the idea that showing from which base classes these solvers inherit would be enough, but since the issue asks to show `property` and `run` explicitly on each of the solver docs, then I opted do to it this way. Also, from my implementation, also other methods are now documented (e.g. add_integrator). Which I believe since these are public methods, they should be documented as well (?)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459:71,inherit,inherit,71,https://qutip.org,https://github.com/qutip/qutip/pull/2167#issuecomment-1566246459,1,['inherit'],['inherit']
Modifiability,"I have a simple task of maximizing $\text{Tr}(O \rho(T))$ using GRAPE where $O$ is a given fixed Hermitian matrix and $\rho(T)$ is a time-evolved quantum state under given Hamiltonian and time interval $[0,T]$. You can also think about this as maximizing trace overlap between two quantum states, if we set $O$ to be another density matrix. I've used all three different fidelitycomputers, but apparently all of them failed to optimize the cost function properly. I'd appreciate it much if anyone can help me understanding what I've been doing wrong! I attached a simple example code below with explanations:. 1. First, I initialized setups such as defining Hamiltonian, initial state, and target observable $O$. Then by creating `create_pulse_optimizer` as follows, I defined/initialized the dynamics as `dyn` with some randomly chosen initial amps. I tried all possible choices of `fid_type`. (see code below). <img width=""977"" alt=""grape_example1"" src=""https://user-images.githubusercontent.com/55151494/170385354-f7efe678-11fc-47de-afa7-ac77359bb5e0.png"">. 2. I then ran the optimization using GRAPE and reported its results. As shown below and in particular the very last line of the figure, the cost function I wanted to estimate is just $0$, whereas my task wants to maximize $\text{Tr}(O\rho)$. While testing several things, I changed $O$ to a ket vector (e.g. $|00>$) and it worked very well. So in principle, I thought the code should work properly as we can think of $O$ being a quantum state (e.g. $|00><00|$). . <img width=""1013"" alt=""grape_2"" src=""https://user-images.githubusercontent.com/55151494/170385858-eeddb7fb-f821-4057-8503-ee2a52e27805.png"">; <img width=""968"" alt=""grape_3"" src=""https://user-images.githubusercontent.com/55151494/170385868-7816a7ee-cc90-4dba-83dd-3304cd2404d8.png"">. I'd be great if someone points out what I'm missing here. One of my guesses of why this is happening is perhaps because we evolve a ket statevector while the target observable is in full matrix",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1900:138,evolve,evolved,138,https://qutip.org,https://github.com/qutip/qutip/issues/1900,1,['evolve'],['evolved']
Modifiability,"I have also found that using the iterative SS solver with the preconditioner gives invalid answers for large systems. The following code will give negative numbers of particles for both oscillators (the correct values should be 0.1 and 9.7 for a and b respectively :. from scipy import *; from qutip import *; from pylab import *; import time. Nc=6 #Number of cavity states; Nm=46 #Number of mechanical states; alpha=0.311 #Coherent state amplitude; g0=0.36 #Coupling strength; kappa=0.3 #Cavity damping rate; gamma=0.00147 #Mech damping rate; xvec=linspace(-10,10,500) #Wigner area and sampling; delta=0; # operators. idc=qeye(Nc); idm=qeye(Nm); a=tensor(destroy(Nc),idm); b=tensor(idc,destroy(Nm)); # Hamiltonian terms that do not depend on detuning or coupling. H=(-delta+g0_(b.dag()+b))_(a.dag()_a)+b.dag()_b+alpha*(a.dag()+a); # collapse operators. cc=sqrt(kappa)_a; cm=sqrt(gamma)_b; c_op_list=[cc,cm]; print('Beginning SS'); s=time.time(); # rho_ss=steadystate_direct(H,c_op_list,use_umfpack=True). rho_ss=steadystate_iterative(H,c_op_list,use_precond=False); print('SS Elapsed time: ',time.time()-s); numa=expect(a.dag()_a,rho_ss); numb=expect(b.dag()_b,rho_ss); print('cavity number ',numa); print('mech. number ',numb); rho_b=ptrace(rho_ss,1); W=wigner(rho_b,xvec,xvec); wmap=wigner_cmap(W); contourf(xvec,xvec,W,100,cmap=wmap); colorbar(); show()",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/29:459,Coupling,Coupling,459,https://qutip.org,https://github.com/qutip/qutip/issues/29,2,"['Coupling', 'coupling']","['Coupling', 'coupling']"
Modifiability,"I have come across the same problem. If you set g=2 you will have a different normalization for the Wigner function. W(0,0)=-0.63661977 is the 0,0 point of the single photon, which usually should be -1/pi so here we multiplied it by two. Same goes for g=1 where you divide it by 2 as far as I see. This does not change the normalization of the marginal distributions so all of those Wigner functions with different g are valid phase-space quasi-probabilities. What does change in fact with the factor g is the commutator relation [x,p]=a*i, where if g!=sqrt(2) a!=1. This will in fact change how we connect annihilation, creation, position and momentum operators together. ; In the case g=sqrt(2) we have the definition x=1/sqrt(2)(a^\dagger + a) and p = i/sqrt(2)(a^\dagger - a).; If we now consider the question at hand concerning the coherent state amplitude we easily understand what is happening. A coherent state is defined by the displacement operator D(\alpha) which is defined as D(\alpha)=Exp[\alpha a^\dagger - Conj[\alpha]a], where we can rewrite the exponential argument as Re(\alpha)(a^\dagger - a) + i Im(\alpha) (a^\dagger + a) which is Re(\alpha) p sqrt(2) + Im(\alpha) x sqrt(2). You can see that with this definition there is a scaling factor alpha/sqrt(2) if we want to plot it in x,p phase space. So all you need to do is rescale your amplitude.; If you instead want to have g=2 then there is no rescaling needed, but your commutator relation and therefore your Heisenberg uncertainty minimum will change.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1112#issuecomment-1970976650:1051,rewrite,rewrite,1051,https://qutip.org,https://github.com/qutip/qutip/issues/1112#issuecomment-1970976650,1,['rewrite'],['rewrite']
Modifiability,"I have found out how to use this after reading the source:; ```; python -m build -n -x --wheel --config-setting=""--global-option=--with-openmp""; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702:97,config,config-setting,97,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219669702,1,['config'],['config-setting']
Modifiability,I have just successfully installed qutip using pip into a fresh conda env (python=3.6) on Linux Mint. I believe this Mint is pretty much identical to Ubuntu.; All dependencies were installed automatically. qutip tests run fine.; So I don't think that there is anything wrong with our setup configuration.; Note we do not recommend installing qutip into a system python env - especially on Linux.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/739#issuecomment-323319515:290,config,configuration,290,https://qutip.org,https://github.com/qutip/qutip/issues/739#issuecomment-323319515,1,['config'],['configuration']
Modifiability,"I have not put any tests in for this, because it seems like a lot of effort for something that is used as a kind of testing tool anyway. When I make my PR for the hsolve enhancements, including tests, this file will get pretty reasonable coverage.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454#issuecomment-193176693:170,enhance,enhancements,170,https://qutip.org,https://github.com/qutip/qutip/pull/454#issuecomment-193176693,1,['enhance'],['enhancements']
Modifiability,"I have some detail information for the GSoC 2020 project ""Error mitigation in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub Wiki page. I post it here so if anyone finding it nice could copy it to the Wiki page. I add some details based on the original description:. -----------------------------------; ## 1. Error mitigation in QuTiP; From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum circuit simulator (which was a GSoC project) providing enhanced features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be fo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184:496,enhance,enhanced,496,https://qutip.org,https://github.com/qutip/qutip/issues/1184,1,['enhance'],['enhanced']
Modifiability,I have started this enhancement.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/101#issuecomment-39626760:20,enhance,enhancement,20,https://qutip.org,https://github.com/qutip/qutip/issues/101#issuecomment-39626760,1,['enhance'],['enhancement']
Modifiability,"I have two matrices `A` and `B`. I run. eigvals, eigvecs = simdiag([A, B]); and get. AttributeError Traceback (most recent call last); <ipython-input-8-966464195054> in <module>(); ----> 1 eigvals, eigvecs = simdiag([A, B]); /usr/lib/python3.6/site-packages/qutip/simdiag.py in simdiag(ops, evals); 82 eigvals, eigvecs = la.eig(A.full()); 83 zipped = zip(-eigvals, range(len(eigvals))); ---> 84 zipped.sort(); 85 ds, perm = zip(*zipped); 86 ds = -np.real(np.array(ds)); AttributeError: 'zip' object has no attribute 'sort'. The solution is to change the lines. zipped.sort(); in `simdiag` and the private function `degen` to. zipped = sorted(zipped); I did this and it works. However, I'm also wondering if there are plans to rewrite `simdiag` to be more numerically stable (if possible). I've found that the eigenvalues returned and the accuracy of the eigenvectors depends significantly on the order that they are passed. For instance, I know that `A` has integer eigenvalues, and when I run. eigvals, eigvecs = simuldiag([A, B]); eigvals[0]. I get. array([ 8., 7., 7., 7., 7., 7., 7., 7., 7., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6.,; 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 6., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5., 5.,; 5., 5., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4., 4.,; 4., 4., 4., 4., 4., 4., 4., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3.,; 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 3., 2., 2.,; 2., 2., 2., 2., 2., 2., 2., 2., 2., 2., ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/756:726,rewrite,rewrite,726,https://qutip.org,https://github.com/qutip/qutip/issues/756,1,['rewrite'],['rewrite']
Modifiability,I just checked the Intel distro. Their numpy config does not point to the correct location for the libraries. They point toward to compiler folders just like Anaconda did in the past. Will stick to Anaconda support for now.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204802167:45,config,config,45,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204802167,1,['config'],['config']
Modifiability,"I just noticed that this PR treats the dims keywords differently than the existing `rand_*` functions, and does not accept a list. I will extend this PR to include that functionality soon.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/316#issuecomment-74428511:138,extend,extend,138,https://qutip.org,https://github.com/qutip/qutip/pull/316#issuecomment-74428511,1,['extend'],['extend']
Modifiability,"I looked at the failures and they seem to be in parts that are completely disconnected from logging. I have no idea why they aren't also in the main branch, but I'll investigate. Anyway, I agree with you, @jrjohansson, that the current implementation is not in keeping with the design of Python's logging package. At the time, it was a bit of a hack to try and make it fit as well as possible, but I think in retrospect that may have been misguided. Do you think the refactoring to more appropriately use Python logging would be a good 3.2.0 feature, or would you suggest that for ≥ 3.3? Thanks!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/379#issuecomment-147493646:467,refactor,refactoring,467,https://qutip.org,https://github.com/qutip/qutip/pull/379#issuecomment-147493646,1,['refactor'],['refactoring']
Modifiability,I made this pull request as part of my bachelor thesis and to give something back to qutip. But this branch has not been touched for 5 years. Turns out @nonhermitian had it right from the start with his concerns about the maintainability. : ); I think you should close it. Keep up the good work!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/554#issuecomment-986276625:222,maintainab,maintainability,222,https://qutip.org,https://github.com/qutip/qutip/pull/554#issuecomment-986276625,1,['maintainab'],['maintainability']
Modifiability,"I managed to successfully install QuTiP in conda, however, installation verification resulted in a FAILED test: test_steadystate.py::test_driven_cavity_power_gmres - Exception: power-gmres failed to find solution in 1000 iterations. Instead of getting a test report I also got an infinite loop returning what you can see on the image below. I installed qutip using:; ```; conda config --append channels conda-forge; conda install qutip. import qutip.testing; qutip.testing.run(). ```; Any ideas why this would happen?; Any tips will be highly appreciated:); ![imagen](https://user-images.githubusercontent.com/85493516/148128436-33f94558-327e-4bed-a921-7bff732bc5d5.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1750:378,config,config,378,https://qutip.org,https://github.com/qutip/qutip/issues/1750,1,['config'],['config']
Modifiability,"I might want to have a Hamiltonian that is two consecutive different pulses. To do this in `mesolve` I just call it like this:. ```; mid_state = mesolve(H1, init_state, ...).states[-1]; end_state = mesolve(H2, mid_state, ...).states[-1]; ```. However in `mcsolve` I can not give a thousand initial states each to be considered as a single trajectory, so I have to use slower time dependent Hamiltonians. Would such an enhancement be welcomed? I will probably have to implemented it for myself anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/120:418,enhance,enhancement,418,https://qutip.org,https://github.com/qutip/qutip/issues/120,1,['enhance'],['enhancement']
Modifiability,"I noticed it because I have a code doing spinor lattice physics; the spinor piece is parameterized by the total angular momentum `F`. All of the operators are written as `tensor(spin_part, lattice_part)`. As part of a Brillouin zone unfolding code, I have reason to accumulate increasing powers of an operator in a loop, like. ```; original_state = tensor(basis(2*F+1, 0), basis(N, 0)); op = tensor(qeye(2*F+1), some_lattice_op); while True:; # ...; if occasionally_do_this:; op = base_op * op; transformed_state = op * original_state; ```. This code works fine, except for `F=0`. Since the `original_state` is a 1xN tensor state with `original_state.dims = [[1, N], [1, 1]]`, the `op * original_state` multiplication fails because `op = base_op * op` has deleted the `1` part of of `op`, leaving `op.dims = [[N],[N]]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/222#issuecomment-53928646:85,parameteriz,parameterized,85,https://qutip.org,https://github.com/qutip/qutip/issues/222#issuecomment-53928646,1,['parameteriz'],['parameterized']
Modifiability,"I noticed that while operating in the batch mode of function propagator, it is not possible to use a user-defined options for the ODE solver. After inspecting the source code of propagator, I noticed that the options variable is redefined by the sentence ""options=Options(normalize_output=False))"" inside the function at line 183. I think it means that whatever options we input to the function, it will be restored to the default options because of this sentence.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/843:217,variab,variable,217,https://qutip.org,https://github.com/qutip/qutip/issues/843,1,['variab'],['variable']
Modifiability,"I posted this issue on the QuTiP Tutorials GitHub repo, but it doesn't look like anyone is monitoring it. I've tried googling, but I only find stuff about making sure Imagemagick and Ghostscript are installed and they both are. I also made sure texlive was installed. When I try to generate a circuit diagram as follows:. > %matplotlib inline; > from qutip import *; > from qutip.qip.models.circuitprocessor import *; > from qutip.qip.models.spinchain import *; > ; > N = 3; > qc = QubitCircuit(N); > ; > qc.add_gate(""CNOT"", targets=[0], controls=[2]); > ; > qc.png; > . I get a stack trace. > FileNotFoundError Traceback (most recent call last); > <ipython-input-2-4489e338191c> in <module>(); > 4 qc.add_gate(""CNOT"", targets=[0], controls=[2]); > 5 ; > ----> 6 qc.png; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in png(self); > 1012 def png(self):; > 1013 from IPython.display import Image; > -> 1014 return Image(self._repr_png_(), embed=True); > 1015 ; > 1016 @property; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit.py in _repr_png_(self); > 1004 ; > 1005 def _repr_png_(self):; > -> 1006 return _latex_compile(self.latex_code(), format=""png""); > 1007 ; > 1008 def _repr_svg_(self):; > ; > /home/jhellmers/anaconda3/lib/python3.6/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); > 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; > 61 filename)); > ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; > 63 result = f.read(); > 64 else:; > ; > FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'; > . I'm using. My configuration information is as follows:. > Software	Version; > QuTiP	4.1.0; > Numpy	1.11.3; > SciPy	0.18.1; > matplotlib	2.0.0; > Cython	0.25.2; > Number of CPUs	4; > BLAS Info	INTEL MKL; > IPython	5.1.0; > Python	3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) [GCC 4.4.7 20120313 (Red Hat 4.4.7-1)]; > OS	posix [linux]; >",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/702:1666,config,configuration,1666,https://qutip.org,https://github.com/qutip/qutip/issues/702,1,['config'],['configuration']
Modifiability,"I propose opening a discussion on migrating from Travis CI to Github Actions workflow. It is a quite general and powerful framework, that allows to specify many [trigger events](https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow) and actions. . I have no intention of taking any action, but I think it may be a good thing to discuss. Happy to hear pros and cons.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1236:213,config,configuring-and-managing-workflows,213,https://qutip.org,https://github.com/qutip/qutip/issues/1236,2,['config'],"['configuring-a-workflow', 'configuring-and-managing-workflows']"
Modifiability,"I reactivated MKL, updated numpy to 1.22.0 and when running `import qutip.testing` I get the following error:. `Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""C:\ProgramData\Miniconda3\lib\site-packages\qutip\utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'`. Then as I wanted to provide my config I typed `import qutip` but it yielded the exact same error so I reverted it back to 1.20.3. QuTiP Version: 4.6.2; Numpy Version: 1.20.3; Scipy Version: 1.7.1; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.9.5; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Miniconda3\lib\site-packages\qutip. Why is it on OPENBLAS now?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725:449,config,config,449,https://qutip.org,https://github.com/qutip/qutip/issues/1750#issuecomment-1005876725,2,['config'],['config']
Modifiability,"I realised I never replied to this. I suggested `2*rtol` in this case because the error propagation in this case would guarantee that this is always sufficient. For other tests, we can always design the test so that it's calculable what the error term should be. I'd say it's generally a good idea to have the tests be as tight as we can possibly make them without risking false-negatives on the results, because otherwise we're not properly testing that the parameters do what they say. Regardless, that test failure isn't due to any of my PRs - it's a pre-existing problem that we happened to get unlucky on this time round. It'll get fixed when I modify `test_mesolve.py`. Can we review this PR to get the ball rolling on getting all of the test refactoring considered?. Possible reviewers: @Ericgig, @BoxiLi, @nathanshammah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133:749,refactor,refactoring,749,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133,1,['refactor'],['refactoring']
Modifiability,I solved this by adding C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\ to the PATH variable,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1026#issuecomment-506732671:101,variab,variable,101,https://qutip.org,https://github.com/qutip/qutip/issues/1026#issuecomment-506732671,1,['variab'],['variable']
Modifiability,I think I am pretty happy now with all my functions and variable names (for now). I would say we should leave the variable name changing and moving gates and measurement to separate files for a different PR (it can just be a restructuring one !). I was wondering how to check if it passes current tests (I am not sure what changes were there on Travis).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-637291687:56,variab,variable,56,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-637291687,2,['variab'],['variable']
Modifiability,"I think `hypothesis` is the best method here in the long term, but it will most likely have to be a long-term goal. I think the main pro in favour of it is that it actually is making an attempt to remove randomness; it's attempting to comprehensively test a spanning set of input parameters, rather than just Monte-Carlo'ing our way through and hoping. There's a couple of points which make it difficult to implement:. 1. QuTiP can be quite fragile with respect to unexpected input formats, particularly in older parts of the code.; 2. Various components are only accurate up to some tolerance, and the error propagation to work out how that corresponds to useful measurable quantities can be rather tricky. Those are certainly both solvable problems, and point 1 in particular is just general improvement of usability. The second point is about designing the tests well, which again is certainly doable, but will take a while (it takes long enough just to refactor them, let alone a total rewrite of large chunks of them!).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-629272663:957,refactor,refactor,957,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-629272663,4,"['refactor', 'rewrite']","['refactor', 'rewrite']"
Modifiability,"I think it would be nice to change the number of cpus to cpus_threads. I would image something like there would be a num_threads variable and then something like num_processes = num_threads_num_cpus, but that looks like it would require a lot of lines to be changed across many files?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/260:129,variab,variable,129,https://qutip.org,https://github.com/qutip/qutip/issues/260,1,['variab'],['variable']
Modifiability,"I think it would make sense to add to the current random quantum objects functionality support for sampling from a few more commonly-used distributions. In particular, the Ginibre and Haar distributions for density operators as well as the [Bruzda et al distribution for CPTP maps](http://www.sciencedirect.com/science/article/pii/S0375960108016885) would be quite nice to have sampling support for. I've written up all three of these based on existing QuTiP functions, such that if there's interest, it would be rather straightforward for me to make a PR for this enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/315:565,enhance,enhancement,565,https://qutip.org,https://github.com/qutip/qutip/issues/315,1,['enhance'],['enhancement']
Modifiability,"I think that @Ericgig makes a good point though. I think we should make the default install from source compile with `-march=native`. I think in the majority of cases this will be the best option for users. However, we need someway to turn it off, so that the conda-forge build will be more portable, and for the use-case illustrated in #920. Ok, I am going to merge this now, while we think of a more complete solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463692072:291,portab,portable,291,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463692072,1,['portab'],['portable']
Modifiability,I think the priority order should be. *. Default value from `qutip.hardware_info`; *. Value from configuration file if exists; *. Environment variable if set,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985674:97,config,configuration,97,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985674,2,"['config', 'variab']","['configuration', 'variable']"
Modifiability,"I think there are two separate issues here. . As for the fortran module, it's true that the it adds a lot of build complexity, but most users do not need it and can easily install qutip without it. There is a case for removing it from qutip and put it in a separate module, but think this should be low priority, since it would require non-negligible amount work, would break backwards compatibility (it should bump next release to 4.0), and does not really provide any new features (other than a less complex code base). There might users who rely on it and for them it might be annoying if we remove it. So I would vote for postponing it until there are very strong arguments for removing it. As for the topic of this issue, I think that qutip should follow the lead of NumPy, even if it breaks backwards compatibility in the configuration methods, so that users that are familiar with NumPy and related projects does not have any surprises when using qutip. Also, if I understand correctly, this would mostly change how one configure and build against blas libraries such as openblas? Then I guess it would not effect the typical user that just download and install the package with standard configuration (no site.cfg file), and it should be safe the follow the advice of the OP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155058653:828,config,configuration,828,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155058653,3,['config'],"['configuration', 'configure']"
Modifiability,"I tried running the same test with pytest and it fails.; ```; ============================= test session starts ==============================; platform darwin -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0; rootdir: /Users/shahnawaz/Dropbox/dev/qutip, inifile:; plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3; collected 13 items. test_superop_reps.py ..Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458572211:270,plugin,plugins,270,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458572211,1,['plugin'],['plugins']
Modifiability,"I was imagining something much simpler for the exception class. There is a backport of the exceptiongroup stuff to older Pythons that we could use if we wanted to: https://pypi.org/project/exceptiongroup/. It's another dependency, but it will mean that on Python 3.11 people could start using ExceptionGroup and `except*` immediately if they wanted to. Users on Python 3.10 and below would have to catch ExceptionGroup or use the backport's ugly `with catch(...)` mechanism. . Then, many years from now when Python 3.10 is obsolete, we could drop the backport entirely. Personally I'm in favour of the simpler `ParallelMapException` that doesn't inherit from all the other exceptions. Then when 3.11 is out we can make `ParallelMapException` inherit from `ExceptionGroup` and 3.11 users will be able to use `except*`. People supporting 3.10 and below will have to use `except ParallelMapException`, but that will work just as well on 3.11.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437:646,inherit,inherit,646,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209370437,4,['inherit'],['inherit']
Modifiability,"I was surprised to see that the color argument was added long time ago for the point methods. These were not ported to master. These changes break backwards compatibility as code that used `point_colors` will not work anymore. I wonder if this change of variable name is something we want to keep as it should be possible to keep the behavior backwards compatible AND include the new colors argument (which I think is a very necessary feature that motivated me to clean the code in master in the first place, I later realized that this was already added in dev.major).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026:254,variab,variable,254,https://qutip.org,https://github.com/qutip/qutip/pull/1909#issuecomment-1141357026,1,['variab'],['variable']
Modifiability,"I was wondering if configuring a bot might be beneficial for some tasks. For example, checking that the code is well formatted with `black`. Examples are given by Sympy and Cirq (although there they use it for CLAs). . https://github.com/topics/bot. This could also be a fun project for a student (or coder in general) willing to contribute to QuTiP on the software side instead of the physics side. . Maybe though, any interesting feature of a bot can be put in place by a given specific API.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1089:19,config,configuring,19,https://qutip.org,https://github.com/qutip/qutip/issues/1089,1,['config'],['configuring']
Modifiability,"I worked around this by doing; ```py; import qutip; import the_library # this sets the log level to DEBUG; import logging; logging.getLogger().setLevel(logging.WARNING); ```; I supposes that it's a bit weird/wrong that the library sets the log level like that, and maybe it's understandable that qutip has somewhat automatic logging for IPython. The real issue is that the config for `log_handler` is broken. I could possibly submit a PR for that at some point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1156#issuecomment-578627722:373,config,config,373,https://qutip.org,https://github.com/qutip/qutip/issues/1156#issuecomment-578627722,1,['config'],['config']
Modifiability,"I would like to add the Underdamped Lorentzian spectral density to the HEOM and realised that there should be some discussion on the design. For this specific PR, I am in two minds: . A. I follow the previous code and make a `HSolverUnderDampedBrownian` class. This will be quite different from the HSolverDL class as now, we will take the coefficients ck and vk separately for the non-Matsubara part and then the Mastsubara part and combine them to get the RHS instead of computing them from the coupling strength as before. B. Rewrite a new `Heom` class with the `configure` method taking the ck and vk values and not caring about the spectral density. We add some additional functions to compute the cks and vks based on Drude-Lorrentz, Underdamped Lorrentzian or Ohmic spectral density. We can even do a numerical fitting for the coefficients using the `bath_correlation` function that I added now for any arbitrary spectral density and then feed it to the `configure` method of the new `Heom` class to build the RHS. This is a more generic version of the HEOM which separates the method from specific spectral densities and is close to implementing the following version that is simplified from @nwlambert 's paper :. ![screenshot 2019-03-05 14 41 25](https://user-images.githubusercontent.com/6968324/53809476-16468080-3f55-11e9-90bd-50159a075663.png). I am leaning more towards B and re-structuring the HEOM functions to seperate the SD and the implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962:497,coupling,coupling,497,https://qutip.org,https://github.com/qutip/qutip/pull/962,4,"['Rewrite', 'config', 'coupling']","['Rewrite', 'configure', 'coupling']"
Modifiability,"I would not worry too much about codeclimate, but:; - some of the errors are arising due to trailing whitespaces. This is an easy fix; - in some cases, the ""cognitive complexity"" is very high. For example here:; ```; __init__ has a Cognitive Complexity of 68 (exceeds 5 allowed).; ```; Maybe it is worth considering some code refactoring.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1066#issuecomment-575498581:326,refactor,refactoring,326,https://qutip.org,https://github.com/qutip/qutip/pull/1066#issuecomment-575498581,1,['refactor'],['refactoring']
Modifiability,"I would rather have the styling checks part of CI than pre-commit. Pre-commit hooks are a nice way to automate repetitive tasks, but for coding conventions, each developer tends to have their own setup (e.g. I would run black or pyflakes as a plugin in my editor, so that I get immediate feedback or fixes long before making a commit). Pre-commit hooks are also a poor choice for checking that coding style is followed, because developers will have different operating systems, difference versions of Python, black, pyflakes, etc, etc and so there are certain to be differences between what is considered correct by the scripts run by different developers. Finally, there are many valid reasons to commit broken code into branches, and I would not want to prevent that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467:243,plugin,plugin,243,https://qutip.org,https://github.com/qutip/qutip/issues/1742#issuecomment-1001477467,2,['plugin'],['plugin']
Modifiability,"I would still prefer `qutip.extensions`, `qutip.ext` or maybe `qutip.extra` rather than `qutip.services` because although picloud and tskmon can properly be called services, I think that if we pursue the idea of having extra utitlities like this in the qutip project we should take a broader approach and call it extensions, which may or may not be services. These would have to be completely isolated from the rest of the qutip code base (including the configuration file parser).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-63908501:454,config,configuration,454,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-63908501,1,['config'],['configuration']
Modifiability,"I'd be interested in providing these changes. I have a few points to ask/consider:; 1. which function is meant by `zero_oper()`? I can't find any reference to it in the code, and judging by the name, I'd guess it's equivalent to `qzero()`, which already supports this.; 2. should we extend the automatic tensoring to other operators, e.g. `create()`, `destroy()`, and so forth? I can't necessarily think of any particular use-case, but _not_ having it causes an odd inconsistency with `qeye()`.; 3. for `projection()` and `basis()` in particular: should the interface allow only scalar `m` and `n`, which must be the same for all dimensions, or should there be broadcasting rules? The latter seems like a more useful choice to me, with the rules for all arguments being:; - if `m` is a list, then `max_len == len(m)`; - if `m` is a scalar, then `m = [m] * max_len`. For example, this would provide `tensor(basis(2, 0), basis(2, 1)) == basis(2, [0, 1]) == basis([2,2], [0, 1])`, which seems the ""least surprising"" to me.; 4. should there be error-checking that supplied scalars/lists are the correct format? For lists in particular, the current behaviour is to silently flatten nested lists, though this is presumably a user error.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/363#issuecomment-575273170:283,extend,extend,283,https://qutip.org,https://github.com/qutip/qutip/issues/363#issuecomment-575273170,1,['extend'],['extend']
Modifiability,"I'll have to trust you mostly on actual operation of the code, but it looks like you've covered everything I could see as particular problems. I don't use this part of QuTiP, so I'm really not the best placed person to talk about how natural the APIs seem or anything like that. I'm still a fan of fixing the issues CodeClimate is complaining about because I think the cognitive complexity tests are a semi-decent indicator of maintainability, but at the end of the day, you're the code owner and that's your call. The other seemingly major potential headache is the dependence on that internal `_EvoElement` API in `QobjEvo` - I know for sure that that's going to go to hell in 5.0 - but I get that this PR didn't really cause this, so that's maybe a problem for another time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444#issuecomment-815033004:427,maintainab,maintainability,427,https://qutip.org,https://github.com/qutip/qutip/pull/1444#issuecomment-815033004,1,['maintainab'],['maintainability']
Modifiability,"I'll take a look at the merge. It seems like it might have gone bad. I'll add in some tests once I fix the merge, as well. I'll look into the diag method and try to move everything over to separate; everything as you described. On Wed, Jun 28, 2023, 3:43 PM Eric Giguère ***@***.***> wrote:. > ***@***.**** requested changes on this pull request.; >; > Are you sure there was not a bad merge somewhere?; > Some code is duplicated, seemingly important variable are never used, a; > typo in the import of flimesolve.py stop it from being imported, etc...; >; > Please add tests covering most case and have them passing.; >; > Also the separation of task is not well used. We split the data container,; > ODE integration and the physics, but here they are mixed together...; >; > The quicksolve is the ""diag"" integrator, you don't have to re implement it; > here. You could just set it as the default method since the rhs is always; > constant (but it seems like this is not desired when time_sense != 0).; > ------------------------------; >; > In doc/guide/scripts/floquet_ex3.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245104940>:; >; > > @@ -35,7 +35,6 @@ def noise_spectrum(omega):; > # Alternatively; > psi_t = output.states[idx]; > p_ex[idx] = qutip.expect(qutip.num(2), psi_t); > -; >; > Why did you erase this line?; > ------------------------------; >; > In VERSION; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245585117>:; >; > > @@ -1 +1 @@; > -5.0.0.dev; > +5.0.0a1; >; > The version change when we do a release, not with each PR.; > ------------------------------; >; > In qutip/solver/correlation.py; > <https://github.com/qutip/qutip/pull/2186#discussion_r1245591365>:; >; > > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; >; > ⬇️ Suggested change; >; > - G1 = correlation_3op(; > - solver, state0, [0], taulist, None, a_op.dag(), a_op)[0]; > + G1 = correlation_3op(; > + solver, state0, [0], taulist, None, a_op.dag",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847:451,variab,variable,451,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1612045847,2,['variab'],['variable']
Modifiability,I'm +1 on having auto tidy up being a feature of the individual data layers. Could the auto tidy up setting perhaps be passed down to the data layers and then each layer can handle it in a way that seems sensible to the data layer?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259:69,layers,layers,69,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882525259,2,['layers'],['layers']
Modifiability,"I'm not at all a fan of making tests part of the public interface like this. It's something that we make absolutely no stability guarantees about, and coupling downstream packages to our own tests just sounds like a recipe for disaster - if we find a bug in main QuTiP and need to change tests or add methods (which we should be able to do completely freely), we're going to inject a ton of extra code into downstream packages, and may completely break them. To be honest, I'm not even wild about how we distribute our tests as part of the module code at all, but that's what we've got. It _could_ be ok if you import the test case base, and redefine your tests from there. We still don't make any stability guarantees about that, but it's conceivable that we could (though of course, the problem of ""what if we need to add methods"" persists). That would also solve your problems about saying you can't import individual tests. You can import individual tests anyway, you just need to rename them to things like `_TestAdd`, or use one of the pytest hooks in your local `conftest.py` to reject tests whose `__module__` isn't your local module, or do one of the other methods of filtering.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355:151,coupling,coupling,151,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-976540355,1,['coupling'],['coupling']
Modifiability,"I'm not entirely sure what's being asked here. `mcsolve` evolves the state `psi0` by the given Hamiltonian for the given times, and returns a `qutip.solver.Result` object that contains various quantities, such as how the state evolved for each of the trajectories at a given time, and values of expectation operators at those times if `e_ops` is given. This looks like a question that's best answered by [reading the user guide on solving system dynamics](http://qutip.org/docs/latest/guide/dynamics/dynamics-monte.html).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1189#issuecomment-809405566:57,evolve,evolves,57,https://qutip.org,https://github.com/qutip/qutip/issues/1189#issuecomment-809405566,4,['evolve'],"['evolved', 'evolves']"
Modifiability,"I'm seeing the same segfault when trying to run the tests on MacOS. I'm using the following script `run_tests.sh` in the qutip root folder for running the tests:; ~~~; #!/usr/bin/env bash; python3 -m venv venv; ./venv/bin/pip install -r requirements.txt; ./venv/bin/pip install pytest matplotlib ipython; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~; This results in the attached [`test.log`](https://github.com/qutip/qutip/files/4307785/test.log). This is for the 4.5.1 release candidate, but I'm getting the same segfault on the current `master` (01132789581821517986fad1a14ab3feec7d2de2)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596633885:424,config,config,424,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596633885,2,['config'],['config']
Modifiability,"I'm trying it now on a Windows without ImageMagick installed. However, it finds a wrong executable `convert`, which is a default command on Windows...... Is there a way to identify if the `convert` is the one we want? Otherwise, we can also just catch the CalledProcessError at line 148 and add an instruction. ```; 147 in_file = file_stem + "".pdf""; 148 out_file = file_stem + ""."" + configuration.file_type; --> 149 _run_command((which, *configuration.arguments, in_file, out_file)); 150 with open(out_file, mode) as file:; 151 return file.read(). ~\Miniconda3\envs\qutip-dev-py3\lib\subprocess.py in run(input, capture_output, timeout, check, *popenargs, **kwargs); 485 if check and retcode:; 486 raise CalledProcessError(retcode, process.args,; --> 487 output=stdout, stderr=stderr); 488 return CompletedProcess(process.args, retcode, stdout, stderr); 489 . CalledProcessError: Command '('convert', '-density', '100', 'qcirc.pdf', 'qcirc.png')' returned non-zero exit status 4.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125:383,config,configuration,383,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125,2,['config'],['configuration']
Modifiability,"I'm using. My configuration information is as follows:. Software	Version; QuTiP	4.5.2; Numpy	1.18.5; SciPy	1.5.0; matplotlib	3.2.2; Cython	0.29.21; Number of CPUs	6; BLAS Info	INTEL MKL; IPython	7.16.1; Python	3.8.3 (default, Jul 2 2020, 11:26:31) [Clang 10.0.0 ]; OS	posix [darwin]; Fri Sep 18 02:42:59 2020 MSK. For Mac OS: FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'.\. When I try to generate a circuit diagram as follows:. %matplotlib inline; from IPython.display import Image; from numpy import pi; import numpy as np; from qutip import *; from qutip.qip.operations import *; from qutip.qip.circuit import QubitCircuit, Gate. cphase(pi/2); q = QubitCircuit(2, reverse_states=False); q.add_gate(""CSIGN"", controls=[0], targets=[1]); q.png. Log Error:. ---------------------------------------------------------------------------; FileNotFoundError Traceback (most recent call last); <ipython-input-14-a760fe8d2360> in <module>; 1 q = QubitCircuit(2, reverse_states=False); 2 q.add_gate(""CSIGN"", controls=[0], targets=[1]); ----> 3 q.png. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit.py in png(self); 1122 def png(self):; 1123 from IPython.display import Image; -> 1124 return Image(self._repr_png_(), embed=True); 1125 ; 1126 @property. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit.py in _repr_png_(self); 1114 ; 1115 def _repr_png_(self):; -> 1116 return _latex_compile(self.latex_code(), format=""png""); 1117 ; 1118 def _repr_svg_(self):. ~/opt/anaconda3/lib/python3.8/site-packages/qutip/qip/circuit_latex.py in _latex_compile(code, filename, format); 60 os.system(""convert -density %s %s.pdf %s.png"" % (100, filename,; 61 filename)); ---> 62 with open(""%s.png"" % filename, ""rb"") as f:; 63 result = f.read(); 64 else:. FileNotFoundError: [Errno 2] No such file or directory: 'qcirc.png'. How do I fix this error on Mac?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/702#issuecomment-694558061:14,config,configuration,14,https://qutip.org,https://github.com/qutip/qutip/issues/702#issuecomment-694558061,1,['config'],['configuration']
Modifiability,"I'm very surprised to see that there is a failing test on qutip.qip, which is pure python and is unlikely to be platform dependent. I have a guess that this one may have something to do with pytest parameterization. I had a problem with that on Mac OS (not M1) before, which I still don't fully understand and I left a comment back then:; https://github.com/qutip/qutip/blob/3ff3f42d2cd950c99af8936b12d9221ed79de5e3/qutip/tests/test_scheduler.py#L92-L94; If I split the test and run them (`test_scheduling_gates2` and `test_scheduling_gates3`) one by one, it is fine. But if I use pytest parameterization to initialize several of them, it fails. And now this time it happens at exactly the same place. If you would like to, you can copy that failing test and run it (without using pytest parameterization but giving the input explicitly) in a Python console. If it works well, then my guess should be right. But it doesn't apply to all other failing tests I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078:198,parameteriz,parameterization,198,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007367078,3,['parameteriz'],['parameterization']
Modifiability,"I've also thought of making these ENH proposals I made as sort of QuTiP Enhancement Proposals (QEP), similarly to PEP and NEP. So far, keeping them as ENH and Q&A github issues may be fine. Or one could possibly use the Projects section of Github, too, but there is no possibility for others to chip in there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1188#issuecomment-593255331:72,Enhance,Enhancement,72,https://qutip.org,https://github.com/qutip/qutip/pull/1188#issuecomment-593255331,1,['Enhance'],['Enhancement']
Modifiability,"I've bumped this to QuTiP 5, since that seems a more polite time to change the default configuration directory than 4.7.1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744:87,config,configuration,87,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758744,1,['config'],['configuration']
Modifiability,"I've found `pytest` to be extremely nice to work with. One advantage is that `pytest` will also pick up and run `nose` tests, so there is no need to rewrite all of the existing tests. At the same time, new tests will be easier to write, as `pytest` has much less boilerplate code than `nose`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/958#issuecomment-488824031:149,rewrite,rewrite,149,https://qutip.org,https://github.com/qutip/qutip/issues/958#issuecomment-488824031,1,['rewrite'],['rewrite']
Modifiability,"If it helps in the future, you can use `pycodestyle` (available in `pip` and `conda`) to check pep8 compliance on your end before pushing a commit. As to the actual command, we might not actually want to remove the usage of `convert` - it's quite possible that a lot of people are still using ImageMagick 6, since for most people it's just a dependency that got installed by something else, and isn't frequently updated. `qutip` doesn't list it as an official dependency, so it wouldn't get updated on our behalf. We could catch which version of `ImageMagick` to use with something like; ```python; def _magick_comamnd():; for command in ['magick', 'convert']:; try:; subprocess.run((command, '--version'), capture_output=True); return command; except OSError:; pass; raise FileNotFoundError(""Couldn't locate system ImageMagick""); ```; and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; ```python; subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); ```; or something like that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473:883,variab,variable,883,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473,1,['variab'],['variable']
Modifiability,"If it's something we want to support, we'll need a bit of a rewrite of the data-layer testing infrastructure, but nothing too major. I'd be in favour of a bit of a larger restructure:; - rearrange the repo root to have `/src/qutip` and `/test/qutip` instead of `/qutip/tests` (I originally didn't like it, but I now see more and more benefits of the `/src` (or `/lib`) convention in Python projects).; - the current `qutip/tests` should entirely become `/test/qutip`; - a new `/src/qutip/test` becomes a fully-supported _public_ module, including base classes (such as the data-layer mixins) and things like that. We'd need to be careful, because reducing your possibilities for flexibility in testing generally sounds like a bad idea to me, but if we take care to be very limited, it could work. I suspect you won't be able to import the test suite from inside `qutip.core.data` because of cyclical dependencies, which is probably a good thing - it'll force us to put the structure the right way round immediately. For an idea pretty far out of left field:; - the data layer tests should really _discover_ the specialisations rather than us needing to specify them (this is true regardless of this PR); - if so, in the new form, we _could_ directly export this part of the test suite from `qutip.test` (our test suite would import this as well), and add a little bit of logic to allow filtering of which tests need to be run (class decorators, probably); - downstream packages could then test just by importing our classes and disabling any specialisations that are only on internal data-layer objects. I'm not 100% sure how I feel about this, but it's plausible - we'd still be able to add extra methods in our own test suite if we wanted them, because we could just derive from the classes, rather than defining the names into the test suite in those cases. ---. About us breaking downstream CI: having been a maintainer of QuTiP and now Qiskit, I have a deep-rooted hatred for any upstream package",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075:60,rewrite,rewrite,60,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-979917075,1,['rewrite'],['rewrite']
Modifiability,"If those editors claim to provide terminal emulation it should be reported as bugs to them. However, even if it is fixed there it will take a long time before such a fix would reach end-users. I think in the interest of avoiding regressions I think we should restore the previous TextProgressBar and rename the current one to EnhancedTextProgressBar or something like that. Then this new progress bar would not disrupt peoples workflow and users who wants to use it can do so by creating an instance of it and pass it to progress-bar enabled functions using the progress_bar keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63267628:326,Enhance,EnhancedTextProgressBar,326,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63267628,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"If we look at https://github.com/cython/cython/issues/4310, they plan to deprecate the compilation time `IF` in a future release.; They suggest using cmacro or code generation to replace this. I suggest to take more time thinking about this and use those method instead. As it is, we would have to set a compilation environment variable each time something want to `cimport Data`, even from outside qutip...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990:328,variab,variable,328,https://qutip.org,https://github.com/qutip/qutip/pull/1727#issuecomment-1104573990,1,['variab'],['variable']
Modifiability,"If you have extra_link_args in the site.cfg, then a double keyword argument; happens when reading the options for the blas library. If you use openblas, add this to your site.cfg; [openblas]; extra_link_args = ... whatever ... and the error will happen.; The error is this. TypeError: config.add_extension() got multiple values for keyword argument; 'extra_link_args'. 2015-11-08 21:12 GMT+01:00 Paul Nation notifications@github.com:. > I do not get a build failure under NumPy 1.10.1. What was the particular; > error message? Any changes would also have to be backward compatible with; > earlier NumPy versions.; > ; > —; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/392#issuecomment-154863591. ## . Kind regards Nick",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-154867711:285,config,config,285,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-154867711,1,['config'],['config']
Modifiability,"If you install from source from the master branch with the environment variable `CI_QUTIP_WITH_IDXINT_64=1` set, you should be able to use matrix with size up to `2**63-1`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/853#issuecomment-1785174200:71,variab,variable,71,https://qutip.org,https://github.com/qutip/qutip/issues/853#issuecomment-1785174200,1,['variab'],['variable']
Modifiability,"ImageMagick is only mentioned in our tutorial page and not listed elsewhere. So we didn't specify a required version for it. . > We could catch which version of `ImageMagick` to use with something like; > ; > ```python; > def _magick_comamnd():; > for command in ['magick', 'convert']:; > try:; > subprocess.run((command, '--version'), capture_output=True); > return command; > except OSError:; > pass; > raise FileNotFoundError(""Couldn't locate system ImageMagick""); > ```; > ; > and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; > ; > ```python; > subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); > ```. This solution looks neat. One minor thing is that maybe we should use `check=True` instead of `capture_output=True` since the latter one is only available from Python 3.7+. Despite those has already been discussed above, the plot sill does not work for me. I find the following lines also wrong on Windows; ``` python; os.system(""rm -f %s.aux %s.log"" % (filename, filename)). os.system(""mv %s-tmp.pdf %s.pdf"" % (filename, filename)); ```; because `rm` and `mv` are not Windows command. We should probably replace it by python script `os.remove` and `os.replace` to make it system independent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793:528,variab,variable,528,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793,1,['variab'],['variable']
Modifiability,"In #1339 I pointed out that the test files were being incorrectly counted in the coverage statistics when running on Travis. This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally ver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1347:469,config,configuration,469,https://qutip.org,https://github.com/qutip/qutip/pull/1347,3,['config'],"['configs', 'configuration']"
Modifiability,"In `smesolve` if heterodyne detection is chosen and custom measurement operators are provided, the variable `m_ops` is used before being declared [here](https://github.com/qutip/qutip/blob/1253740be0600315286438d1a64f172920b0dadc/qutip/solve/stochastic.py#L604). A quick fix would be changing this line to; ```python; if sso.m_ops is None:; sso.m_ops = m_ops; ```; But probably adding some checks (correct shape, and whether the measured ops look like quadratures) would be nice. Thank you for the tremendous work, by the way!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2078:99,variab,variable,99,https://qutip.org,https://github.com/qutip/qutip/issues/2078,1,['variab'],['variable']
Modifiability,"In addition to cherry picking from #246, I think that gets rid of the suprious warnings when either `configobj` or `~/.qutiprc` is missing. Is there any other outstanding issue that I can address to make this more useful?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-63155472:101,config,configobj,101,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-63155472,1,['config'],['configobj']
Modifiability,"In doctest, we can add an option which runs specific commands only conditionally. This is already the case right now for parfor. It can be configured before building in conf.py.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1534#issuecomment-675696166:139,config,configured,139,https://qutip.org,https://github.com/qutip/qutip/issues/1534#issuecomment-675696166,1,['config'],['configured']
Modifiability,"In file [propagator.py](https://github.com/qutip/qutip/blob/master/qutip/propagator.py), near line 119:; ```python; td_type = _td_format_check(H, c_op_list, solver='me')[2]; if td_type > 0:; rhs_generate(H, c_op_list, args=args, options=options); ```; The performance would be improved if this code checked for the presence of an already compiled tdfunc like this:; ```python; if td_type > 0 and config.tdfunc is None:; ...; ```; which only requires an additional import of the config object from qutip.solver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/555:396,config,config,396,https://qutip.org,https://github.com/qutip/qutip/issues/555,2,['config'],['config']
Modifiability,"In qutip-tensoflow, we aim to include TensorFlow's autodifferentiation with Qobj. However, this will require the following code to work:; ```python; import numpy as np; import qutip. random_matrix = np.random.random((2, 2)) + 1j * np.random.random((2, 2)); complex_number = np.random.random((1, 1)) + 1j * np.random.random((1, 1)). qobj = qutip.Qobj(random_matrix); qobj*complex_number; ``` ; I used numpy `ndarray` instead of a `tf.Tensor` or `tf.Variable` for simplicity and so that the example is reproducible. . Currently this example raises: ; ""TypeError: incompatible dimensions [[2], [2]] and [[1], [1]]""; as `__mul__(self, other)` defaults to `__matmul__(self, other)` when `other` is not an instance of `numbers.Number`. . If instead we do:; ```python; complex_number*qobj; ```; The error raised is:; ""TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'Qobj'""; This error is different because `__rmul__` checks first for `other` being an instance of `numbers.Number` and if not, it raises `NotImplementedError`. It does not check whether `Qobj(other)` works. I would say this is undesired and that `__rmul__` should try first converting `other` into `Qobj` and not assume that other is already `Qobj`. . **Describe the solution you'd like**; I would like to suggest either:; 1) changing the behaviour of `matmul` dispatcher so that (1,1) shaped data is multiplied element wise by default. However this, although not terrible, it breaks conceptually what matmul is, as a (1,1) x (2,2) matrix multiplication can not happen. 2) Allow `mul` dispatcher to have as input a `Data` object. In this way we would raise an error when the `Data` for `mul` dispatcher is not of shape (1,1) and perform an elementwise multiplication when it is. I am not sure how difficult it is to code this. 3) Create `mul_elementwise` dispatcher to have as input two `Data` objects and perform elementwise multiplication. Another change that I would like to suggest is to add a check in `__rmul__` to see",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607:448,Variab,Variable,448,https://qutip.org,https://github.com/qutip/qutip/issues/1607,1,['Variab'],['Variable']
Modifiability,"In the latest commit I refactored the `entropy_vn_dicke` and `purity_dicke` functions in terms of a more general function, `dicke_trace`, which accounts for adding with the correct weight the blocks of a density matrix in the Dicke basis. The `dicke_trace` function can be used by other similarly nonlinear functions that involve taking the trace of a Taylor-expandable function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1046#issuecomment-514997016:23,refactor,refactored,23,https://qutip.org,https://github.com/qutip/qutip/pull/1046#issuecomment-514997016,1,['refactor'],['refactored']
Modifiability,"In the mcsolver function, it seems that (read from tutorial) the **quantum jumps** happen when a random number is generated larger than **(1-dp)**, where **dp** is no jump probability. And this is the only option for jumping in the algorithm. . In theory, there is another strategy to choose **jump**--that is to use the concept of **waiting time** (see Dum and Zoller's PRA **45** (7), 1992 paper, for example). That is to say, we check the no jump time **t** to see if it is longer than the waiting time $\tau$: if **t** is longer, then a quantum jump happens; otherwise, there is no jump. . Could anyone make the mcsolver flexible enough to let users freely to choose which strategy to use in the algorithm? Each of these two strategies have different meanings and their own advantages: the jumping probability strategy is good for simulating measurement models; the waiting time is more efficient if one just wants to know the averaged result. . If currently none can implement this idea, could you provide a direction for me to write another mcsolver to use the counterpart strategy of jumping? Thanks. Regards,; Qi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111:625,flexible,flexible,625,https://qutip.org,https://github.com/qutip/qutip/issues/111,1,['flexible'],['flexible']
Modifiability,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:124,parameteriz,parameterization,124,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135,1,['parameteriz'],['parameterization']
Modifiability,"It appears that the coefficients in your Hamiltonian are large, and the time-dependent part of the Hamiltonian oscillates very rapidly, The result is that the solver does not by default take small enough time steps when evolving the state. You can fix this by specifying a `max_step` to the `Options`:; ```python; max_step = 1. / (100 * gamma); options = Options(max_step=max_step, nsteps=10000); ```; With this max_step the solver correctly evolves the system for me. Closing this for now, but please feel free to continue the discussion here as needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677:442,evolve,evolves,442,https://qutip.org,https://github.com/qutip/qutip/issues/2051#issuecomment-1366076677,1,['evolve'],['evolves']
Modifiability,"It is actually basically the same thing. However, there are several technicalities that need to be addressed in the implementation. For example, one does not know the collapse times a priori, so one has to evolve pass this time and then take a step back. Can also see:. Monte Carlo simulation of the atomic master equation for spontaneous emission; R. Dum, P. Zoller, and H. Ritsch; Phys. Rev. A 45, 4879 – Published 1 April 1992",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/344#issuecomment-105088915:206,evolve,evolve,206,https://qutip.org,https://github.com/qutip/qutip/issues/344#issuecomment-105088915,1,['evolve'],['evolve']
Modifiability,"It is not discouraging at all, quite the contrary. Thank you very much for; looking at it and taking the time to let me know your thoughts. I will take; peek on #1181 and provide any help I can. Regarding the PEP changes: I am extremely inexperienced with this project; and contrasted my ideas with others such as Qskit and projectQ before; proceeding. I also find that this refactoring can be excessively thorough; and not needed since it breaks backwards compatibility.; On the other side, I knew these changes would not go through to master but; they can serve some purpose as to help me get a better understanding of the; library as well as get in touch with the community. It also helped me on; how to approach potential improvements for the tool.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603579386:375,refactor,refactoring,375,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603579386,1,['refactor'],['refactoring']
Modifiability,"It is possible that someone having trouble compiling qutip extensions may wish to set CFLAGS, CPATH, C_INCLUDE_PATH. Currently these would not be used in the qutip installation / building or extensions generally. I had a scenario where I was trying to install qutip on machines which I did not have sudo access on. They did not have cython or pydev. So I managed to install pydev and cython into the home folder. For the latter I had to set the C_INCLUDE_PATH to the local install of the C headers, or maybe I used the -I switch with CFLAGS. This did not work for qutip, so I made some changes to the `setup.py` files, and also the `pyximport` in `__init__.py`. However, none of it worked due to disk space issues in the end. Clearly, if there had been enough disk space, then Anaconda would have been a much better solution. So, the question are: ; 1. Is there any value in making a PR from the changes I made (in a local copy) to use the CFLAGS, CPATH, C_INCLUDE_PATH env vars if they are set?. 2. If so should the qutip pyximport extend or prepend the CFLAGS or should it not set CFLAGS at all if the user has set values?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/571:1033,extend,extend,1033,https://qutip.org,https://github.com/qutip/qutip/issues/571,1,['extend'],['extend']
Modifiability,"It looks as though NumPy keeps some metadata on MKL if it was compiled with MKL support. The `numpy.__config__` module in particular gives a path to the directory that NumPy loads its MKL libraries from. On my Linux box, for instance:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_intel_lp64', 'mkl_intel_thread', 'mkl_core', 'iomp5', 'pthread']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['/home/cgranade/anaconda/lib']; ```. The case seems to be worse for Anaconda on Windows (naturally), with `C:\aroot\stage\` taking the place of the actual Anaconda root:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_core_dll', 'mkl_intel_lp64_dll', 'mkl_intel_thread_dll']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['C:\\aroot\\stage\\Library\\lib']; ```. In the case that NumPy is compiled without MKL support, it seems to just omit the `mkl_info` dict entirely:. ``` bash; cgranade@berith:~$ source activate py27-nomkl; discarding /home/cgranade/anaconda/bin from PATH; prepending /home/cgranade/anaconda/envs/py27-nomkl/bin to PATH; cgranade@berith:~$ ipython; Python 2.7.11 |Anaconda custom (64-bit)| (default, Dec 6 2015, 18:08:32); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 4.0.3 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); <ipython-input-2-ebe4f6e784e1> in <module>(); ----> 1 print(numpy.__config__.mkl_info['libraries']). AttributeError: 'module' object has no attribute 'mkl_info'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204251671:1366,enhance,enhanced,1366,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204251671,1,['enhance'],['enhanced']
Modifiability,"It looks like the loop on line 64 https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/qobjevo_codegen.py#L64 completes on the first try, but doesn't manage to import any objects, so the import_list remains empty. Could you use pdb to access local variables?. ---; P.S. You can use Markdown to format the traceback in a user-friendly way:; e.g. ; \`\`\`python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; \`\`\`. Renders to:; ```python-traceback; /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108:278,variab,variables,278,https://qutip.org,https://github.com/qutip/qutip/issues/1196#issuecomment-595050108,2,['variab'],['variables']
Modifiability,"It refers to the system's Liouvillian, I'd say. I think all the `C_n` there are stochastic jumps, `sc_ops `, while the system Liouvillian is the constant part, `c_ops`. But I am not 100% sure. . The user guide is partly out of date there, @Ericgig and others have considerably extended the functionalities of the stochastic solvers. Looking at the [API documentation](http://qutip.org/docs/latest/apidoc/functions.html#module-qutip.stochastic) is safer, and the [source code](http://qutip.org/docs/latest/modules/qutip/stochastic.html) is even more complete. . Meanwhile, you can also have a look at these development notebooks [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-milstein-speed-test.ipynb), [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb), and [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb) with regards to the new methods (you can find them all, a bit hidden, at the bottom of the http://qutip.org/tutorials.html list). Technically this issue could be transferred under [`qutip/qutip-doc`](https://github.com/qutip/qutip-doc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702:277,extend,extended,277,https://qutip.org,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702,2,['extend'],['extended']
Modifiability,"It seems like I could change or remove the option if I could find it. Here is a dump of my issue with setup.py: . $ sudo python setup.py install; Installing without the fortran mcsolver.; running install; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-armv7l-2.7/qutip; copying build/src.linux-armv7l-2.7/qutip/**config**.py -> build/lib.linux-armv7l-2.7/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC. compile options: '-I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/include/python2.7 -c'; extra options: '-w -ffast-math -O3 -march=native -mfpmath=sse'; arm-linux-gnueabihf-gcc: qutip/cy/spmatfuncs.c; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; arm-linux-gnueabihf-gcc: error: unrecognized command line option '-mfpmath=sse'; error: Command ""arm-linux-gnueabihf-gcc -pthread -fno-strict-aliasing -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fPIC -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist-packages/numpy/core/include -I/usr/lib/python2.7/dist",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/309:258,config,config,258,https://qutip.org,https://github.com/qutip/qutip/issues/309,4,['config'],['config']
Modifiability,"It seems like this routine is geared toward a specific problem, rather than a general input. Regardless, I think a notebook explaining this method is required, including better examples on the usage. This can be added to the documentation once it is converted to IPython notebooks. A few things I noticed are given below:; - The output is not a list, but a Result class object.; - Why is it not possible to directly calculate expectation values other than the coupling term?; - Why are the default input values what they are?; - The print statement at the end should be optional depending on the setting of the debugger.; - The call to Odeoptions in mesolve needs to be user accessible.; - tlist should not be the last input argument and should probably not be a kwarg.; - The call to eigenstates should also have an optional argument to call the sparse eigenstates solver if needed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-103712771:460,coupling,coupling,460,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-103712771,1,['coupling'],['coupling']
Modifiability,"It would be (for now):; ```; options = qt.solver.options.SolverOptions(store_states=True); solver = MeSolver(H, options=options); ```; `SolverResultsOptions` is not used directly but is contained in `SolverOptions`. While I expect verner method to work with tensorflow, there is still no way to pass a tensorflow variable as a coefficient in a QobjEvo yet, so autodiff will not work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668:313,variab,variable,313,https://qutip.org,https://github.com/qutip/qutip/issues/1804#issuecomment-1041471668,1,['variab'],['variable']
Modifiability,"It would be great if it were possible to specify where the temporary pyx (and other?) files are stored during a cython build. At the moment when one runs mesolve, the pyx files (and maybe others?) get written in the current working folder. Therefore running mesolve with some parameter scan (say with multiprocessing), results in *many* temp files that something like dropbox has to struggle in the background to process. . I can tell from those around me this happens to be an extremely common use case; i.e. most people are using dropbox or the like to backup their files. I would think the easiest thing to do might be to have an ENV variable, like, say QUTIP_BUILD_FOLDER that could dictate where this happens. Alternatively setting the default to system's tmp folder would be a good alternative. . I've looked in docs, and can't see anything like that; please let me know if i missed it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1259:637,variab,variable,637,https://qutip.org,https://github.com/qutip/qutip/issues/1259,1,['variab'],['variable']
Modifiability,"It's very clean, I really like the `set & set` and reusing the classes. But in v4, while we used `f(t, args)` in most examples, we never said that it should be the exact signature up to variable name, so I don't think it an appropriate check for which version to use. Ideally, the check should be good enough we don't need to change any tests not directly related to the addition of this feature. Also what should; ```; def f(t, w, a=1):; return a. coeff = coefficient(f, args={'w':1}); coeff.replace_arguments(a=2)(0); ```; give? Since `a` is not given, it's not our job to update it, or should we add it to `_f_arg_names`?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481:186,variab,variable,186,https://qutip.org,https://github.com/qutip/qutip/pull/1633#issuecomment-894438481,1,['variab'],['variable']
Modifiability,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:1026,variab,variable,1026,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230,1,['variab'],['variable']
Modifiability,"Just to get the ball rolling, I will go ahead and ask my question here and migrate it if necessary. . My code performs quantum annealing on a transverse-field Ising Hamiltonian as inspired by D-Wave Systems devices which is explained briefly [here](https://docs.dwavesys.com/docs/latest/c_gs_2.html), but the essential equation is; ![D-Wave-hamiltonian](https://user-images.githubusercontent.com/29308150/61193322-bdb48c00-a688-11e9-94ac-22c5d093b47a.png).; The A(s) and B(s) factors dictate the time-evolution from the initial Hamiltonian to the final Hamiltonian where s is a linear function of time, i.e. s(t) is linear with slope between 0 and some max and 0 <= s <= 1. In my code, my sesolve command looks like 'results = qt.sesolve(listH, init_state, discretized_times_list)' where 'listH = [[Hx, A(s(t))], [Hz, B(s(t))]]' and A(s(t)) and B(s(t)) and created by using QuTiP's interpolate.Cubic_Spline function that dictates what the A and B parameters should be at each point in time. . When I make successive calls, it is to do several different things. For example, I may change coupling (h and J) values to create a new spin-glass, adjust number of qubits (larger or smaller H), or anneal for a longer or shorter time. I am not sure how to directly relate this to what has been posted so far, but perhaps I am not fully understanding the point made in https://github.com/qutip/qutip/issues/966#issuecomment-474569011.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511266095:1087,coupling,coupling,1087,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511266095,1,['coupling'],['coupling']
Modifiability,"Looking through the commit history, @nonhermitian wrote the graph functions back in 2013: see fd4920d. Since then, he contributed a lot of the same code to `scipy` in `scipy.sparse.csgraph`: see https://github.com/scipy/scipy/pull/3751. I suggest we consider dropping most of them, and consequently their surrounding `Cython` code to ease maintainability and reduce code bloat of the repository. First, a couple of arguments against doing so:; - the versions in `scipy` and `qutip` did subsequently diverge in some form, because they no longer universally give the same results, possibly as a result of #654.; - the `qutip` version of `reverse_cuthill_mckee` is about 10% faster than the `scipy` version; - people may be using them. I think the main argument in favour of removal is that they're now also in `scipy` as `scipy.sparse.csgraph`. For the speed argument, for 1000 by 1000 matrices we're talking 780us vs 850us per matrix difference, so it's unlikely to be a limiting factor, and I think the ability to remove a large chunk of Cython code and maintainability cost outweighs this. I began investigating this because I was looking at `qutip.graph.reverse_cuthill_mckee`, since some of its tests are incorrect. The error is here:; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/tests/test_graph.py#L91-L108; Line 105 is broken: it should read; ```python; assert np.all(ans_perm == perm); ```; to test if _all_ the elements match. As it stands, it currently tests that _not all are different_, or in other words, it would only fail if not a single element in the two arrays matched. On fixing this line, we then learn that the test is actually a failing test, because the expected and actual results do not match (though they do however have equal bandwidths). I also note that `qutip` and `matlab` are in disagreement for the test case there: for the matrix; ```python; np.array([[0, 0, 0, 1, 0, 1, 0, 0, 0, 0],; [0, 0, 1, 0, 1, 0, 1, 0, 0, 1],; [0, 1, 0, 1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1203:339,maintainab,maintainability,339,https://qutip.org,https://github.com/qutip/qutip/issues/1203,2,['maintainab'],['maintainability']
Modifiability,"Looks good to me as well, looks like a great enhancement!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/464#issuecomment-210293697:45,enhance,enhancement,45,https://qutip.org,https://github.com/qutip/qutip/pull/464#issuecomment-210293697,1,['enhance'],['enhancement']
Modifiability,"Looks like it's resolved now (unless documentation should be updated on how to use the --with-openmp option with the new build method. I'm not sure if end users should now be using wheels builds). Both `--config-setting=""--global-option=--with-openmp""` and `--config-setting=""--build-option=--with-openmp""` achieve a wheels (PEP517) build and `python -c ""import qutip; qutip.about()""` reports `OPENMP Installed: True` for both python3.10 and python 3.11. `--global-option` gets a warning message:; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /projects/misc/build/qutip/.pybuild/cpython3_3.10_qutip --config-setting=""--global-option=--with-openmp""; * Building wheel...; /usr/lib/python3/dist-packages/setuptools/build_meta.py:307: SetuptoolsDeprecationWarning: ; The arguments ['--with-openmp'] were given via `--global-option`.; Please use `--build-option` instead,; `--global-option` is reserved to flags like `--verbose` or `--quiet`.; ; warnings.warn(msg, SetuptoolsDeprecationWarning); ...; ```; So it's saying we should be using `--build-option` not `--global-option`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726:205,config,config-setting,205,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1368866726,3,['config'],['config-setting']
Modifiability,"Looks ok to me, but also prefaced with ""not an expert"" :) Also the ICM stuff looks very nice. . Robert and Anubhav did this QIP module. There were various plans to extend it, vaguely summarized here https://github.com/qutip/qutip/issues/441",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-270594647:164,extend,extend,164,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-270594647,1,['extend'],['extend']
Modifiability,"Made another quick change. We know from Prop. 3.44 of (Watrous, 2018) that the diamond norm of CPTP channel is 1. So I added a quick `if` statement that checks this. Also refactored `dnorm` so there's only one return statement to make code climate happy. Looks like it's unhappy with something else and maybe made the logic harder to follow. Please advise if you have a preference. Again, can't really run tests locally, so approving the CI pipeline would be fantastic.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691:171,refactor,refactored,171,https://qutip.org,https://github.com/qutip/qutip/pull/2416#issuecomment-2098903691,1,['refactor'],['refactored']
Modifiability,"Main module control.ctrlpulseoptim provides functions for optimising control; pulses for quantum systems. Relies on the other classes for processing. Uses the BFGS (actually primarily the L-BFGS-B) algorthim, which is a quasi-second order Newton method for multivar function optimisation. Examples in the 'examples' folder to demonstrate usage.; 1. Hadamard - a simple example of Hadamard gate synthesis; 2. Lindbladian (open systems) - amplitude damping channel example; 3. Symplectic - a coupled oscillator example; 4. QFT - a 2 qubit example, showing alternative (more configurable) method for invoking the optimisation",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/246:572,config,configurable,572,https://qutip.org,https://github.com/qutip/qutip/pull/246,1,['config'],['configurable']
Modifiability,"Many thanks! I solved it!; Now I have this WARNING:matplotlib.animation:MovieWriter avconv; unavailable. Trying to use pillow instead.; *Many thanks*. *P**arfait Atchadé*. *Tel Spain: 0034661205543*; *Tel Deutsch: 00491706659017*. On Wed, 9 Dec 2020 at 15:45, Jake Lishman <notifications@github.com> wrote:. > You'll find it easier installing from conda-forge, since we distribute; > binary releases there: see the installation guide; > <http://qutip.org/docs/latest/installation.html> here.; >; > If you want to install from source using pip, you need to configure your; > C++ development environment correctly - you'll probably need to enable the; > XCode command-line tools (see e.g. this; > <https://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/>).; >; > —; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1404#issuecomment-742038577>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AGKQN3YYS6ZYMTV4HEHFTELST7OW3ANCNFSM4UT7TWQQ>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404#issuecomment-742050650:556,config,configure,556,https://qutip.org,https://github.com/qutip/qutip/issues/1404#issuecomment-742050650,2,['config'],['configure']
Modifiability,"Measuring the statistics of electron transport though nanostructures has been found to be a powerful experimental tool to gather information about such structures. The functions in countstat.py return the first two cumulants of a transport process, which are associated with measuring the current and shot noise, respectively. However at the moment they are a little buggy, and the current noise function fails sometimes, depending on the dimensionality of the system. As well as fixing this issue, there a couple of enhancements that can be done:. 1) Making the current noise function frequency dependant. This just requires adding a list of frequencies to return, and calculating the noise power for each given frequency ( at the moment it returns the zero frequency current noise). 2) Adding higher-order current cumulants. This is a straightforward generalization of the current noise function, though for very high orders the expansion of a given cumulant in terms of pseudo-inverse and current operators can be a little complicated. An iterative method for generating these can be found in C. Flindt et al., Phys. Rev. Lett. 100, 150601 (2008). and C. Flindt, T. Novotny, A. Braggio, and A.-P. Jauho, Phys. Rev. B 82, 155407 (2010). 3) Calculate the large-deviation function of the current. Such functions return the probability of observing deviations from the average transport behaviour, and have been found to give insight on a range of physical phenomena, including bistability and criticality (and, more practically, life insurance!).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/442:517,enhance,enhancements,517,https://qutip.org,https://github.com/qutip/qutip/issues/442,1,['enhance'],['enhancements']
Modifiability,"Minor cleanup of `Qobj` (docstrings, removed unused variable, fixed typo in setter of `data`). Docstring fixes include: removing `type` parameter from constructor, documenting possible types of `inpt` parameter, adding a handful missing functions to the list of functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2330:52,variab,variable,52,https://qutip.org,https://github.com/qutip/qutip/pull/2330,1,['variab'],['variable']
Modifiability,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:528,variab,variable,528,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561,1,['variab'],['variable']
Modifiability,"NUM_THREADS actually does not do anything as far as I can tell. We store the number of CPUs to use in qutip.settings.num_cpus. We can of course replace this with and environ variable, but is it needed?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41984812:174,variab,variable,174,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41984812,1,['variab'],['variable']
Modifiability,"Nah, don't disparage yourself - your code is good and you've done well to copy the style of the rest of the files. Typically consistency is better than having ""the one true style""; code's read more than it's written, and having a module which is clearly written by four different people makes the logic very very difficult to follow, which in turns makes it much harder to spot bugs. If it were up to me (which is isn't, really), I would say that your changes are good as they are. I didn't mean for the comments to be changes you _had_ to make. You can't reduce the number of merge conflicts that are going to happen with #1181 anyway, because that PR is a massive refactor of large swathes of the testing suite. You've done a good job to keep your work consistent with the rest of the file, so it will be very easy to merge in your logical changes. Merge conflicts are pretty much just par for the course; just the fact that we're discussing this here shows that logically, there _is_ a conflict between two pieces of work being done at the same time. I'd suggest merging this as-is. We'll handle the problems caused by the refactor elsewhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607971891:666,refactor,refactor,666,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607971891,4,['refactor'],['refactor']
Modifiability,Need for code refactoring?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729:14,refactor,refactoring,14,https://qutip.org,https://github.com/qutip/qutip/issues/1729,1,['refactor'],['refactoring']
Modifiability,"No problem, but to create an example, I need extra time to unwrap the self-defined gate sequence and refactor my test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1038#issuecomment-608335014:101,refactor,refactor,101,https://qutip.org,https://github.com/qutip/qutip/issues/1038#issuecomment-608335014,1,['refactor'],['refactor']
Modifiability,"No, `--config-setting=--global-option=--with-openmp` is still not working with git head. This is with ; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080:7,config,config-setting,7,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1220036080,1,['config'],['config-setting']
Modifiability,"No, it's mostly here on qutip and direct email. There is only a few of us. We have a qutip-dev google group on invitation managed by @nathanshammah. agarwal1998 is not a maintainer but cgranade was. Last year, we took time to review old issues and let some less pressing with ""help wanted"". We would be happy if you can propose a solution that would close the issue and help with Qutip in general. The only use I personally see from this would be case like:; ```; out = qzero(dims); for i in range(N):; out += f(i, dims); ```; Cases were the qobj is more of a dummy variable than a physical operator. `coherent` and `create` have a physical meaning and I would not know what `coherent([2,10])` is supposed to be, but I understand what `tensor(coherent(2), coherent(10))` is. For `projector`, it could be added, it's meaning is clear. To make it consistent, removing the list support from `qeye`, etc. and fixing the few case that it is used, might be a better option. The dimension can easily be corrected after the creation of the object.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/363#issuecomment-575811864:566,variab,variable,566,https://qutip.org,https://github.com/qutip/qutip/issues/363#issuecomment-575811864,2,['variab'],['variable']
Modifiability,"No, this is not included in my project. The commit above seems to be lost so I can't see the original proposal. It is easy to add a new option to let some gates remain as they are (and I think this is what was proposed). To resolve other multiqubit gates into TOFFOLI basis needs, however, much more work :). If resolving gate becomes a high demand, it might be a good idea to refactor the current `resolve_gate` method as it is quite long and hard to maintain. An optimized gate resolving method needs more complex logic such as merging single-qubit gate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-532940297:377,refactor,refactor,377,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-532940297,1,['refactor'],['refactor']
Modifiability,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1328:686,maintainab,maintainable,686,https://qutip.org,https://github.com/qutip/qutip/pull/1328,1,['maintainab'],['maintainable']
Modifiability,"Not sure if I can answer your specific question but I have used QUTIP GRAPE before. I would first suggest opening a pull request or linking to your fork, so it's easier to compare your modifications to the original code.; I have briefly looked at your code and I would suggest dropping numba as qutip doesn't currently have numba as a dependency. I am confused about why you choose the cnot notebook as your example? There is an example of quantum optimal control using open quantum systems, control-pulseoptim-Lindbladian.ipynb .; Nonetheless, I believe grape.py is definitely not the place to place your additional support for open quantum systems. Grape is an optimization method, you should be looking extending support for open quantum systems in the pulseoptim class.; If you are interested you can also take a look at the quantum optimal control tool I built, QUTIP's quantum optimal control didn't satisfy my needs. ; https://github.com/lifeishard/PADQOC",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845:706,extend,extending,706,https://qutip.org,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845,1,['extend'],['extending']
Modifiability,"Not sure if it's that simple.; ```; --config-setting=""--global-option=--with-openmp""; ```; actually gives me a build error:; ```shell; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5;",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:38,config,config-setting,38,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152,4,['config'],['config-setting']
Modifiability,"Not to discourage you from contributing, but there's already been some movement on #1208 in #1209. About tests: `qutip` uses `pytest` now, so the preferred method is actually just a bare `assert`, because `pytest` does introspection on the variables on an assertion failure. But yes, any changes to that should be in a new PR, because it's a different logical unit of work. There's some movement on that too (e.g. #1181). About pep8 changes: I'm not a maintainer, but it might be a good idea to be conservative about changing actual public APIs in the name of pep8. Changing public APIs that work fine means the users, who are the reason we're writing the code in the first place, have to adjust, and the pep8 spec explicitly warns against breaking backwards compatibility to match the pep. `N` is fairly consistent within `qutip` for the number of qubits, and the `U` in `U_list` refers to unitary matrices, which are conventionally a capital `U` in mathematical writing. You could argue that `U_list` should perhaps be called `unitaries`, but again, there's a degree of backwards-compatibility that should be maintained.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1212#issuecomment-603560557:240,variab,variables,240,https://qutip.org,https://github.com/qutip/qutip/pull/1212#issuecomment-603560557,1,['variab'],['variables']
Modifiability,"Note that the same holds for Cython:. ``` zsh; % pip install qutip; Collecting qutip; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:319,config,configuration,319,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,6,['config'],"['config', 'configuration']"
Modifiability,"Note: in theory you can install QuTiP from the test PyPI server right now by doing; ```; pip install -i https://test.pypi.org/simple qutip-jakelishman; ```; (that's just the name - you still do `import qutip`) but since it's on the ""wrong"" server, you first have to manually install `numpy` and `scipy`. When it's released properly on PyPI it'll handle the dependencies correctly - this is only an artifact of being on the testing server. Running that command will install a binary version with no compilation, and should work on any (reasonable) Linux machine, Mac (possibly not M1 chips) and Windows. It's possible you may get an error about `ndarray size changed ... this may indicate binary incompatibility` - if so, either force `numpy` up to the new 1.20 or down to 1.19 (whichever one you don't have). This was a breaking change in numpy 1.20. Per my reading of the release notes, it won't be an issue provided in the future we always build against `numpy>=1.20` (even when using lower `numpy` at runtime) because the new version updates a certain C-API macro to take into account the possibility of runtime variability. I have pushed an additional change to the build requirements to ensure this always happens. This has another knock-on effect: numpy 1.20 only supports Python 3.7+ (released June 2017). Currently, officially QuTiP supports Python 3.6, but I think it's reasonable to follow numpy's footsteps and **drop support for python 3.6 from qutip 5.0**. It's offset by gaining support for 3.9. (Apologies for all the force-pushing - whenever I want to re-run a test release on my own branch I have to temporarily add an extra commit to swap to the testing server, then force-push a rewind of this PR's branch.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-770459519:1115,variab,variability,1115,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-770459519,2,['variab'],['variability']
Modifiability,"OK, I see. If you are refactoring the parallelization of the mcsolve (which is currently tightly integrated in the mc code and quite messy) I would strongly recommend and lobby for using the new parallel_map API, and do away with all multiprocessing code in the mcsolve module and not using the callback function. I think this could make the mcsolve module vastly more readable and easier to maintain.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020826:22,refactor,refactoring,22,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020826,1,['refactor'],['refactoring']
Modifiability,"OK, good. I see no harm in keeping bicg and lgmres though, if only for backwards compatibility, also in case one encounters a bug in one of them the other could be tried (this just happend to me, bicg failed with an undefined variable error deep in the scipy code, but bicgstab worked). The defaults should be chosen carefully though, of course.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/214#issuecomment-52879383:226,variab,variable,226,https://qutip.org,https://github.com/qutip/qutip/pull/214#issuecomment-52879383,1,['variab'],['variable']
Modifiability,"OK, this is a bit broken. The debug flag throughout qutip doesn't really support setting at run time, it's only consistent when set in the config file. But let's fix it some other day then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261#issuecomment-64150936:139,config,config,139,https://qutip.org,https://github.com/qutip/qutip/pull/261#issuecomment-64150936,1,['config'],['config']
Modifiability,"OT AVAILABLE; atlas_threads_info:; NOT AVAILABLE; atlas_info:; NOT AVAILABLE; lapack_info:; libraries = ['lapack', 'lapack']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; language = f77; lapack_opt_info:; libraries = ['lapack', 'lapack', 'blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; language = c; define_macros = [('NO_ATLAS_INFO', 1), ('HAVE_CBLAS', None)]; include_dirs = ['/usr/local/include', '/usr/include']; Supported SIMD extensions in this NumPy install:; baseline = SSE,SSE2,SSE3; found = SSSE3,SSE41,POPCNT,SSE42,AVX,F16C,FMA3,AVX2; not found = AVX512F,AVX512CD,AVX512_SKX,AVX512_CLX,AVX512_CNL,AVX512_ICL; ```; So numpy itself marks openblas_info as NOT AVAILABLE (evidently using a build-time test, not runtime, which arguably is a pity). It seems to me that `hasattr` in qutip's BLAS support tests is returning false positives and false negatives. It indicates if the attribute was defined, even though it might be empty. Would it be better to replace; ```; hasattr(config,'openblas_info'); ```; in qutip/utilities.py with; ```; hasattr(config,'openblas_info') and config.openblas_info; ```; likewise for blas_mkl_info (not mkl_info) ?. This would be similar to numpy's own usage in `np.show_config()` (i.e. `np.__config__.py.show()`), which [uses](https://github.com/numpy/numpy/blob/3b7672ebd16982b661b8fbcabac80158662a8784/numpy/__config__.py.in#L116) `if not info_dict` to print ""NOT AVAILABLE"". ### Code to Reproduce the Bug. ```shell; import numpy; numpy.show_config(). import qutip; qutip.about(); ```. ### Code Output. ```shell; $ python3; Python 3.10.9 (main, Dec 7 2022, 13:47:07) [GCC 12.2.0] on linux; Type ""help"", ""copyright"", ""credits"" or ""license"" for more information.; >>> import numpy; >>> numpy.show_config(); ...; blas_mkl_info:; NOT AVAILABLE; ...; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; ...; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/u",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:3713,config,config,3713,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['config']
Modifiability,"Oh, I completely agree with the argument nested loops/if/else. I was more talking about the logistic depth requirement (edit: wrong again, it is called Cognitive Complexity) of code climate. I just realized that is not the climate issue here. But, anyway, indeed `circuit.py` is quite messy. And the Gate class is more or less just a place holder. A refactoring to define each gate as a subclass should make things much easier. Also for this latex method. I like it very much what is going on in `dev.major`!. Tbh the millions of `_gate_resolved` functions are actually already after a short refactoring last year by a brave volunteer. It used to be 400-line functions. That was horrible. Just like the `adjacent_gates` method in `spinchain.py` (another F). I haven't dared to touch it... > For say qobj.py, the master version has maintainability F, while `dev.major` has maintainability A with the only issues being TODOs and like 5 pep8s. That's amazing! When I joined QuTiP, the overall maintainability was D, as I remember. Now it is B. I'm keen to see it becomes A after `dev.major` got merged :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-782599642:350,refactor,refactoring,350,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-782599642,5,"['maintainab', 'refactor']","['maintainability', 'refactoring']"
Modifiability,"Oh, a thought: perhaps I should modify the commit messages of PRs in the old qutip-doc to make them link correctly. For example, instigate a rewrite rule of #xxx goes to qutip/qutip-doc#xxx?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066:141,rewrite,rewrite,141,https://qutip.org,https://github.com/qutip/qutip/pull/1513#issuecomment-829621066,1,['rewrite'],['rewrite']
Modifiability,"Oh, also, about callback functions and `yield`: if we did this, the patterns for making `mesolve` re-entrant and forwards-compatible without hamstringing our ability to extend the APIs in the future would probably not be very ergonomic. Both callbacks and `yield` allow the caller to feed information back into `mesolve`, but in this architecture, we'd have to completely define an interchange API, and specify quite explicitly what ""commands"" you can tell this sort of `mesolve` state machine to execute. The pattern in your original comment (reproduced here); ```python; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ```; is probably a little fragile; doing this means we have to guarantee that at _no point_ is the `ctrl_array` object copied. If you wanted to branch off execution part-way through the iterator, you'd have to copy the whole state, and then you'd lose your reference to the control array unless you kept manually walking the structure of the time-dependent object (internally it gets converted into a `QobjEvo` Liouvillian) to retrieve it. The other problem is that `state0` and the `Qobj` parts of the Hamiltonian aren't mutable; the preprocessing of `mesolve` means that none of those objects will exist inside the integrator loop. That's fine for this use-case, but it's not very general. These problems of mutability would apply to callback functions as well. A different way of using `yield` or callback function would be to really lean into a co-routine sort of pattern. So `mesolve` internally would look like; ```python; def mesolve(H, state, times, c_ops, e_ops, options):; # [... set up problem ...]; integrator = scipy.integrate.ode(...); for time in times[1:]:; state = integrator.step_to(time); instructions = yield _mesolve_output_state(state, time, e_ops); integrator",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481:169,extend,extend,169,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859907481,1,['extend'],['extend']
Modifiability,"Ok, I've reverted to using the PR number for the news fragment file names, and updated the contributing/PR instructions. I also looked into why the `towncrier-check` test is failing. It looks like towncrier is not finding the `pyproject.toml` config file because it is not running in the root directory. I added a `working-directory: /` specification to the action step to address this, hopefully this should fix it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537:243,config,config,243,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1159608537,1,['config'],['config']
Modifiability,"Ok, it looks like the tests are finally going to pass. As the number of commits suggests, this was a pain. Not because the code was wrong, but because:. 1) The default config used by Travis has GCC 4.6 which contains an error that happens to get raised in our case. Thus, had to move to the Trusty build stack. 2) Although it took forever to hunt down, it appears that when .pyx files are included as package data, Py27 may try to rebuild them upon calling **init**. This would throw a missing header error. Since these files are not needed after building, removing them clears up this issue.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-254497807:168,config,config,168,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-254497807,2,['config'],['config']
Modifiability,"Ok, it seems that for some reason the 'mkl_info' key from the NumPy config info is no longer available in some miniconda installs. This took forever to find as I could not reproduce the error at home when using a fresh miniconda install. Now I look in the libs as well for BLAS info.; - Also removed matplotlib from the requirements as it is not a requirement. At least not at present.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/547#issuecomment-252450097:68,config,config,68,https://qutip.org,https://github.com/qutip/qutip/pull/547#issuecomment-252450097,1,['config'],['config']
Modifiability,"Ok, so I tweaked the template and configuration for towncrier so that it doesn't render an issue/PR number next to each changelog entry. This frees you from requiring an issue / PR number when writing a news fragment. ; @hodgestar yes I think with this configuration you can just use any unique string for the filename.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155:34,config,configuration,34,https://qutip.org,https://github.com/qutip/qutip/pull/1927#issuecomment-1156932155,2,['config'],['configuration']
Modifiability,"One can read a little bit of somewhat useful information in PEP517 -- https://peps.python.org/pep-0517/#config-settings. I tried `--build-option` instead of `--global-option`, but that didn't work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267:104,config,config-settings,104,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219672267,1,['config'],['config-settings']
Modifiability,"One can reduce the number of variables of the DM by N(N+1)/2 when operating on the upper (or lower) triangle of the DM only. This leads to a overdetermined least-squares problem that can be solved in SciPy. Since the scaling of these solution methods depends heavily on N, this should hopefully lead to a good speed up.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/101:29,variab,variables,29,https://qutip.org,https://github.com/qutip/qutip/issues/101,1,['variab'],['variables']
Modifiability,"OpenMP handling is broken in the current `master`. It is likely caused by changes made in #1289. Trying to `import qutip` with OpenMP built produces errors; ```python; In [1]: import qutip; Calibrating OPENMP threshold...; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-1-e01d5608f34f> in <module>; ----> 1 import qutip. ~/code/qutip/qutip/qutip/__init__.py in <module>; 277 print('Calibrating OPENMP threshold...'); 278 thrsh = calculate_openmp_thresh(); --> 279 qutip.configrc.write_rc_key(rc_file, 'openmp_thresh', thrsh); 280; 281 # Load the config file. ~/code/qutip/qutip/qutip/configrc.py in write_rc_key(key, value, section, rc_file); 169 config.read(rc_file); 170 if not config.has_section(section):; --> 171 config.add_section(section); 172 config.set(section, key, str(value)); 173. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in add_section(self, section); 1205 RawConfigParser.add_section by validating if the section name is; 1206 a string.""""""; -> 1207 self._validate_value_types(section=section); 1208 super().add_section(section); 1209. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in _validate_value_types(self, section, option, value); 1178 """"""; 1179 if not isinstance(section, str):; -> 1180 raise TypeError(""section names must be strings""); 1181 if not isinstance(option, str):; 1182 raise TypeError(""option keys must be strings""). TypeError: section names must be strings; ```. The issue is probably due to `__init__.py` being out-of-date with regards to the change to how the `qutiprc` file is written. The immediate fix should be very simple, however it highlights a larger problem with our testing - this should have been caught by the OpenMP tests. In this case, I believe that the tests don't see the issue because there is a test in `__init__.py` that doesn't trigger the OpenMP calibration if only there is only 1 CPU. Presumably, we only ever get allocate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470:560,config,configrc,560,https://qutip.org,https://github.com/qutip/qutip/issues/1470,8,['config'],"['config', 'configparser', 'configrc']"
Modifiability,PR #256 restores the old progress bar as TextProgressBar and renames the new progress bar to EnhancedTextProgressBar. Considering the circumstances I think this is the best solution at this point.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63271426:93,Enhance,EnhancedTextProgressBar,93,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63271426,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,PR #991 (in review) rewrite a good part of mcsolve and have this feature.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1006#issuecomment-497391220:20,rewrite,rewrite,20,https://qutip.org,https://github.com/qutip/qutip/issues/1006#issuecomment-497391220,1,['rewrite'],['rewrite']
Modifiability,"Perhaps someone else can give a more concrete answer, but I guess the driving frequency is too high for the number of time-steps? Try tweaking the ODE solver with options like the following:. `; options = Options(nsteps=15000, atol=1e-13, rtol=1e-13) ; `. and passing it to mesolve. `result1 = mesolve(Ha, psi0, times, [np.sqrt(T1)*sig01, np.sqrt(T2)*sig02, np.sqrt(gamma*(nth + 1))*a, np.sqrt(gamma*nth)*a.dag()], [a.dag()*a, sig00, sig11, sig22], progress_bar=True, options=options); `. More practically speaking, for the problem you are solving I guess explicitly including the time dependence is unneccessary, since you have already made a RWA on the drive and the coupling? . Moving to an interaction picture in w1, w2 and wph, and removing the explicit time-dependence might simplify the problem and might give you equivalent results, and in the process make your code much simpler and more efficient?. In other words just set w1=w2=wph=0, and put the drive as a time-independent term in the hamiltonian . `; H01 = g*(sig12*a.dag() + sig21*a) + pump1*(sig01 + sig01.dag()); `",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1038#issuecomment-508634514:669,coupling,coupling,669,https://qutip.org,https://github.com/qutip/qutip/issues/1038#issuecomment-508634514,2,['coupling'],['coupling']
Modifiability,"Picking a new random number at each time step would be an expensive way to do the computation since each call to the random number generator is costly. One could pre-generate a large array of random numbers before hand, but there is no way to know if you generated enough since we are using an adaptive step size ODE method. You are correct about the way mcsolve does its calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE me",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:294,adapt,adaptive,294,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,2,['adapt'],['adaptive']
Modifiability,Prefix variable names with _ to clear Travis CI warnings,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1213:7,variab,variable,7,https://qutip.org,https://github.com/qutip/qutip/pull/1213,2,['variab'],['variable']
Modifiability,"Prefixes variable names with ```_``` to clear the Travis CI warnings, as mentioned in #1133. Before the changes, the ```travis lint``` output was:. ```; Warnings for .travis.yml:; [x] [warn] on root: deprecated key: stage_generic_linux (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_36 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_38 (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_no_cython (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_openblas (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_linux_37_omp (anchor on a non-private key); [x] [warn] on root: deprecated key: stage_osx (anchor on a non-private key); ```. After the changes, it is:. ```; Hooray, .travis.yml looks valid :); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1213:9,variab,variable,9,https://qutip.org,https://github.com/qutip/qutip/pull/1213,1,['variab'],['variable']
Modifiability,"Pursuant to discussions over the build failures observed in #359, this PR migrates Travis CI support to their new container-based configuration. I've observed that the builds with this configuration are more reliable, but they are slower for some reason. In the [instructions](http://docs.travis-ci.com/user/migrating-from-legacy/?utm_source=legacy-notice&utm_medium=banner&utm_campaign=legacy-upgrade#Faster-builds) they provide, Travis say that this configuration should be faster, and to let them know if our build is slower; that might be worth doing.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/360:130,config,configuration,130,https://qutip.org,https://github.com/qutip/qutip/pull/360,3,['config'],['configuration']
Modifiability,"Qobj currently use sparse matrix representation for operators and kets/bras, which is optimal for large systen but suboptimal for small systems. We want Qobj to support both sparse and dense matrix representation for the quantum object it represents. This should probably be implemented with two different classes, QobjSparse and QobjDense which inherit a common interface from a parent class Qobj.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/26:346,inherit,inherit,346,https://qutip.org,https://github.com/qutip/qutip/issues/26,1,['inherit'],['inherit']
Modifiability,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1132:360,enhance,enhance,360,https://qutip.org,https://github.com/qutip/qutip/issues/1132,1,['enhance'],['enhance']
Modifiability,"QuTiP is currently distributed through both Anaconda's conda-forge channel (`conda install qutip`) and PyPI (`pip install qutip`).; It could be helpful to the maintainers to have the project also on the test channel of PyPI, https://test.pypi.org, testing the distribution before uploading a new release on the actual PyPI channel. The [instructions](https://packaging.python.org/guides/using-testpypi/) are straightforward. Placing this as a memo for v. 4.4. Testing this would be helpful also as we attempt the wheels configuration (#933), which, as I understood from @Ericgig, might not be so straightforward given the low-level calls that QuTiP makes in some functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/992:520,config,configuration,520,https://qutip.org,https://github.com/qutip/qutip/issues/992,1,['config'],['configuration']
Modifiability,"Quick example is below. To add a bit more, the ''slowness'''of the standard brmesolve() run in this example depends on whether I install mkl or not. without mkl, its >10 mins, with mkl, about one minute. The run with converting the tensor to sparse always takes around 30-40 seconds, and doesn't depend too much on mkl. ```; import qutip as qt; import numpy as np. #spectral density; def Jw(w): ; return lam**2 * gamma * w / ((w0**2 - w**2)**2 + (gamma**2) * (w**2)); ; ; #power spectrum; def J_power_spectrum(w):; """""" The Ohmic bath power spectrum as a function of w; (and the bath parameters).; """"""; return (; Jw(w) * 2 * (w>0); ); def Ising_solve(N, g0, J0, gamma, tlist, options, use_csr=True):; # N : number of spins; # g0 : splitting; # J0 : couplings. #Setup operators for individual qubits; sx_list, sy_list, sz_list = [], [], []; for i in range(N):; op_list = [qt.qeye(2)] * N; op_list[i] = qt.sigmax(); sx_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmay(); sy_list.append(qt.tensor(op_list)); op_list[i] = qt.sigmaz(); sz_list.append(qt.tensor(op_list)). # Hamiltonian - Energy splitting terms; H = 0.; for i in range(N):; H += g0 * sz_list[i]. # Interaction terms; for n in range(N - 1):; H += -J0 * sx_list[n] * sx_list[n + 1]. # Initial state; state_list = [qt.basis(2, 1)] * (N-1); state_list.append(qt.basis(2, 0)); psi0 = qt.tensor(state_list); fx = 1; fy = 1.1; fz = 0.9; coup = (fx * (sx_list[N-1]) ; + fy * (sy_list[N-1]); + fz * (sz_list[N-1])). ; if use_csr:; R = qt.bloch_redfield_tensor(H, [[coup, J_power_spectrum]], fock_basis=True, sparse_eigensolver=True,br_dtype = 'sparse', sec_cutoff=-1); R = R.to('csr').tidyup(); result = qt.mesolve(R,psi0, tlist, options=options); else:; result = qt.brmesolve(H, psi0, tlist, a_ops = [[coup, J_power_spectrum]], e_ops=sz_list, options=options, sec_cutoff=-1); return result. #bath sd params; lam = 5; w0 = 10; gamma = 5; . #system params; N = 5; g0 = 1; J0 = 5. tlist = np.linspace(0, 100, 1000); options ={""nsteps"": 15000, ""s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583:748,coupling,couplings,748,https://qutip.org,https://github.com/qutip/qutip/issues/2530#issuecomment-2403834583,1,['coupling'],['couplings']
Modifiability,"Qutip works fine with numpy 1.21.1, but fails on import with 1.22 numpy, released Dec 31st. Tested on ubuntu and MacOS. ```; >>> import qutip; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; File ""/Users/work/miniconda3/envs/QF9/lib/python3.9/site-packages/qutip/__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""/Users/work/miniconda3/envs/QF9/lib/python3.9/site-packages/qutip/utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'; ```. Failure occurs here,. https://github.com/qutip/qutip/blob/52d01da181a21b810c3407812c670f35fdc647e8/qutip/utilities.py#L340. which is kind of mysterious since line 339 explicitly checks that the 'blas_opt_info' attribute exists, and then fails at line 340 because the attribute doesn't exist.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1766:512,config,config,512,https://qutip.org,https://github.com/qutip/qutip/issues/1766,1,['config'],['config']
Modifiability,"Re tidyup dispatcher: I think this should still exist:. * It's useful for implementing efficient explicity tidyup calls on the different data layers.; * It's useful for specializations on data layer implementations if they want to do, e.g., `__matmul__(self, other): other = other.tidyup() ...` at the start of an operation (not 100% sure this is a good example -- probably other.tidyup() and conversion to sparse needs to happen in one step to happen efficiently, but I feel like there are cases like this out there).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980:142,layers,layers,142,https://qutip.org,https://github.com/qutip/qutip/pull/1615#issuecomment-883256980,1,['layers'],['layers']
Modifiability,Refactor mcsolve parallel,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276:0,Refactor,Refactor,0,https://qutip.org,https://github.com/qutip/qutip/pull/276,1,['Refactor'],['Refactor']
Modifiability,Refactor solve gates,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1226:0,Refactor,Refactor,0,https://qutip.org,https://github.com/qutip/qutip/pull/1226,1,['Refactor'],['Refactor']
Modifiability,Refactor sparse module,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/158:0,Refactor,Refactor,0,https://qutip.org,https://github.com/qutip/qutip/pull/158,1,['Refactor'],['Refactor']
Modifiability,Refactor tensor,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/100:0,Refactor,Refactor,0,https://qutip.org,https://github.com/qutip/qutip/pull/100,1,['Refactor'],['Refactor']
Modifiability,"Regarding your questions:. - It's the same in QuTiP 5 currently. I am creating a PR also for that version, but I will include support for multiple coupling operators to the PR.; - Yes, I will add a test for this.; - This parameter is only relevant for `fmmesolve` ( master equation solver ). There is already the parameter `kmax` which sets the truncation of sidebands to be considered for the integration of the coupling operator. The integral to solve reads as:. $$ \frac{1}{T} \int_0^T dt e^{-ik\Omega t} f(t) $$. where $k \in \[-k_{max}, k_{max} \]$ and $f(t)$ is a $T$-periodic function. Hence, we know the frequency of the integrand and therefore the required number of grid points for the numerical integration can be set based on `kmax`.; I think, we don't need to create another parameter for `nT`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790:147,coupling,coupling,147,https://qutip.org,https://github.com/qutip/qutip/pull/1961#issuecomment-1198959790,2,['coupling'],['coupling']
Modifiability,Remove operator in data-layers,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1649:24,layers,layers,24,https://qutip.org,https://github.com/qutip/qutip/pull/1649,1,['layers'],['layers']
Modifiability,"Repeat the test 20 times and accept if at least 19 pass?. I remember adapting the tests when numpy's rng changed. 1~2 where failing. I believe that the tests pass over 99% with a random seed, but with the number of tests, it's not enough. I did not realize the test tolerance was smaller than the test one. But the solver tolerance is for the state itself, not expectation values and other scalars obtained from them. The test is not to check numerical error. When there is an mistake in the code, the error is orders of magnitude greater. Not sure if using the sovler's tol is right, but probably better than using a number that just seems to work.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625307705:69,adapt,adapting,69,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625307705,1,['adapt'],['adapting']
Modifiability,Rewrite entire git procedure for release,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1544:0,Rewrite,Rewrite,0,https://qutip.org,https://github.com/qutip/qutip/pull/1544,1,['Rewrite'],['Rewrite']
Modifiability,"See #238 for more details, but this extends `_permute` and `super_tensor` to act correctly on `operator-ket` as well as `super, superrep=""super""`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241:36,extend,extends,36,https://qutip.org,https://github.com/qutip/qutip/pull/241,1,['extend'],['extends']
Modifiability,See #954 ; > This builds fine except for the cqobjevo_omp module that uses unsigned variables for the openmp for loop which is not allowed on windows,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/955:84,variab,variables,84,https://qutip.org,https://github.com/qutip/qutip/issues/955,1,['variab'],['variables']
Modifiability,Setting qutip-qip as an optional plugin for qutip-5 [unitaryhack],MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1920:33,plugin,plugin,33,https://qutip.org,https://github.com/qutip/qutip/pull/1920,1,['plugin'],['plugin']
Modifiability,"Setting up the testing environment with `conda` avoids the segfault, but hangs indefinitely while running the tests. I'm using the following `run_tests_conda.sh`:; ~~~; #!/usr/bin/env bash; conda create -y -p venv python=3.8 'cython>=0.21' 'numpy>=1.12' 'scipy>=1.0' matplotlib ipython pytest; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~. This produces the attached [`test.log`](https://github.com/qutip/qutip/files/4307943/test.log): testing hangs at `test_mcsolve.py::test_MCTDFunc`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939:413,config,config,413,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939,2,['config'],['config']
Modifiability,"Since I have been using GCC 4.8 for a while now, i did not think about compilers back to 4.4. I will take a look at this code on Monday, but my initial thinking is just to drop the optimization and leave it at that. This would save us from having to run an extra test suite on Travis. The only compiler flags that matter at the end are O3 and the fast math. Everything else is just a few percent improvement at best. . Paul. > On Feb 21, 2015, at 06:42, Dominic Meiser notifications@github.com wrote:; > ; > gcc 4.4 does not support the -flto option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6.; > ; > In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to setup.py to enable or disable link time optimization.; > ; > I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.; > ; > You can view, comment on, or merge this pull request online at:; > ; > https://github.com/qutip/qutip/pull/318; > ; > Commit Summary; > ; > Remove -flto compilation flags.; > Add gcc4.4 and clang builds to travis build matrix.; > File Changes; > ; > M .travis.yml (8); > M qutip/control/setup.py (4); > M qutip/cy/setup.py (2); > Patch Links:; > ; > https://github.com/qutip/qutip/pull/318.patch; > https://github.com/qutip/qutip/pull/318.diff; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75334652:784,variab,variable,784,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75334652,1,['variab'],['variable']
Modifiability,"So I did an update of my conda environment to the latest version and now also the installation via pip has a problem, producing an `ImportError` (but not a segfault!) in the same location:. goerz@mlhpc2 develop:~/Documents/Programming/QNET> ipython; Python 3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 5.1.0 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import qutip; ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-1-ad45215f3e51> in <module>(); ----> 1 import qutip. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 169; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/fastsparse.py in <module>(); 404 #Need to do some trailing imports here; 405 #-------------------------------------; --> 406 from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult). ImportError: /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/cy/spmath.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E. The verbose log file from the installation (`pip install -v --no-cache-dir qutip`) is here: [pip_log.txt](https://github.com/qutip/qutip/files/914669/pip_log.txt)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-293395036:406,enhance,enhanced,406,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-293395036,1,['enhance'],['enhanced']
Modifiability,"So, while I agree that having a flexible storage format is a good way to go, the truth of the matter is that no one has time to implement such a big change. SciPy supports both 32 and 64-bit ints, and checks to see which ones are needed at runtime. e.g. a tensor product of two sparse matrices with int32, may need int64 in the result since their shape is larger. We could also do a similar thing, but it is a lot of work. The reason why we no longer use standard SciPy sparse objects is: 1) They tend to have a sizeable overhead when being created and/or manipulated do to redundant safety checks. 2) Many of the sparse operations are not well optimized. Because SciPy supports many different sparse formats, they had to generalize many of their core operations, making them slower. For example, the sparse kronecker product first converts to COO format, does the tensoring, and then converts back to the original format. Our method is much faster. Supporting more than just the current CSR format is also problematic. As already mentioned, there would be type checks, conditionals, and format conversions everywhere. e.g. what happens when DIA * CSR. As usual, available time is the limiting factor here. Support for both int32 and int64 is not that hard, but would take some time. Just int64 would make smaller matrices larger, but would allow for much greater system dimensions. In this later case, it would be a simple switch `int` -> `int64` and `size_t` -> `uint64` in the Cython code, and the fastsparse module (plus probably other places.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384005667:32,flexible,flexible,32,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384005667,2,['flexible'],['flexible']
Modifiability,"Solver object for `sesolve`, `mesolve` and `mcsolve`: `SeSolver`, `MeSolver` and `McSolver`:; - Removed all `rhs_reuse` (except in `brmesolve`). Still work but there is deprecation warning.; - steper for `Sesolver` and `MeSolver` as proposed by Michael.; - Variable output type (`Qobj`, `dense` or `sparse`) input must still be `Qobj`.; - Intermediate object to change the solver used: scipy `zvode`, `solve_ivp`, `dorpri853` are all available for `SeSolver`, `MeSolver`. More could be added in the future, @tehruhn 's GPU solver could probably fit here. I will work on an Adaptative Hilbert Space one eventually. . The objects do not do much more than the original functions if the system is not used more than once. Still to-do:; - Other algorithm for `McSolver`: diagonalized solver (suggested by Fabio?) and one using scipy ivp.; - Inline documentation; - Notebooks; - Cleaning options management. (Unique options object is getting limited for multiple low level solver and both all se,me,mc solve, I would appreciate opinions on how to make this better).; - Add to `__init__.py`; - Add tests. Build on the QobjEvoFunc Pr, with some bug fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1186:257,Variab,Variable,257,https://qutip.org,https://github.com/qutip/qutip/pull/1186,2,"['Adapt', 'Variab']","['Adaptative', 'Variable']"
Modifiability,Some examples I found interesting:. PyPI - Downloads (monthly) ![PyPI - Downloads](https://img.shields.io/pypi/dm/qutip.svg?style=plastic). GitHub code size ![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/qutip/qutip.svg?style=plastic). PyPI - Python Version ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/qutip.svg?style=plastic). Code Climate maintainability ![Code Climate maintainability](https://img.shields.io/codeclimate/maintainability/qutip/qutip.svg?style=plastic). Conda platform support ![Conda](https://img.shields.io/conda/pn/conda-forge/qutip.svg?style=plastic). GitHub contributors ![GitHub contributors](https://img.shields.io/github/contributors-anon/qutip/qutip.svg?style=plastic). PyPI status ![PyPI - Status](https://img.shields.io/pypi/status/qutip.svg?style=plastic). Closed Pull Requests ![GitHub closed pull requests](https://img.shields.io/github/issues-pr-closed/qutip/qutip.svg?style=plastic). Already on Readme.md:. Travis status ![Travis (.org)](https://img.shields.io/travis/qutip/qutip.svg). Coveralls github ![Coveralls github](https://img.shields.io/coveralls/github/qutip/qutip.svg?style=plastic),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/983#issuecomment-484765518:393,maintainab,maintainability,393,https://qutip.org,https://github.com/qutip/qutip/issues/983#issuecomment-484765518,3,['maintainab'],['maintainability']
Modifiability,"Some more clean up of the code. Unit tests still pass. I touched some lines in bloch.py to make things more readable. Is there a generic example that I can run, to make sure the plotting still looks the same. For now the the change to bloch.py is minor, but thought about refactoring some things along the way and didn't want to break anything without a proper test.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/11:272,refactor,refactoring,272,https://qutip.org,https://github.com/qutip/qutip/pull/11,1,['refactor'],['refactoring']
Modifiability,"Some of the test have decorators like this:. ```; @unittest.skipIf(_version2int(Cython.__version__) < _version2int('0.14') or; Cython_found == 0, 'Cython not found or version too low.'); ```. with the Cython_found variable being set at the top of the file like this:. ```; # find Cython if it exists; try:; import Cython; except:; Cython_found = 0; else:; Cython_found = 1; ```. The condition in the decorator will error, as the Cython version is checked even though it failed to import.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/449:214,variab,variable,214,https://qutip.org,https://github.com/qutip/qutip/issues/449,1,['variab'],['variable']
Modifiability,"Soon (TM). The refactor is all done (thanks to @tehruhn ). We are just mostly working up the example notebooks. . There is some uncertainty about how to include this in qutip, given recent discussions about qutip ""prime"" and external modules. But we will get it uploaded, and see what happens.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962#issuecomment-619398337:15,refactor,refactor,15,https://qutip.org,https://github.com/qutip/qutip/pull/962#issuecomment-619398337,1,['refactor'],['refactor']
Modifiability,"Sorry for such a long delay... @QuantumFall This issue somehow escaped from my email list and I never noticed it. This is actually a situation often encountered when testing just one gate. If Hamiltonian acts trivially on the state for a few time steps, the adaptive solver may decide on a step size so large that all the reaming pulses are skipped. Set the max step size fixes it:; ```python; options = qutip.Options(max_step=0.05); processor_state = processor.run_state(init_state, options=options).states[-1].tidyup(1.0e-6); ```. Usually, this is because the Hamiltonian is 0 at the first few steps. This example is actually slightly different. The first pulse is a non-trivial (sxsx+sysy) (swap-like). Maybe it is because it has no effect on the initial state `(0,0,0,1)`. But `(1,0,0,0)` seems to work well. It seems really necessary to adaptively choose a step size for the simulators. BTW, new updates will most likely only be added to the separate package [`qutip-qip`](https://github.com/qutip/qutip-qip). Please feel free to check there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054:258,adapt,adaptive,258,https://qutip.org,https://github.com/qutip/qutip/issues/2003#issuecomment-1343478054,2,['adapt'],"['adaptive', 'adaptively']"
Modifiability,"Sorry for the bad description. What I need to do (and which is already possible with `mesolve`) is to start with a hamiltonian H1, evolve for time T1, stop, change the hamiltonian to H2 and evolve for additional time T2. With `mesolve` I just use the final result of `mesolve(H1, initial_state,...)` as the initial result in `mesolve(H2,...)`. In `mcsolve` I can not do this, because I can not start `mcsolve` with a set of initial states over which to run single trajectories. In other words, I want to be able to run `mcsolve` up to time T1 and then be able to use the result in another call to `mcsolve` in order to run the trajectories for additional time T2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/120#issuecomment-41978600:131,evolve,evolve,131,https://qutip.org,https://github.com/qutip/qutip/issues/120#issuecomment-41978600,2,['evolve'],['evolve']
Modifiability,"Sorry for the delay in getting involved in this.; @bencbartlett Thank you for what looks like an excellent contribution.; @sahmed95 Thanks a lot for reviewing this. Personally I am ambivalent about 1 or 2 lines between functions. I just pick people up on it, as I was picked up on it by Rob with my first contribution. I thought pep8 says 1 between function and 2 between classes, but I happy to go with either. Regarding classes...; Yes, class objects could broadly fall into two categories: ; 1. data containers; 2. processing objects. QuTiP has historically used only the first kind.; Personally I am a big believer in the benefits of object-oriented (OO) programming. As can be seen in the control modules I contributed. I won't write an essay on it here, but being able to pass around processors of different kinds, with similar interfaces, has a many benefits. I would like to see all the solvers in QuTiP move to a class structure, as this would allow for some more code re-use, and this helps with maintainability.; Some of the more recent contributions have started using processor type classes, these I think @sahmed95 has already highlighted. If @sahmed95 has recommended an significant advantage of using some class object, then I support this. If it's not a lot of work, then I suggest implement it now. Otherwise I suggest merge now and consider a PR to implement in the near future, as @bencbartlett has waited patiently for us to look at this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-385964143:1006,maintainab,maintainability,1006,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-385964143,1,['maintainab'],['maintainability']
Modifiability,"Sorry for the delay on the docstrings and so on, I think all suggestions should be incorporated now. However, thanks to Paul's suggestion of adapting the tutorial 1e. I realized that I made a ""mistake from the very beggining"", namely the function used to fit the correlation function is only good if the imaginary part of the spectral density is 0 at t=0, because I'm using. $C(t)=\sum_{k}a_{k}e^{-b_{k} t}e^{i c_{k} t}$. so . $C_{R}(t)=\sum_{k}a_{k}e^{-b_{k} t}cos(c_{k} t)$. $C_{I}(t)=\sum_{k}a_{k}e^{-b_{k} t}sin(c_{k} t)$. No matter how many terms I take $C_{I}(0)=0$. I should have realized before but this can be bypassed by excluding $t=0$ from the fit, and starting at a small t, you get a decent fit, as long as you don't look at C(0), and I never check for these situations before. The results of doing this are pretty decent, but updating tutorial 1e I realized it required higher calculation times for the HEOMSolver when compared to using another ansatz for the correlation function, since solving is the expensive bit then I changed the code use another function for fitting. $C(t)=\sum_{k}(a_{k}+i d_{k})e^{-b_{k} t}e^{i c_{k} t}$. The downside is that since this function has 4 parameters, it required changing other functions as well, luckily only functions starting with _, hopefully this won't delay the PR too much. I updated the tutorials with this as well, and added a bit so that passing the parameters for the fitting is easier (after this comment), if the change is not desirable we can just go back to the commit before this comment",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764:141,adapt,adapting,141,https://qutip.org,https://github.com/qutip/qutip/pull/2260#issuecomment-1925945764,1,['adapt'],['adapting']
Modifiability,"Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (**1-P(no jump)**), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable? . I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the **array[1, 10, 11]**? ... . At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response. Cheers,; Qi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42091087:456,evolve,evolve,456,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42091087,4,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"Sounds good, I'll get on that, then, and make that a PR to qutip-notebooks. Roughly, this produces a pair of partial isometries representing a quantum channel that are quite useful for some theory work. For instance, [Watrous showed that](http://theoryofcomputing.org/articles/v005a011/) the diamond norm can be expressed in terms of a semidefinite program parameterized by the Stinespring dilation. It's that application in particular that motivated me to get this working, as computing diamond norms would be very useful to a wide range of different quantum information projects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/332#issuecomment-93119397:357,parameteriz,parameterized,357,https://qutip.org,https://github.com/qutip/qutip/pull/332#issuecomment-93119397,1,['parameteriz'],['parameterized']
Modifiability,"Sounds good. I'll pull out the non-configobj version, then, and make sure everything's handled in the case that it's not there. I'll also rename the module and set `__all__`, that's easy enough. As for `configspec.ini`, I made that change but forgot to push it, sorry. Easily taken care of.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61394612:35,config,configobj,35,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61394612,2,['config'],"['configobj', 'configspec']"
Modifiability,Sounds like a good plan. I was hoping to standardise the way we read in file data. I used the ConfigParser in control/load_params,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/652#issuecomment-283903782:94,Config,ConfigParser,94,https://qutip.org,https://github.com/qutip/qutip/pull/652#issuecomment-283903782,1,['Config'],['ConfigParser']
Modifiability,Spin-phonon coupling.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1235:12,coupling,coupling,12,https://qutip.org,https://github.com/qutip/qutip/issues/1235,1,['coupling'],['coupling']
Modifiability,"Sure! Here are the plots before the changes using the code posted in issue #1974. The bug we wanted to fix is that when choosing style 'm' and passing an array of colors as we did in V4, the scrip only plots one color, (additionally, i also plot one case with style 'l'):. ![M_self_test_old](https://github.com/qutip/qutip/assets/78165605/c0ed44c7-74d1-47f3-8787-254e4d6806d5) ![L_self_old](https://github.com/qutip/qutip/assets/78165605/66cfdb8c-18d2-45d9-a64e-97a28f72e10f). And these are the same plots after the changes using the variables `inner_point_color` (left graph) and `point_color` (right graph). As we can see for both variables we get the same result which is what we expected:. <img src=https://github.com/qutip/qutip/assets/78165605/1c6f0d5b-080f-49e2-98f7-8ead19ef739b width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/346835ab-5065-4180-b4dd-3a9b8b99dc45 width=45% height=45%>. <img src=https://github.com/qutip/qutip/assets/78165605/20e28bba-a720-4197-b6c8-a5bbb26814ec width=45% height=45%> <img src=https://github.com/qutip/qutip/assets/78165605/8c987724-d7b1-49bb-ab1b-e25908673425 width=45% height=45%>. For before and after changes the plots using the default colors are the same (these are styles 'l', 's' and 'm' in that order):. <img src=https://github.com/qutip/qutip/assets/78165605/3d995e25-8f7e-4240-9707-cb3d6e562cb5 width=30% height=30%> <img src=https://github.com/qutip/qutip/assets/78165605/d1ac9aed-063d-472d-99b7-b935522f308e width=30% height=30%><img src=https://github.com/qutip/qutip/assets/78165605/4dfaa6d9-3691-4e71-83d9-3418869c0103 width=30% height=30%> . Making more tests I found the error with style 'l' that I mentioned in issue #1974, which consisted in an erratic plotting after sorting the points. Here we can see some results of those tests before the changes (style 'l' using the `point_color` and `point_default_color` variables, plus 'm' with the `point_color` variable):. <img src=https://github.com/qutip/qutip/as",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617:534,variab,variables,534,https://qutip.org,https://github.com/qutip/qutip/pull/2308#issuecomment-1913220617,2,['variab'],['variables']
Modifiability,"Thank for spotting another bug @Canoming, I'll check it and merge if everything is good. @quantshah I'd say we let the test wait for a while. @jakelishman 's refactoring is still not merged and adding tests now will lead to conflicts. He will need to rewrite the test again. Maybe we can build a more thorough test for the circuit module during the GSoC project @sarsid ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-629662675:158,refactor,refactoring,158,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-629662675,2,"['refactor', 'rewrite']","['refactoring', 'rewrite']"
Modifiability,"Thank you @AGaliciaMartinez as of late I was getting the same issue with the tests. @hodgestar ; dev.major lacks this lines in the toml. ``` ; [tool.pytest.ini_options]. addopts = ""-Werror --strict-config --strict-markers"". testpaths = [; ""tests"",; ]; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212:198,config,config,198,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864935212,1,['config'],['config']
Modifiability,"Thank you @kevinsung. Closing this as the bug has been fixed by @jevonlongdell in #879. If you wish, please open a PR for the stability enhancement of `simuldiag`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/756#issuecomment-497302015:136,enhance,enhancement,136,https://qutip.org,https://github.com/qutip/qutip/issues/756#issuecomment-497302015,1,['enhance'],['enhancement']
Modifiability,"Thank you Marek,; It seems you forgot to add a seed variable in the definition of the rand_herm function (line 112~114). Because of this, many tests fails. ; Could you add it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/917#issuecomment-426421470:52,variab,variable,52,https://qutip.org,https://github.com/qutip/qutip/pull/917#issuecomment-426421470,1,['variab'],['variable']
Modifiability,"Thank you for all your work @gsuarezr . Just for a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would r",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:737,coupling,coupling,737,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525,1,['coupling'],['coupling']
Modifiability,"Thank you for doing this quickly, I guess you did until quite late. Yes, tests in `test_integrator` are parameterized over all integrators registered in `sesolve_integrators`, etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011:104,parameteriz,parameterized,104,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925428011,1,['parameteriz'],['parameterized']
Modifiability,"Thank you for the suggestions. (2) It should be easy. We could reuse the `parallel_map` as you said. I would make a good first contribution. . (1) We need to be careful about this. ; I can see case where the user think the correlation is gone by `tlist[-1]` but it is not, so it should be clear which output are `0` and which are not computed.; Also if we do that, maybe finer control could be given. We could have a variable `max_t_plus_tau` with default `np.inf`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043:417,variab,variable,417,https://qutip.org,https://github.com/qutip/qutip/issues/2315#issuecomment-1925474043,2,['variab'],['variable']
Modifiability,"Thank you for your answer @Ericgig !. So, even though we are not using any quotes in our code, this internally maps to the string approach ?; I am trying to understand how to do what I want using callbacks instead, I could use a bit of help.; This is what the original code I shared here reads:. ```; # list of variational parameters ""a[]""; a=[]; for i in range(numite):; a.append(0.01*i). # define energy function by using variational parameters; def energy(a):; psi = initial_H.eigenstates(sparse=False)[1][0]; t = np.linspace(0, 1, timesteps+1); for i in range(numite):; 	H=[[initial_H,1-a[i]*t],[final_H,a[i]*t]]; 	result= qt.mesolve(H, psi, t, [], []); 	psi=result.states[timesteps]. E = qt.expect(final_H,psi); return E; ```. I tried to understand the documentation here: http://qutip.org/docs/latest/modules/qutip/mesolve.html; What I think I need to do is the following:. - I need to just pass callbacks instead of formulas / strings for the coefficients when defining the operators.; - these callbacks must have a signature with the format `(t, *args)` and should return an np.array; - `t` and `args` values are passed as arguments to mesolve. . I am a bit unclear whether or not ""args"" is a list or a dictionary and how I can access it inside my callbacks. I made an attempt but it returns errors: maybe it would be easy for you to fix some lines of this example and tell me if I am on the right track? Or do you have a link to an example, maybe ?; I am just targeting the innermost portion of the code, here:. ```; mesolve_args = ... # a dictionary ? a list? Something that lets me access the variable ""a""; def h_t1(t, *args):; return np.array(1-a[i]*t) # how do I retrieve a[i] by accessing args?; def h_t2(t, *args):; return np.array(a[i]*t) # same. H=[ [initial_H, h_t1], [final_H, h_t2] ]; result= qt.mesolve(H, psi, t, c_ops=[], e_ops=[], args=mesolve_args) # is this correct ?; psi=result.states[timesteps]; ```. Thank you for your help !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-474154477:1604,variab,variable,1604,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-474154477,1,['variab'],['variable']
Modifiability,Thanks @Ericgig for feedback.; I see (having read more carefully) in; https://github.com/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb; there is an example showing the equivalence of using `smesolve` and `general_stochastic` with a clear performance enhancement in the former. So I think I can easily switch my example to use `smesolve`. Thanks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581:284,enhance,enhancement,284,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581,2,['enhance'],['enhancement']
Modifiability,Thanks Chris. This is looking good. I'll try it out in more detail in the comings days. Some immediate comments:; - I don't think we should keep two code-paths for parsing the config file. So either we keep using the old manual parsing or we make configobj the official and only way to parse the config file. In that case I think it would be Ok to simply fail to parse the config file if configobj is not available. I don't think many users use the config file so would be to worried about breaking backwards compatibility with respect to this.; - I think I'd prefer to have the logging module called logging.py rather than _logging.py even though it is supposed to internal to qutip. ; - Please add a `__all__` list in logging.py; - Shouldn't configspec.ini be added to the setup.py file?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61393881:176,config,config,176,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61393881,14,['config'],"['config', 'configobj', 'configspec']"
Modifiability,"Thanks Jake. I've raised the Issue in regards to building deb packages from source (https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=999517), so pip can't be used in that context. The Debian build machinery invokes `python3 setup.py {config,build,install}` not `setup.py develop`, c.f. past build log with numpy 1.19 [here](https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-2&stamp=1630423818&raw=0).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138:235,config,config,235,https://qutip.org,https://github.com/qutip/qutip/issues/1720#issuecomment-974835138,1,['config'],['config']
Modifiability,"Thanks a lot for awakening this PR from its slumber @hodgestar !. All the decorator `avg_gate_fidelity_test` does is to skip the decorated test on Mac. Looks like it has been removed in the following commit which is included in your merge, in favour of refactoring the AGF tests into a class and skipping the whole class on Mac: https://github.com/qutip/qutip/commit/99ce2d5c511e2487505a79455c9b53f7676a5731#diff-a9cd5a7620c34d60ffb61360a78bab270214a212c997e0c2cf5a6617443a90ab; (The decorator was originally introduced in https://github.com/qutip/qutip/pull/1034. The underlying issue https://github.com/qutip/qutip/issues/963 seems to be resolved, so maybe skipping the tests on Mac isn't necessary any more?). The only test that is included in my original PR, but not after your merge, is `test_average_gate_fidelity_against_legacy_implementation` at https://github.com/fhopfmueller/qutip/blob/74080688cbece61a3d095fa6fc9dd347114b6152/qutip/tests/core/test_metrics.py#L443. Would you like to include that test? On the one hand, it contains copy-pasted code from the previous implementation, so the test isn't exactly elegant. On the other hand, it ensures that the new implementation of this PR gives the same result as the previous correct implementation. I'd favor including it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496:253,refactor,refactoring,253,https://qutip.org,https://github.com/qutip/qutip/pull/1788#issuecomment-1172777496,1,['refactor'],['refactoring']
Modifiability,"Thanks for reporting this bug. I'm working on refactoring the Qobj class in PR #95, and I have tried to fix this problem there. The PR is still work in progress though, and not quite ready for merging yet, but I think the problems you describe are fixed now. If you are interested you are very welcome to try it with the cleanup-qobj branch which that PR is based on. Code reviewing and general comments on the changes would also be very welcome of course :-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/96#issuecomment-39052411:46,refactor,refactoring,46,https://qutip.org,https://github.com/qutip/qutip/issues/96#issuecomment-39052411,1,['refactor'],['refactoring']
Modifiability,"Thanks for the clue, it was helpfull.; The source of problem is localization of `lscpu` util, which used by `_linux_hardware_info()` function.; The function expects `'Socket(s)'`, `'Core(s) per socket'`, etc in `lscpu` output, but in my system it actually `'Потоков на ядро'`, `'Сокетов'`, etc.; I think, maybe better less system dependent ways to calculate cpu count, for example, we could use `multiprocessing` module and it's `cpu_count` function. Or `len(os.sched_getaffinity(0))`for computers with dynamic cpu management (see [this](https://stackoverflow.com/questions/31346974/portable-way-of-detecting-number-of-usable-cpus-in-python) for details).; Or show exception/error, if we try to use lscpu and `LANG` is not english (or we couldn't found mentioned above `'Socket(s)'`).; Ideas?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045:583,portab,portable-way-of-detecting-number-of-usable-cpus-in-python,583,https://qutip.org,https://github.com/qutip/qutip/issues/1004#issuecomment-497325045,2,['portab'],['portable-way-of-detecting-number-of-usable-cpus-in-python']
Modifiability,"Thanks for the feedback. I am very keen to spend some time making the control modules more QuTiP like in style. In particular trying to utilise QuTiP elements, e.g. maintaining Qobjs throughout the code. I am however focussed on trying to get some results out using the library, so it will probably be a month of so before I can start on this. ; Re the documentation, there is some theory in the first of our notebooks example-pulse_optim-Hadamard, however it could be a lot more detailed and better presented. I should be able to make a start on a general overview of the control modules though, i.e. one notebook that outlines the theory and then explains the different functions and classes and how / when to use them. Is that the kind of thing you mean?; I was wondering about the auto-generated API docs, how it deals with inherited and overidden methods etc. Do you use some specific tool to generate these? Can you point me to some docs about how it works.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/338#issuecomment-97736382:828,inherit,inherited,828,https://qutip.org,https://github.com/qutip/qutip/pull/338#issuecomment-97736382,2,['inherit'],['inherited']
Modifiability,"Thanks for the quick reply! . > Should it raise a warning for users that tries to access each trajectories? Or add a note in the docstring? The trajectories would look strange if you don't read the documentation.; > ; Maybe, though I'm not sure why they would look strange? It's possible a user could get confused if they don't see any no-jump trajectories other than the first one, but hopefully they wouldn't be confused if they set the flag to use this algorithm. > I am wondering if `MCSolverImprovedSampling` could be merged in `MCSolver`. I am not a fan of having `mcsolve` use 2 different solvers and it should be accessing by the new class interface. Another options would be that make `MCSolverImprovedSampling` public and add a new function to call it `mcissolve`?; > ; Yeah this might be the way to go. I only had it the way I did to have `MultiTrajSolverImprovedSampling` get inherited before `MCSolver` so that the functionality there gets used and also have `resultclass = McResultImprovedSampling`. We could do a conditional inheritance in `MCSolver`, but I'm worried that might be messy/ugly?. > I would prefer that you revert the changes made by black. It add a lot of changes that are unrelated to the new feature and makes reviewing the PR annoying. Also we use the pep8 line width of 80 instead of black's 88. For now, we mostly use black in new code and adding black to existing file should be their own PR.; >; Sorry about that, will revert",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681:888,inherit,inherited,888,https://qutip.org,https://github.com/qutip/qutip/pull/2218#issuecomment-1687054681,2,['inherit'],"['inheritance', 'inherited']"
Modifiability,"Thanks for the useful feedback, both here and in PR #1611 ! From the discussion in PR #1611 it seems that the second option with the modifications proposed by Jake in this issue seems to be the most sensible approach. Hence, if there are no objections, I will open a PR (which I will probably do tomorrow) where I implement the following changes (adapted from Simon's comment in PR #1611):. - `Qobj.__mul__(self, other) ` ; - dispatch to `data.matmul` if `other` is a `Qobj`; - dispatch to `data.mul` otherwise which will return `NotImplemented` if it does not know how to handle `other`. ; - `Qobj.__rmul__(self, other) `:; - Dispatch to `data.mul` (`other` will never be a Qobj): Notice that in this way both left and right multiplication will behave in the same way. This would also ""solve"" the inconsistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex py",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:347,adapt,adapted,347,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473,2,['adapt'],['adapted']
Modifiability,"Thanks for your replies.; I did not have any python on my computer. Firstly, I installed Anaconda, then build a qutip-env. I typed ""conda activate qutip-env"" and then used the following command to install the requirements: ""conda install numpy scipy cython matplotlib pytest pytest-cov jupyter notebook spyder"" .; Then, I added ""conda config --append channels conda-forge"", getting the following warning: ""conda-forge already in channels list, moving to the bottem"".; Then, I run ""conda install qutip"" with no errors.; qutip was installed in ""/root/anaconda3/env"" and i opened a terminal in ""/root"", typed ""python"" and then ""import qutip.testing as qt"" getting the above error.; I really appreciate any help!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1391#issuecomment-735554120:335,config,config,335,https://qutip.org,https://github.com/qutip/qutip/issues/1391#issuecomment-735554120,1,['config'],['config']
Modifiability,"Thanks to some pointer from @nonhermitian I think I now understand this better; I will illustrate with some pseudo code. What we want to do is: M_out = (L_1 + L_2 + ... + L_i)*M; where L_i are sparse matrices and M is a dense matrix.; So one option (A) could be; ```; for L in L_list:; M = spmm(L, M); ```; which would seem more efficient than option B:; ```; for col in M:; for L in L_list:; col = spmv(L, col); ```; but as `spmm(L, M)` would effectively be:; ```; for col in M:; col = spmv(L, col); ```; Then options A & B would be the same efficiency wise.; As option B is much easier for us to implement within our existing codes, then this is what I will do. Just one note: M actually starts are sparse, but has to converted to a dense column stacked vector as it is used as the variable in the ODE solver",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/877#issuecomment-395350256:784,variab,variable,784,https://qutip.org,https://github.com/qutip/qutip/issues/877#issuecomment-395350256,1,['variab'],['variable']
Modifiability,"Thanks! I'll work out how to handle this numpy 1.20 C-API change properly before this is ready to merge, I think - turns out my reading of the numpy release notes was wrong, or (possibly) Cython is generating some compile-time-constant code it should be deciding at runtime (as of the latest numpy). Hopefully it's just a configuration change on our end that I can work out somewhere.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429#issuecomment-770779664:322,config,configuration,322,https://qutip.org,https://github.com/qutip/qutip/pull/1429#issuecomment-770779664,1,['config'],['configuration']
Modifiability,"Thanks, @jakelishman. Even you say that you didn't look into very details, your comments were very inspiring and helpful!. What code climate is complaining about is mostly left from the previous code structure. I do plan on further cleaning them. Another refactor probably. Actually, the `_EvoElement` here is a simplified ""copy"" of the `EvoElement` in `QobjEvo`, not directly referring to that. Switch to `dev.major` won't break it. I did this long ago because I was having problems initialize `QobjEvo` in my particular use case. But indeed exposing a private class is fragile and dangerous. Planning on remove it too.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1444#issuecomment-815048230:255,refactor,refactor,255,https://qutip.org,https://github.com/qutip/qutip/pull/1444#issuecomment-815048230,2,['refactor'],['refactor']
Modifiability,"That is true. I'll try to look into why this is the case. However, it does have three expectation calculated. You can check this with output.expect ! . Edit: . So, I just realized that the noise-spectrum is associated with the coupling operator [sigmax()], I think the correct call to brmesolve must infact be (updated to current qutip standards) . `output = brmesolve(H, psi0, tlist, [[sigmax(), ohmic_spectrum]], e_ops)`. This is in line with the notation we use in example (https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/examples/brmesolve-time-dependent-Liouvillian.ipynb). I will make a pull request updating both the example notebook (http://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html ) to reflect this and make sure we depreciate the spectra_cb argument in bloch_redfield_tensor to eliminate the confusion. Thanks for bringing this to notice !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1223#issuecomment-605711703:227,coupling,coupling,227,https://qutip.org,https://github.com/qutip/qutip/issues/1223#issuecomment-605711703,2,['coupling'],['coupling']
Modifiability,"That is what I did in fact, but I had to add it myself. That is load them in from CPATH or C_INCLUDE_PATH. They were not included automatically. I am not suggesting that we do that in this PR, but maybe extending rather than overwriting the CFLAGS might be better. Unless there is good reason not to?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265068820:203,extend,extending,203,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265068820,1,['extend'],['extending']
Modifiability,"That sounds good, I'll start refactoring this PR to address that structure, then.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-64314727:29,refactor,refactoring,29,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-64314727,1,['refactor'],['refactoring']
Modifiability,That's a bit unfortunate. Perhaps there is a way of configuring the textmate console to support the \r carriage return? Exactly how do you run a script from textmate?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63265163:52,config,configuring,52,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63265163,1,['config'],['configuring']
Modifiability,"The CI is still running but have you tried to align with other qutip API docs like this?; ```; .. automodule:: qutip.core.operators; :members: charge, commutator, create, destroy, displace, fcreate, fdestroy, jmat, num, qeye, identity, momentum, phase, position, qdiags, qutrit_ops, qzero, sigmam, sigmap, sigmax, sigmay, sigmaz, spin_Jx, spin_Jy, spin_Jz, spin_Jm, spin_Jp, squeeze, squeezing, tunneling, qeye_like, qzero_like; ```; I am not sure if autosummary is fully configured in qutip",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068:472,config,configured,472,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2148389068,1,['config'],['configured']
Modifiability,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/441:774,enhance,enhancements,774,https://qutip.org,https://github.com/qutip/qutip/issues/441,2,"['Extend', 'enhance']","['Extend', 'enhancements']"
Modifiability,"The RK45 code here has no notion of error associated with it; you have no way of saying whether a particular step size `dt` is actually good. It ideally should converge to something as the step size goes to zero. QuTiP has an adaptive solver that modifies the step size to keep the error below the supplied tolerances. For time-dependent problems one could run into issues with very narrow pulses, but that is not the case here. Writing ones own ODE solver is not really the best thing to do outside of a learning exercise for reasons along these lines.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508:226,adapt,adaptive,226,https://qutip.org,https://github.com/qutip/qutip/issues/1733#issuecomment-986722508,2,['adapt'],['adaptive']
Modifiability,The Travis CI should be up and running now. Can you rebase your PR so we can rerun the tests with the latest travis ci configuration?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36082072:119,config,configuration,119,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36082072,1,['config'],['configuration']
Modifiability,"The `general_stochastic` function does process the `e_ops`. ; I see your point about it being it being a general solver of SDEs and so it makes sense that the variable is a vector. Certainly no value in changing the processing to work on Qobj.; I just think it would make usage easier if `state0` and `e_ops` (and I guess `m_ops`) could be provided as dm and opers rather than vectorised and superoperators. These could be recognised as such and converted before processing. We could then convert the `result.states` accordingly. . Anyway, I am only just beginning to understand this stuff, so I will leave it up to your judgement as to whether this is worth the effort. If the aim to try always to avoid `general_stochastic`, then I suppose it is not.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289:159,variab,variable,159,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547219289,1,['variab'],['variable']
Modifiability,The `reverse_circuit` function was broken as the gates should have been added to the temporary variable's `QubitCircuit.gates`. A better way is to use the `add_gate` method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/684:95,variab,variable,95,https://qutip.org,https://github.com/qutip/qutip/pull/684,1,['variab'],['variable']
Modifiability,"The coverall integration is nice, but could we configure it not to comment each and every travis build on every PR? I think is is rather noisy and generates a lot of email notifications... Perhaps the badge in the README file would be sufficient?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/254:47,config,configure,47,https://qutip.org,https://github.com/qutip/qutip/issues/254,1,['config'],['configure']
Modifiability,"The default Apple `clang` version doesn't recognise `-fopenmp` out-of-the-box, because Apple don't ship an OMP library with macOS. You'll have more luck (with most C/C++ projects!) if you install a fully-featured compiler and environment. On [homebrew](https://brew.sh) you can find both `clang`/`clang++` and `gcc`/`g++`, both of which can be installed with OMP support. Make sure your set `PATH`/`CC`/`CXX` environment variables are set up correctly after you've installed, so you're calling the compiler you've just installed, not just the Xcode versions. This isn't a bug in QuTiP, although we could remember this when somebody's working on modernising the distribution - in C/C++ land, tools like `automake` run through a big list of things to check during build configuration, and one of them is if OMP appears to exist. That way the error message is a little clearer (although in this case it's reasonable clear if you're used to C compilers).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1230#issuecomment-611425774:421,variab,variables,421,https://qutip.org,https://github.com/qutip/qutip/issues/1230#issuecomment-611425774,4,"['config', 'variab']","['configuration', 'variables']"
Modifiability,The dnorm tests are sporadically (quite regularly) failing e.g. ```; ======================================================================; ERROR: Metrics: checks that special cases for dnorm agree with SDP solutions.; ----------------------------------------------------------------------; cvxpy.error.SolverError: Solver 'CVXOPT' failed. Try another solver or solve with verbose=True for more information. Try recentering the problem data around 0 and rescaling to reduce the dynamic range.; ```. I suggest we turn them off by not installing cvxpy for any of the test configurations.; We can turn them on again if someone can make an attempt to make the dnorm tests more reliable @cgranade . I will raise a PR for this now.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/880:571,config,configurations,571,https://qutip.org,https://github.com/qutip/qutip/issues/880,1,['config'],['configurations']
Modifiability,"The dpsi option worked fine on my mac from jupyter. ; - please update the docstring to highlight this option (could also add the presence of the `name` option, besides directory and format); - It is a nice feature, it could be highlighted in the documentation, here https://github.com/qutip/qutip-doc/blob/master/guide/guide-bloch.rst; - add to 4.4.1 enhancements in the changelog, https://github.com/qutip/qutip-doc/blob/master/changelog.rst; Let's skip the codeclimate issues for the moment, but in the future it might be nice to refactor the Bloch class inner workings, as it took me a while to sort out issue #1027.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1104#issuecomment-541539574:351,enhance,enhancements,351,https://qutip.org,https://github.com/qutip/qutip/pull/1104#issuecomment-541539574,4,"['enhance', 'refactor']","['enhancements', 'refactor']"
Modifiability,The feature is very interesting and makes the propagator class very flexible. I like it! I left some small comments but otherwise looks good.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343:68,flexible,flexible,68,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1256993343,1,['flexible'],['flexible']
Modifiability,"The latest numpy enables `extra_link_args` in your site.cfg. Hence the `setup.py` files should not set those values. For instance `qutip/fortran/setup.py`:. ```; config.add_extension('qutraj_run',; sources=sources,; extra_compile_args=extra_compile_args,; extra_link_args=extra_link_args,; libraries=libs,; **newblas; ); ```. should be. ```; config.add_extension('qutraj_run',; sources=sources,; libraries=libs,; **newblas; ); ```. as `newblas` can be given options through the `site.cfg`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392:162,config,config,162,https://qutip.org,https://github.com/qutip/qutip/issues/392,2,['config'],['config']
Modifiability,"The main issue causing these errors though is that `cvxpy.Variable` and `cvxpy.Parameter` expect the first arg to be a tuple with dimensions. We are passing `num_rows, num_cols` is two args. Who knows how this has happened - cvxpy changed its interface?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394201690:58,Variab,Variable,58,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394201690,1,['Variab'],['Variable']
Modifiability,"The old `cdef ndarray` syntax can _technically_ be a little faster in some Cython applications because it doesn't involve instantiating a new type; Cython just generates Numpy C-API code. However, this is legacy behaviour of Cython and using these variables generates very old Numpy C-API code in some instances (e.g. pre-Numpy 1.7 (2013)). The memory-view syntax does not require holding the GIL and is rather shorter and easier to read - the former makes threaded parallelisation more possible, particularly in `dev.major` where we are more aggressive about releasing the GIL during heavy computation. Closing for now because it's not really urgent to update old code, but we'll touch it up (speed permitting) as we modify this sort of file in the future. `dev.major` already removed well over half the uses of it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/866#issuecomment-809641984:248,variab,variables,248,https://qutip.org,https://github.com/qutip/qutip/issues/866#issuecomment-809641984,1,['variab'],['variables']
Modifiability,"The plugin was already enabled by default, so this does not turn it on. However, it also defaults to Python 2, which means it produces a lot of syntax errors, and the run (silently) failed every time. This may cause our CodeClimate score to drop, not because we actually got worse, but because we suddenly start seeing a load of duplication that was previously hidden. I'm hoping that getting these parser errors fixed will mean that the ""Progress report"" tab on CodeClimate will start getting populated. **Changelog**: (developer changes) fixed Python version for duplication detection in CodeClimate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577:4,plugin,plugin,4,https://qutip.org,https://github.com/qutip/qutip/pull/1577,1,['plugin'],['plugin']
Modifiability,"The problem was that I was using a pytest plugin to output the docstrings, which are not available in conda. Now I just increased verbosity to 2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1131#issuecomment-560254158:42,plugin,plugin,42,https://qutip.org,https://github.com/qutip/qutip/pull/1131#issuecomment-560254158,1,['plugin'],['plugin']
Modifiability,"The problem with OPENMP is that the point where parallel processing begins to have an advantage is platform, and hardware dependent. As such, I have added a simple benchmark routine that calculates a good number of NNZ that a matrix should have for OPENMP to be utilized. This also required me to change the way the qutiprc file is done, i.e. it now uses the standard configparser module. This benchmark is called on first run, or anytime where the qutiprc 'openmp_thresh' flag is missing, or the qutiprc file itself does not exist.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/652#issuecomment-283874454:368,config,configparser,368,https://qutip.org,https://github.com/qutip/qutip/pull/652#issuecomment-283874454,2,['config'],['configparser']
Modifiability,"The qutip/debian directory should also be moved out of the qutip main repository, but this would require changing the configuration in launchpad and could be a bit tricky.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/160:118,config,configuration,118,https://qutip.org,https://github.com/qutip/qutip/issues/160,1,['config'],['configuration']
Modifiability,"The qutip/setup.py; has these lines. ```; config.add_subpackage('cy'); config.add_subpackage('control'); ```. Should the qip packages and nonmarkov go in there or or is this covered by this in the main setup.py. ```; PACKAGES = ['qutip', 'qutip/ui', 'qutip/cy', 'qutip/qip', 'qutip/qip/models',; 'qutip/qip/algorithms', 'qutip/control', 'qutip/nonmarkov', ; 'qutip/tests']; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/450:42,config,config,42,https://qutip.org,https://github.com/qutip/qutip/issues/450,2,['config'],['config']
Modifiability,"The reason is the same as for https://github.com/qutip/qutip/issues/1265. The pulse starts with 0 for a long time and the adaptive solver skips the real part of the pulse. You need to set `max_step` in `qutip.Options`. You can see this by setting a very small but none-zero value:; ```python; def func(t, *args):; omega_R = 2e-3; if t <100:; return 0.00001; elif t>600:; return 0.00001; else:; return 2*np.pi*omega_R; ```; The result is correct. I'll close it for now but please feel free to ask further questions if there are any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566:122,adapt,adaptive,122,https://qutip.org,https://github.com/qutip/qutip/issues/1945#issuecomment-1168748566,1,['adapt'],['adaptive']
Modifiability,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:231,plugin,plugin,231,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503,1,['plugin'],['plugin']
Modifiability,"The suggestion that @Ericgig and I discussed is that qutip will set the the flags `-w -O3 -funroll-loops` via Cython's `extra_compile_args` *unless* the `CFLAGS` variable is set, in which case it will not set `extra_compile_args`, as Cython picks these `CFLAGS` up. That is if `CFLAGS` is set then qutip assumes the user knows what they are doing and won't interfere. We need to test that this will work with the conda-forge build etc.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/951#issuecomment-466654660:162,variab,variable,162,https://qutip.org,https://github.com/qutip/qutip/issues/951#issuecomment-466654660,1,['variab'],['variable']
Modifiability,"The td-BR solver has about a 3-5 second compile time, regardless of system size. Not 100% sure why it takes this long verses the other solvers, but that is what we got. This Pull allows for passing the usual args dict of variables to the solver for use in td Hamiltonian or c-op terms. In combination with Options(rhs_reuse=True), this should allow the user to bypass additional compilation steps when changing Hamiltonian parameters. This trick does not work for the a_op spectrum strings, since they need to be hardcoded due to limitations in c++.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/750:221,variab,variables,221,https://qutip.org,https://github.com/qutip/qutip/pull/750,1,['variab'],['variables']
Modifiability,"The tests ran fine, besides for the option with OpenMP, where it gave ; ```; /home/travis/miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+2fe7701-py3.7-linux-x86_64.egg/qutip/__init__.py:166: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Calibrating OPENMP threshold...; No output has been received in the last 10m0s, this potentially indicates a stalled build or something wrong with the build itself.; Check the details on how to adjust your build configuration on: https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received; The build has been terminated; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-566115975:557,config,configuration,557,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-566115975,1,['config'],['configuration']
Modifiability,"The variable e does not exist outside the except block even if the try failed...; So trying to give more information about the error resulted in more confusion, sorry. I would suggest to use functions instead of string for your coefficient, the speedpup is often less than the time it take to compile the string, (which is not included in the progressbar). . It is the first case where it would work once, but not the following times. I would be interested in the real error message and/or a code to reproduce the bug. If you are comfortable hacking your version of qutip: adding `print(e)` in the except block; https://github.com/qutip/qutip/blob/01132789581821517986fad1a14ab3feec7d2de2/qutip/qobjevo_codegen.py#L77-L80; should do it give the proper error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196#issuecomment-595847212:4,variab,variable,4,https://qutip.org,https://github.com/qutip/qutip/issues/1196#issuecomment-595847212,1,['variab'],['variable']
Modifiability,"There appears to be a bug in OptimizerLBFGSB.run_optimization . At line 901, _build_bounds_list is called and correctly constructs the list of upper and lower bound tuples and sets self.bounds, however there is no return value. At line 939, the empty variable 'bounds' is passed to scipy.fmin_l_bfgs_b and therefore the constraints are not active. . Easy solution is to change ""bounds=bounds"" to ""bounds=self.bounds"" in line 939.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353:251,variab,variable,251,https://qutip.org,https://github.com/qutip/qutip/issues/353,1,['variab'],['variable']
Modifiability,"There are two reasons I did not go with `isinstance(other, numbers.Number)`:; - This returns False when `other` is a NumPy array or TensorFlow tensor which makes `__mul__` significantly less flexible.; - If we accept objects that are not instances of `numbers.Number`, we will still have to use `complex(other)`. This is necessary to infer if the output is hermitian or unitary. Hence, instead of doing a set of `isinstance` checks and `shape` checks for NumPy TensorFlow or any other future library we may want to be somewhat compatible with, we just check whether other it can be casted to `complex`. If it can, `mul` makes sense and we let the specialisation do whatever they ""want"" (they could always just do complex(value) in any case). I must admit that the try except with complex also seems not ideal to me. But I could not find a better implementation that fitted the requirements. I mean, we do use this same code pattern at some other points in the code (in `__matmul__` we raise not implemented if `other` can not be casted to Qobj and we catch this with a try) but what worries me is: what happens if `complex(other)` raises TypeError not because we do not know how to do the cast but because the user made a mistake in the code? An example of this could be:; ```python; arrray = np.array([1,2]) # length 2 array; qobj*array; ```; This will return `TypeError` but with a different message if we catch it in the `complex(other)` try execpt. ; - _With_ a try execpt that returns NotImplemented (current implementation) the error message is:` TypeError: operand 'Qobj' does not support ufuncs (__array_ufunc__=None)`; - Wehreas _without_ the try expect (not returnt NotImplemented if `complex(other)` fails), the error message is: `TypeError: only length-1 arrays can be converted to Python scalars`, which could be a useful error message.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798:191,flexible,flexible,191,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885550798,1,['flexible'],['flexible']
Modifiability,"There doesn't seem to be the package released under Ubuntu 16.04 channel. After I added the Ubuntu PPA for QuTiP, I got the following error/warning:. ```; qxd@ubuntu1604$: sudo apt-get update; ...; W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; N: See apt-secure(8) manpage for repository creation and user configuration details.; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; ```. Thanks for maintaining it :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/472:487,config,configuration,487,https://qutip.org,https://github.com/qutip/qutip/issues/472,1,['config'],['configuration']
Modifiability,"There is a bunch of .xml and .iml files that keep being tracked in your PR, I expect this is not part of the refactoring but just due to your local environment? You can fix it setting up a specific gitignore in your workspace I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1100#issuecomment-541548331:109,refactor,refactoring,109,https://qutip.org,https://github.com/qutip/qutip/pull/1100#issuecomment-541548331,1,['refactor'],['refactoring']
Modifiability,"There seems to be a bug when trying to solve the Schrödinger equation with the sesolve and essolve functions using an initial state vector. The following code reproduces the error:; ```python; ### import dependencies; %matplotlib inline; from qutip import *; import numpy as np; import matplotlib.pyplot as plt. ### define spin operators at each site ; N = 3 # Number of spins; def sz(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmaz()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sp(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmap()] + [qeye(2) for j in range(i+1,N)]; return tensor(l); def sm(i):; if i==N:; i=0; l = [qeye(2) for j in range(0,i)] + [sigmam()] + [qeye(2) for j in range(i+1,N)]; return tensor(l). ### Hamiltonian with on-site field and XX-type coupling between spins 0&1 and spins 0&2; delta = 1; V1 = 0.1; V2 = 0.1 ; H0 = -0.5*delta*(sz(0) + sz(1) + sz(2)) + V1*(sp(0)*sm(1) + sm(0)*sp(1)) + V2*(sp(0)*sm(2) + sm(0)*sp(2)) . ### no collapse operaters; e_op is total magnetization in z-direction ; c_ops = []; e_ops = [sz(0)+sz(1)+sz(2)]. ### initial state: each spin polarized in x-y-plane; psi0 = tensor([(basis(2,0) + (1j)**i *basis(2,1)).unit() for i in range(0,N)]); rho0 = psi0*psi0.dag(). ### compute time evolution with different solvers; t_list = np.linspace(0, 50, 500); output0 = mesolve(H0, rho0, t_list, c_ops, e_ops); output1 = essolve(H0, rho0, t_list, c_ops, e_ops); output2 = sesolve(H0, psi0, t_list, e_ops). ### plot result; plt.plot(t_list, output0.expect[0], label='mesolve'); plt.plot(t_list, output1.expect[0], label='essolve'); plt.plot(t_list, output2.expect[0], label='sesolve'); plt.legend(). ### time evolution with essolve, use state vector --> Exception raised; output3 = essolve(H0, psi0, t_list, c_ops, e_ops); plt.plot(t_list, output0.expect[0], label='essolve, state vector'); plt.legend(); ```; The Hamiltonian commutes with the operator for which the expectation value is computed as is easily checked. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/841:806,coupling,coupling,806,https://qutip.org,https://github.com/qutip/qutip/issues/841,1,['coupling'],['coupling']
Modifiability,"These are all the remaining files from #1181 that neither Eric nor Boxi had explicitly said they were checking, with the commits all tidied up and rebased onto `master`. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1252:259,refactor,refactor,259,https://qutip.org,https://github.com/qutip/qutip/pull/1252,1,['refactor'],['refactor']
Modifiability,"These are the files that Boxi (@BoxiLi) was checking in #1181, but the commits are tidied up and rebased onto `master`. The merge conflict in `test_gates.py` that's present in #1181 is fixed (with all the tests safely maintained). This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1251:320,refactor,refactor,320,https://qutip.org,https://github.com/qutip/qutip/pull/1251,1,['refactor'],['refactor']
Modifiability,"These are the files that Eric (@Ericgig) was checking in #1181, but the commits are tidied up and rebased onto `master`. I'll copy over the review comments in that PR that haven't been actioned yet. The potential merge conflict with `test_mcsolve.py` is fixed. This is based on #1249, and that one needs to be merged first. **Changelog**; Major test refactor into a pytest style.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1250:350,refactor,refactor,350,https://qutip.org,https://github.com/qutip/qutip/pull/1250,1,['refactor'],['refactor']
Modifiability,"These tests seem a little too scant in my opinion, I am not fully satisfied with the final result. They do not provide full coverage of these new functionalities. I am thinking of refactoring the whole thing and start all over again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1224#issuecomment-607558652:180,refactor,refactoring,180,https://qutip.org,https://github.com/qutip/qutip/pull/1224#issuecomment-607558652,1,['refactor'],['refactoring']
Modifiability,"This PR is part of PR #969 , splitting that PR in two parts. It contains:; - `qobjevo`'s args that update with the state. (replacing rhs_with_state functionality) ; - method `norm` renamed to `_cdc` as it was not used as a norm.; - cython side of expect method no longer take `isherm` as an arguments.; - security check in propagator for `H` as a function with `batch` method.; - `propagator` uses `sesolve` capability to evolve operators.; - floquet now call `sesolve` instead of `mesolve` with no collapse.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990:422,evolve,evolve,422,https://qutip.org,https://github.com/qutip/qutip/pull/990,1,['evolve'],['evolve']
Modifiability,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/998:763,refactor,refactoring,763,https://qutip.org,https://github.com/qutip/qutip/pull/998,1,['refactor'],['refactoring']
Modifiability,This also affects qutip-qip and other family packages that inherited the qutip `setup.py` file.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183:59,inherit,inherited,59,https://qutip.org,https://github.com/qutip/qutip/issues/2036#issuecomment-1342861183,1,['inherit'],['inherited']
Modifiability,This builds fine except for the cqobjevo_omp module that uses unsigned variables for the openmp for loop which is not allowed on windows. It will work fine after that is fixed,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/954#issuecomment-466762659:71,variab,variables,71,https://qutip.org,https://github.com/qutip/qutip/issues/954#issuecomment-466762659,1,['variab'],['variables']
Modifiability,"This change enables the use of Python standard logging, and backs it by a new qutip.settings entry. A few instances of classic `if debug: print` style logging have been refactored. The new `qutip.settings` entry is based on [configobj](http://configobj.readthedocs.org), with a fallback to classic `~/.qutiprc` parsing if that library is not available. Errors in the new functionality introduced by this commit are also logged, and can be accessed by setting up `logging.basicConfig` _before_ importing QuTiP. The optional configobj dependency should almost always be met, since it's shipped with matplotlib.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248:169,refactor,refactored,169,https://qutip.org,https://github.com/qutip/qutip/pull/248,4,"['config', 'refactor']","['configobj', 'refactored']"
Modifiability,"This document is a design specification for new dimensions handling. It is only a draft right now; please feel free to offer comments and suggestions. If you only read one section, read ""Overview"" inside ""Proposal"" to get the gist of what will happen. ## Background. For an extended discussion of some of the problems in 4.x branch dimension handling, see #1320. With the new system, we aim to solve a few main problems:; 1. `Qobj` `type` inference should be instantaneous; 2. Binary operation dimension compatibility tests should be instantaneous; 3. Dimension/shape equality tests should be instantaneous; 4. Invalid dimensions should not be representable; Currently, dimension handling is the major overhead in `Qobj` because these problems are not solved. The allowed exception to point 1 is if we include a short-hand notation to represent dimension objects; we may allow a ""pure-Python"" representation (effectively the current dimension specification) to be parsed into new-form dimension objects for user convenience. Certain objects, like the excitation-number-restricted spaces (enr) may not have ""compatible"" dimensions and shapes. This may need further discussion elsewhere. ## Proposal. ### Overview. The principle change is to make dimension objects singleton instances of classes. All `Qobj` of the same dimension will have a reference to the exact same object, which has all the expensive operations already calculated. Internally, dimensions will represented in a very pure linear algebra manner. A dimension object is a single `Dims` object, which is exactly one of the subclasses:; - `Space` representing a vector space; * `Space(size: int)` is a standard ket; * `Space(Map(...))` is an operator-ket; - `Space(Map(from, to))` representing an operator in column-stacked format.; - `Map(from, to)` representing some mapping `Dims -> Dims`; - `Field` used only to represent the absence of `Dims` in `Map` and `Compound`. A `Qobj` may not have this `dims`; it would simply be a complex n",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421:274,extend,extended,274,https://qutip.org,https://github.com/qutip/qutip/issues/1421,1,['extend'],['extended']
Modifiability,"This fixes the calls to the `qutip.configrc` module in `qutip/__init__.py` when setting up OpenMP. Also, this tidies up a lot of very old code out of `__init__.py` that was testing for ancient versions of SciPy and Numpy. Since we have hard requirements at installation time for those, it's fine for us not to test their versions at initialisation. We still should check the version of Cython because it's an optional dependency, so isn't always constrained by the package manager. Some of the changes deliberately make `qutip/__init__.py` less forgiving of exceptions, especially when it comes to loading up `pyximport`. This is deliberate, even though it may make a couple more errors surface that have previously gone undetected. As it stands right now, the file will causes several errors to be silently ignored, even if they weren't the error we were testing for. That masks problems for a short while, but they usually resurface during use when they're much harder to debug. We should be solving the underlying problems, not sweeping them under the rug. In particular, we've frequently had complaints about `pyximport` failing, or trying to import OpenMP modules that have previously been compiled but aren't currently active, and things like that. This patch won't fix all those problems, but it hopefully will make some of them easier to debug when they do appear. There is more explanation to the logic behind each change in the commit messages. Fix #1470.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1471:35,config,configrc,35,https://qutip.org,https://github.com/qutip/qutip/pull/1471,1,['config'],['configrc']
Modifiability,This is a good find. Previous versions of Anaconda did not show the correct dirs in numpy.**config**. They used to point the the Intel compiler directory that built them. This makes things easier than I thought.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204252414:92,config,config,92,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204252414,1,['config'],['config']
Modifiability,"This is a tidied up and completed version of #934. The first commit is credited to the original author (although I fixed up some little concerns in the PR and rebased it), because it's logically built off that PR, although in the end it's a complete reimplementation. This is a complete rewrite of the Husimi Q calculations, to make a more formal split between the iterative (low-memory) and precomputed (faster) algorithms, giving full access to both of them. It's a bit easier to use from a user's perspective, and it's faster than #934 as well. The concept of the precomputed matrix is encapsulated into a class with a cached tensor, so that the same precomputed system can be used for many states of different sizes, and autoexpands (up to the memory limit) to accommodate larger states. This is called `QFunc` as opposed to the standard function interface `qfunc`. It also adds rather more error checking on its inputs, and adds a complete testing suite for the new implementation. Closes #934. ## Examples. Let's say we have some states, and the phase-space coordinates we want to calculate the Husimi Q function at.; ```python; >>> import qutip; >>> states = [qutip.rand_dm(32, density=0.2) for _ in [None]*100]; >>> xs = np.linspace(-2, 2, 401); ```. Now the normal way of calculating the Q distribution for a single state is; ```python; >>> qutip.qfunc(states[0], xs, xs); array( ... ); ```. This already has some speed advantages over the pre-PR version of `qfunc`, because it caches a lot of its intermediary results, to avoid recomputing them. This results in calculating more matrix-vector products than before, but far fewr FLOPS overall. By default, `qfunc` issues a warning if it exceeds a certain amount of memory, and falls back to the low-memory version. You can control this limit with the `precompute_memory` option:; ```python; >>> qutip.qfunc(states[0], xs, xs, precompute_memory=0); qutip/qutip/wigner.py:822: UserWarning: Falling back to iterative algorithm due to lack of mem",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583:287,rewrite,rewrite,287,https://qutip.org,https://github.com/qutip/qutip/pull/1583,1,['rewrite'],['rewrite']
Modifiability,"This is an interesting bug, thanks for raising it! Roughly, QuTiP looks at `$HOME` to find where the `qutiprc`configuration file. If QuTiP can't find it, it will raise a warning and proceed with defaults, so that shouldn't adversely affect you unless you've set some flags like `debug=True`. That said, we should definitely raise a less intimidating warning when `$HOME` is unset.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/365#issuecomment-136613770:110,config,configuration,110,https://qutip.org,https://github.com/qutip/qutip/issues/365#issuecomment-136613770,1,['config'],['configuration']
Modifiability,"This is code from a jupyter notebook in which I am trying to plot a graph of mesolve. Times is the variable that specifies the scale of the x axis (in units of s). I need to plot over 1ms, but it takes so long to plot that I think it just get stuck. If I plot over a much smaller scale, like 10^-6, it plots with no problem, but even then it can only do so if the number of points is small. It seems that the issue is with nsteps. As you can see, I have made nsteps very large already and if I make it any larger I get an error. I've tried debugging this to the best of my abilities but I've hit a dead end and I just can't find any useful info on nsteps online. %matplotlib inline. import matplotlib.pyplot as plt; import numpy as np; import qutip as q; import cmath; import matplotlib as mpl; from mpl_toolkits.mplot3d import Axes3D. rc_dict = {; ""figure.subplot.bottom"": 0.11,; ""figure.subplot.hspace"": 0.2,; ""figure.subplot.left"": 0.125,; ""figure.subplot.right"": 0.9,; ""figure.subplot.top"": 0.88,; ""figure.subplot.wspace"": 0.2,; ""figure.figsize"":(10,10/1.61),; ""axes.grid"": True,; ""text.usetex"": True,; ""grid.linestyle"": "":"",; ""grid.color"": ""black"", #; ""legend.fontsize"": 20,; ""lines.linewidth"": 2.5,; ""axes.linewidth"": 1.5,; ""font.family"": [""serif""],; ""font.sans-serif"": ""Times New Roman Bold"",; ""font.size"":26,; }; plt.rcParams.update(rc_dict). qutip_options = q.Odeoptions(; store_states=True,; nsteps=2000000000000; ). si, sx, sy, sz=q.qeye(2), q.sigmax(), q.sigmay(), q.sigmaz(); sp, sm=q.sigmap(), q.sigmam(); state_z_plus=q.basis(2,0); state_z_minus=q.basis(2,1); state_x_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + q.basis(2,1)); state_x_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - q.basis(2,1)); state_y_plus=1.0/cmath.sqrt(2)* (q.basis(2,0) + 1j* q.basis(2,1)); state_y_minus=1.0/cmath.sqrt(2)* (q.basis(2,0) - 1j* q.basis(2,1)). h = 6.62607015e-34; b = 0.1786195317554453 ; b_AC = 3.572390635108906e-05 ; g = 2; u = 9.274E-24 ; w = g*u*b/h . gamma_phi = 442; gamma_minus = 1. epsilon = g*u*b/h",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1376:99,variab,variable,99,https://qutip.org,https://github.com/qutip/qutip/issues/1376,1,['variab'],['variable']
Modifiability,"This is just a test. ; Since many failed Travis builds had a malloc error, also according to [this StackOverflow thread](https://stackoverflow.com/questions/19840671/malloc-error-incorrect-checksum-for-freed-object-object-was-probably-mod/19841133) it seemed that XCode was the source of the problem. . I added as osx environment in the travis configuration file xcode 10.2 (should be on osx 10.14 Mojave, not sure though). Build still fails, now at ; ```; Qobj subtraction ... python(2491,0x1192585c0) malloc: Incorrect checksum for freed object 0x7ffe6ff1ad50: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(2491,0x1192585c0) malloc: *** set a breakpoint in malloc_error_break to debug; /Users/travis/.travis/functions: line 104: 2491 Abort trap: 6 nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip; The command ""nosetests --verbosity=2 --with-coverage --cover-package=qutip qutip"" exited with 134.; ```; which seems a pretty basic test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/985#issuecomment-485054530:344,config,configuration,344,https://qutip.org,https://github.com/qutip/qutip/pull/985#issuecomment-485054530,1,['config'],['configuration']
Modifiability,"This is just for future reference for topological quantum circuits. A lab mate of mine (https://github.com/rxnew/) has developed a nice code for visualisation of topological quantum circuits which can be seen here - http://sahmed.in/tqc_viewer/. Click on one of the samples to see the circuit visualisation. It is in 3D and you can zoom in, zoom out and pan the figure. In future, if we implement topological quantum computing, surface codes etc we may wish to use this in some way. . I also had some difficulties with the LaTeX visualisation of quantum circuits and I was wondering if that could be improved somehow. Particularly, the .png file is not created during latex compilation. I will try to reproduce the issue and post here. This should probably be marked as an enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/623:773,enhance,enhancement,773,https://qutip.org,https://github.com/qutip/qutip/issues/623,1,['enhance'],['enhancement']
Modifiability,"This is my first attempt at fixing and slightly extending the functionality of the countstat_current_noise(); function in countstat.py. There were several issues with this function, which I have attempted to rectify as described below. Also its my first pull request (instead of asking anubhav or alex to help), so if I messed it up let me know. 1) The default method, a direct solution using sparse matrices, would fail with an ""exactly singular"" error on small examples (like the well studied single-resonant level or double quantum dot examples). The other sparse methods also suffered from the same issue, as did the 'direct' method for dense solutions. The latter, the dense matrices solver, I have fixed by capturing the error using lstsq() if np.linalg.solve() fails. For the sparse cases there seems to no equivalent fix. One can solve the issue by adding a small finite frequency to the definition of the shot noise. However, this seems like a bit of a bodge, and could cause issues if this small frequency is of the order of some system frequencies. So I have changed the default behavior to use the dense solvers, and added a description of the sparse matrix issues in the function description and in an example notebook I will upload to the example notebooks github. . Maybe someone can suggest a better fix?. 2) There was, in addition, an error in the definition of the shot noise formula in the default sparse matrix direct solution. In addition, the dense methods which used pinv() were also incorrectly defined (they were missing pre and post- multiplication by the 'Q' operator), and would thus give different results from the direct solutions. These issues have been fixed, and everything now fits expected analytical results (see example notebook). 3) I have added a frequency dependence via a list of possible frequencies at which to evaluate the shot noise. 4) I removed the option of passing a pseudo-inverse to the function directly, and changed various other interface things. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528:48,extend,extending,48,https://qutip.org,https://github.com/qutip/qutip/pull/528,1,['extend'],['extending']
Modifiability,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959:251,config,configurations,251,https://qutip.org,https://github.com/qutip/qutip/issues/959,1,['config'],['configurations']
Modifiability,"This is ready for a review. I incorporated the changes and the pep8 fixes. We still might go for a change in the name for the module as `piqs` and the class as `Dicke` to follow the naming in the paper. There are some more tests that we would like to add today. . However, for the rest of it, things remain the same. Since the `is_diagonal` feature is more general, I could open a PR to include that as a `Qobj` property. Otherwise, this function will only be used once we add the enhancement `diagonal_solver` which can solve for some special classes of Hamiltonians. But that is for later.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-367197236:481,enhance,enhancement,481,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-367197236,1,['enhance'],['enhancement']
Modifiability,"This is the base PR for the split-up of #1181. This one puts in all the helper functions and updates to previously converted files that are present in that PR, and needs to be merged first before any of the others can be merged. The commits are tidied up and rebased onto `master`. This is the base PR for #1250, #1251 and #1252. **Changelog**; Add pytest helper functions for large-scale test refactoring",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249:394,refactor,refactoring,394,https://qutip.org,https://github.com/qutip/qutip/pull/1249,1,['refactor'],['refactoring']
Modifiability,"This is the clean PR contains the main part of my commits to this GoSC project. It includes the following main points:. 1. A numerical Noisy Intermediate Scale Quantum Computing (NISQ) simulator using the QuTiP opens system solver.; 2. Refactoring the existing `SpinChain` and `CavityQED` module, so that they can also use the numerical simulator.; 3. A noise module `CircuitNoise` that complements the simulator with a framework for noise handling. Documentation can be found at https://github.com/qutip/qutip-doc/pull/85; Notebooks and examples are at https://github.com/qutip/qutip-notebooks/pull/88 . There are other small independent RPs. It would be helpful for the review if they are merged first. - [x] #1050 Modifies the QobjEvo class for step function coefficients; - [x] #1052 Update expand_operator for cyclic permutation; - [x] #1064 Fix the wrong type handling for constant QobjEvo; - [x] #1075 Fix the cyclic importation in the control module. After they get merged, the changed files should be limited within the `qip` module.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1065:236,Refactor,Refactoring,236,https://qutip.org,https://github.com/qutip/qutip/pull/1065,1,['Refactor'],['Refactoring']
Modifiability,"This issue has a two-fold interest: decreasing test time in general and expand the platforms through which QuTiP is available. . What is the reason it takes so long on Nix? QuTiP, in the [latest PR](https://travis-ci.org/qutip/qutip/builds/628865624?utm_source=github_status&utm_medium=notification), takes on average 20 minutes to run its tests on a given platform. Much of this I think is due to the Cython configurations, indeed the no-cython option takes only 13 minutes. My first suggestion would be to try without Cython if things speed up, from those requirements (@Ericgig set that up and I am not knowledgeable about it). . From your PR on `nixpkgs` do you build on Travis CI or a similar cloud? If you could give a list of time taken by the different tests that would help. . The idea of a subset of tests is interesting (essential tests vs. thorough tests), in general; for example thorough tests could be done only in production and a lighter version could be called with `qutip.testing.run()`. Although, in specific, it is not clear to me how to triage which tests to skip. I would be glad to have the others opinion on this too (pinged them as assignees).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1147#issuecomment-569696700:409,config,configurations,409,https://qutip.org,https://github.com/qutip/qutip/issues/1147#issuecomment-569696700,2,['config'],['configurations']
Modifiability,"This looks great and I think it will help a lot in cleanly implementing more complex solvers light the HEOMSolver. I have two suggestions for future improvements:. - I'd like to see `.options = ...` become a method because it now modifies the existing integrator and `.options(...)` would both make that clearer and more flexible. E.g. with a method we could allow both `.options(new_options)` to completely override the options and `.options(key=new_value)` to update just one setting. - The first call to `result.add(t, X)` uses `X = state0` but state0 could be almost anything the user passed in (and not necessarily the canonical form returned by `_restore_state`). It would be better if either there was a separate method to override to convert `state0` into the canonical form, or `result.add(t, X)` was called initially with `X = _restore_state(_data0)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616:321,flexible,flexible,321,https://qutip.org,https://github.com/qutip/qutip/pull/1879#issuecomment-1108749616,2,['flexible'],['flexible']
Modifiability,"This parallelism does not come from `qutip` but `scipy`: `coherent` use `scipy.sparse.linalg.expm` which run in parallel for big matrix.; This can be fixed with enviroment variable like`$ export OPENBLAS_NUM_THREADS=1` in bash or `os.environ[""OPENBLAS_NUM_THREADS""] = ""1""` in python, but there are a few possibilities:; ```; OMP_NUM_THREADS: openmp,; OPENBLAS_NUM_THREADS: openblas,; MKL_NUM_THREADS: mkl,; VECLIB_MAXIMUM_THREADS: accelerate,; NUMEXPR_NUM_THREADS: numexpr; ```; See https://stackoverflow.com/questions/30791550/limit-number-of-threads-in-numpy",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1175#issuecomment-583773226:172,variab,variable,172,https://qutip.org,https://github.com/qutip/qutip/issues/1175#issuecomment-583773226,1,['variab'],['variable']
Modifiability,"This patch overhauls how QuTiP is packaged and distributed. Once this patch is merged to `master` (not just `dev.major`), there will be an option on QuTiP's GitHub Actions tab for people who have write permission on qutip/qutip to build all wheels and optionally release the build to PyPI, making it available on `pip` as a binary release. The major changes are in the files `pyproject.toml`, `setup.py`, `setup.cfg` and `.github/workflows/build.yml`, while `MANIFEST.in` and a new file `VERSION` were also touched. The patch also contains two commits that remove unused OpenMP code and remove a particularly problematic C struct from some inner Python code; the struct and the presence of the dead code caused portability problems, and they in no way change the behaviour of the package. ### Distribution changes:; - there is a GitHub Action which will build all the wheels for CPython 3.6+ on Linux (`manylinux1` x86 and x86_64), macOS and Windows (32- and 64-bit). This action is triggered manually, and the wheels will be available for download afterwards. Optionally, the action will push to PyPI, making the version immediately available on `pip` by binary release.; - `.cpp` files are now distributed with the wheels but not added to source control. This is a step towards a full Cython-free delivery of the QuTiP source (binary releases never require Cython), but right now I think our `setuptools` machinery doesn't quite handle that. ### Changes to `setup.py`; - all package metadata is moved out into `setup.cfg`, which is easier to read and change, and modern `setuptools`' preferred way of doing things; - build requirements are moved into `pyproject.toml` including listing `setuptools` as the build method, in accordance with PEP 517. Any PEP 517-complaint installation and build process will now _enforce_ the presence of `numpy`, `scipy` and `cython` (and `setuptools`) before attempting the build, so no more need for attempted import guards.; - packages are now discovered rather th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429:711,portab,portability,711,https://qutip.org,https://github.com/qutip/qutip/pull/1429,1,['portab'],['portability']
Modifiability,"This randomly failing test appears again. It is really getting annoying. I copied the error message from Travis bellow:. ```; =================================== FAILURES ===================================; ___________________________ test_MCSimpleConstStates ___________________________; @pytest.mark.slow; def test_MCSimpleConstStates():; ""Monte-carlo: Constant H with constant collapse (states)""; N = 10 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 9) # initial state; kappa = 0.2 # coupling to oscillator; c_op_list = [np.sqrt(kappa) * a]; tlist = np.linspace(0, 10, 100); mcdata = mcsolve(H, psi0, tlist, c_op_list, [], ntraj=ntraj,; options=Options(average_states=True)); assert_(len(mcdata.states) == len(tlist)); assert_(isinstance(mcdata.states[0], Qobj)); expt = expect(a.dag() * a, mcdata.states); actual_answer = 9.0 * np.exp(-kappa * tlist); avg_diff = np.mean(abs(actual_answer - expt) / actual_answer); > assert_equal(avg_diff < mc_error, True); E AssertionError: ; E Items are not equal:; E ACTUAL: False; E DESIRED: True; ../../../../miniconda/envs/test-environment/lib/python3.7/site-packages/qutip-4.5.0.dev0+4512014-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_mcsolve.py:240: AssertionError; ----------------------------- Captured stdout call -----------------------------; 10.0%. Run time: 2.25s. Est. time left: 00:00:00:20; 20.0%. Run time: 4.93s. Est. time left: 00:00:00:19; 30.0%. Run time: 6.67s. Est. time left: 00:00:00:15; 40.0%. Run time: 8.10s. Est. time left: 00:00:00:12; 50.0%. Run time: 10.13s. Est. time left: 00:00:00:10; 60.0%. Run time: 12.40s. Est. time left: 00:00:00:08; 70.0%. Run time: 14.97s. Est. time left: 00:00:00:06; 80.0%. Run time: 16.57s. Est. time left: 00:00:00:04; 90.0%. Run time: 18.81s. Est. time left: 00:00:00:02; 100.0%. Run time: 20.29s. Est. time left: 00:00:00:00; Total run time: 20.34s; ---------- coverage: platform darwin, python 3.7.7-final-0 -----------; Name ; ```; Restart the tests",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1209#issuecomment-607477749:529,coupling,coupling,529,https://qutip.org,https://github.com/qutip/qutip/pull/1209#issuecomment-607477749,1,['coupling'],['coupling']
Modifiability,"This removes the `CI_QUTIP_RELEASE` environment variable and the `--release` flag to `setup.py` in favour of deriving this information from the `VERSION` file. This file should now contain a `.dev` suffix on the `master` and `dev.major` branches to indicate that they are not releases, while release branches will omit it. This means that sdists will no longer attempt to build in local development mode. This also fixes the related bug in handling local versioning when `git` is not installed on the system by making sure any relevant errors are caught. Fix #1514 (after a new sdist release)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1541:48,variab,variable,48,https://qutip.org,https://github.com/qutip/qutip/pull/1541,1,['variab'],['variable']
Modifiability,"This seems to fix the issue reported by Vlad on the Google group. This fixes the errors when using complex cmath header and typedef variables. Variables must be of float, int, or complex, not np.kind_t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/322:132,variab,variables,132,https://qutip.org,https://github.com/qutip/qutip/pull/322,2,"['Variab', 'variab']","['Variables', 'variables']"
Modifiability,"This segfault is still _very_ occasionally present on Mac as of QuTiP 4.6.0 and the current master (624405e7). Unfortunately, I've not been able to find any sort of reliable reproducer, so I can't offer a huge amount of insight into what might be causing it. Here's an example output:; ```; jake@tauros$ pytest tests/test_superop_reps.py; =========================================================================================== test session starts ============================================================================================; platform darwin -- Python 3.8.8, pytest-6.2.3, py-1.10.0, pluggy-0.13.1; rootdir: /Users/jake/code/qutip/qutip/qutip/tests, configfile: pytest.ini; plugins: rerunfailures-9.1.1; collected 15 items. tests/test_superop_reps.py ..F............ [100%]. ================================================================================================= FAILURES =================================================================================================; ____________________________________________________________________________________ TestSuperopReps.test_ChoiKrausChoi ____________________________________________________________________________________. self = <qutip.tests.test_superop_reps.TestSuperopReps object at 0x11f1140d0>. Fatal Python error: Segmentation fault. Current thread 0x000000010c77b5c0 (most recent call first):; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 312 in _optimize_charset; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 120 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 607 in _code; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/sre_compile.py"", line 768 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 304 in _compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/re.py"", line 252 in compile; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:669,config,configfile,669,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,2,"['config', 'plugin']","['configfile', 'plugins']"
Modifiability,"This was an incredibly minor optimisation that had a ~2% speedup in some cases on Linux/Mac, but was preventing the build in some configurations on Windows due to failed type conversions. That's not a worthwhile trade-off for some functions that aren't even used that heavily in QuTiP code. I'm now using `dev.major` QuTiP on a Windows machine in day-to-day life, so maybe I'll catch a few more problems with it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1485:130,config,configurations,130,https://qutip.org,https://github.com/qutip/qutip/pull/1485,1,['config'],['configurations']
Modifiability,This will take a bit of work. Especially since the docs are not so easy to read. Just changing the setup import does not work as we use numpy.distutils for the configuration.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/593#issuecomment-269730765:160,config,configuration,160,https://qutip.org,https://github.com/qutip/qutip/issues/593#issuecomment-269730765,1,['config'],['configuration']
Modifiability,"Topic:. The `measure(state, ops)` and `measurement_statistics(state, ops)` functions in the measurement PR #1274 have different return types based on whether `ops` is a single observable or a list of POVMs. For e.g. the `measurement_statistics` returns; ; > eigenvalues: List of floats; The list of eigenvalues of the measurement operator.; eigenstates_or_projectors: List of Qobj; If the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates.; probabilities: List of floats; The probability of measuring the state as being in the; corresponding eigenstate (and the measurement result being; the corresponding eigenvalue). if `ops` is an observable and ; ; > collapsed_states : List of Qobjs; the collapsed states (density matrices) obtained after; measuring the qubits and obtaining the; qubit specified by the target in the state; specified by the index.; probabilities : List of floats; the probability of measuring a state in a the state; specified by the index. if `ops` is a list of POVMs/PVMs. Is there a good way to specify a numpy docstring for the function given that the return variables can vary !",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1305:1158,variab,variables,1158,https://qutip.org,https://github.com/qutip/qutip/issues/1305,1,['variab'],['variables']
Modifiability,"Two suggestions: ; 1. QuTiP uses an environment variable `NUM_THREADS`. We should probably name-space this variable, calling it `QUTIP_NUM_THREADS` (consistent with how other packages name their variables, like `MKL_NUM_THREADS` and `OPENBLAS_NUM_THREADS`. The upcoming 3.0 release would be a good time to make this change.; 2. Considering that QuTiP does not use thread but processes, it would be even better to call the variable `QUTIP_NUM_PROCESSES`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119:48,variab,variable,48,https://qutip.org,https://github.com/qutip/qutip/issues/119,4,['variab'],"['variable', 'variables']"
Modifiability,UnboundLocalError: local variable 'e' referenced before assignment,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196:25,variab,variable,25,https://qutip.org,https://github.com/qutip/qutip/issues/1196,1,['variab'],['variable']
Modifiability,UnboundLocalError:local variable 'e' referenced before assignment,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1244:24,variab,variable,24,https://qutip.org,https://github.com/qutip/qutip/issues/1244,1,['variab'],['variable']
Modifiability,"Update Travis build passes. ### Summary . This PR helps convert between superop reps with non-square shape. This is needed because quantum channels can have input and output spaces of different dimension. It works between super, choi, kraus. It correctly handles tensor product structures and systems with different dimensions e.g. a qubit and a qutrit. . It does not work for Chi rep or the Steinspring rep. In the Chi rep only the qubit Pauli basis has been implemented. One would need to first get the Chi rep working for Qudits. At the moment it is unclear how to generalize to the Stinespring rep. . **changes**; - in `type_from_dims` the flag `enforce_square` was set to `False`. This helps in the conversion.; - in `qobj`, `__mul__` was extended to allow construction of non square operators from an outer product using the suggestion of @Ericgig ; - `_super_tofrom_choi`, `choi_to_kraus`, `kraus_to_choi` have been changed so they work with non-square shapes.; - to support the above changes `vector_to_operator` and `vec2mat` were changed to allow for non square shapes. **other changes**; - `Qobj permute`. `tidyup` was removed from to resolve a failing test at the suggestion of @nonhermitian ; - `choi_to_kraus` and `to_kraus`. When converting from Choi to to Kraus there are many small norm Kraus operators. A `tol` parameter was added to help remove these spurious operators. ### Added Tests; **test_superoperator_reps**; - Convert non-square Kraus operator to Super + Choi matrix and back.; - Neglect tiny Kraus operators when converting Choi to Kraus. **test_superoper**; - Operator - vector - operator conversion with a tensor product state.; - Operator - vector - operator conversion for non-square matrix. **test_qobj**; - bra and ket multiplication with different dims e.g. [N, 1] and [1, M] for M \neq N",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1098#issuecomment-576981021:744,extend,extended,744,https://qutip.org,https://github.com/qutip/qutip/pull/1098#issuecomment-576981021,1,['extend'],['extended']
Modifiability,Update test_superop_reps to parameterized pytest format,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1825:28,parameteriz,parameterized,28,https://qutip.org,https://github.com/qutip/qutip/pull/1825,1,['parameteriz'],['parameterized']
Modifiability,Variable used before declaration in `smesolve` for heterodyne detection.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2078:0,Variab,Variable,0,https://qutip.org,https://github.com/qutip/qutip/issues/2078,1,['Variab'],['Variable']
Modifiability,"We had an issue like this in the past. The ODE use variable steps sizes, when nothing happens, these steps can become very long and skip over the pulse. The option max_step can limit this step size, so it should be set to be shorter than the shortest pulse.; Here I beleive that using `options=qu.Options(max_step=5)` in the solver calls would fix it.; If it does not work, I can look in more details next week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-629712706:51,variab,variable,51,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-629712706,1,['variab'],['variable']
Modifiability,"We had it before and it introduced issues that lead us to remove it, see #1278, #1433, #1611... It also limits us to what is a `Qobj` which we have ideas extend.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195:154,extend,extend,154,https://qutip.org,https://github.com/qutip/qutip/pull/2533#issuecomment-2400118195,1,['extend'],['extend']
Modifiability,"We have a number of pull requests that are all nice fixes and enhancements, however we are delaying merging because of travis test failures. I can't see how any of these pull request can be an underlying cause:; #421; #422; #428; #429. So I will merge all these. We can then investigate what is causing some of the tests to fail under this issue.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/430:62,enhance,enhancements,62,https://qutip.org,https://github.com/qutip/qutip/issues/430,1,['enhance'],['enhancements']
Modifiability,"We have been talking about pulse level control in the `qip` device simulator for a while, but I just released that we didn't really define it in as separate ""pulse"". I find it really important and therefore I rewrite the data part of the `qip` numerical simulator as a new class `Pulse`. It's quite interesting that I end up to define a class very similar to `EvoElement` in `Qobjevo` (I called it `_EvoElement` for internal use, cannot find a better name). Instead of the full Hamiltonian, I only save the target qubits label and the non-trivial Hamiltonian (e.g. `sigmaz()` instead of `tensor(sigmaz(), identity(2)`). It is defined in this way for easy inspection after initialized, such as adding noise. `_EvoElement` consists of; - Hamlitonian; - Target qutbis label; - `tlist`; - `coeff`. `Pulse` consists of. - ideal part: `_Evoelement`; - coherent noise: list of `_Evoelement`; - lindblad noise: list of `_Evoelement`. The advantages are:; - A list of `Pulse `is easier to understand and manipulate compared to the old design: a list of H and a list of `coeff`. Now different `tlist `can also be defined for different pulses.; - Adding noise is much easier as we now can get the non-trivial part of the Hamiltonian and the targets of each pulse, instead of only a huge Hamiltonian in `QobjEvo`. One can now define noise for each Pulse. Still working on the docs.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1155:209,rewrite,rewrite,209,https://qutip.org,https://github.com/qutip/qutip/pull/1155,1,['rewrite'],['rewrite']
Modifiability,"We have decided not to continue to maintain the Ubuntu channel. Please; install from source to using qutip 3.2.; Alternatively you can use the conda-forge channel if you are able to work; with qutip 3.1. On 9 May 2016 at 02:52, Qi notifications@github.com wrote:. > There doesn't seem to be the package released under Ubuntu 16.04 channel.; > After I added the Ubuntu PPA for QuTiP, I got the following error/warning:; > ; > qxd@ubuntu1604$: sudo apt-get update; > ...; > W: The repository 'http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu xenial Release' does not have a Release file.; > N: Data from such a repository can't be authenticated and is therefore potentially dangerous to use.; > N: See apt-secure(8) manpage for repository creation and user configuration details.; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-amd64/Packages 404 Not Found; > E: Failed to fetch http://ppa.launchpad.net/jrjohansson/qutip-releases/ubuntu/dists/xenial/main/binary-i386/Packages 404 Not Found; > ; > Thanks for maintaining it :); > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/472",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/472#issuecomment-218122293:765,config,configuration,765,https://qutip.org,https://github.com/qutip/qutip/issues/472#issuecomment-218122293,1,['config'],['configuration']
Modifiability,"We should modify the `QubitCircuit` class to have input and output states specified for a quantum circuit. Currently the `QubitCircuit` class has only the following variables - N, reverse_gates, gates, U_list. We could add two more variables - input_states, output_states which could contain the input and output states as a list or a dictionary with the qubit number as key and the state as the value. This can be added to QubitCircuit [here](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L168). . Then we can modify the function [`latex_code`](https://github.com/qutip/qutip/blob/master/qutip/qip/circuit.py#L939) to add in the input and output states similar to how the gates are added so the qcircuit latex package compiles it. The original [discussion](https://groups.google.com/forum/#!topic/qutip/QRu54GlED9A) can be found in the QuTiP Google help group where Morten Kjaergaard suggested this. . To do; -----. - [x] Add input and output states to `QubitCircuit` class.; - [x] Implement latex visualisation of input and output states.; - [ ] Create a dictionary to label known states and get their representation using the `qubit_states` function for computation. {""+"": (|0> + |1>)/sqrt(2), ""0"": 0}. This can be used with the `qubit_state` function to get a `Qobj` so that it can be used for computing.; - [ ] Add a method to get output states from input states by acting the propagators of the circuit on the given input states.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/678:165,variab,variables,165,https://qutip.org,https://github.com/qutip/qutip/issues/678,2,['variab'],['variables']
Modifiability,"What about the c99 complex math functions? Are those a possibility? Perhaps we could specify that 'j' is a reserved variable and then search the input string for 'j' and then call math or cmath, depending on the result.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-61041717:116,variab,variable,116,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-61041717,1,['variab'],['variable']
Modifiability,"When I ran against @dick-t's example, it still violated the bound F ≤ 1, but by significantly less than before, as can be confirmed by the [success of `test_fidelity_bounded_purepure`](https://github.com/qutip/qutip/pull/362/files#diff-3e3c19be6d013d22c4823607e07cd240R106), introduced by #362. That PR doesn't fully adapt to the pure vs pure case that @dick-t lists, but it does avoid `sqrtm` in that case. I can fully specialize to that case, if you like, by using the inner product of the two pure states.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134930346:317,adapt,adapt,317,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134930346,1,['adapt'],['adapt']
Modifiability,"When I try it now, it says that the software plugin is incompatible with the OS, which is 10.14.5, Mojave.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1030#issuecomment-574232335:45,plugin,plugin,45,https://qutip.org,https://github.com/qutip/qutip/issues/1030#issuecomment-574232335,1,['plugin'],['plugin']
Modifiability,"When doing pulse type simulations, it is best to set the max_step size to be half the width of the smallest pulse in the simulation. This makes sure that pulses do not get over stepped. Propagators are unitaries. To compute them you need to evolve all basis vectors. In addition, it is normal to get a dense matrix for the resulting unitary. In contrast, canonical Hamiltonians are usually quite sparse, and the computing the evolution is quick sparse matrix - dense vector multiplication.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-629730292:241,evolve,evolve,241,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-629730292,1,['evolve'],['evolve']
Modifiability,"When installing Qutip from source in an MSYS2 environment, the build flags should be set to GCC-style like in *nix installations - I updated the relevant files to do this. I just check for the existence of the MSYSTEM environment variable to check for this case.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/779:230,variab,variable,230,https://qutip.org,https://github.com/qutip/qutip/pull/779,1,['variab'],['variable']
Modifiability,"Whether it is an issue likely depends on you school of thought. The error comes from the finite accuracy of the solvers. By default, the solutions are found using a method that is accurate 12-order in the step size and looks for absolute and relative errors at the 1e-8 and 1e-6 levels, respectively. If you evolve for long enough then inevitably there is going to be some error, and you will not get perfectly Hermitian matrices. One can accept this, and possibly lower the tolerance levels for more accuracy, or you can take 0.5*(A+A.dag()) to force the Hermicity. What method you use likely depends on your question and taste. Either way, I do not think that I would call this an issue. It is more of a fact of life when doing numerics. Paul. > On Jun 1, 2015, at 20:00, mmensing notifications@github.com wrote:; > ; > I was wondering if this is still an issue? If so I could try to spend some thinking on possible ways to correct the errors.; > ; > —; > Reply to this email directly or view it on GitHub https://github.com/qutip/qutip/issues/122#issuecomment-107400015.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/122#issuecomment-108683653:308,evolve,evolve,308,https://qutip.org,https://github.com/qutip/qutip/issues/122#issuecomment-108683653,1,['evolve'],['evolve']
Modifiability,"While solving some time-dependent Hamiltonians, I decided to refactor the list-style definition of my Hamiltonian and completely get rid of all ```partial``` calls which made my code much cleaner. In particular, I implemented a small class to construct the time-dependent components that go into the Hamiltonian and overwrote the ```__call__``` method to make my class object directly callable by Qutip. However, this was rejected by Qutip as an ""Incorrect Hamiltonian specification"" due to the format check. Since, as far as I know, subclassing the built-in FunctionType ```function``` is not possible in Python, and subclasses of FunctionType would not be accepted by Qutip either (```_td_format_check``` calls ```isinstance``` and not ```issubclass```), I suggest that Qutip also accepts general objects which have the ```__call__``` attribute defined. Changes: Update ```_td_format_check``` by one extra condition to allow any object with attribute ```__call__``` in the definition of a Hamiltonian.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1107:61,refactor,refactor,61,https://qutip.org,https://github.com/qutip/qutip/pull/1107,1,['refactor'],['refactor']
Modifiability,"Without the black changes, the patch would have applied cleanly, I think. With them, it's better to wait til the end, and then rebase the PR on top of master (in git, not github), then merge the PR into master as normal. The rebase is a destructive operation (rewrites history of the PR), so we have to take more care when working with more than one person, but it's better afterwards. I've heard this called a few things - Atlassian calls it a ""foxtrot merge"", for example. Here's a blog post they made about them, and some of the problems: https://blog.developer.atlassian.com/stop-foxtrots-now/. *Edit*: I usually wouldn't care about this, and we'd just squash the PR into a single commit to avoid all these problems, but in this particular case, the PR is kind of like two logical things at once. First it does @dweigand's original PR (but completed), and then it does what could have been another improvement change to all the code. We want to preserve the history in source control of the original PR (so you can see the changes I made to speed it up), so it needs to go in as two separate commits, doing a regular merge. If you're working on your own stuff, normally you'd be able to just squash and be done with it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970:260,rewrite,rewrites,260,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-878194970,1,['rewrite'],['rewrites']
Modifiability,Work in progress:; - Refactor tensor so that it plays better with tensor products of superoperators (see PR #99); - Simplify and cleanup the code,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/100:21,Refactor,Refactor,21,https://qutip.org,https://github.com/qutip/qutip/pull/100,1,['Refactor'],['Refactor']
Modifiability,"Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", Path.home() / "".config"")` rather than depend on the `xdg` package?. How does one know if one is on a system where XDG is supported? E.g. I know Windows used to use a special APP configuration folder of its own.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222:75,config,config,75,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219758222,2,['config'],"['config', 'configuration']"
Modifiability,"Wow, that a lot of work. Good to see you are still working on the lattice stuff. Right now, we don't have enough hands to maintain it and it pretty much abandoned. If you have the will to give it some love, it would be great. However could you make those PRs to qutip-lattice, in small review able chunks? v4.7 is the last of the v4 series and new feature like this can't be a bug-fix release. And in v5 we are splitting lattice, qip and control in other repo and keeping in Qutip only what me and @hodgestar can actively maintain. qutip-notebook is also taking the door in favour of qutip-tutorial, which tests notebooks and adds other maintainability features. Is this tools you created for your research that you are now contributing or do you plan to stick around contributing on qutip-lattice?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765:637,maintainab,maintainability,637,https://qutip.org,https://github.com/qutip/qutip/pull/1956#issuecomment-1186306765,1,['maintainab'],['maintainability']
Modifiability,"Yeah in my experience this is something one has to be careful of with the steady-state solver as it is. Depending on the method chosen it can either fail, return one of the possibilities, or some linear combination of them. The default one (direct) tends to fail, which at least sometimes lets you know you have this issue. . We could consider adding null_space solver which returns all possibilities, or modify the existing svd solver to do so if possible? ; Still, if the default ""direct"" method is silently failing it may trip people up still, so adding some examples to the documentation might help, as a minimum. I don't know of a way to extend that direct method to return all possible solutions, and connect those to possible initial conditions. It would be very interesting if its possible!. One minor thing; looking at the the example in the linked paper you provided seems to badly constructed. The dephasing operator they define there is actually just an identity, so does nothing, so technically the second example has no well-defined steady-state at all. A more useful example would be a proper dephasing through a collapse operator = sigma_z, and no driving on the qubit, so the degenerate steady-states are <sigmaz>=\pm 1.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812:643,extend,extend,643,https://qutip.org,https://github.com/qutip/qutip/issues/2175#issuecomment-1594101812,1,['extend'],['extend']
Modifiability,"Yeah, definitely there's no point running tests that aren't really testing the package properly. I would hope that if we're much more aggressive about converting time-dependent lists into QobjEvo objects inside `mesolve`, `mcsolve` and `sesolve` (or the class-based versions of them), we could significantly reduce the amount of testing that needs to be done with them. Most of the tests of time-dependent formats would then occur in the QobjEvo tests. We could still test all the configurations of the solvers without too heavy a time penalty. If we only use a small number of different time-dependent operators, we can compile them all only once, and have `pytest` manage the resources through shared fixtures. That would really cut down the run times, especially for the current ""slow"" tests. Another avenue for cutting down run time is if we could merge say the MKL and OpenMP tests into one Travis job - the setup time for one job is about 2.5 minutes, and that's before any tests have run at all. I would hazard a guess that having MKL but not OpenMP is a pretty rare case (maybe more common on high-performance clusters where people submit single-cpu jobs?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182:481,config,configurations,481,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182,1,['config'],['configurations']
Modifiability,"Yeah, in the context of #850, I was only thinking of a global switch for the storage format. But #437 makes a good point about using full storage. I'd add to that the [Lapack banded storage format](http://www.netlib.org/lapack/lug/node124.html) which is extremely efficient for diagonal or tri-diagonal operators (or scipy's [DIA](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dia_matrix.html#scipy.sparse.dia_matrix), which I think is mostly equivalent). I've actually had to solve the equivalent problem of allowing multiple internal formats in the [Fortran QDYN package](https://www.qdyn-library.net), so I'm not sure why I didn't think of that in the first place ;-). I can definitely vouch for the efficiency gained by being able to switch internal sparse representations. So yeah, you'd definitely have the most flexible solution by allowing `Qobj.data` to use varying storage classes from object to object. Maybe the ""protocol"" could be for `Qobj.data` to be any subclass of the [scipy `spmatrix` base class]( https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html#scipy.sparse.spmatrix)? Then the `Qobj` constructor would probably need an additional parameter `format` for the class that should be used to convert the `inpt` argument to the `data` attribute. The onus would then be on Scipy to provide a full matrix that is a subtype of `scipy.spmatrix` (just to keep the interface contract), and also to have `int64` versions of all their existing sparse classes. From a community standpoint, it would seem like one would get much more bang for the buck to have this problem solved inside SciPy, instead of doing a lot of low-level stuff in QuTiP -- at least if they're amenable to pull requests, but worst case you can still define necessary new `scipy.spmatrix` subclasses externally. Take all of my musings with a little grain of salt... I never really looked too deep into QuTiP's low-level internals, specifically where QuTiP is using Cython.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383937610:838,flexible,flexible,838,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383937610,1,['flexible'],['flexible']
Modifiability,"Yeah, you're right, I should have done the style changes in a different PR. It was mostly a lack of thought - I have a linter hooked into my text editor, so I get gutter-marks telling me all the PEP8 inconsistencies and stuff like that, and I usually change them without thinking. The `assert_` usually gets changed to bare `assert` when I'm actually trying to debug the tests - the bare `assert` gives _far_ more debugging detail with `pytest`, so it's much more helpful. By the way, if you're interested, the list of files which _didn't_ change is; ```text; .codeclimate.yml; .coveragerc; .github/ISSUE_TEMPLATE/bug_report.md; .github/ISSUE_TEMPLATE/feature_request.md; .github/ISSUE_TEMPLATE/others.md; .github/pull_request_template.md; .mailmap; .travis.yml; CODE_OF_CONDUCT.md; LICENSE.txt; README.md; pyproject.toml; qutip.bib; qutip/_mkl/__init__.py; qutip/_mkl/spmv.py; qutip/_mkl/spsolve.py; qutip/_mkl/utilities.py; qutip/about.py; qutip/cite.py; qutip/configspec.ini; qutip/control/__init__.py; qutip/control/cy_grape.pyx; qutip/hardware_info.py; qutip/ipynbtools.py; qutip/logging_utils.py; qutip/matplotlib_utilities.py; qutip/orbital.py; qutip/parallel.py; qutip/qip/__init__.py; qutip/qip/algorithms/__init__.py; qutip/qip/circuit_latex.py; qutip/qip/compiler/__init__.py; qutip/qip/compiler/cavityqedcompiler.py; qutip/qip/compiler/gatecompiler.py; qutip/qip/compiler/spinchaincompiler.py; qutip/qip/device/__init__.py; qutip/qip/gates.py; qutip/qip/operations/__init__.py; qutip/qip/qasm.py; qutip/qip/qip_deprecation.py; qutip/tests/Hadamard_params.ini; qutip/tests/__init__.py; qutip/tests/conftest.py; qutip/tests/pytest.ini; qutip/tests/qasm_files/bracket_error.qasm; qutip/tests/qasm_files/command_error.qasm; qutip/tests/qasm_files/qasm_error.qasm; qutip/tests/qasm_files/teleportation.qasm; qutip/tests/qasm_files/test_add.qasm; qutip/tests/qasm_files/test_custom_gates.qasm; qutip/tests/test_control_pulseoptim.py; qutip/tests/test_entropy.py; qutip/tests/test_fileio.py; quti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332#issuecomment-671534803:963,config,configspec,963,https://qutip.org,https://github.com/qutip/qutip/pull/1332#issuecomment-671534803,1,['config'],['configspec']
Modifiability,"Yeah. Just do a 'git pull upstream master' on this branch. The Travis; config file was updated and it's not the same as this branch. You don't; have to do a painful rebase. The tests need to run online. On Mon, Jun 18, 2018, 9:03 PM Louis Tessler <notifications@github.com>; wrote:. > @sahmed95 <https://github.com/sahmed95> shouldn't the merge automatically; > take care of that without bothering to rebase?; >; > I'd like to avoid wasting time on a rebase if there's no tangible benefit; >; > —; > You are receiving this because you were mentioned.; >; >; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/883#issuecomment-398031660>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBArCWgSxWGFO-QoURjxQPLZ63Eeiks5t95crgaJpZM4UrUyK>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398048087:71,config,config,71,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398048087,1,['config'],['config']
Modifiability,"Yes, I had used it to check whether a variable was a string type. I saw it suggested somewhere. It has only just come up as I am adding (long overdue) tests for the control modules. I have now replaced the six based method with something else, but I think the six.string_types method was more elegant.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/378#issuecomment-145861008:38,variab,variable,38,https://qutip.org,https://github.com/qutip/qutip/issues/378#issuecomment-145861008,1,['variab'],['variable']
Modifiability,"Yes, configuring a bot is beneficial for several tasks. However, the scope would be broad then. Narrowing down seems reasonable. What do you think about opening a new issue, mentioning several examples that can be worked on?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1089#issuecomment-1852573254:5,config,configuring,5,https://qutip.org,https://github.com/qutip/qutip/issues/1089#issuecomment-1852573254,1,['config'],['configuring']
Modifiability,"Yes, how that will look like is still under discussion and a list in the qutip docs/website is indeed a good candidate. It will probably come along with QuTiP 5.0 later this year. I'm closing the issue as issues are meant for ongoing bugs and enhancement in code. Free feel to discuss further in our [Google group](https://groups.google.com/g/qutip) or per emails!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1439#issuecomment-779766759:243,enhance,enhancement,243,https://qutip.org,https://github.com/qutip/qutip/issues/1439#issuecomment-779766759,1,['enhance'],['enhancement']
Modifiability,"Yes, it is not the same thing. You need to rewrite it manually so that each collapse operator contribute on standard lindblad form.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/223#issuecomment-54383218:43,rewrite,rewrite,43,https://qutip.org,https://github.com/qutip/qutip/issues/223#issuecomment-54383218,1,['rewrite'],['rewrite']
Modifiability,"Yes, looks good to me. Think you should merge sooner rather than later. btw these other tests have appeared due trying to make this conda-forge package. Looks like I will have to create some kind of solution file for the appveyor one to work. However, nice to see the circleci one worked without any specific config.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/443#issuecomment-187578137:309,config,config,309,https://qutip.org,https://github.com/qutip/qutip/pull/443#issuecomment-187578137,1,['config'],['config']
Modifiability,"Yes, that is one of the solutions.; This issue could be included in the refactoring task of the quantum circuit library.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-821950406:72,refactor,refactoring,72,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-821950406,1,['refactor'],['refactoring']
Modifiability,"Yes. I saw that. So should we have a single script for all the if statements (checking and installing python2.7, MKL, CVOPT etc.) and run it by passing some command line argument such as. ```; - travis_config install_conda; - travis_config install_mkl; - travis_config install; ```. to do all the complex config stuff?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/875#issuecomment-394644625:305,config,config,305,https://qutip.org,https://github.com/qutip/qutip/pull/875#issuecomment-394644625,1,['config'],['config']
Modifiability,"You are measuring the expectation of sigmax, if you measure the expectation value of sigmaz, or the population, you will not observe such a big oscillation but very small oscillations. Not sure what you want to achieve, but your detuning is negligibly small compared to the frequency. It has little effect. Also I'm not sure if there is a typo `v_0` and `drive_detuning` seems to have the unit of frequency, and 2*pi* frequency. You have a time-independent Hamiltonian, so if you want to compute the ZZ interaction, you can simply diagonalize the matrix and see if you have a ZZ coupling term.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908:579,coupling,coupling,579,https://qutip.org,https://github.com/qutip/qutip/issues/2549#issuecomment-2449988908,2,['coupling'],['coupling']
Modifiability,"You can use it to select number of processes to use, right? I think it is useful if you don't want to use all processors for a calculation, although I usually use the .qutiprc configuration file for this rather than environment variables. I guess it is not really necessary but could be useful I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/119#issuecomment-41985199:176,config,configuration,176,https://qutip.org,https://github.com/qutip/qutip/issues/119#issuecomment-41985199,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"You'll find it easier installing from conda-forge, since we distribute binary releases there: see the [installation guide](http://qutip.org/docs/latest/installation.html) here. If you want to install from source using `pip`, you need to configure your C++ development environment correctly - you'll probably need to enable the XCode command-line tools ([see e.g. this](https://osxdaily.com/2014/02/12/install-command-line-tools-mac-os-x/)).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404#issuecomment-742038577:237,config,configure,237,https://qutip.org,https://github.com/qutip/qutip/issues/1404#issuecomment-742038577,2,['config'],['configure']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1566656/badge)](https://coveralls.io/builds/1566656). Coverage decreased (-0.58%) when pulling **9dd4d43cc1b04894b7f7513425c594beccd0984d on jrjohansson:refactor-mcsolve-parallel** into **79c89f066522c8343a1cd0cdcd7bca2e9625db2a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65739997:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65739997,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1566697/badge)](https://coveralls.io/builds/1566697). Coverage decreased (-0.56%) when pulling **2255544d231c8c27d9221ba366b7842dbb37bcf6 on jrjohansson:refactor-mcsolve-parallel** into **79c89f066522c8343a1cd0cdcd7bca2e9625db2a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65741485:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65741485,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1567605/badge)](https://coveralls.io/builds/1567605). Coverage decreased (-0.49%) when pulling **6c04ce3700be46a4ca49d74490c2e5c16f8fd4f8 on jrjohansson:refactor-mcsolve-parallel** into **98fe91d9fe9c37b13835c21a12bd237bbab42c8f on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65765723:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65765723,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1568019/badge)](https://coveralls.io/builds/1568019). Coverage decreased (-0.55%) when pulling **c5c4ff11b39c2243126d8d9149befec0a7f9c39f on jrjohansson:refactor-mcsolve-parallel** into **74c548dc64c377c8e21dfcf662ea7017b97306c3 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65777213:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65777213,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1568060/badge)](https://coveralls.io/builds/1568060). Coverage decreased (-0.55%) when pulling **c5c4ff11b39c2243126d8d9149befec0a7f9c39f on jrjohansson:refactor-mcsolve-parallel** into **74c548dc64c377c8e21dfcf662ea7017b97306c3 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-65778609:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-65778609,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1588549/badge)](https://coveralls.io/builds/1588549). Coverage decreased (-0.55%) when pulling **aabbc2590895552d4b96cd2f42fb401ce6d0d80e on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66394630:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66394630,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1594952/badge)](https://coveralls.io/builds/1594952). Coverage decreased (-0.24%) when pulling **844f102113c37bdf1f599abff89c0d2d9a67c962 on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66604157:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66604157,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1594994/badge)](https://coveralls.io/builds/1594994). Coverage decreased (-0.25%) when pulling **844f102113c37bdf1f599abff89c0d2d9a67c962 on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66604437:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66604437,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1595281/badge)](https://coveralls.io/builds/1595281). Coverage decreased (-0.24%) when pulling **c6279c428887c4308a17c024e009d8888fd50c7d on jrjohansson:refactor-mcsolve-parallel** into **6d186dfa7a1086ffa591670e25698e8668eaaeeb on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66605622:201,refactor,refactor-mcsolve-parallel,201,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66605622,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/1595345/badge)](https://coveralls.io/builds/1595345). Coverage decreased (-0.4%) when pulling **cf9a5e766f11fc2d514267d2a643237e5c28cc96 on jrjohansson:refactor-mcsolve-parallel** into **1738f5f73b4b0225eab3c0fbc3ada97b56e70b9a on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66605769:200,refactor,refactor-mcsolve-parallel,200,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66605769,1,['refactor'],['refactor-mcsolve-parallel']
Modifiability,[![Coverage Status](https://coveralls.io/builds/37558676/badge)](https://coveralls.io/builds/37558676). Coverage increased (+1.3%) to 66.469% when pulling **702de3ece279dc9920332467af01b58d90b73829 on Ericgig:solve.evolve** into **0ca50e9d97ce4031ca886670bed43b960c36a226 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409#issuecomment-767650176:215,evolve,evolve,215,https://qutip.org,https://github.com/qutip/qutip/pull/1409#issuecomment-767650176,1,['evolve'],['evolve']
Modifiability,[![Coverage Status](https://coveralls.io/builds/38609281/badge)](https://coveralls.io/builds/38609281). Coverage increased (+0.05%) to 63.659% when pulling **862d0de844d9d5b39f0301d0ea4c47c37d995499 on jakelishman:tests-refactor-metrics** into **ee047df81e3fcb1b941d04588409c4a8de09e2c7 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815115509:220,refactor,refactor-metrics,220,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815115509,1,['refactor'],['refactor-metrics']
Modifiability,[![Coverage Status](https://coveralls.io/builds/45388930/badge)](https://coveralls.io/builds/45388930). Coverage increased (+0.007%) to 65.527% when pulling **6ec2612fbcd8f832dcba64ea5dbc6adeff8bd480 on fhopfmueller:dev.major-refactor-process-fidelity** into **6287bd37f3446110af82e2a038fdb3bd336268db on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123:226,refactor,refactor-process-fidelity,226,https://qutip.org,https://github.com/qutip/qutip/pull/1748#issuecomment-1003775123,1,['refactor'],['refactor-process-fidelity']
Modifiability,[![Coverage Status](https://coveralls.io/builds/49815148/badge)](https://coveralls.io/builds/49815148). Coverage increased (+0.2%) to 65.494% when pulling **286cce4bd3d5a778a7ad0ab817fe68db72bc30db on hodgestar:feature/flexible-result-base-class** into **e8f8b0fe6f343c585bc2d80f727a25a5f3cca1a1 on qutip:dev.major**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813:219,flexible,flexible-result-base-class,219,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139721813,1,['flexible'],['flexible-result-base-class']
Modifiability,"`--config-setting=""--global-option=--with-openmp""` gives a build error (qutip 4.7.0, debian unstable, python 3.10.6):; ```; $ python3.10 -m build --skip-dependency-check --no-isolation --wheel --config-setting=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355:3,config,config-setting,3,https://qutip.org,https://github.com/qutip/qutip/pull/1978#issuecomment-1219844355,2,['config'],['config-setting']
Modifiability,`--config-setting=--global-option=--with-openmp` is still not working with git head (with #1978 merged). This is with; * python 3.10.6-1; * python3-build 0.7.0-3; * python3-setuptools 59.6.0-1.2; * python3-wheel 0.37.1-2; * gcc 12.1.0-7,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489:3,config,config-setting,3,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1220037489,1,['config'],['config-setting']
Modifiability,"`general_stochastic` is very manual, halfway to scipy's ode solver. It can be used for both open and closed system and does not correspond to any particular physics equation. It the function that you use if you do weird stuff that does not fit already available template and I would discourage it's use. ; If other type of stochastic evolution are commonly used, it would be better to make a new specialized function than use `general_stochastic`. Old example should be adapted to `smesolve` as much as possible. The solver does not know if it is solving an close or open system (or something else). So e_ops are not touched. ; d1, d2 are working in array for performance issue. We could easily have them work in Qobj, but I would expect a significant slowdown. These function, taking no args, and being call many time at each step could benefit from being compiled with numba.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283:470,adapt,adapted,470,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283,1,['adapt'],['adapted']
Modifiability,`mcsolve` can only evolve ket states. The closest to what you want is `photocurrent_mesolve` which does master equation evolution of a density matrix with the liouvillian build from `H` and `c_ops` but using discrete jumps for `sc_ops`. It is a lot slower than mesolve since it use only basic ode method (Euler's or Heun's method) and you need to set a very small time step to keep the error resonable.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1375#issuecomment-720652251:19,evolve,evolve,19,https://qutip.org,https://github.com/qutip/qutip/issues/1375#issuecomment-720652251,1,['evolve'],['evolve']
Modifiability,"`python3 -mbuild` has a `-C` option (`--config-setting`), see`https://pypa-build.readthedocs.io/en/latest/`. It sounds like it could be used for build configuration options like qutip's openmp support. It doesn't seem to work with the current handling in setup.py however. Permutations of `-C--with-openmp`, `-Copenmp`, `-Copenmp=1` enable a succcessful qutip PEP517 build, but `qutip.about()` then reports; ```; OPENMP Installed: False; ```; indicating the option is ignored.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223:40,config,config-setting,40,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1107460223,2,['config'],"['config-setting', 'configuration']"
Modifiability,"`type: callable`, each type is associated to a function that create a coefficient, allowing to add support for other coefficient types per project such as qutip-tensorflow. Also, function based coefficient no longer cast to complex, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1364,variab,variable,1364,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability,"a>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 304 in wrap_session; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 316 in pytest_cmdline_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 84 in <lambda>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 162 in main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 185 in console_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/bin/pytest"", line 11 in <module>; Segmentation fault: 11; ```. This was done with commit 624405e7, SciPy 1.6.2 and Numpy 1.19.5. My BLAS version has chopped and changed an awful lot, but I believe that run was with MKL implementations. The ""random"" stack trace from pytest looks to me like the error came about during garbage collection, and I really don't imagine pytest is to blame. We have in the past had issues with some bad calls in SciPy linalg functions, so it's _possible_ that they are the cause again, but I doubt it; we'd expect the stack traces to reliably show scipy to be the problem in that case. I wasn't able to reproduce this segfault on Windows, but that doesn't mean a huge amount, because I also can't reliably reproduce it on Mac. I suspect that the cause is some",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:5727,config,config,5727,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,1,['config'],['config']
Modifiability,"ackages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 252 ss = H; 253 elif isinstance(H, (list, Qobj, QobjEvo)):; --> 254 ss = _mesolve_QobjEvo(H, c_ops, tlist, args, options); 255 elif callable(H):; 256 ss = _mesolve_func_td(H, c_ops, rho0, tlist, args, options). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/mesolve.py in _mesolve_QobjEvo(H, c_ops, tlist, args, opt); 298 ; 299 nthread = opt.openmp_threads if opt.use_openmp else 0; --> 300 L_td.compile(omp=nthread); 301 ; 302 ss = SolverSystem(). /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo.py in compile(self, code, matched, dense, omp); 1553 if self.use_cython:; 1554 # All factor can be compiled; -> 1555 self.coeff_get, Code, file_ = _compiled_coeffs(; 1556 self.ops,; 1557 self.args,. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _compiled_coeffs(ops, args, dyn_args, tlist); 121 """"""; 122 code = _make_code_4_cimport(ops, args, dyn_args, tlist); --> 123 coeff_obj, filename = _import_str(code, ""cqobjevo_compiled_coeff_"",; 124 ""CompiledStrCoeff"", True); 125 return coeff_obj(ops, args, tlist, dyn_args), code, filename. /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip/qobjevo_codegen.py in _import_str(code, basefilename, obj_name, cythonfile); 80 if not import_list:; 81 raise Exception(""Could not convert string to importable function, ""; ---> 82 ""tmpfile:"" + try_file + ext) from e; 83 coeff_obj = import_list[0]; 84 return coeff_obj, try_file + ext. UnboundLocalError: local variable 'e' referenced before assignment. Version details.; QuTiP Version: 4.5.0; Numpy Version: 1.18.1; Scipy Version: 1.3.1; Cython Version: 0.29.15; Matplotlib Version: 3.1.3; Python Version: 3.8.1; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /opt/anaconda3/envs/qutip-env/lib/python3.8/site-packages/qutip",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1196:2203,variab,variable,2203,https://qutip.org,https://github.com/qutip/qutip/issues/1196,1,['variab'],['variable']
Modifiability,"actually, just realised my fork is configured to do CodeClimate on `dev.major`. For say `qobj.py`, the `master` version has [maintainability F](https://codeclimate.com/github/qutip/qutip/qutip/qobj.py), while `dev.major` has [maintainability A](https://codeclimate.com/github/jakelishman/qutip/qutip/core/qobj.py) with the only issues being TODOs and like 5 pep8s.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1447#issuecomment-782267965:35,config,configured,35,https://qutip.org,https://github.com/qutip/qutip/pull/1447#issuecomment-782267965,3,"['config', 'maintainab']","['configured', 'maintainability']"
Modifiability,"aculate(phi, step_dot, v); 4 a_0 = []; 5 for j in tnrange(step_dot):; ----> 6 temp = connection(alpha2_list[j],1,0,phi,step_dot,v); 7 a_0.append(temp); 8 sum_0 = 0. <ipython-input-27-8ed9b415bc26> in connection(alpha2, n_state, w, phi, step, v); 33 H = [H_static,[H_dynamic_0,str0],[H_dynamic_1,str1],[H_dynamic_2,str2],[H_dynamic_3,str3]]; 34 t_list = np.linspace(0,(alpha1_end - alpha1_0)/v,step); ---> 35 result = mesolve(H,psi0,t_list,[],args = {'alpha2':alpha2,'phi':phi,'v':v}); 36 psi = result.states; 37 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 335 elif n_str > 0:; 336 res = _sesolve_list_str_td(H, rho0, tlist,; --> 337 e_ops, args, options, progress_bar); 338 elif isinstance(H, (types.FunctionType,; 339 types.BuiltinFunctionType, partial)):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 420 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 421 '<string>', 'exec'); --> 422 exec(code, globals()); 423 config.tdfunc = cy_td_ode_rhs; 424 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/qutip/sesolve.py in <module>(). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyximport.py in load_module(name",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697:1363,config,config,1363,https://qutip.org,https://github.com/qutip/qutip/issues/697,1,['config'],['config']
Modifiability,"ad of it's own. When then using `update` (without calling `start` manually again) there will be an `AttributeError` because `width` is not getting initialized by `__init__`. ### Code to Reproduce the Bug. ```shell; from qutip.ui.progressbar import *. n = 10; a = EnhancedTextProgressBar(n); # a.start(n); for i in range(n):; a.update(i); a.finished(); ```. ### Code Output. ```shell; Traceback (most recent call last):; File ""C:\Users\Name\Desktop\qutip_bug.py"", line 6, in <module>; a.update(i); File ""C:\Users\Name\AppData\Local\Programs\Python\Python311\Lib\site-packages\qutip\ui\progressbar.py"", line 96, in update; all_full = self.width - 2; ^^^^^^^^^^; AttributeError: 'EnhancedTextProgressBar' object has no attribute 'width'; ```. ### Expected Behaviour. Proper initialization of the `width` attribute by `EnhancedTextProgressBar.__init__`. ### Your Environment. ```shell; QuTiP Version: 4.7.1; Numpy Version: 1.24.2; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.7.1; Python Version: 3.11.0; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64); ```. ### Additional Context. Currently in master the `__init__` for both `TextProgressBar` and `EnhancedTextProgressBar` have been commented out and made to just pass. See https://github.com/qutip/qutip/blob/af49884aa1db47a980626ac00adfe83277d8d261/qutip/ui/progressbar.py#L66 and https://github.com/qutip/qutip/blob/af49884aa1db47a980626ac00adfe83277d8d261/qutip/ui/progressbar.py#L94. I would suggest making them both call their own `start` method to omit an additional call of start by the user right after initialization. This would also make both classes be in line with the usage suggested by the docstring of `BaseProgressBar.` Otherwise I would suggest to include the call to start in said docstring. As I'm pretty new to github and git in general I would like to try and create a PR myself once you give me approval for the suggested change here.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2148:1393,Enhance,EnhancedTextProgressBar,1393,https://qutip.org,https://github.com/qutip/qutip/issues/2148,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,additional arguments added to load_parameters so that a general object attributes can be loaded from a configuration file. For a example a custom fidelity computer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/403:103,config,configuration,103,https://qutip.org,https://github.com/qutip/qutip/pull/403,1,['config'],['configuration']
Modifiability,"agma: no cover&quot; <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7668"">#7668</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Trim glyph size in ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7669"">#7669</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix loading IPTC images and update test <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7667"">#7667</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Allow uncompressed TIFF images to be saved in chunks <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7650"">#7650</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Concatenate multiple JPEG EXIF markers <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7496"">#7496</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Changed IPTC tile tuple to match other plugins <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7661"">#7661</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not assign new fp attribute when exiting context manager <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7566"">#7566</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support arbitrary masks for uncompressed RGB DDS images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7589"">#7589</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support setting ROWSPERSTRIP tag <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7654"">#7654</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Apply ImageFont.MAX_STRING_LENGTH to ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7662"">#7662</a> [<a href=""https://github.com/ra",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:1961,plugin,plugins,1961,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['plugin'],['plugins']
Modifiability,"and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:3338,config,configuration,3338,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['config'],['configuration']
Modifiability,"and the Qutip version of the code. The code just set up the parameters of the system and builds the Hamiltonian and Lindblad equation. Finally it solves de equation with mesolve, and compute a 2op_2t correlation function. For the case of Qutip, the mesolve spends about 15 minutes for solving the equation, and 3 hours the correlation function. For the case of matlab toolbox, it takes a few seconds solving the equation and one minte computing the correlation function. Finally, if I try ode2solve in qutip, it solves the equation in just 45 seconds. Is there something I am doing terribly wrong with the mesolver in qutip?, or is just that the matlab toolbox has a much better solver?. Thank you very much,. Joaquin Guimbao. %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import * ; qutip.settings.num_cpus = 16; import math. # Set parameters. g2 = 1 # coupling strength with EM field; kappa = 1 # cavity dissipation rate; gamma = 1 # atom dissipation rate; gamma12 = 1 # dipole-coupling dissipation; N = 2 # number of cavity fock states; dephasing = 10000 # pure dephasing; g=np.random.rand(10)*500 # dipole coupling strengths between 5 atoms. tlist = np.linspace(0,60,200). # intial state; psi0 = tensor(basis(N,0), basis(2,1),basis(2,0),basis(2,0),basis(2,0),basis(2,0)) # start with an excited atom; rho0 = psi0 * psi0.dag();. # operators; a = tensor(destroy(N),qeye(2),qeye(2),qeye(2),qeye(2),qeye(2));; sm1 = tensor(qeye(N),destroy(2),qeye(2),qeye(2),qeye(2),qeye(2));; sm2 = tensor(qeye(N),qeye(2),destroy(2),qeye(2),qeye(2),qeye(2));; sm3 = tensor(qeye(N),qeye(2),qeye(2),destroy(2),qeye(2),qeye(2));; sm4 = tensor(qeye(N),qeye(2),qeye(2),qeye(2),destroy(2),qeye(2));; sm5 = tensor(qeye(N),qeye(2),qeye(2),qeye(2),qeye(2),destroy(2));. # Hamiltonian; H = sm1.dag()*sm1+sm2.dag()*sm2 +sm3.dag()*sm3+ sm4.dag()*sm4+sm5.dag()*sm5+a.dag()*a + g2*(sm1.dag()*a+sm1*a.dag())+g2*(sm2.dag()*a+sm2*a.dag()) + g2*(sm3.dag()*a+sm3*a.dag())+g2*(sm4.dag()*a+sm4*a.dag(",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1591:1286,coupling,coupling,1286,https://qutip.org,https://github.com/qutip/qutip/issues/1591,2,['coupling'],['coupling']
Modifiability,"arallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2533,refactor,refactor,2533,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactor']
Modifiability,"as functions to detect the available of BLAS libraries. For instance on my system (debian unstable), `python3 -c ""import qutip; qutip.about()""` reports; ```; BLAS Info: OPENBLAS; ```. However, I think the logic behind BLAS Info is not robust. For context, debian builds packages against generic libblas.so (libblas-dev package). The various optimised BLAS implementations are supposed to be binary compatible, such that the system administrator can install the preferred implementation for use at runtime (the identity of libblas.so is controlled using debian's alternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:1021,config,config,1021,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['config']
Modifiability,"back (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._bootstrap>"", line 673, in _load_unlocked; File ""<frozen importlib._bootstrap_external>"", line 662, i",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1177,config,configuration,1177,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,2,['config'],"['config', 'configuration']"
Modifiability,"build/src.macosx-11.0-arm64-3.9/numpy/core/include/numpy/__ufunc_api.h']; building extension ""numpy.core._umath_tests"" sources; building extension ""numpy.core._rational_tests"" sources; building extension ""numpy.core._struct_ufunc_tests"" sources; building extension ""numpy.core._operand_flag_tests"" sources; building extension ""numpy.fft._pocketfft_internal"" sources; building extension ""numpy.linalg.lapack_lite"" sources; building extension ""numpy.linalg._umath_linalg"" sources; building extension ""numpy.random._mt19937"" sources; building extension ""numpy.random._philox"" sources; building extension ""numpy.random._pcg64"" sources; building extension ""numpy.random._sfc64"" sources; building extension ""numpy.random._common"" sources; building extension ""numpy.random.bit_generator"" sources; building extension ""numpy.random._generator"" sources; building extension ""numpy.random._bounded_integers"" sources; building extension ""numpy.random.mtrand"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; creating build/lib.macosx-11.0-arm64-3.9; creating build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/conftest.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/version.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/_globals.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/__init__.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/dual.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/_distributor_init.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/setup.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/ctypeslib.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/matlib.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying numpy/_pytesttester.py -> build/lib.macosx-11.0-arm64-3.9/numpy; copying build/src.macosx-11.0-arm64-3.9/numpy/__config__.py -> build/lib.macosx-11.0-arm64-3.9/numpy; creating build/lib.macosx-11.0-arm64-3.9/numpy/compat; copying numpy/compat/py3k",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:11571,config,config,11571,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['config'],['config']
Modifiability,"but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this n",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1132:2384,Enhance,Enhancement,2384,https://qutip.org,https://github.com/qutip/qutip/issues/1132,1,['Enhance'],['Enhancement']
Modifiability,"callback]; 28 # Solve the master equation; ---> 29 output = qt.mesolve(H, rho_0, times, c_ops, e_ops); 31 plt.plot(output.expect). File ~/anaconda3/envs/danjou/lib/python3.10/site-packages/qutip/mesolve.py:244, in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 241 v = rho0.full().ravel('F'); 242 func(0., v, *ode_args) + v; --> 244 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 245 progress_bar, dims=rho0.dims); 246 res.num_collapse = len(c_ops); 248 if e_ops_dict:. File ~/anaconda3/envs/danjou/lib/python3.10/site-packages/qutip/mesolve.py:519, in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 517 for m in range(n_expt_op):; 518 if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; --> 519 output.expect[m][t_idx] = e_ops[m](t, rho_t); 520 continue; 521 output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; 522 e_ops[m].isherm; 523 and rho0.isherm). UnboundLocalError: local variable 'rho_t' referenced before assignment; ```. ### Expected Behaviour. I expect that callback functions passed as a list should be computed without issue. ### Your Environment. ```shell; QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.1; Numpy Version: 1.24.3; Scipy Version: 1.10.1; Cython Version: 0.29.33; Matplotlib Version: 3.7.1; Python Version: 3.10.6; Number of CPUs: 12; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2189:2884,variab,variable,2884,https://qutip.org,https://github.com/qutip/qutip/issues/2189,1,['variab'],['variable']
Modifiability,closes #1106 . Adds update_view method to change view variable. Thus abstracting from attribute naming. Also forces view update in render.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1216:54,variab,variable,54,https://qutip.org,https://github.com/qutip/qutip/pull/1216,1,['variab'],['variable']
Modifiability,codeclimat config,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/974:11,config,config,11,https://qutip.org,https://github.com/qutip/qutip/pull/974,1,['config'],['config']
Modifiability,"coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(expects[-1], variable); ```. Output:; ```; 20.0%. Run time: 0.03s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.05s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.08s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.10s. Est. time left: 00:00:00:00; 100.0%. Run time: 0.12s. Est. time left: 00:00:00:00. /home/eric/miniconda3/lib/python3.9/site-packages/tensorflow/python/framework/ops.py:1128: ComplexWarning: Casting complex values to real discards the imaginary part; return float(self._numpy()). Total run time: 0.12s; CPU times: user 15.9 s, sys: 174 ms, total: 16 s; Wall time: 16.1 s. <tf.Tensor: shape=(5,), dtype=complex128, numpy=; array([-0.17340122+2.03548130e-09j, -0.18075013+2.08120101e-09j,; -0.19236081+1.58339267e-08j, -0.18075012+1.12229134e-08j,; -0.17648842-7.47414642e-08j])>; ```; So while slow, it works.; Maybe adding simpler runge-kutta method and / or support for [tensorflow's ode](https://www.tensorflow.org/probability/api_docs/python/tfp/math/ode/Solver) could make it more ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:2663,variab,variable,2663,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability,cosx-11.0-arm64-3.9/numpy/distutils; copying numpy/distutils/setup.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; copying numpy/distutils/extension.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; copying numpy/distutils/msvccompiler.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; copying numpy/distutils/intelccompiler.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; copying numpy/distutils/_shell_utils.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; copying build/src.macosx-11.0-arm64-3.9/numpy/distutils/__config__.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils; creating build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/config_compiler.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build_ext.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/config.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/install_headers.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build_py.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build_src.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/__init__.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/sdist.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build_scripts.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/bdist_rpm.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/install_clib.py -> build/lib.macosx-11.0-arm64-3.9/numpy/distutils/command; copying numpy/distutils/command/build_clib.py -> build/li,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:22812,config,config,22812,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['config'],['config']
Modifiability,"cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, multiprocessing, and; 35 tidyup functionality, etc.; 36 """"""; ```. Can the `pyximport` be dea",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2268,config,config,2268,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,2,['config'],['config']
Modifiability,cvxpy Variable and Parameter dims passed as tuple; cvxpy and its depends only installed in tests for NOMKL builds; Extra test added for NOMKL with OPENMP,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/873:6,Variab,Variable,6,https://qutip.org,https://github.com/qutip/qutip/pull/873,1,['Variab'],['Variable']
Modifiability,"cy, like you suggest. For the Milstein solver it might be the best, or at least the quickest, way to implement heterodyne, but I don't really agree that the current method is overcomplicated. It is in fact basically the same as the method you suggest, so I don't see that either would be more complicated or simpler than the other. The only issue is whether the two stochastic increments are divided up in several stochastic collapse operators or if the d2 function internally takes care of the both stochastic increments for a given stochastic collapse operator. The complexity is just shifted from the d2 function to somewhere else, which in general doesn't simplify anything. However, since the milstein solver you submitted is written so that it only support one increment per collapse operators, then there might be a real advantage of splitting the heterodyne process into two homodyne processes. . I've tried to make the qutip stochastic solver API as general as I could (and it is still a work in process), so that it will be as flexible as possible for implementing custom types of SMEs. Having support for multiple stochastic increments per collapse operators seems to be useful in certain applications. Although such SMEs could probably always be rewritten as multiple collapse operators with single stochastic increments, it might not always be the most natural way to define the SME. The heterodyne detection is one example of this, and it can be formulated in both ways, but I want the qutip SME API to work with both methods (at least with the basic euler solver, not necessarily with every solver we implement). However, that doesn't mean that the implementation of heterodyne for a particular solver has to use one way or the other. We should just document which solvers support multiple increments per operators and which solvers don't. So if it is easier to get the milstein solver working for heterodyne by simulating two homodyne detections, then let's go ahead use that method f",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22543416:1163,flexible,flexible,1163,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22543416,2,['flexible'],['flexible']
Modifiability,"dnorm tests have historically been very flaky, and for as long as we're using random tests (which we possibly shouldn't be), we always run the risk of temperamental failures. In particular, the semidefinite solvers used in dnorm fail every now and again on random states; we historically haven't treated this as a bug, since it's pretty similar to an integration failing to converge because the system was too stiff. It means that the user has to adjust some settings and try again. To prevent this sort of error from failing our test suite, however, we can mark the tests as being allowed to rerun twice on a failure. We had a relatively small sample to judge the test failure rate by, but my very very approximate guess is that we'd have a failure about 1 in 10 runs on Travis. We counter this with two strategies:. 1. parametrise the tests in pytest style, so each random repetition is a separate instance, and known to pytest (some of this was done in earlier commits); 2. allow 2 reruns of every dnorm test. The two of these together should remove all random failures; since all random loops have been moved into pytest-handled repeats, there are far fewer calls to dnorm handled within each test. This means less chance that an individual test run will fail, but a slightly higher chance the entire suite will. Now with the test re-running a single failure point is tried again up to twice more, to determine if it was just a one-off, or if the test is truly broken. The reruns are handled by a pytest plugin pytest-rerunfailures. It's quite nontrivial behaviour to hook this in to the pytest mechanism, so better to use an external dependency to do it than to vendor in a custom version. The dnorm problems have resurfaced a little after lying dormant for a long time, because #1463 reactivated them. Before that, they'd not actually been running because none of the test runners had cvxpy installed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490:1508,plugin,plugin,1508,https://qutip.org,https://github.com/qutip/qutip/pull/1490,1,['plugin'],['plugin']
Modifiability,"e computation since each call to the random number generator is costly. One could pre-generate a large array of random numbers before hand, but there is no way to know if you generated enough since we are using an adaptive step size ODE method. You are correct about the way mcsolve does its calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...; > ; > At this stage, I have to resort ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:1182,evolve,evolve,1182,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,2,['evolve'],['evolve']
Modifiability,"e equation with mesolve, and compute a 2op_2t correlation function. For the case of Qutip, the mesolve spends about 15 minutes for solving the equation, and 3 hours the correlation function. For the case of matlab toolbox, it takes a few seconds solving the equation and one minte computing the correlation function. Finally, if I try ode2solve in qutip, it solves the equation in just 45 seconds. Is there something I am doing terribly wrong with the mesolver in qutip?, or is just that the matlab toolbox has a much better solver?. Thank you very much,. Joaquin Guimbao. %matplotlib inline; import matplotlib.pyplot as plt; import numpy as np; from qutip import * ; qutip.settings.num_cpus = 16; import math. # Set parameters. g2 = 1 # coupling strength with EM field; kappa = 1 # cavity dissipation rate; gamma = 1 # atom dissipation rate; gamma12 = 1 # dipole-coupling dissipation; N = 2 # number of cavity fock states; dephasing = 10000 # pure dephasing; g=np.random.rand(10)*500 # dipole coupling strengths between 5 atoms. tlist = np.linspace(0,60,200). # intial state; psi0 = tensor(basis(N,0), basis(2,1),basis(2,0),basis(2,0),basis(2,0),basis(2,0)) # start with an excited atom; rho0 = psi0 * psi0.dag();. # operators; a = tensor(destroy(N),qeye(2),qeye(2),qeye(2),qeye(2),qeye(2));; sm1 = tensor(qeye(N),destroy(2),qeye(2),qeye(2),qeye(2),qeye(2));; sm2 = tensor(qeye(N),qeye(2),destroy(2),qeye(2),qeye(2),qeye(2));; sm3 = tensor(qeye(N),qeye(2),qeye(2),destroy(2),qeye(2),qeye(2));; sm4 = tensor(qeye(N),qeye(2),qeye(2),qeye(2),destroy(2),qeye(2));; sm5 = tensor(qeye(N),qeye(2),qeye(2),qeye(2),qeye(2),destroy(2));. # Hamiltonian; H = sm1.dag()*sm1+sm2.dag()*sm2 +sm3.dag()*sm3+ sm4.dag()*sm4+sm5.dag()*sm5+a.dag()*a + g2*(sm1.dag()*a+sm1*a.dag())+g2*(sm2.dag()*a+sm2*a.dag()) + g2*(sm3.dag()*a+sm3*a.dag())+g2*(sm4.dag()*a+sm4*a.dag())+g2*(sm5.dag()*a+sm5*a.dag())+g[0]*(sm1.dag()*sm2+sm2.dag()*sm1)+g[1]*(sm1.dag()*sm3+sm3.dag()*sm1)+g[2]*(sm1.dag()*sm4+sm4.dag()*sm1)+g[3]*(sm1.dag()*s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1591:1542,coupling,coupling,1542,https://qutip.org,https://github.com/qutip/qutip/issues/1591,1,['coupling'],['coupling']
Modifiability,"e not properly closed before completing tests. So it's likely it's related to tests using matplotlib. The only test using matplot lib is testPlot in test_processor.py. Sure enough, if testPlot is skipped then test_processor.py passes successfully without triggering the XIO error. **To Reproduce**. Run test_processor.py directly:; ```; python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; ```. The terminal output is; ```; $ python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; =============================================================================================== test session starts ===============================================================================================; platform linux -- Python 3.9.2, pytest-6.0.2, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/home/drew/.hypothesis/examples'); rootdir: /usr/lib/python3/dist-packages/qutip/tests, configfile: pytest.ini; plugins: cov-2.10.1, mpi-0+unknown, doctestplus-0.9.0, remotedata-0.3.2, asyncio-0.14.0, filter-subpackage-0.1.1, arraydiff-0.3, astropy-header-0.1.2, hypothesis-5.43.3, openfiles-0.5.0, xvfb-1.2.0; collected 11 items . ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_modify_ctrls PASSED [ 9%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_save_read PASSED [ 18%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_evolution PASSED [ 27%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_with_T1_T2 PASSED [ 36%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 45%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testSpline PASSED [ 54%]; ../../usr/lib/p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:3108,config,configfile,3108,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['config'],['configfile']
Modifiability,"e the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help windows users.; - Added a `reduce_func` input. Presently the map function is saving all results and the average, std, etc. are only computed at the end. There was no real advantage in saving only average values since all trajectories were in memory at the end of the map. But users expected lower memory usage when asking for only the results average.; - Added `timeout` options to the map, when passed, no error is raised but obtained results are returned. This allow to ask for 30s ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:2108,Adapt,Adaptative,2108,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['Adapt'],['Adaptative']
Modifiability,"e](http://qutip.org/docs/4.1/guide/guide-bloch.html#animating-with-the-bloch-sphere) of how to do an animation of a Bloch sphere by saving the frames of the movie using a for loop like so:. ```python; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```. With `b.clear()` we erase the points and vectors in the image, which is nice for updating the data, but What if I want to update also the attributes of the Bloch sphere?. To give an example let's say that I want the viewing angle of the Bloch sphere to smoothly change throughout the animation. I can define a function like so:. ```python; def bloch_camera_path(t, dt, azim_0, azim_f, elev_0, elev_f):; azim = ((azim_f-azim_0)/dt)*t+azim_0; elev = ((elev_f-elev_0)/dt)*t+elev_0; return [azim, elev]; ```. This function changes the viewing angle across time from the initial `[azim_0, elev_0]` configuration to the final `[azim_f, elev_f]` configuration in a linear manner. So I thought that by doing. ```python; b = Bloch(); b.vector_color = ['r']; for i in range(len(t)):; b.clear(); b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp'); ```; My animation would had that change in position of the ""camera"", but the result is just as if `b.view` wouldn't update. The only way I can make this work is by making a new bloch sphere on each iteration and defining all the attributes again and again (which I find highly inconvenient in terms of speed), like so;. ```python; import os. for i in range(len(t)):; b = Bloch(); b.vector_color = ['r']; b.view = bloch_camera_path(t[i], t[-1]-t[0], -80, -70, 45, 40); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(os.getcwd()+'/temp/bloch_'+str(i)+'.png', dirc='temp'); b.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1106:1052,config,configuration,1052,https://qutip.org,https://github.com/qutip/qutip/issues/1106,2,['config'],['configuration']
Modifiability,"ed features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Best; Boxi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:2052,Refactor,Refactoring,2052,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,1,['Refactor'],['Refactoring']
Modifiability,"ely it's related to tests using matplotlib. The only test using matplot lib is testPlot in test_processor.py. Sure enough, if testPlot is skipped then test_processor.py passes successfully without triggering the XIO error. **To Reproduce**. Run test_processor.py directly:; ```; python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; ```. The terminal output is; ```; $ python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; =============================================================================================== test session starts ===============================================================================================; platform linux -- Python 3.9.2, pytest-6.0.2, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/home/drew/.hypothesis/examples'); rootdir: /usr/lib/python3/dist-packages/qutip/tests, configfile: pytest.ini; plugins: cov-2.10.1, mpi-0+unknown, doctestplus-0.9.0, remotedata-0.3.2, asyncio-0.14.0, filter-subpackage-0.1.1, arraydiff-0.3, astropy-header-0.1.2, hypothesis-5.43.3, openfiles-0.5.0, xvfb-1.2.0; collected 11 items . ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_modify_ctrls PASSED [ 9%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_save_read PASSED [ 18%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_evolution PASSED [ 27%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_with_T1_T2 PASSED [ 36%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testPlot PASSED [ 45%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testSpline PASSED [ 54%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestC",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:3132,plugin,plugins,3132,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['plugin'],['plugins']
Modifiability,"epresentations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qobj` representing the operator-sum decomposition of Λ and `phi` is the representation of Φ, then `lambda_ + phi` should be some superoperator representation (most likely Kraus to match inputs) of the function (Λ + Φ)(ρ) = Λ﴾ρ) + Φ(ρ). Similarly, multiplying by a scalar 𝑠 would rescale each term by √𝑠 so that the corresponding function is (𝑠Λ)(ρ) = s · (Λ(ρ)) and multiplying two channels in Kraus decomposition would return their decomposition, (ΦΛ)(ρ) = (Φ ∘ Λ)(ρ) = Φ(Λ(ρ)). > Given that currently `dims` describe the dimension of the Hilbert space and that the dimension isn't changing, I feel `dims` is perhaps an odd place to put the number of elements in the sum, but that doesn't prevent this becoming a feature of Qobj in some other way. Fair enough; I guess my thinking there was that the term index is indeed just another kind of index, but if there's a better way to represent that in the metadata for a Qobj than in `dims`, I'm all for it!. > Either way, QobjEvo would need to support this too (probably not a giant amount of work, but some careful checking would be needed) & some other parts of the code might be surprised.; > ; > @jakelishman had some ideas for revamping dims support in QuTiP. I don't think it's the same idea, but the two definitely overlap in terms of which parts of QuTiP they'd evolve. Jake, would you mind posting the link to your dims proposal here if you have it handy (apologies, I seem to have lost it). Even if dims isn't the right place for this, it would be good for me to reread it. Ah, nice, I hadn't realized! I'll take a look, then!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:4731,evolve,evolve,4731,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574,2,['evolve'],['evolve']
Modifiability,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:2042,extend,extends,2042,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,2,['extend'],['extends']
Modifiability,"es: `Result` and `Evolver`. . `Result` was previously just a container of the solver output. It now does the snapshot: compute the expectation values, save the state, compute trajectories average, etc. . `Evolver` is qutip's ODE solver interface: the states are `Data` object and the function is `QovjEvo`(or `QobjEvoFunc`). There are multiple type of evolver wrapping different scipy's ode solver and a few of our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1184,Evolve,Evolver,1184,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['Evolve'],['Evolver']
Modifiability,"eter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactorin",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:1812,refactor,refactor,1812,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['refactor'],['refactor']
Modifiability,"ever, this also implies that `Qobj` should fulfil the numpy ufunc interface; `Qobj` would be a container for data such that operations like `np.sin` is the elementwise sin, or (most notably) `np.multiply` is the *elementwise* multiplication. Our `Qobj` _does not_ fulfil the ufunc interface:; 1. elementwise operations don't make sense on quantum objects, which are arrays only as an implementation detail - the `Qobj` class is meant to represent an abstract linear algebra object, not specifically a matrix.; 2. we don't honour the `shape` guarantees of numpy as we test compatibility based on `dims`, which are not 1D (superoperators) so cannot follow numpy's broadcasting rules; 3. we treat multiplication as matrix multiplication, violating how `np.multiply` should behave. My main concern is point 1: I don't think that `Qobj` provides a similar object to an `ndarray` at all. Right now we _do_ use matrices underneath, but proposed additions to QuTiP such as symbolic `Qobj` and adaptive Hilbert spaces are compatible with the idea of ""abstract linear algebra objects"", but do not necessarily have a backing array. Point 2 is mostly an extension of that: I'm not sure there is a sensible way for numpy's broadcasting rules to be applied to quantum objects as they exist now, even without extensions. ## More control over dispatch: `__array_ufunc__` and `__array_function__`. See [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html), [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html) and [NEP 35](https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html). Later versions of numpy allowed greater control over how ufuncs get implemented, which was most recently extended in 1.16 to cover non-ufuncs like `tensordot`. These functions are intended for classes to define how ufuncs operate on their data, but implementors should still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:4838,adapt,adaptive,4838,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['adapt'],['adaptive']
Modifiability,extended plot_wigner,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/128:0,extend,extended,0,https://qutip.org,https://github.com/qutip/qutip/pull/128,1,['extend'],['extended']
Modifiability,"ey reduce conceptual clarity. (For example, `temporal_basis_vector` returns a specific vector in the temporal basis; I would expect a function named `temporal_basis` to return an enumeration of all basis vectors.) However, I will try to think of shorter names which don't reduce clarity and will make changes if I come up with any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2851,Evolve,Evolver,2851,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['Evolve'],['Evolver']
Modifiability,fix - semidefinite cvxpy Variable and Parameter,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/873:25,Variab,Variable,25,https://qutip.org,https://github.com/qutip/qutip/pull/873,1,['Variab'],['Variable']
Modifiability,"format-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/include/python3.5m -c; > qutip/cy/spmatfuncs.c -o; > build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3; > -march=native -funroll-loops"" failed with exit status 1|; >; > Then, I cloned the qutip/qutip repository, and tried to build a wheel; > with |python setup.py bdist_wheel| under the qutip directory. Which; > gave me the following log:; >; > `running bdist_wheel; > running build; > running config_cc; > unifing config_cc, config, build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_e",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:3178,config,config,3178,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,2,['config'],['config']
Modifiability,"ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c qutip/cy/spmatfuncs.c -o build/temp.linux-x86_64-3.5/qutip/cy/spmatfuncs.o -w -ffast-math -O3 -march=native -funroll-loops"" failed with exit status 1; `. Then, I cloned the qutip/qutip repository, and tried to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639:2849,config,config,2849,https://qutip.org,https://github.com/qutip/qutip/issues/639,2,['config'],['config']
Modifiability,"g a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added incrementally, with only the most common operations needing to be defined to get good efficiency. **Important caveat:** the data layer operates only on _exact_ types; subclasses of defined types will be treated as completely different types. This is to do with keeping the computational complexity of multiple-dispatch operations as O(1) (i.e. I don't know how to do multiple dispatch in constant time allowing inheritance). ### `data.to`: conversion between types. ```python; >>> matrix = data.dense.identity(5); >>> matrix; Dense(shape=(5, 5), fortran=True); >>> data.to(data.CSR, matrix); CSR(shape=(5, 5), nnz=5); ```. ```python; >>> data.to[data.CSR, data.Dense]; <converter to CSR from Dense>; ```. ```python; >>> data.to[data.Dense]; <converter to Dense>; ```. ```python; >>> class NewDataType:; ... # [...]; >>> def new_from_dense(matrix: data.Dense) -> NewDataType:; ... # [...]; >>> def dense_from_new(matrix: NewDataType) -> data.Dense:; ... # [...]; >>> data.to.add_conversions([; ... (NewDataType, data.Dense, new_from_dense),; ... (data.Dense, NewDataType, dense_from_new),; ... ]); >>> data.to[data.CSR, NewDataType]; <converter to CSR from NewDataType>; ```. #### Basic usage. Convert data into a different type. This object is the knowledge source for every allowable data-layer type in QuTiP, and provides the conversions between all of them. The base use is to call",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338:2880,inherit,inheritance,2880,https://qutip.org,https://github.com/qutip/qutip/pull/1338,1,['inherit'],['inheritance']
Modifiability,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184:2055,Refactor,Refactoring,2055,https://qutip.org,https://github.com/qutip/qutip/issues/1184,1,['Refactor'],['Refactoring']
Modifiability,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318:271,variab,variable,271,https://qutip.org,https://github.com/qutip/qutip/pull/318,1,['variab'],['variable']
Modifiability,"generic `Options` class that accept any keys used by integrator or solver and can be converted to any specific solver options:; ```; Options(futur_cupy_ode_specific_options=True) # Will work; Options(not_an_options=True) # Error; # For most solver:; __solve(..., opt=Options()); ```; Once options are associated to a solver, they are frozen:; ```; opt = SeOptions(); solver = SeSolver(..., opt); opt['...'] = ... # Ok, but solver has a copy and is unaffected.; solver.options['...'] = ... # Error; solver.options = opt; ```; This is because changing options without the solver knowing will not take effect. I removed saving / storing options for now. It was mostly used to store openmp threshold, which is not supported.; I also propose to write the stored options as python code when we restore it. (`options = eval(repr(options))`, we may have some issue with circular import if called from `__init__.py`, but we can just write the `repr` of the `dict`.). While it's working fine as is, there are few point to discuss:; - Freezing options associated to solver work fine, but I see 2 alternatives:; - Options know they are used by a solver and inform it when modified. More complex but give the image that it just work. ; - All options instance are read-only. To change a key, you create a new options. Simple for us. To modify an existing options we could make it callable: `updated_options = old_options(atol=1e-5)`.; - Passing bad options keys or wrong options types (`mesolve(..., SeOptions)`) raise error, should we be less strict?; - Should we flatten SolverOptions.ode: ; ```; opt = SolverOptions(method='lsoda'); opt['progress_bar'] = False; opt['max_order_ns'] = 10; ```; And associated to it, where do we store default for integrators, per solver or per integrator.; - Do we add more sanity check to options values, or do we move `use_cython` to setting and remove the feature?. **Related PR**; It will cause conflict with #1710 and #1644. **Changelog**; Options classes using inheritance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1812:4277,inherit,inheritance,4277,https://qutip.org,https://github.com/qutip/qutip/pull/1812,1,['inherit'],['inheritance']
Modifiability,"handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then calls the `Dispatcher` with this information. I think this form would likely be preferable for several reasons:; 1. it will allow arbitrary mixing of different data types (`CSR` complete space and `Dense` operator, or both `CSR`, or whatever), with the allowed conversions respecting the global dispatcher rules, not having this function use a different, special configuration; 2. it will mean that the function can also be implemented by plug-in data types (TF/CuPy/etc), installed separately to QuTiP; 3. it will be more general, and easier to maintain; the current `subsystem_apply`, `partial_transpose`, `ptrace`, `tensor_contract` and this can all become special cases of this backing `einsum`-like routine.; 4. after we've implemented new dimensions objects, we'll be able to use a more standardised description of how to refer to individual subspaces of a Hilbert space, which will provide a more consistent UX across the library. This is particularly important if we want this to work well with superoperators. Really, thank you very much for making the PR - I really am excited to see people with an interest in the new data layer! I'm sorry that I took quite so long to respond properly to it, and that when I have, I've ended up being somewhat against the implementaton as it is. I would be really interested in pursuing this, likely after the initial release of 5.0, but right now I think we might need to get our ducks in a row ab",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:3452,plug-in,plug-in,3452,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,2,['plug-in'],['plug-in']
Modifiability,"hat casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2944,Variab,Variable,2944,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,1,['Variab'],['Variable']
Modifiability,"he code copied straight from the website it returns this error . ""ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class."". so I increase the nsteps to 100000:; output = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a, sm.dag() * sm], options = Options(nsteps= 10000)). however I get an output that is completely different to what I should be getting. What I should be getting: . ![image](https://user-images.githubusercontent.com/75099190/186995018-26029946-bba2-4b71-888d-74b88361c832.png). What my code is outputting:. ![image](https://user-images.githubusercontent.com/75099190/186995092-75b9d285-f854-487f-bd11-7dffc19d57cb.png). Do you have any idea what could be causing this error?; Any help would be hugely appreciated . my code:. import matplotlib.pyplot as plt; import numpy as np; from qutip import *. wc = 1.0 * 2 * np.pi # cavity frequency; wa = 1.0 * 2 * np.pi # atom frequency; g = 0.05 * 2 * np.pi # coupling strength; kappa = 0.005 # cavity dissipation rate; gamma = 0.05 # atom dissipation rate; N = 15 # number of cavity fock states; n_th_a = 0.0 # temperature in frequency units; use_rwa = True. tlist = np.linspace(0, 25, 100). psi0 = tensor(basis(N, 0), basis(2, 1)) # start with an excited atom. a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)). if use_rwa:; H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()); else:; H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() + a) * (sm + sm.dag()). c_op_list = []. rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a). rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()). rate = gamma; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * sm). output = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a, sm.dag() * sm], options = Options(nsteps= 10000)). fig, ax = plt.subplots(figsize=(8, 5)); ax.plot(tlist, output.expect[0], label=""Cavity""); ax.plot(tlist, ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1987:1346,coupling,coupling,1346,https://qutip.org,https://github.com/qutip/qutip/issues/1987,1,['coupling'],['coupling']
Modifiability,"he implementation itself. This has some advantages in the future too perhaps if we want to work specificially on the HEOM part without caring about the form of the spectral density. The second point is:. Most of QuTiP's solvers are function based eg., `mesolve`. In `qutip.piqs` however, we tried to do things with the class called `Dicke`. We defined a `pisolve` method similar in spirit to `mesolve` which takes in an initial state, tlist and computes the evolution. For many sophisticated approaches like `piqs` or `heom`, there needs to be some amount of pre-processing such as computing the Liouvillian/Lindbladian or the levels of the Hierarchy that needs to be done to get the RHS which is solved to get the dynamics. I saw similar approaches in `qutip.pdpsolve` with `StochasticSolverOptions`. I really like the `HEOMSolver` class defined here and was wondering if we can we have a similar abstract class which can be shared across all future solver methods and not just HEOM or the stochastic solver? I add an example below. @ajgpitch Does this make sense and should we strive to get some uniform class for all future solvers? ; @nathanshammah @nonhermitian . ```; class Solver(object):; """"""; A super-class specifying the basic methods required in a solver. Parameters; ----------; name: str; The name of the specific solver the sub-class represents, eg., `heom`.; default: None; """"""; def __init__(self, solver=None):; 	self.solver = solver. def configure(self, *args, **kwargs):; 	""""""; 	Configures the solver by computing the necessary objects required; 	to run the `solve` method.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example `Dicke.configure`""). def solve(self, initial_state, tlist, options, *args, **kwargs):; 	""""""; 	Runs the solver to compute the evolution using the initial state and tlist.; 	""""""; 	raise NotImplementedError(""This is a abstract class only. ""; ""Use the solve method from a subclass, for example `Dicke.solve`""); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/962:2904,config,configure,2904,https://qutip.org,https://github.com/qutip/qutip/pull/962,3,"['Config', 'config']","['Configures', 'configure']"
Modifiability,"heir projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projects, even on their own funding resources (most probably together with the development of research projects), in coordination with the lead development team, could help foster development in a more sustainable way. . ## Proposal; I propose to help sustain available projects in a more structural way than what is done now. This is an example of a what we could call a **QEP, or ""QuTiP Enhancement Proposal"".**. - One thing that could be done is to simply expand the existing Wiki. The downside of taking only this action is that only organization members can modify the wiki. So this could work, but mainly as a more static and cleaner staple. . - I propose to integrate the Wiki with Issues that contain the projects, adding a `projects` (or similar) label. This is in the spirit also of other large quantum open source projects such as Qiskit, which has even an ad-hoc `qiskit-community` repository, https://github.com/qiskit-community/. In QuTiP case, we could create a new repository similar to the notebooks one, e.g., https://github.com/qutip/qutip-community/. The downside is that in general the division is subfolders is not advised for easiness of maintainability. So one could just open issues with open projects. Of course, for physics questions, sometimes spilling in to PRs and Issues, qutip already has a Google Group forum, where I advise that this new capabilities may be advertised with a proper thread.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1132:3156,maintainab,maintainability,3156,https://qutip.org,https://github.com/qutip/qutip/issues/1132,1,['maintainab'],['maintainability']
Modifiability,"her would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Python space exept for in special methods (`__mul__`, ...). I think that 3.i is the closest to an ideal solution.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2998,plug-in,plug-ins,2998,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,9,"['Variab', 'plug-in']","['Variable', 'plug-in', 'plug-ins']"
Modifiability,"hi gary, thanks for making this an issue, i think it fell through the cracks on the google groups. . I think the problem is with how the expectation values are calculated. Mesolve() returns the correct states, but they are wrongly flagged with isherm=True, even when they are not actually hermitian, so when expect() is called it takes the real part. I think this incorrect flagging happens here for the output states; https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mesolve.py#L520. and here for collating the expectation values; https://github.com/qutip/qutip/blob/d285e96b3afc61afd1deceef61d9635f9d9aa505/qutip/mesolve.py#L510; (where only the hermiticity of the operators are checked, not the state. you can check this by setting x.isherm=False in your code example, which fixes everything). @Ericgig is there any issue with just removing this isherm=True flag here, and fixing the hermiticity check in the expectation values output call? i guess all this is getting replaced with your solver rewrite anyway, but if not it might make a good ''first issue'' for gsoc?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796432374:1032,rewrite,rewrite,1032,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796432374,1,['rewrite'],['rewrite']
Modifiability,"his case numpy - haven't checked with others). Create a `rho0` for mesolve to use with the flat array while explicitly specifying the matrix dimensions in the `dims` parameter. Upon passing the density matrix to `mesolve` a segmentation fault occurs. A simple proof of concept is included below. `np.random.random` was used to fill the matrix in this case, but the issue was encountered using valid density matricies, and the issue seems to be unrelated to whether the matrix is valid or not as a density matrix. ### Code to Reproduce the Bug. ```shell; import qutip as qtip; import numpy as np. dim = 100 # Small dims don't work. I assume python has some buffer after the array; H = qtip.Qobj(np.identity(dim),dims=[[dim],[dim]]); rho0 = np.random.random([dim**2]); rho0 = qtip.Qobj(rho0.flatten(),dims=[[dim],[dim]]) # This fails; # rho0 = qtip.Qobj(rho0.reshape([dim,dim]),dims=[[dim],[dim]]) # This works; qtip.mesolve(rho0=rho0,H=H,tlist=np.linspace(0,10,1),progress_bar=qtip.ui.EnhancedTextProgressBar()); ```. ### Code Output. ```shell; [ 0% ] Elapsed 0.00s / Remaining 00:00:00:00[1] 3281154 segmentation fault (core dumped); ```. ### Expected Behaviour. The code should exit without failure or throw a python error elaborating on the issue. ### Your Environment. ```shell; QuTiP Version: 4.6.2; Numpy Version: 1.21.4; Scipy Version: 1.6.0; Cython Version: 0.29.21; Matplotlib Version: 3.4.3; Python Version: 3.9.7; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /home/lala5th/.local/lib/python3.9/site-packages/qutip; ```. ### Additional Context. I ran the code through `gdb` to somewhat narrow down the cause of the issue. It seems that `dense2D_to_fastcsr_fmode` causes the segmentation fault, but the parameters passed to it seem fine at first glance, since I expect `ncols = 10000`. While I don't know how useful it is I will put the top of the stack trace (after this the only the call to `mesolv",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782:1069,Enhance,EnhancedTextProgressBar,1069,https://qutip.org,https://github.com/qutip/qutip/issues/1782,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L229-L230. `if n:` ignore it completely and assign the wrong variable... This is the main problem. https://github.com/qutip/qutip/blob/2ca20fb829dc67d0ee32498422bad1f8ff852a95/qutip/core/data/permute.pyx#L265. And here's the offending unchecked multiplication. That test is actually off from what I intended, which was hiding the buggy function call below it. The unchecked 32-bit overflow punched through the test and revealed the problematic function. In worse matrices, this would have actually been a huge segfault - the identity was only safe because it has the same number of elements in each row. ---. That's exciting that someone else is trying it out! I'm glad there are speed-ups. If you've got issues let me know and I can maybe help out with some of the internals (my email's in my github profile). I'm fine to wait to check out a PR if you guys are working on something between you. I still need to find the time to finish off the dispatching system and pull the OpenMP parts back into `dev.major`...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500:166,variab,variable,166,https://qutip.org,https://github.com/qutip/qutip/issues/1382#issuecomment-728373500,1,['variab'],['variable']
Modifiability,"hub.com/psf/requests/commit/b639e66c816514e40604d46f0088fbceec1a5149""><code>b639e66</code></a> test on py3.12 (<a href=""https://redirect.github.com/psf/requests/issues/6448"">#6448</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/d3d504436ef0c2ac7ec8af13738b04dcc8c694be""><code>d3d5044</code></a> Fixed a small typo (<a href=""https://redirect.github.com/psf/requests/issues/6452"">#6452</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/2ad18e0e10e7d7ecd5384c378f25ec8821a10a29""><code>2ad18e0</code></a> v2.30.0</li>; <li><a href=""https://github.com/psf/requests/commit/f2629e9e3c7ce3c3c8c025bcd8db551101cbc773""><code>f2629e9</code></a> Remove strict parameter (<a href=""https://redirect.github.com/psf/requests/issues/6434"">#6434</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/87d63de8739263bbe17034fba2285c79780da7e8""><code>87d63de</code></a> v2.29.0</li>; <li><a href=""https://github.com/psf/requests/commit/51716c4ef390136b0d4b800ec7665dd5503e64fc""><code>51716c4</code></a> enable the warnings plugin (<a href=""https://redirect.github.com/psf/requests/issues/6416"">#6416</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/a7da1ab3498b10ec3a3582244c94b2845f8a8e71""><code>a7da1ab</code></a> try on ubuntu 22.04 (<a href=""https://redirect.github.com/psf/requests/issues/6418"">#6418</a>)</li>; <li>Additional commits viewable in <a href=""https://github.com/psf/requests/compare/v2.28.2...v2.31.0"">compare view</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=requests&package-manager=pip&previous-version=2.28.2&new-version=2.31.0)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dep",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2164:6850,plugin,plugin,6850,https://qutip.org,https://github.com/qutip/qutip/pull/2164,1,['plugin'],['plugin']
Modifiability,"i. def __create_sigmaz_ij(self,i,j):; '''; creates coupling hamiltonians for ; problem hamiltonian; '''; base = []; k = self._n; # create list of I2; for l in range(self._n):; base.append(qt.qeye(2)); base[i] = qt.sigmaz(); base[j] = qt.sigmaz(); sigmaz_ij = qt.tensor(base); return sigmaz_ij. def driver(self):; '''; creates drive Hamiltonian, which is the sum of -sigmax_i operators ; ; '''; k = self._n; Hd = np.zeros((2**k, 2**k)); Hd = qt.Qobj(Hd, dims=[[2 for i in range(k)],[2 for i in range(k)]]); for i in range(self._n):; sigmax_i = self.__create_sigma_i(i); Hd -= sigmax_i; return Hd. def problem(self):; '''; creates problem Hamiltonian. '''; # initialise Hp array; p = self._n # to save on writing; Hp = np.zeros((2**p, 2**p)); Hp = qt.Qobj(Hp, dims=[[2 for i in range(p)],[2 for i in range(p)]]). #vertex coefficients; if self._spin_coeff is None:; pass; else:; for i in range(self._n):; sigmaz_i = self.__create_sigma_i(i, sigma = qt.sigmaz()); Hp += self._spin_coeff[i] * sigmaz_i; #coupling coefficients; if self._coupling_coeff is None:; pass; else:; k = -1; for i in range(p):; for j in range(i+1,p):; k += 1; print(str(i), str(j)); sigma_ij = self.__create_sigmaz_ij(i,j); Hp += self._coupling_coeff[k] * sigma_ij; return Hp; ```. The code returns the error `incompatible Liouvillian and state dimensions: [[[2, 2, 2], [2, 2, 2]], [[2, 2, 2], [2, 2, 2]]] and [[8], [8]]`. Adding the commented line `#initial_state = qt.Qobj(initial_state, dims = [[[2, 2, 2], [2, 2, 2]], [[2, 2, 2], [2, 2, 2]]])` returns the error `Shapes don't match: (64, 64) @ (64, 1)`. I am confused as to why there is a 64x64 matrix, even though my inputs were 8x8 matrices for `Hd` and `Hp` and the input density matrix is also 8x8. I am inputting an initial spin state $\ket{\psi} = \dfrac{1}{8} (1,1,1,1,1,1,1,1)$, which is the lowest energy eigenstate in the basis of $H_d$. I believe `mesolve` is combining `Hd` and `Hp` into a 64x64 matrix, perhaps computing their tensor product. Why would this be the ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1989:4174,coupling,coupling,4174,https://qutip.org,https://github.com/qutip/qutip/issues/1989,1,['coupling'],['coupling']
Modifiability,"ide that (e.g. in `dnorm`), I overrode it by providing a definition in a tighter scope - either at class level or per-function (via `pytest.mark.parametrize` directly). The correct scoping just depends a lot on the type of tests you're writing - if you're going to have to overwrite something constantly then module scoping isn't good, but if you have lots of different functions to test, and every test for a given function will want the same parametrisation, then class scoping might be a good choice. If you only need the parametrisation once, then it's best to put it right next to the place it's used (like in the case of mine that you've highlighted). It means that if you've opened that file to read the tests, then everything you need to understand `Test_fidelity.test_known_cases` will be on your screen if you just scroll to it. That makes it much easier for the next person who has to come along to edit your code. I used a couple of temporary variables in that case just to aid readability - my cases wouldn't have nicely fit on one line if I'd shoved the `qutip.basis(2, 0)` stuff inside the `pytest.param` constructors, and it would be hard to read. This way you can easily verify that the code is correct bit-by-bit; you can see clearly that the names are descriptive and match exactly what they say, and that means you can trust them when they then appear in the parametrisation. I won't pretend to be perfect at any part of coding, and particularly testing. I rewrote all the testing files starting from those beginning with ""a"" up to (now) ""metrics"" while I was first getting to know the QuTiP codebase, and hopefully you can see that my early efforts weren't that great, and they get a bit better and easier to read as time went on. (The later files haven't been converted yet.) The main things are to always be thinking about readability both of the code and the error messages that are coming out, and making sure that your tests are really testing that your functions have your ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706:1448,variab,variables,1448,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706,2,['variab'],['variables']
Modifiability,if you run:. ``` python; import numpy as np; config = np.__config__; config.show(); ```. what do you get?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/552#issuecomment-259599373:45,config,config,45,https://qutip.org,https://github.com/qutip/qutip/issues/552#issuecomment-259599373,2,['config'],['config']
Modifiability,"ile ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 304 in wrap_session; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/main.py"", line 316 in pytest_cmdline_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 84 in <lambda>; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 162 in main; File ""/Users/jake/.anaconda3/envs/qutip-dev/lib/python3.8/site-packages/_pytest/config/__init__.py"", line 185 in console_main; File ""/Users/jake/.anaconda3/envs/qutip-dev/bin/pytest"", line 11 in <module>; Segmentation fault: 11; ```. This was done with commit 624405e7, SciPy 1.6.2 and Numpy 1.19.5. My BLAS version has chopped and changed an awful lot, but I believe that run was with MKL implementations. The ""random"" stack trace from pytest looks to me like the error came about during garbage collection, and I really don't imagine pytest is to blame. We have in the past had issues with some bad calls in SciPy linalg functions, so it's _possible_ that they are the cause again, but I doubt it; we'd expect the stack traces to reliably show scipy to be the problem in that case. I wasn't able to reproduce this segfault on Windows, but that doesn't mean a huge amount, because I also can't reliably reproduce it on Mac. I suspect that the cause is some dodgy handling of pointers in the `struct CSR_Matrix` type in `qutip/cy/sparse_routines.pxi`, but this is just a suspi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502:5846,config,config,5846,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826099502,1,['config'],['config']
Modifiability,in setup.py (could not find a good config that included the pyx files in the source distribion file produced by setup.py),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/196:35,config,config,35,https://qutip.org,https://github.com/qutip/qutip/pull/196,1,['config'],['config']
Modifiability,"inistic where the current deterministic contributions are calculated. These functions can now be called from a stochastic rhs implementation, like this. ```; dpsi_t = _rhs_psi_deterministic(H, psi_t, t, dt, args); ```. In this way the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE in terms of d1 and d2, and then possibly select a rhs solver using the solver argument to smesolve. This will not work in general for solvers like the milstein scheme, since it requires an analytical derivative (unless it can be evaluated numerically?), and in those cases it would be sufficient to implement problem specific rhs functions (like rhs_rho_milstein_homodyne etc). Regarding the use of expm: OK, I agree that it could be a nice method to have to be used on smallish system. However, since we are stepping with a small timestep dt, shouldn't it be sufficient to use an expansion of of expm as usual? Perhaps a second-order expansio",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:1637,flexible,flexible,1637,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['flexible'],['flexible']
Modifiability,"is None:; 99 # get the unitary propagator; --> 100 U = propagator(H, T, [], args); 101 ; 102 # find the eigenstates for the propagator. F:\Anaconda3\lib\site-packages\qutip\propagator.py in propagator(H, t, c_op_list, args, options, unitary_mode, parallel, progress_bar, **kwargs); 181 output = sesolve(H2, psi0, tlist, [],; 182 args=args, _safe_mode=False,; --> 183 options=Options(normalize_output=False)); 184 for k, t in enumerate(tlist):; 185 u[k] = sp_reshape(output.states[k].data, (N, N)). F:\Anaconda3\lib\site-packages\qutip\sesolve.py in sesolve(H, rho0, tlist, e_ops, args, options, progress_bar, _safe_mode); 153 elif n_str > 0:; 154 res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; --> 155 progress_bar); 156 ; 157 elif isinstance(H, (types.FunctionType,. F:\Anaconda3\lib\site-packages\qutip\sesolve.py in _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt, progress_bar); 432 code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; 433 '<string>', 'exec'); --> 434 exec(code, globals()); 435 config.tdfunc = cy_td_ode_rhs; 436 . F:\Anaconda3\lib\site-packages\qutip\sesolve.py in <module>(). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(self, fullname); 443 self.pyxbuild_dir,; 444 build_inplace=self.inplace,; --> 445 language_level=self.language_level); 446 return module; 447 . F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 230 name, traceback.format_exception_only(*sys.exc_info()[:2]))); 231 if sys.version_info[0] >= 3:; --> 232 raise exc.with_traceback(tb); 233 else:; 234 exec(""raise exc, None, tb"", {'exc': exc, 'tb': tb}). F:\Anaconda3\lib\site-packages\pyximport\pyximport.py in load_module(name, pyxfilename, pyxbuild_dir, is_package, build_inplace, language_level, so_path); 214 module_name = name; 215 so_path = build_module(module_name, pyxfilename, pyxbuild_dir,; --> 216 inplace=build_inplace, lang",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/854:4962,config,config,4962,https://qutip.org,https://github.com/qutip/qutip/issues/854,1,['config'],['config']
Modifiability,"is feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(expects[-1], variable); ```. Output:; ```; 20.0%. ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1683,Variab,Variable,1683,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['Variab'],['Variable']
Modifiability,"is is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if we make major breaking changes to effectively our premier function, and I don't see a need to do that. We can add, rather than change, and keep `mesolve` as the ""quick-and-dirty"" method that just works.; > * I'm in favour of exposing the different parts of the `mesolve` process as user-accessible, composable chunks. So something like exposing a `mesolve_prepare_ode(H, state, c_ops) -> OdeState` function, where `OdeState` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using what",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10914,refactor,refactor,10914,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['refactor'],['refactor']
Modifiability,"is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using the builtin Python module multiprocessing.; 36 """"""; 37 __all__ = ['parfor', 'parallel_map', 'serial_map']; 38 ; 39 from scipy import array; 40: from multiprocessing import Pool; 41 from functools import partial; 42 import os. /Users/shahnawaz/dev/qutip/qutip/settings.py:; 32 ###############################################################################; 33 """"""; 34: This module contains settings for the QuTiP graphics, ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:2111,config,config,2111,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,2,['config'],['config']
Modifiability,"ithout a palette <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7797"">#7797</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use palette when loading ICO images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7798"">#7798</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use consistent arguments for load_read and load_seek <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7713"">#7713</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Turn off nullability warnings for macOS SDK <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7827"">#7827</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix shift-sign issue in Convert.c <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7838"">#7838</a> [<a href=""https://github.com/r-barnes""><code>@​r-barnes</code></a>]</li>; <li>winbuild: Refactor dependency versions into constants <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7843"">#7843</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Build macOS arm64 wheels natively <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7852"">#7852</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed typo <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7855"">#7855</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Open 16-bit grayscale PNGs as I;16 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7849"">#7849</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Handle truncated chunks at the end of PNG images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7709"">#7709</a> [<a href=""https://github.com/lajiyuan""><code>@​lajiyuan</code></a>]</li>; <li>Match mask size to pasted image si",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:7650,Refactor,Refactor,7650,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['Refactor'],['Refactor']
Modifiability,keep the new text based progress bar as EnhancedTextProgressBar. Related to #121,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/256:40,Enhance,EnhancedTextProgressBar,40,https://qutip.org,https://github.com/qutip/qutip/pull/256,1,['Enhance'],['EnhancedTextProgressBar']
Modifiability,"le.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help windows users.; - Added a `reduce_func` input. Presently the map function is saving all results and the average, std, etc. are only computed at the end. There was no real advantage in ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1780,evolve,evolver,1780,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['evolve'],['evolver']
Modifiability,"les in QuTiP follow the pep8 standard and wrap two newlines for top-level functions. I am in favor of the pep8 standard and have two newlines. @ajgpitch what do you suggest?. Please remove the helper function `count_filled` without the test if it is not required. We aim to test as much as possible and remove redundancy in code. About `__all__`, I will shift all the rest in a new PR and we can keep yours as it is now. Coming to the more important discussion regarding the `class` based implementation, I have started pushing for similar approaches in newer modules such as [qutip.models.piqs](https://github.com/qutip/qutip/blob/master/qutip/models/piqs.py). I am also working on a new non-Markovian method which requires a class. Something of that sort is already used in `qutip.nonmarkov.heom`. I understand that many of qutip's solvers are written to be isolated functions but that should not mean that we should not write code to fully use the object oriented framework Python provides. Moreover, I noticed that you have to rewrite wrappers for the functions anyways to deal with repeatedly calculating things such as `scattering_probability` which clearly can be made much more compact if we use a class based approach. I am not making this suggestion just for the minor performance improvement. It improves the organization of the code, allows greater flexibility in adding new things to an existing class and modifying it easily. In terms of user experience, this means less clutter in the code and verbosity of arguments. You can initialize something once and keep re-calculating things by dynamically changing the parameters and calling the `class` method. If it does not hurt to slowly shift in this direction then I think we should go for it. If there is an alternative reason for not having classes then please let us know as the cons @bencbartlett mentions has more to do with following qutip precedent than some fundamental disadvantage in performance or use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384860713:1746,rewrite,rewrite,1746,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384860713,2,['rewrite'],['rewrite']
Modifiability,"lf.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 303 if not self.initialized:; --> 304 self.initialize(); 305 compile_info = self._setup_compile(output_dir, macros, include_dirs,; 306 sources, depends, extra_postargs). F:\Anaconda3\lib\distutils\_msvccompiler.py in initialize(self, plat_name); 195 plat_spec = PLAT_TO_VCVARS[plat_name]; 196 ; --> 197 vc_env = _get_vc_env(plat_spec); 198 if not vc_env:; 199 raise DistutilsPlatformError(""Unable to find a compatible "". F:\Anaconda3\lib\distutils\_msvccompiler.py in _get_vc_env(plat_spec); 83 vcvarsall, vcruntime = _find_vcvarsall(plat_spec); 84 if not vcvarsall:; ---> 85 raise DistutilsPlatformError(""Unable to find vcvarsall.bat""); 86 ; 87 try:. ImportError: Building module rhs75680 failed: ['distutils.errors.DistutilsPlatformError: Unable to find vcvarsall.bat\n']; ```; I have tried it many t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/854:7957,variab,variable,7957,https://qutip.org,https://github.com/qutip/qutip/issues/854,1,['variab'],['variable']
Modifiability,"look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; define_macros = [('HAVE_CBLAS', None)]; blas_opt_info:; define_macros = [('NO_ATLAS_INFO', 1), ('HAVE_CBLAS', None)]; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; lapack_armpl_info:; NOT AVAILABLE; lapack_mkl_info:; NOT AVAILABLE; openblas_lapack_info:; NOT AVAILABLE; openblas_clapack_info:; NOT AVAILABLE; flame_info:; NOT AVAILABLE; atlas_3_10_threads_info:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:1685,config,configuration,1685,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['configuration']
Modifiability,"lternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_threads_info:; NOT AVAILABLE; atlas_blas_info:; NOT AVAILABLE; blas_info:; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; define_macros = [('HAVE_CBLAS', None)]; blas_opt_info:; define_macros = [('NO_ATLAS_INFO', 1), ('HAVE_CBLAS', None)]; libraries = ['blas', 'blas']; library_dirs = ['/usr/lib/x86_64-linux-gnu']; include_dirs = ['/usr/local/include', '/usr/include']; language = c; lapack_armpl_info:; NOT AVAILABLE; lapack_mkl_info:; NOT AVAILABLE; openblas_lapack_info:; NOT AVAILABLE; ope",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:1586,config,config,1586,https://qutip.org,https://github.com/qutip/qutip/issues/2053,1,['config'],['config']
Modifiability,"lution that works for both. > * What is the advantage of this over using the existing superoperator representations?. I don't think there is one, per se, in the same sense that there's no strict advantage to superoperators over Choi operators over χ operators — each is useful in different contexts, such that QuTiP supports all three in order to allow users to pick the right representation for their problem. Similarly, operator-sum decompositions of channels are quite common and are useful in some special circumstances (e.g.: expressing a Choi-rank–sparse channel without requiring a 4^n × 4^n matrix). In the Quantum Development Kit, for instance, we use `qutip.to_kraus` to express user-supplied superoperators, Choi operators, and χ operators in terms of an operator-sum decomposition that is then passed to the underlying open systems simulator. While the operator-sum decomposition is quite useful internally to the simulator, that's not a detail that we want to enforce upon users, such that QuTiP's support for multiple superoperator representations is quite useful in presenting a user-friendly interface for configuring noise models. > * Can this advantage be carryied over into, e.g., using solvers, eigenvalue finding, etc?. I'm not sure I entirely follow, sorry?. > * Would it be better to have a new object, sort of like QobjEvo but for sums rather than evolutions?. Perhaps, but at least for the operator-sum decomposition of channels, it would feel a bit weird to me to have superoperators, Choi operators and χ operators all have one Python type, but for Kraus representations to have a fully different Python type. Whether I represent Λ(ρ) by 0.9 𝟙ρ𝟙 + 0.1 𝑋ρ𝑋 or {√(0.9) 𝟙, √(0.1) 𝑋}, they both represent the same function from density operators to density operators. > * How do you see the various mathematical operations working?. My thought here would be that an operator-sum decomposition of a channel is just that: a representation of a channel. Thus, if `lambda_` is a `Qo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574:2536,config,configuring,2536,https://qutip.org,https://github.com/qutip/qutip/issues/1673#issuecomment-927981574,2,['config'],['configuring']
Modifiability,"lve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; --> 218 progress_bar=progress_bar, _safe_mode=_safe_mode); 219 ; 220 if isket(rho0):. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in sesolve(H, psi0, tlist, e_ops, args, options, progress_bar, _safe_mode); 135 ; 136 res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; --> 137 progress_bar, dims=psi0.dims); 138 if e_ops_dict:; 139 res.expect = {e: res.expect[n]. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt, progress_bar, dims); 360 if expt_callback:; 361 # use callback method; --> 362 output.expect.append(e_ops(t, Qobj(cdata, dims=dims))); ...; ---> 11 H = qt.qobj_list_evaluate(h_t, tau, args); 12 ; 13 # find the M lowest eigenvalues of the system. NameError: name 'qt' is not defined; ```. If I do `import qutip as qt`, a different error occurs:; ```; AttributeError Traceback (most recent call last); <ipython-input-8-ea74e5ab1d35> in <module>; 1 # Evolve the system, request the solver to call process_rho at each time step.; 2 ; ----> 3 qt.mesolve(h_t, psi0, taulist, [], process_rho, args). ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 216 if not use_mesolve:; 217 return sesolve(H, rho0, tlist, e_ops=e_ops, args=args, options=options,; --> 218 progress_bar=progress_bar, _safe_mode=_safe_mode); 219 ; 220 if isket(rho0):. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in sesolve(H, psi0, tlist, e_ops, args, options, progress_bar, _safe_mode); 135 ; 136 res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; --> 137 progress_bar, dims=psi0.dims); 138 if e_ops_dict:; 139 res.expect = {e: res.expect[n]. ~/anaconda3/envs/fda/lib/python3.7/site-packages/qutip/sesolve.py in _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, opt, progress_bar, dims); 360 if e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1930:1807,Evolve,Evolve,1807,https://qutip.org,https://github.com/qutip/qutip/issues/1930,1,['Evolve'],['Evolve']
Modifiability,"ly useful and will simplify the code inside the propagator a bit. I removed `.evolve_dm`. > **For `.sys_dims`**:; > ; > The meaning of what `.sys_dims` returns is already unclear in this PR. The docstring says its the dimension of the system. Practically I assume that to mean ""the dimension of the initial state or dm passed to .run()"". However, in the PR its used as the size of the propagator. These are the same if there is no environment, but will be different otherwise.; > ; > I suggest we keep `.sys_dims` but document that it is the dimensions of the system excluding any environment. Changed in HEOMSolver. Since environment only means something for HEOM, so it took some time to understand what it referred to. Adding the change elsewhere would be confusing. ; > **Specifying which solvers support propagators**:; > ; > Currently we have a list of explicit checks at the top of the propagator constructor, but we could instead have a ""propagator_class"" attribute on solvers the same way we have a ""result_class"" and then that could be set to some suitable default for ordinary solvers and None or ""PropagatorNotSupported"" for solvers that don't support them. There is only one class for propagator and I don't see us needing any other, so there is no use for a `propagator_class` . We could have a `support_propagator` flag, but I prefer it this way as we can set a special error message for `HEOMSolver`. ; `HEOMSolver` is the only exceptions where we could support it but choose not to take the time to implement it. ; All deterministic solver we have can be used for propagator, trajectories solver don't have a properly defined propagator for single trajectory and I don't see any use to create a propagator for the averaged states. It would take a lot of trajectories to obtain what is effectively mesolve's propagator. . We could add the flag to the integrator instead, some krylov integrator cannot evolve 2D states, but it's the only one we have plan for and it's not merged yet...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120:2324,evolve,evolve,2324,https://qutip.org,https://github.com/qutip/qutip/pull/1999#issuecomment-1335766120,2,['evolve'],['evolve']
Modifiability,"m wrong). This would require to have a function that casts any defined scalar to a complex scalar. The dispatcher would be responsible to ensure that the correct scalar gets passed appropriately to the specialisation and for returning not implemented if necessary. ; - This solves the inconsistency problem as you could register a ""new"" scalar and define how it gets cast to a python complex scalar with a function (in most of the times, if not always, this will be `complex(other)`). ; - This does _not_ solve having `NotImplemented` at the python space.; - It seems to be challenging to implement and will probably make things more difficult to maintain. 3) We can also define more rigorously what a scalar is for `Qobj` with a list, `_ALLOWED_SCALARS = [numbers.Number, ...]` that defines what we accept as scalars. We then do: `isinstace(other, _ALLOWED_SCALARS)` and return `NotImplemented` if not there. Two options here:; 1) QuTiP allows only `numbers.Number`:; - In this case `qutip-tensorflow` can extend `_ALLOWED_SCALARS` with tf.Variable and tf.Tensor. However, if the user uses two plug-ins, say qutip-tensorflow and qutip-something-that-does-not-work-well-with-tensorflow (second plug-in), the second plug-in may not work properly. ; - The above point is not a big deal if we make clear that _ALLOWED_SCALARS must accept `complex(other)` for compatibility reasons. In this way the second plug-in can always default to `complex(other)` (this is already the default behaviour of `mul_dense`).; 2) QuTiP allows `numbers.Number`, `ndarray` of shape `(,)`, `tf.Variable` of shape `(,)` and more in the future.; - The upside of this method with respect to 3.1 is that users know which types they must accept.; - This is probably not a good idea as it means qutip has to handle new dependencies (tensorflow and probalby more in the future).; - This _still_ defines what an scalar is at he `Qobj` level. I think this is not bad as it seems to be the only way of avoiding `NotImplemented` at Pyt",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152:2910,extend,extend,2910,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-889006152,2,['extend'],['extend']
Modifiability,"m/python-pillow/Pillow/issues/7928"">#7928</a>; [radarhere, hugovk]</p>; </li>; <li>; <p>Deprecate <code>eval()</code>, replacing it with <code>lambda_eval()</code> and <code>unsafe_eval()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7927"">#7927</a>; [radarhere, hugovk]</p>; </li>; <li>; <p>Raise <code>ValueError</code> if seeking to greater than offset-sized integer in TIFF <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7883"">#7883</a>; [radarhere]</p>; </li>; <li>; <p>Add <code>--report</code> argument to <code>__main__.py</code> to omit supported formats <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7818"">#7818</a>; [nulano, radarhere, hugovk]</p>; </li>; <li>; <p>Added RGB to I;16, I;16L, I;16B and I;16N conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7918"">#7918</a>, <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7920"">#7920</a>; [radarhere]</p>; </li>; <li>; <p>Fix editable installation with custom build backend and configuration options <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7658"">#7658</a>; [nulano, radarhere]</p>; </li>; <li>; <p>Fix putdata() for I;16N on big-endian <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7209"">#7209</a>; [Yay295, hugovk, radarhere]</p>; </li>; <li>; <p>Determine MPO size from markers, not EXIF data <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7884"">#7884</a>; [radarhere]</p>; </li>; <li>; <p>Improved conversion from RGB to RGBa, LA and La <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7888"">#7888</a>; [radarhere]</p>; </li>; <li>; <p>Support FITS images with GZIP_1 compression <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7894"">#7894</a>; [radarhere]</p>; </li>; <li>; <p>Use I;16 mode for 9-bit JPEG 2000 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7900"">#7900</a>; [scaramallion, radarhere]</p>; </l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:11303,config,configuration,11303,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['config'],['configuration']
Modifiability,"mm4[1,0] ; Target 0: (python) stopped.; ```. Not passing `c_ops` restores just raising a `ValueError`. ```python; from qutip import *. D = 13; psi0 = tensor(coherent(D, 100e-9), qeye(D)); result = mesolve(qeye(D**2), psi0,[0, 100e-9], []); ```; gives; ```; (qutip) ➜ ~ python mwe.py ; Traceback (most recent call last):; File ""mwe.py"", line 5, in <module>; result = mesolve(qeye(D**2), psi0,[0, 100e-9], []); File ""/Users/colmrya/miniconda3/envs/qutip/lib/python3.8/site-packages/qutip/mesolve.py"", line 266, in mesolve; func(0., v, *ode_args) + v; ValueError: operands could not be broadcast together with shapes (28561,) (2197,) ; ```. **Expected behavior**; A exception for incompatible dimensions raised in all cases. ** Environment**; Please use `qutip.about()` to get the information about your environment and paste it here. ```; (qutip) ➜ ~ ipython; Python 3.8.8 (default, Feb 24 2021, 13:46:16) ; Type 'copyright', 'credits' or 'license' for more information; IPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help. In [1]: import qutip; q; In [2]: qutip.about(). QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li and Jake Lishman.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.3; Numpy Version: 1.19.2; Scipy Version: 1.6.1; Cython Version: 0.29.22; Matplotlib Version: 3.3.4; Python Version: 3.8.8; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/colmrya/miniconda3/envs/qutip/lib/python3.8/site-packages/qutip; ============================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1456:3014,enhance,enhanced,3014,https://qutip.org,https://github.com/qutip/qutip/issues/1456,1,['enhance'],['enhanced']
Modifiability,"modules, also because in the other cases the title are self-explanatory. ; Regarding this comment:; ```; Function to build cython code from str, compile and import it.; Used by cQobjEvo.; cy/codegen.py does the same thing for specific solver; ```; could then this file by moved to `qutip/cy/`?. * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), block 24 online has a printed error `TypeError: __call__() got an unexpected keyword argument 'args'`, yet on my machine runs fine, it can be replaced. I opened a PR, also running the last blocks and qutip.about(), https://github.com/qutip/qutip-notebooks/pull/72. . * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), `Time for cte` could be more explanatory. Similarly elsewhere. * I wonder whether instead `QobjEvo`, `Qobjt` could be even more intuitive for the user. * I would really encourage you to write one notebook (or more), about the new functionalities of the stochastic solvers, as well as the old methods. This could be the to-go resource, beyond documentation, to understand how these stochastic solvers are now expanded and coherently defined. It does not need to be a lot of work, it can copy a lot of stuff from the development notebooks. It would be fundamental to have the solvers' master equations written down, explaining for each solver what each term is, e.g., the jump operator. Also, in `development-smesolve-tests`, the equations are already there for example. Block 23 is beautiful, and it could be reproduced in the tutorial. . * Similarly, a user guide entry would really enhance the adoption of these solvers. At a later stage, some more refined example applications could be provided. * Review is still ongoing, I will provide comments on the .py files and other solvers files. Help from other developers is welcome as these are massive changes.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:3849,enhance,enhance,3849,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,2,['enhance'],['enhance']
Modifiability,"n my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interface, not a broadcast-able _array_ interface. They specifically document that they will not provide this interface (see scipy/scipy#12279). Somewhat weirdly, they do have custom methods for some elementwise ufuncs, though (like `np.sin`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:7542,variab,variable,7542,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['variab'],['variable']
Modifiability,"n you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wishes,; >; > Nathan; >; > Dr. Nathan Shammah; > Postdoctoral Research Scientist; > Theoretical Quantum Physics Laboratory; > RIKEN, Wako, Saitama, Japan; > www.nathanshammah.com; >; >; >; > On Sun, Feb 23, 2020 at 5:42 AM Boxi Li <notifications@github.com> wrote:; >; > > I have some detail information for the GSoC 2020 project ""Error; > mitigation; > > in QuTiP"". Unfortunately, I don't have writing access to the QuTiP GitHub; > > Wiki page. I post it here so if anyone finds it nice could copy it to the; > > Wiki page.; > >; > > I add some details based on the original description:; > > ------------------------------; > > 1. Error mitigation in QuTiP; > >; > > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > > quantum circuit simulator (which was a GSoC project) providing enhanced; > > features for a pulse-level description of quantum circuits and noise; > > models. A new class Processor and several subclasses are added to; > > represent different platforms for quantum computing. They can transfer a; > > quantum circuit into the corresponding control sequence and simulate the; > > dynamics with QuTiP solvers. Different noise models can be added to; > > qutip.qip.noise to simulate noise in a quantum device.; > >; > > This module is still young and many features can be improved, including; > > new device models, new noise models and integration with the existing; > > general framework for quantum circuits (qutip.qip.circuit). There are; > > also possible applications such as error mitigation techniques [1-3].; > >; > > The tutorial notebooks can be found at; > > http://qutip.org/tutorials.html#nisq. A recent presentation on the; > FOSDEM; > > conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:4572,enhance,enhanced,4572,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,2,['enhance'],['enhanced']
Modifiability,"n-pillow/Pillow/issues/5833"">#5833</a> [<a href=""https://github.com/hoodmane""><code>@​hoodmane</code></a>]</li>; <li>Add support for pickling TrueType fonts <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5826"">#5826</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Only prefer command line tools SDK on macOS over default MacOSX SDK <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5828"">#5828</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix compilation on 64-bit Termux <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5793"">#5793</a> [<a href=""https://github.com/landfillbaby""><code>@​landfillbaby</code></a>]</li>; <li>Replace 'setup.py sdist' with '-m build --sdist' <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5785"">#5785</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Use declarative package configuration <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5784"">#5784</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Use title for display in ImageShow <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5788"">#5788</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix for PyQt6 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5775"">#5775</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>9.0.0 (2022-01-02)</h2>; <ul>; <li>; <p>Restrict builtins for ImageMath.eval(). CVE-2022-22817 <a href=""https://github-redirect.dependabot.com/python-pill",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:9524,config,configuration,9524,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['config'],['configuration']
Modifiability,"n. qutip keeps configuration (e.g. for openmp) in a config file handled in configrc.py. The default location is in the home dir, with; https://github.com/qutip/qutip/blob/d2f1ed57d13bd35055d72f3f6b3418c962491bd9/qutip/configrc.py#L36; setting the dir to `~/.qutip` and; https://github.com/qutip/qutip/blob/d2f1ed57d13bd35055d72f3f6b3418c962491bd9/qutip/configrc.py#L38; setting the config file to `~/.qutip/qutiprc`. This forces Linux distributions to do more work when building in a chroot. For instance Debian build chroots set the ""home"" directory to `/nonexistent`, and then building docs fails with; ```; PermissionError: [Errno 13] Permission denied: '/nonexistent'; ```; since it can't create `/nonexistent/.qutip`. In practice that's not a great problem since when building docs for the package, we can set `HOME=$BUILDDIR` to place the config location in the build dir (which is writable) instead of `/nonexistent`. However there is a standardized location for config files which might be worth considering instead. The freedesktop.org specification at https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html identifies locations for config and data files. Config files can be located under (one of) `$XDG_CONFIG_DIRS` for system configuration, or under `$XDG_CONFIG_HOME` for user configuration. ### Code to Reproduce the Bug. _No response_. ### Code Output. _No response_. ### Expected Behaviour. In python XDG is accessible from the xdg package (in debian, the python3-xdg package). So the XDG equivalent of ; ```; qutip_conf_dir = os.path.join(os.path.expanduser(""~""), '.qutip'); ```; could be done with; ```; from xdg import XDG_CONFIG_HOME; ...; qutip_conf_dir = os.path.join(XDG_CONFIG_HOME, '.qutip'); ```; A more sophisticated method could be set up to also check XDG_CONFIG_DIRS instead (XDG_CONFIG_HOME is the first entry in the list defined in XDG_CONFIG_DIRS). ### Your Environment. ```shell; QuTiP Version: 4.7.0; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876:1182,config,config,1182,https://qutip.org,https://github.com/qutip/qutip/issues/1876,4,"['Config', 'config']","['Config', 'config', 'configuration']"
Modifiability,"n[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 572 except KeyError:; 573 continue; --> 574 self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts); 575 ; 576 # Return *all* object filenames, not just the ones we just built. /home/caidish1234/anaconda3/lib/python3.6/distutils/unixccompiler.py in _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts); 118 extra_postargs); 119 except DistutilsExecError as msg:; --> 120 raise CompileError(msg); 121 ; 122 def create_static_lib(self, objects, output_libname,. ImportError: Building module rhs82342421 failed: [""distutils.errors.CompileError: command 'gcc' failed with exit status 1\n""]; ```. So, I opened my server's log,it showed lots of:; `cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++ [enabled by default]`. And an e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697:4760,variab,variable,4760,https://qutip.org,https://github.com/qutip/qutip/issues/697,1,['variab'],['variable']
Modifiability,"nction based coefficient no longer cast to complex, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them o",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1515,variab,variable,1515,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability,"ne 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 246 in _main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 196 in wrap_session; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/main.py"", line 239 in pytest_cmdline_main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/config/__init__.py"", line 92 in main; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/testing.py"", line 45 in run; File ""<stdin>"", line 1 in <module>; Abort trap: 6; ```; This is in a conda environment with qutip development version with ; ```; Python 3.7.4 (default, Aug 13 2019, 15:17:50); [Clang 4.0.1 (tags/RELEASE_401/final)] :: Anaconda, Inc. on darwin; ```; and ; ```; QuTiP Version: 4.5.0.dev0+d13f5435; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: 3.1.1; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160:4293,config,config,4293,https://qutip.org,https://github.com/qutip/qutip/issues/1160,1,['config'],['config']
Modifiability,"nfo on general resources to learn about QuTiP and more; references to the #3 project, i.e. your blog and the talk.; https://github.com/qutip/qutip/wiki/Google-Summer-of-Code-2020. Neill, Alex, if you have a lead, please add a HEOM project. Bests,. Nathan. Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com. On Tue, Feb 25, 2020 at 5:10 PM Boxi Li <notifications@github.com> wrote:. > Hi Nathan,; >; > I can't modify the Wiki page because I'm not a maintainer of QuTiP. And it; > seems that there is no way to make a PR to Wiki. I can also send you the; > markdown source code per email like this, but I’m not sure if it works as I; > expected.; >; > The following is the markdown source code:; >; > -----------------------------------; > ## 1. Error mitigation in QuTiP; > From the QuTiP 4.5 release, the qutip.qip module now contains the noisy; > quantum circuit simulator (which was a GSoC project) providing enhanced; > features for a pulse-level description of quantum circuits and noise; > models. A new class `Processor` and several subclasses are added to; > represent different platforms for quantum computing. They can transfer a; > quantum circuit into the corresponding control sequence and simulate the; > dynamics with QuTiP solvers. Different noise models can be added to; > `qutip.qip.noise` to simulate noise in a quantum device.; >; > This module is still young and many features can be improved, including; > new device models, new noise models and integration with the existing; > general framework for quantum circuits (`qutip.qip.circuit`). There are; > also possible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:1095,enhance,enhanced,1095,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,2,['enhance'],['enhanced']
Modifiability,"ng=""--global-option=--with-openmp""; * Building wheel...; Traceback (most recent call last):; File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 363, in <module>; main(); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 345, in main; json_out['return_val'] = hook(**hook_input['kwargs']); File ""/usr/lib/python3/dist-packages/pep517/in_process/_in_process.py"", line 261, in build_wheel; return _build_backend().build_wheel(wheel_directory, config_settings,; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 230, in build_wheel; return self._build_with_temp_dir(['bdist_wheel'], '.whl',; File ""/usr/lib/python3/dist-packages/setuptools/build_meta.py"", line 211, in _build_with_temp_dir; sys.argv = (sys.argv[:1] + setup_command +; TypeError: can only concatenate list (not ""str"") to list. ERROR Backend subproccess exited when trying to invoke build_wheel; ```. The other method; ```; --config-setting=""--build-option=--with-openmp""; ```; appears to work in the sense that it builds successfully. But after installing the package it reports that openmp is still missing; ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.0; Numpy Version: 1.21.5; Scipy Version: 1.8.1; Cython Version: 0.29.30; Matplotlib Version: 3.5.2; Python Version: 3.10.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); I",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152:1177,config,config-setting,1177,https://qutip.org,https://github.com/qutip/qutip/issues/1875#issuecomment-1219841152,2,['config'],['config-setting']
Modifiability,"o a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Instead, I have a nested list like `[L0, [L1, control1], ...]` where `L0`, `L1`, ... are super-operators. I should also note that I use `mesolve` both for Schrödinger equations and Lindblad equations (relying on `mesolve` delegating to `sesolve`), and the Krotov package uses `H` as a variable/attribute name to refer to nested-Lindbladians or nested Hamiltonians interchangeable. Sorry if that's causing a bit of confusion. I am ultimately interested both in open system and closed system dynamics interchangeably. > [...] In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:2282,variab,variable,2282,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['variab'],['variable']
Modifiability,"ocesses to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularly effective for operations that can be divided into independent, smaller tasks.; - **Compatibility**: Ensured that the enhancements are backward-compatible with existing code by modifying only the internal execution strategy of the `correlation_2op_1t` function and by maintaining the original API signature.; - **Performance Considerations**: The parallel implementation can significantly reduce computation times, particularly for larger systems or longer `taulist` arrays, by leveraging multiple CPU cores concurrently. ### Conclusion. The enhancements to the `correlation_2op_1t` function in QuTiP are designed to harness the capabilities of modern multi-core processors, thereby improving the efficiency of quantum correlation computations. This is still a WIP enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:2517,enhance,enhancements,2517,https://qutip.org,https://github.com/qutip/qutip/pull/2395,3,['enhance'],"['enhancement', 'enhancements']"
Modifiability,"och sphere; see [here](https://user-images.githubusercontent.com/906390/232609935-a701d20f-aab0-43f8-bf27-7b7088517cf2.mp4). This issue appears to be fixed by modifying the line `ax = Axes3D(fig, azim=-40, elev=30)` in the example to `ax = fig.add_subplot(111, projection=""3d"", elev=30, azim=-40)`. ### Code to Reproduce the Bug. ```shell; import numpy as np; import qutip; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2156:1866,evolve,evolve,1866,https://qutip.org,https://github.com/qutip/qutip/issues/2156,1,['evolve'],['evolve']
Modifiability,"ocumentation of the data-layer isn't readily available yet (we weren't expecting interest this early!). It does individual detection on two different types, rather than creating a `Dispatcher` to handle the multiple dispatch over potentially different data types of the two inputs. I would imagine that a better form of organisation for this sort of routine, which will be able to handle arbitrary tensor-network operations, will end up being made up of two components:; 1. a `Dispatcher` version of something akin to `einsum`, with a couple of limitations; 2. a high-level wrapper function to handle the specific case of local multiplication, which examines the dimensions and target specifiers to produce the input to the `einsum`-like function, then calls the `Dispatcher` with this information. I think this form would likely be preferable for several reasons:; 1. it will allow arbitrary mixing of different data types (`CSR` complete space and `Dense` operator, or both `CSR`, or whatever), with the allowed conversions respecting the global dispatcher rules, not having this function use a different, special configuration; 2. it will mean that the function can also be implemented by plug-in data types (TF/CuPy/etc), installed separately to QuTiP; 3. it will be more general, and easier to maintain; the current `subsystem_apply`, `partial_transpose`, `ptrace`, `tensor_contract` and this can all become special cases of this backing `einsum`-like routine.; 4. after we've implemented new dimensions objects, we'll be able to use a more standardised description of how to refer to individual subspaces of a Hilbert space, which will provide a more consistent UX across the library. This is particularly important if we want this to work well with superoperators. Really, thank you very much for making the PR - I really am excited to see people with an interest in the new data layer! I'm sorry that I took quite so long to respond properly to it, and that when I have, I've ended up being so",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566:3376,config,configuration,3376,https://qutip.org,https://github.com/qutip/qutip/pull/1405#issuecomment-864073566,2,['config'],['configuration']
Modifiability,"olverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help windows users.; - Added a `reduce_func` input. Presently the map function is saving all re",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1749,evolve,evolvers,1749,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['evolve'],['evolvers']
Modifiability,"ommand python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File ""<frozen importlib._bootstrap>"", line 693, in _load; File ""<frozen importlib._bootstrap>"", line 673, in _load_unlocked; File ""<frozen impor",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:1121,config,configuration,1121,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['config'],['configuration']
Modifiability,"omplicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me kno",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1576,variab,variable,1576,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,2,['variab'],['variable']
Modifiability,"on.; Current admin team: Alexander Pitchford, Paul D. Nation, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, and Eric Giguère.; Project Manager: Franco Nori.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.5.0.dev0+d377c997; Numpy Version: 1.17.2; Scipy Version: 1.3.1; Cython Version: 0.29.13; Matplotlib Version: None; Python Version: 3.7.4; Number of CPUs: 2; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+; d377c997-py3.7-macosx-10.9-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; nose.plugins.cover: ERROR: Coverage not available: unable to import coverage module; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/lib/python3.7/site-packages/qutip-4.5.0.dev0+d377c997-py3.7-macos; x-10.9-x86_64.egg/qutip/__init__.py:161: UserWarning: matplotlib not found: Graphics will not work.; warnings.warn(""matplotlib not found: Graphics will not work.""); Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093:2027,plugin,plugins,2027,https://qutip.org,https://github.com/qutip/qutip/issues/1093,1,['plugin'],['plugins']
Modifiability,"or each stochastic collapse operator, but now it is also possible to do something more sophisticated, like in your milstein solver. I've edited your notebook so that it uses the standard (now modified) smesolve and your rhs functions for the milstein methods. http://nbviewer.ipython.org/6153688. Note that I still only use the rhs function for the contributions due to the stochastic collapse operators (both the deterministic and stochastic part), and it does not include the unitary part or the deterministic collapse operators (if those are given as well), so it is not quite what you suggested when proposing that the rhs should calculate \rho_{n+1}. Do you think this approach is reasonable, or do you see any problems with it?. Regarding your milstein implementation, it seems that it is only valid for homodyne detection, since your have hardcoded the d1 and d2 function into the rhs function. I've tried to separate the definition of the SDE (d1 and d2) from the implementation of the SDE integrator (rhs), and naively it seems like you could use the d1 and d2 functions in rhs_milstein to make it possible to use it with hetrodyne detection as well. Is there any difficulties in generalizing the milstein method and parameterize it in terms of d1 and d2 functions in this way?. I've also tried to use the smesolve_imp and smesolve_milstein with explicit=False in your original notebook, but I do not get resuls that agree with the other methods if I use these. Looking at the code for smesolve_imp, you do an inversion of some variant of the liouvillian to calculate Lsparse, what is the purpose of that calculation? And finally, I see you use expm in _smesolve_single_milstein_implicit: I think this should be avoided because it will be very computationally demanding for larger systems. If you are satisfied with how the new rhs functions work I'll merge the branch sme-rhs-restructuring into qutip master and then feel free to submit a pull request with your milstein rhs implementation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22088170:1998,parameteriz,parameterize,1998,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22088170,2,['parameteriz'],['parameterize']
Modifiability,"or::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5394,config,config,5394,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['config'],['config']
Modifiability,"ossible applications such as error mitigation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; >; > ### Expected outcomes; > - More devices defined in the `qutip.qip.device` module. At the moment, we; > have two models: spin chain and cavity QED. We would like to include some; > other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in `qutip.qip.device` and; > `qutip.qip.compiler`; > - Refactoring the circuit compiler to allow simple pulse scheduling, e.g.; > Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages or; > commonly used language e.g. through quantum assembly language (qasm); > ----------------------------------------------------------------; >; > Best; > Boxi; >; > From: Nathan Shammah<mailto:notifications@github.com>; > Sent: Tuesday, February 25, 2020 8:36 AM; > To: qutip/qutip<mailto:qutip@noreply.github.com>; > Cc: Boxi Li<mailto:etamin1201@gmail.com>; Author<mailto:; > author@noreply.github.com>; > Subject: Re: [qutip/qutip] More detailed information for GSoC 2020 project; > (#1184); >; > Hi Boxi,; >; > Can you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:2738,Refactor,Refactoring,2738,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['Refactor'],['Refactoring']
Modifiability,"p>; </li>; <li>; <p>Do not close provided file handles with libtiff <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7199"">#7199</a>; [radarhere]</p>; </li>; <li>; <p>Convert to HSV if mode is HSV in getcolor() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7226"">#7226</a>; [radarhere]</p>; </li>; <li>; <p>Added alpha_only argument to getbbox() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7123"">#7123</a>; [radarhere. hugovk]</p>; </li>; <li>; <p>Prioritise speed in <em>repr_png</em> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7242"">#7242</a>; [radarhere]</p>; </li>; <li>; <p>Do not use CFFI access by default on PyPy <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7236"">#7236</a>; [radarhere]</p>; </li>; <li>; <p>Limit size even if one dimension is zero in decompression bomb check <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7235"">#7235</a>; [radarhere]</p>; </li>; <li>; <p>Use --config-settings instead of deprecated --global-option <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7171"">#7171</a>; [radarhere]</p>; </li>; <li>; <p>Better C integer definitions <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6645"">#6645</a>; [Yay295, hugovk]</p>; </li>; <li>; <p>Fixed finding dependencies on Cygwin <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7175"">#7175</a>; [radarhere]</p>; </li>; <li>; <p>Changed grabclipboard() to use PNG instead of JPG compression on macOS <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7219"">#7219</a>; [abey79, radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/e34d346f10c0b1c814661e662a3e0c1ef084cf1c""><code>e34d346</code></a> Updated order</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/a62f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:10388,config,config-settings,10388,https://qutip.org,https://github.com/qutip/qutip/pull/2237,1,['config'],['config-settings']
Modifiability,"pe = oper, isherm = True; Qobj data =; [[ 0. -1. -1. 0. -1. 0. 0. 0.]; [-1. 0. 0. -1. 0. -1. 0. 0.]; [-1. 0. 0. -1. 0. 0. -1. 0.]; [ 0. -1. -1. 0. 0. 0. 0. -1.]; [-1. 0. 0. 0. 0. -1. -1. 0.]; [ 0. -1. 0. 0. -1. 0. 0. -1.]; [ 0. 0. -1. 0. -1. 0. 0. -1.]; [ 0. 0. 0. -1. 0. -1. -1. 0.]]; ```. For completeness, here is the class: ; ```; class bacon:; '''; n - number of qubits; spin_coeff - vertex coefficients, in order of the spin strength; '''; def __init__(self, n, spin_coeff = None, coupling_coeff = None):; self._n = int(n); self._spin_coeff = spin_coeff; self._coupling_coeff = coupling_coeff. pass. def __create_sigma_i(self, i, sigma = qt.sigmax()):; '''; creates a list to be inputted into tp; for a particular matrix; sigma - type of pauli matrix; '''; base = []; # create list of I2; for j in range(self._n):; base.append(qt.qeye(2)); # change ith component to sigmax; base[i] = sigma; sigma_i = qt.tensor(base); return sigma_i. def __create_sigmaz_ij(self,i,j):; '''; creates coupling hamiltonians for ; problem hamiltonian; '''; base = []; k = self._n; # create list of I2; for l in range(self._n):; base.append(qt.qeye(2)); base[i] = qt.sigmaz(); base[j] = qt.sigmaz(); sigmaz_ij = qt.tensor(base); return sigmaz_ij. def driver(self):; '''; creates drive Hamiltonian, which is the sum of -sigmax_i operators ; ; '''; k = self._n; Hd = np.zeros((2**k, 2**k)); Hd = qt.Qobj(Hd, dims=[[2 for i in range(k)],[2 for i in range(k)]]); for i in range(self._n):; sigmax_i = self.__create_sigma_i(i); Hd -= sigmax_i; return Hd. def problem(self):; '''; creates problem Hamiltonian. '''; # initialise Hp array; p = self._n # to save on writing; Hp = np.zeros((2**p, 2**p)); Hp = qt.Qobj(Hp, dims=[[2 for i in range(p)],[2 for i in range(p)]]). #vertex coefficients; if self._spin_coeff is None:; pass; else:; for i in range(self._n):; sigmaz_i = self.__create_sigma_i(i, sigma = qt.sigmaz()); Hp += self._spin_coeff[i] * sigmaz_i; #coupling coefficients; if self._coupling_coeff is None:; pass; el",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1989:3226,coupling,coupling,3226,https://qutip.org,https://github.com/qutip/qutip/issues/1989,1,['coupling'],['coupling']
Modifiability,"plotlib/backends/backend_tkagg.py"", line 540, in resize; self.canvas._tkcanvas.master.geometry(""%dx%d"" % (width, height)); File ""/Users/tilek/miniconda2/lib/python2.7/lib-tk/Tkinter.py"", line 1668, in wm_geometry; return self.tk.call('wm', 'geometry', self._w, newGeometry); _tkinter.TclError: can't invoke ""wm"" command: application has been destroyed; ```. When I try to execute the code from the User Guide as a complete .py Python file (see below) ; it produces first bloch_0.png file where it is supposed to, but then shows the same error.; ```; import numpy as np; from qutip import *; from scipy import *. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; print 'len(sx) is ', len(sx); for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/796:2397,evolve,evolve,2397,https://qutip.org,https://github.com/qutip/qutip/issues/796,1,['evolve'],['evolve']
Modifiability,"project” with reference to all software developed under the QuTiP Github organization, hosted at “[www.github.com/qutip](www.github.com/qutip)” and all related activities involving its community happening through its official channels. **<span style=""text-decoration:underline;"">The Community</span>**. QuTiP is at the center of a lively ecosystem and creative community. As of October 2020, QuTiP’s large community comprises over 80 code contributors and thousands of users that have downloaded the software over 300’000 times. QuTiP enables an infrastructure of other scientific libraries for the investigation of specific quantum physics or quantum information processing features. . There are several ways through which members of the wider QuTiP community can receive information on QuTiP. This is through any of its official channels: the Google forum; the qutip.org/news webpage tracking the releases on Github, and opening [Issues](https://github.com/qutip/qutip/issues) on Github to file bug reports or discuss and proposed enhancements. Users are encouraged to contribute bug fixes or enhancements to the project with [Pull Requests](https://github.com/qutip/qutip/pulls). **<span style=""text-decoration:underline;"">Governance</span>**. This governance document outlines the governance of the QuTiP project, in order to better serve the community and provide robust liveliness and sustained maintenance for the project. Changes to this document need to be approved by ¾ of the Admin Team. The contents of this QuTiP Governance are shown on QuTiP’s website (qutip.org/goverance) and in its documentation. The changes are tracked at github.com/qutip/governance. We view this governance model as the formalization of what we are already doing, rather than a change in direction. This document is composed of information regarding the following:. **1. Code of Conduct**. **2. Admin Team: Tasks, Composition, Decisions, Communications.**. **3. Board: Tasks, Composition, Decisions, Communications",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1373:5522,enhance,enhancements,5522,https://qutip.org,https://github.com/qutip/qutip/issues/1373,1,['enhance'],['enhancements']
Modifiability,"ps://qiskit.org/documentation/stubs/qiskit.quantum_info.average_gate_fidelity.html relating the average gate fidelity to the process fidelity, and https://qiskit.org/documentation/stubs/qiskit.quantum_info.process_fidelity.html#qiskit.quantum_info.process_fidelity to compute that from a superoperator. I think it would be better to use that direct formula if the input is not already in Kraus form!. There is also a function `process_fidelity` in Qutip, but I'm having a hard time understanding what it's intended for. It doesn't seem to be the process fidelity explained in the Qiskit docs above. The arguments of Qutip's `process_fidelity` are called `U1` and `U2` suggesting they are expected to be unitary, but this is not checked. It is computed as `(U1 * U2).tr()`, which is not between 0 and 1, and doesn't give 1 as I'd expect if `U1==U2`. Does someone know the intended use of that function? If not, I'd implement the process fidelity as described in the Qiskit docs here, with several version depending on whether the input is Kraus, a superoperator, and maybe a chi matrix. Lastly, there is an issue with the tests - the lines; ```; class Test_dnorm:; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since it; # depends on them.; cvxpy = pytest.importorskip(""cvxpy""); cvxopt = pytest.importorskip(""cvxopt""); ```; actually skip all the tests in the file if cvxpy is not available, not just the ones in the `Test_dnorm` class. The test output, if `cvxpy` is not installed, is; ```; $ pytest qutip/tests/test_metrics.py ; ============================= test session starts ==============================; platform linux -- Python 3.9.7, pytest-6.2.4, py-1.10.0, pluggy-0.13.1; rootdir: /home/florian/code/qutip/qutip/qutip/tests, configfile: pytest.ini; plugins: rerunfailures-10.1; collected 0 items / 1 skipped ; ```; That issue seems to be addressed on the dev.major branch. Would it make sense to take the test file from there and use it in the master branch also?. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1703:2262,config,configfile,2262,https://qutip.org,https://github.com/qutip/qutip/issues/1703,2,"['config', 'plugin']","['configfile', 'plugins']"
Modifiability,"ps://redirect.github.com/python-pillow/Pillow/issues/7497"">#7497</a>; [ZachNagengast, nulano, radarhere]</p>; </li>; <li>; <p>Attempt memory mapping when tile args is a string <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7565"">#7565</a>; [radarhere]</p>; </li>; <li>; <p>Fill identical pixels with transparency in subsequent frames when saving GIF <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7568"">#7568</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/6956d0b2853f5c7ec5f6ec4c60725c5a7ee73aeb""><code>6956d0b</code></a> 10.2.0 version bump</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/31c8dacdc727673e9099f1ac86019714cdccec67""><code>31c8dac</code></a> Merge pull request <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7675"">#7675</a> from python-pillow/pre-commit-ci-update-config</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/40a3f91af2c78870676a13629b5902bab4ab4cf0""><code>40a3f91</code></a> Merge pull request <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7674"">#7674</a> from nulano/url-example</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/cb41b0cc78eeefbd9ed2ce8c10f8d6d4c405a706""><code>cb41b0c</code></a> [pre-commit.ci] pre-commit autoupdate</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/de62b25ed318f1604aa4ccd6f942a04c6b2c8b59""><code>de62b25</code></a> fix image url in &quot;Reading from URL&quot; example</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/7c526a6c6bdc7cb947f0aee1d1ee17c266ff6c61""><code>7c526a6</code></a> Update CHANGES.rst [ci skip]</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/d93a5ad70bf94dbb63bdbfb19491a02976574d6d""><code>d93a5ad</code></a> Merge pull request <a href=""https://redirect.github.com/pyth",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:13358,config,config,13358,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['config'],['config']
Modifiability,"pt/homebrew/Caskroom/miniforge/base/envs/qutip_test/lib; libraries f77blas,cblas,atlas not found in /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/lib; libraries lapack_atlas not found in /usr/local/lib; libraries f77blas,cblas,atlas not found in /usr/local/lib; libraries lapack_atlas not found in /usr/lib; libraries f77blas,cblas,atlas not found in /usr/lib; <class 'numpy.distutils.system_info.atlas_info'>; NOT AVAILABLE; ; FOUND:; extra_compile_args = ['-faltivec', '-I/System/Library/Frameworks/vecLib.framework/Headers']; extra_link_args = ['-Wl,-framework', '-Wl,Accelerate']; define_macros = [('NO_ATLAS_INFO', 3), ('HAVE_CBLAS', None)]; ; /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/lib/python3.9/distutils/dist.py:274: UserWarning: Unknown distribution option: 'define_macros'; warnings.warn(msg); running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building library ""npymath"" sources; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/npymath' to include_dirs.; None - nothing done with h_files = ['build/src.macosx-11.0-arm64-3.9/numpy/core/src/npymath/npy_math_internal.h']; building library ""npysort"" sources; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/common' to include_dirs.; None - nothing done with h_files = ['build/src.macosx-11.0-arm64-3.9/numpy/core/src/common/npy_sort.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/common/npy_partition.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/common/npy_binsearch.h']; building library ""npyrandom"" sources; building extension ""numpy.core._multiarray_tests"" sources; building extension ""numpy.core._multiarray_umath"" sources; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath' to include_dirs.; adding 'build/src.macosx-11.0-arm",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:8590,config,config,8590,https://qutip.org,https://github.com/qutip/qutip/issues/1740,2,['config'],['config']
Modifiability,"py/core/src/common/npy_binsearch.h']; building library ""npyrandom"" sources; building extension ""numpy.core._multiarray_tests"" sources; building extension ""numpy.core._multiarray_umath"" sources; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath' to include_dirs.; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/npymath' to include_dirs.; adding 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/common' to include_dirs.; numpy.core - nothing done with h_files = ['build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath/funcs.inc', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath/simd.inc', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath/loops.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath/matmul.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/umath/clip.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/npymath/npy_math_internal.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/src/common/templ_common.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/include/numpy/config.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/include/numpy/_numpyconfig.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/include/numpy/__multiarray_api.h', 'build/src.macosx-11.0-arm64-3.9/numpy/core/include/numpy/__ufunc_api.h']; building extension ""numpy.core._umath_tests"" sources; building extension ""numpy.core._rational_tests"" sources; building extension ""numpy.core._struct_ufunc_tests"" sources; building extension ""numpy.core._operand_flag_tests"" sources; building extension ""numpy.fft._pocketfft_internal"" sources; building extension ""numpy.linalg.lapack_lite"" sources; building extension ""numpy.linalg._umath_linalg"" sources; building extension ""numpy.random._mt19937"" sources; building extension ""numpy.random._philox"" sources; building extension ""numpy.random._pcg64"" sources; building extension ""numpy.random._sfc64"" sources; building extension ""numpy.random._common"" sources; building extension ""numpy.random.bit_generator"" sources; building extension ""numpy.random._",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:10393,config,config,10393,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['config'],['config']
Modifiability,quantum circuits inherit user gates from `add_circuit`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1871:17,inherit,inherit,17,https://qutip.org,https://github.com/qutip/qutip/pull/1871,1,['inherit'],['inherit']
Modifiability,"quick note; we are still trying to decide about a few things, e.g., what to do about the units, i.e., whether to make hbar and boltzmann constant user definable parameters, or rescale the coupling and the cut-off frequency of the bath in a more sensible way to take them into account. I guess the latter is the 'more sensible' option, but will need to do it carefully.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/341#issuecomment-112662390:188,coupling,coupling,188,https://qutip.org,https://github.com/qutip/qutip/pull/341#issuecomment-112662390,1,['coupling'],['coupling']
Modifiability,"r a bit more context. Qutip currently contains in the HEOM module ""BosonicBath / FermionicBath"" classes that describe a bath with a multi-exponential decomposition of the correlation function. This new environment module is supposed to be a more general framework to characterize thermal environments. Environments with multi-exponential decompositions are included as `ExponentialBosonicEnvironment`; this class is supposed to mostly replace the old HEOM `BosonicBath`. We now use the term ""environment"" instead of ""bath"" mostly to avoid having the same name for the new classes as in the HEOM module. There is a little difference between the old and the new class, namely that the system coupling operator is a part of BosonicBath (i.e., an attribute of BosonicBath and required in the constructor), but we have decided for the new module that system operators should not be part of the environment. This means that to create a HEOM solver, one will need to specify environments and coupling operators, somewhat similar to the `brmesolve` solver where one specifies both power spectrum and `a_op`. (Currently, one just specifies a list of ""baths"" in the HEOM solver). This will require some small changes to the HEOM solver interface that we still have to implement before merging this PR. Note that we are also making sure that existing code continues to work without changes. Another thing missing from this PR are fermionic environments. I would have liked to have them, but it was becoming too much work and a too large PR, so fermionic environments will have to be added a bit later. Some more advantage of our changes are:; * The new environment classes could be used directly as inputs for solvers other than the HEOM solver, for example for `mesolve` or `brmesolve`. These solvers could compute their jump operators and rates from the environment power spectrum and system operators. (That is however also left for a future PR, since it would require some thinking about how environments ca",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525:1032,coupling,coupling,1032,https://qutip.org,https://github.com/qutip/qutip/pull/2534#issuecomment-2359719525,1,['coupling'],['coupling']
Modifiability,"r the qutip directory. Which; > gave me the following log:; >; > `running bdist_wheel; > running build; > running config_cc; > unifing config_cc, config, build_clib, build_ext, build commands; > --compiler options; > running config_fc; > unifing config_fc, config, build_clib, build_ext, build commands; > --fcompiler options; > running build_src; > build_src; > building py_modules sources; > building extension ""qutip.cy.spmatfuncs"" sources; > building extension ""qutip.cy.stochastic"" sources; > building extension ""qutip.cy.sparse_utils"" sources; > building extension ""qutip.cy.graph_utils"" sources; > building extension ""qutip.cy.interpolate"" sources; > building extension ""qutip.cy.spmath"" sources; > building extension ""qutip.cy.heom"" sources; > building extension ""qutip.cy.math"" sources; > building extension ""qutip.cy.spconvert"" sources; > building extension ""qutip.cy.ptrace"" sources; > building extension ""qutip.control.cy_grape"" sources; > building data_files sources; > build_src: building npy-pkg config files; > running build_py; > copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; > copying build/src.linux-x86_64-3.5/qutip/*config*.py ->; > build/lib.linux-x86_64-3.5/qutip; > running build_ext; > customize UnixCCompiler; > customize UnixCCompiler using build_ext; > building 'qutip.cy.spmatfuncs' extension; > compiling C sources; > C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall; > -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2; > -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer; > -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions; > -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error; > -Wp,-D_REENTRANT -fPIC; >; > compile options:; > '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include ; >; > -I/h",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639#issuecomment-275734243:4043,config,config,4043,https://qutip.org,https://github.com/qutip/qutip/issues/639#issuecomment-275734243,1,['config'],['config']
Modifiability,"r.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback function. So now it is as before but in addition `result.expect[3]` contains energy and `result.expect[4]` contains fidelity and no custom managed global external lists required as it was in the [example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe alternatives you've considered**. Alternatively we could establish that custom measurement callback function must return only single value and user would be able to pass mixed list of operators and functions in the `e_ops`. **Additional context**. Correct me if I'm wrong, based on the docs and examples I referenced above I have impression there is no better way to do it, but maybe I just missed it? Please regard this issue as opening a discussion, I'll be happy to participate and of course, implement the changes I suggest.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1238:2444,Evolve,Evolve-the-system-in-time,2444,https://qutip.org,https://github.com/qutip/qutip/issues/1238,1,['Evolve'],['Evolve-the-system-in-time']
Modifiability,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2834,variab,variables,2834,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,2,['variab'],['variables']
Modifiability,"re `f(t, args) -> Qobj`, similarly to the Hamiltonian. This is not the case, and as best as I can tell, has never been the case. Basic reproduction (though the functionality is just completely missing, so this won't ever succeed).; ```python; import qutip; def c_ops(t, args):; return qutip.create(3); qutip.mesolve(qutip.num(3), qutip.basis(3, 1).proj(), [0, 1], c_ops); ```. ## History. - @jrjohansson originally wrote the docstring saying that `c_ops` could be a callback function in 2012 (pre-QuTiP 1.1.4) in commit 1bf006d4, although the code did not support it at this time; - in issue #40 (2013), he commented that this functionality should be implemented, and this issue was closed without further action in 2018.; - in issue #223 (2014) there is some further discussion, but nothing is done until @Ericgig closes it in 2019, saying it is addressed by QuTiP 4.4.0 (the big swap to QobjEvo), but this doesn't appear to be the case. As of tag `v4.4.0`, the code does not support it. The failing line of code would be https://github.com/qutip/qutip/blob/fc9d9915d0f6242587828ce716ff3cd444edf82a/qutip/mesolve.py#L227-L236; as a function type is truth-y but has no length, but the underlying problem is more just that there's no support for it at all - there's no check for `callable(c_ops)`. At the current `master` at the time of writing (QuTiP ~4.5.1, 4102b99), we're in the same place as at tag `v4.4.0`. ## Solution. In previous issues, people have been told to rewrite the Liouvillian in the supported form, however that's not reasonably possible here. Technically it can be well-approximated by using an interpolation for each individual matrix element, as the time-dependent Hamiltonian can be solved ahead of time, but that's not at all sensible. Most pressingly, the documentation is currently wrong and should be changed to reflect reality. Secondly, we have to decide whether we're going to implement this functionality at all, perhaps as a part of @Ericgig's refactor of the solvers?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260:1905,rewrite,rewrite,1905,https://qutip.org,https://github.com/qutip/qutip/issues/1260,2,"['refactor', 'rewrite']","['refactor', 'rewrite']"
Modifiability,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3580,evolve,evolved,3580,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,2,['evolve'],['evolved']
Modifiability,refactor process_fidelity using new function _hilbert_space_dims,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1748:0,refactor,refactor,0,https://qutip.org,https://github.com/qutip/qutip/pull/1748,1,['refactor'],['refactor']
Modifiability,"remove settings.qutip_graphics flag and conditional imports of matplotlib based on DISPLAY variable, to allow head-less generation of graphics. if matpotlib is unavailable, a warning is given, but no failures until a function that actually uses matplotlib is called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/235:91,variab,variable,91,https://qutip.org,https://github.com/qutip/qutip/pull/235,1,['variab'],['variable']
Modifiability,"rence between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. I would absolutely not expect you to modifying how `mesolve` works directly. In fact, I would strongly recommend leaving the `mesolve` interface unchanged. The internal refactoring is all I'm after here. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462:. > I also note that I'm not replying to the thread I thought I was - I thought I was in `krotov`! For my response to the discussion points:. Yeah, sorry the discussion got a little confused between what I was suggesting in https://github.com/qucontrol/krotov/issues/93 for myself to try out (adding a `yield` to `mesolve` as a dirty hack) and the discussion here about how to address the underlying use case properly in QuTiP itself. So just to be clear: Do *not* add a `yield` to the existing `mesolve` function in QuTiP! I would strongly recommend keeping the existing interface for `mesolve` and just refactor what is going on in the backend to enable single-time-step propagation with as little overhead as possible. > * I think the function `qutip.mesolve` shouldn't change interface at all for 5.0 - we can change its backend, but I think it'll be a huge hindrance to adoption of 5.0 if",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:10192,refactor,refactoring,10192,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['refactor'],['refactoring']
Modifiability,"respect users environment variables, if set",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/87:26,variab,variables,26,https://qutip.org,https://github.com/qutip/qutip/pull/87,1,['variab'],['variables']
Modifiability,"ress between time in `tlist` and take a snapshot of the state at these time. The work of this loop have been moved to 2 classes: `Result` and `Evolver`. . `Result` was previously just a container of the solver output. It now does the snapshot: compute the expectation values, save the state, compute trajectories average, etc. . `Evolver` is qutip's ODE solver interface: the states are `Data` object and the function is `QovjEvo`(or `QobjEvoFunc`). There are multiple type of evolver wrapping different scipy's ode solver and a few of our own. The wrapper around scipy's zvode that was previously used in qutip's is `EvolverScipyZvode`, but we now have our own cython solver based on [Verner's method](http://people.math.sfu.ca/~jverner/) that accept any Data type as state. Different evolver based on different ODE method are interchangeable and have their dispatcher `evolver_collection`, allowing to easily add new methods. . With this, time-dependent system are managed by `QobjEvo`, ODE by `Evolver`, therefore the solvers can concentrate more closely on the physic. **Evolver:**; Method supported with this PR: `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Ad",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:1106,Evolve,Evolver,1106,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['Evolve'],['Evolver']
Modifiability,"rtionError Traceback (most recent call last); Input In [11], in <cell line: 6>(); 2 return w * np.exp(-w); 4 out = brmesolve(sigmax(), psi0=basis(2,0), tlist=np.arange(0, 1, 0.01), a_ops=[[sigmax(), psd]]); ----> 6 assert len(out.states) == len(out.times), f'{len(out.states)} vs {len(out.times)}'. AssertionError: 10 vs 100; ```. ### Expected Behaviour. As we see, the above code does run and produces an output, but the states list is not the same as the times lists (these should be the same length as they have a 1-1 correspondence). It actually appears it has only given data for the first 10 time-steps in this case.; The same code works fine on Intel chip. ; We can increase the `nsteps` parameter to give the correct number of output states, but they do not agree with Intels output (also see below for related issue), and actually are not always even quantum states, so something in the solver went wrong. Another example, using the cython string formatting:. ```brmesolve([[sigmax(), 'cos(t)']], psi0=basis(2,0), tlist=np.arange(0, 1, 0.01), a_ops=[[sigmax(), '1']])``` works fine on Intel, but gives error ```Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.``` on M1. . Moreover, if I do increase the `nsteps` sufficiently, this does appear to run correctly, but the output states are not the same as we get on Intel (and so I assume are incorrect). ### Your Environment. ```shell; QuTiP Version: 4.7.0; Numpy Version: 1.21.6; Scipy Version: 1.7.3; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.9.13; Number of CPUs: 10; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); ```. ### Additional Context. A few random observations, hopefully not just an issue on my side due to my local configurations. I installed qutip via conda, and it generally seems to work fine on M1. In the meantime, everything runs as expected with Rosetta.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1965:2503,config,configurations,2503,https://qutip.org,https://github.com/qutip/qutip/issues/1965,1,['config'],['configurations']
Modifiability,"rue)); ---------------------------------------------------------------------------; NameError Traceback (most recent call last); Cell In[5], line 1; ----> 1 coeff = qutip.coefficient(""sin(t)"", compile_opt=qutip.CompilationOptions(use_cython=True)). File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:170, in coefficient(base, tlist, args, args_ctypes, order, compile_opt, function_style, boundary_conditions, **kwargs); 168 for type_ in coefficient_builders:; 169 if isinstance(base, type_):; --> 170 return coefficient_builders[type_](base, **kwargs); 172 if callable(base):; 173 op = FunctionCoefficient(base, args.copy(), style=function_style). File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:388, in coeff_from_str(base, args, args_ctypes, compile_opt, **_); 385 code = make_cy_code(parsed, variables, constants,; 386 raw, compile_opt); 387 try:; --> 388 coeff = compile_code(code, file_name, parsed, compile_opt); 389 except PermissionError:; 390 pass. File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:528, in compile_code(code, file_name, parsed, c_opt); 524 os.chdir(qset.coeffroot); 525 # Files with the same name, but differents extension than the pyx file, are; 526 # erased during cythonization process, breaking filelock.; 527 # Adding a prefix make them safe to use.; --> 528 lock = filelock.FileLock(""compile_lock_"" + file_name + "".lock""); 529 try:; 530 lock.acquire(timeout=0). NameError: name 'filelock' is not defined; ```. However, I would expect it to be rare that users call `qutip.coefficient` directly including compilation options. The only indication that something might be wrong then comes from two failing tests, but it is very hard to deduce the actual problem from the pytest output:. ```shell; $ pytest --di",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2162:2260,variab,variables,2260,https://qutip.org,https://github.com/qutip/qutip/issues/2162,1,['variab'],['variables']
Modifiability,"rules; 3. we treat multiplication as matrix multiplication, violating how `np.multiply` should behave. My main concern is point 1: I don't think that `Qobj` provides a similar object to an `ndarray` at all. Right now we _do_ use matrices underneath, but proposed additions to QuTiP such as symbolic `Qobj` and adaptive Hilbert spaces are compatible with the idea of ""abstract linear algebra objects"", but do not necessarily have a backing array. Point 2 is mostly an extension of that: I'm not sure there is a sensible way for numpy's broadcasting rules to be applied to quantum objects as they exist now, even without extensions. ## More control over dispatch: `__array_ufunc__` and `__array_function__`. See [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html), [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html) and [NEP 35](https://numpy.org/neps/nep-0035-array-creation-dispatch-with-array-function.html). Later versions of numpy allowed greater control over how ufuncs get implemented, which was most recently extended in 1.16 to cover non-ufuncs like `tensordot`. These functions are intended for classes to define how ufuncs operate on their data, but implementors should still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (mostly elementwise operations or reductions). Several libraries implement only these, but _not_ `__array__`, but given my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:5574,extend,extended,5574,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['extend'],['extended']
Modifiability,"s relatively new, so by default pybuild uses setup.py if it is available. pybuild will use PEP517 instead, if the pybuild-plugin-pyproject package is installed and pyproject.toml is available. Without pybuild-plugin-pyproject installed, the Debian build was invoking; ```; /usr/bin/python3.10 setup.py build --with-openmp; ```; using setup.py and specifying `--with-openmp`. A successful build log for this method can be found at https://buildd.debian.org/status/fetch.php?pkg=qutip&arch=amd64&ver=4.6.2-3&stamp=1641397514&raw=0. With pybuild-plugin-pyproject installed, the Debian build invokes a wheel build (command line given below). But `--with-openmp` causes the build to fail. ### Code to Reproduce the Bug. ```shell; python3.10 -m build --skip-dependency-check --no-isolation --wheel --outdir /build/qutip/.pybuild/cpython3_3.10_qutip --with-openmp; ```. ### Code Output. ```shell; usage: python -m build [-h] [--version] [--sdist] [--wheel] [--outdir OUTDIR] [--skip-dependency-check] [--no-isolation] [--config-setting CONFIG_SETTING] [srcdir]; python -m build: error: unrecognized arguments: --with-openmp; ```. ### Expected Behaviour. The PEP517 build should be able to be configured to support openmp. ### Your Environment. ```shell; QuTiP Version: 4.6.2 (trying to build 4.7.0); Numpy Version: 1.21.5; Scipy Version: 1.8.0; Cython Version: 0.29.28; Matplotlib Version: 3.5.1; Python Version: 3.10.4; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: True (from setup.py build, not PEP517 build); INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ```. ### Additional Context. PEP517 support is new for Debian. It is possible the pybuild build tool needs to be adapted to handle setup.py options like `--with-openmp` in the context of PEP517. But I've tried to pose the issue here in terms of the underlying python3 build commands without needing to consider pybuild as such. Is there a different way in which `--with-ope",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1875:1517,config,config-setting,1517,https://qutip.org,https://github.com/qutip/qutip/issues/1875,1,['config'],['config-setting']
Modifiability,"s tests on all platforms. They pass for all besides Mac OS (similar error as for other PR). With `python setup.py install`, with `install` instead of `develop`, things seem to work. What it is unclear to me is why it reads that the QuTiP Version is `4.4.0.dev0+1a639d7a`, when I could not find this hash in here (or maybe I am confused). Now, after some tries with install and develop, I am on that version of qutip-dev. . To begin with, I am running the contents of the [development notebooks](https://github.com/qutip/qutip-notebooks/tree/master/development). Some comments below are relevant to the PR of the notebooks, https://github.com/qutip/qutip-notebooks/pull/71. * `development-qobjevo.ipynb`: Runs fine. ; * `development-qobjevo-adv.ipynb`: Runs fine. ; * `development-qobjevo-timing.ipynb`: Runs fine. * The notebook [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb) could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:984,adapt,adapted,984,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,2,['adapt'],['adapted']
Modifiability,"s to suppress the local identifier on the version information, replacing the old `ISRELEASED` boolean flag in the code. ### Notes on the wheels. Currently I build only for CPython. I haven't tried to build pypy wheels, but we _may_ support it - Cython does in theory, but I think complex numbers and raw pointers aren't handled completely smoothly, and we make heavy use of both. We get `manylinux1` builds for Linux, which is the oldest `manylinux` spec. This can be updated in the future, but I'm not sure I see a need; all our heavy mathematical lifting is either done by custom code (which is mostly immune) or BLAS/LAPACK (which we link to dynamically), so I don't think there's much to be gained. I don't know if the macOS images will run on the new M1 chips, but if not, there's not much that can be done there until GitHub Actions adds the necessary cross-compilation headers and libraries to their CI. ### Examples. You can see the result of this upload on the testing PyPI server: https://test.pypi.org/project/qutip-jakelishman (version 5.0.0a1 failed to upload due to previous testing, and 5.0.0a2 has a broken OpenMP configuration so won't run). I ran the CI action from my fork, with a temporary commit that changed the server to the testing archive (and the package name). Here's a screenshot of what the deployment screen will look like:. <img width=""1440"" alt=""GitHub Actions screen when triggering the build and deploy action"" src=""https://user-images.githubusercontent.com/5968590/106396051-8e49a980-63fd-11eb-867d-48a5ff2527f9.png"">. ### Further action needed. The GitHub Action won't become available until this is merged, _and_ `dev.major` is merged into `master`. This is because GitHub only makes workflows on the default branch available. ~We also need to generate a PyPI secret token with write access to the `qutip` package, and add it to the qutip/qutip repository secrets with the name `PYPI_TOKEN` (as defined in `.github/workflows/build.yml`).~ *edit: Done 2021-02-15.*",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1429:3868,config,configuration,3868,https://qutip.org,https://github.com/qutip/qutip/pull/1429,1,['config'],['configuration']
Modifiability,"s_method.html#time-discretization). The single-step-`mesolve` would be for the ""(2) forward-propagation with updated control"" in the bottom of the diagram: After each propagation time step, we calculate a new control value based on the current propagated state and other information (the ∂H/∂ϵ and stored backward-propagated states χ). The new control value is then used for the next time step. I'd also add that `mesolve` ideally should be ""thread-safe"" in the sense that we may have multiple `mesolve` run in parallel (index k in the diagram, where all the different k contribute to the update of the control values at the next time step), within whatever parallelization framework Python makes available. I vaguely remember looking at some Runge-Kutta implementations within scipy where this was a problem. I noted this in the docstring of krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162), which was an attempt to adapt some of `mesolve`'s inner workings to Krotov's needs. It turned out the overhead was still too large for this work very well, cf. the large runtime of the [corresponding example](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). To get very technical, Krotov's requirements are laid out in the documentation of the [`Propagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:3243,adapt,adapt,3243,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,2,['adapt'],['adapt']
Modifiability,"setup.cfg is configured with; ```; setup_requires =; numpy>=1.16.6,<1.20; ```; This means that qutip cannot (easily) be built when numpy 1.20 or higher is installed. The current stable release of numpy is 1.21. Can qutip be updated to run with current versions of numpy?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1720:13,config,configured,13,https://qutip.org,https://github.com/qutip/qutip/issues/1720,1,['config'],['configured']
Modifiability,"sistency PR #1611 was trying to solve but this time `data.mul` will handle it and will raise NotImplemented whenever required. . - `mul_dense` and `mul_csr`:; - Use a thin wrapper that returns `NotImplemeneted` if input is not a complex python scalar. There are a few things I would like to discuss before opening a PR:; 1) These changes will break backwards compatibility as:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # With the changes this also returns NotImplemented.; matrix * qobj # With the changes this also returns NotImplemented; ```; will now behave consistently (""fixes"" PR #1611). Is this acceptable? I would say yes given that we are doing a major version change. However, it may be a good idea to start raising a deprecation warning in QuTiP 4 if these changes go forward. 2) `data.add` has a similar behaviour to `data.mul` in that it accepts `scale` which is not a `Data` (there are a few more specialisations that also accept an argument that is not a `Data`). Should these specialisations behave in the same way allowing arbitrary python objects as ""scale"" and raise NotImplemented when required or should they just allow a complex python scalar? At this moment, `qutip.data.add(dense, dense, np.array(10)` and and `qutip.data.add(dense, dense, tf.constant(10))` works just fine. I guess they work due to the `__complex__` method they implement. Furthermore `qutip.data.add(TfTensor, TfTensor, tf.Variable(10))` also works _and_ can be differentiated. I wonder this is intended behaviour. Supporting this behaviour would be desirable for qutip-tensoflow as functions that create a Qobj as a function of a scalar (such as `alpha` for `displace(N, alpha)` or `z` for `squeezing(a1, a2, z)`) could work with `tf.Variable ` instead if they do not assume at any moment that `alpha` and `z` are python scalars. This could be a huge bonus point for `qutip-tensorflow` or any other library (Jax or Pytorch) that implements auto differentiation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473:2264,Variab,Variable,2264,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-883317473,2,['Variab'],['Variable']
Modifiability,"site may help for future reference. On Wed, 13 May 2020 at 23:38, Eric Giguère <notifications@github.com> wrote:. > I did some tests and; > 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian; > matrices) (c's version Ok); > 2 - It happen when installing the scipy stack with pip but not when; > installing it with conda.; > 3 - It depend on the problem size, 64 seems particularly bad, usually it; > fails on the second call.; > 4 - I only got it in zheevr which is only used in brmesolve. But Nathan; > got it in other tests which use scipy's eigh.; > 4 - It happen in scipy in the fortan version of lapack:; >; > import numpy as np; > from scipy.linalg import eigh; > H = random_hermitian(64); > eigh(H) # Work fine; > eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; >; > Possible solutions (for zheevr):; >; > - Installing scipy with conda, the easiest solution, but not in our; > control.; > - Finding a way to link clapack from cython. Linking scipy's one would; > require good knowledge of scipy internals since only one cython interface; > is provided. Linking to another installation of lapack, but it would; > require the user to install lapack or install it with qutip. Both seems; > wrong to me.; > - For mac user, call scipy's eigh from cython i zheevr, slower but; > better than risking segfault.; > - Have the code directly in qutip. We can adapt it from OpenBlas:; > https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1197#issuecomment-628259492>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67AJF3WTZBCU4YWFY23RRMHMHANCNFSM4LCKXE6A>; > .; >; -- ; Dr. Nathan Shammah; Postdoctoral Research Scientist; Theoretical Quantum Physics Laboratory; RIKEN, Wako, Saitama, Japan; www.nathanshammah.com",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264:1662,adapt,adapt,1662,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628441264,1,['adapt'],['adapt']
Modifiability,"sks, then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Ignored | Always completes all tasks anyway, see below. **New behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | Aborts currently running tasks, <br> then returns results of all finished tasks.; CTRL+C | First CTRL+C raises `KeyboardInterrupt` | First CTRL+C raises `KeyboardInterrupt`; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes tasks earlier in the list, then <br> aborts remaining ones and raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Removed from documentation | Removed from documentation. **Job timeout**. Currently, the job timeout parameter is ignored by parallel_map. In loky_pmap, it is not the maximum allowed time for one job, but the maximum time between two job finishes (possibly in different processes). If this time is exceeded, all tasks will still be executed until the end; only the results of the tasks that finished too slowly will be discarded. I do not think that this was the intention of the job timeout parameter?. Unfortunately, both `ProcessPoolExecutor` (which parallel_map is based on) and its loky version do not support timeouts for single tasks, nor do they support aborting single tasks manually. (The loky one supports killing *all* worker processes at once.) If we wanted to have a job timeout parameter, we would need to either use non-public API to obtain references to the worker processes and interrupt them manually, or to completely rewrite parallel_map and base it on e.g. `multiprocessing.pool.Pool`. Maybe better to just remove the job_timeout parameter? If you agree with that, I will then also remove it from the available options for `MultiTrajSolver` and all its subclasses.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2280:2985,rewrite,rewrite,2985,https://qutip.org,https://github.com/qutip/qutip/pull/2280,1,['rewrite'],['rewrite']
Modifiability,"ssing list of observables in the `e_ops` argument of `mesolve` or `sesolve`, a list of expectation values at each time step of all those operators will be provided in returned `qutip.Result` object. It becomes much less elegant once we implement custom measurements and pass a callback function (for example to work with time-dependent Hamiltonians etc). According to the [documentation](http://qutip.org/docs/4.1/apidoc/functions.html#module-qutip.mesolve). > An instance of the class qutip.Result, which contains either an array result.expect of expectation values for the times specified by tlist, (...), or nothing if a callback function was given in place of operators for which to calculate the expectation values. So to work with callback function, we need to manage the storage by ourselves, for example by defining a global list, as it is done in [this example](https://nbviewer.jupyter.org/github/jrjohansson/qutip-lectures/blob/master/Lecture-8-Adiabatic-quantum-computing.ipynb#Evolve-the-system-in-time). **Describe the solution you'd like**. Currently when we pass a list of operators such as. ```python; e_ops = [sigmax(), sigmay(), sigmaz()]; result = mesolve(H, rho0, e_ops=e_ops); ```. We will be able to access expectation value of `sigmax()` in `result.expect[0]`, of `sigmay()` in `result.expect[1]` and of course `sigmaz()` in `result.expect[2]`. Why not capture the custom measurement in similar way?. ```; def customMeasurement(tau, psi):; exp_x = expect(sigmax(), psi); exp_y = expect(sigmaz(), psi); exp_z = expect(sigmay(), psi); energy = expect(H, psi); fidelity = np.abs(psi_ref.overlap(psi))**2.; return [exp_x, exp_y, exp_z, energy, fidelity]; ```. Now it is possible to still get expectation values as before, but in addition we can take more custom measurements (in this example energy and fidelity of state) and access them in exactly the same way for the convenience. The only thing user needs to keep track of is order of operators returned from the callback functi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1238:1115,Evolve,Evolve-the-system-in-time,1115,https://qutip.org,https://github.com/qutip/qutip/issues/1238,1,['Evolve'],['Evolve-the-system-in-time']
Modifiability,"started looking into QuTiP only very recently, and I'm yet to start familiarising myself with its more intricate details and get to run the full set of tests, and investigate what kind of test failures occur. In the meantime, I'll generally share some (what I _think_ is) relevant experience in the context of handling randomness in tests:; - My understanding is that we're talking about not testing the behaviour of random-number generations per se, but how the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another con",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:1582,coupling,coupling,1582,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['coupling'],['coupling']
Modifiability,"t create a coefficient, allowing to add support for other coefficient types per project such as qutip-tensorflow. Also, function based coefficient no longer cast to complex, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1393,variab,variable,1393,https://qutip.org,https://github.com/qutip/qutip/pull/1816,2,['variab'],['variable']
Modifiability,"t possibly a bit tedious since it there are so many different dispatch functions from `mesolve` depending on the different types of time-dependence etc. One would also need cython implementations of the RHS functions for superoperator evolutions. Please let me know what you think about implementing this in qutip. Here is the code for a function that propagates the Lindblad equation with a superoperator as initial value (written as a standalone module for illustration purposes). As you will notice in the code, there is a subtle issue with needing to transpose the Lindbladian to get the correct result. I'm not sure why this is the case.. must be something with the superoperator representation. Perhaps @cgranade knows?. ``` python; import scipy. from qutip.mesolve import _generic_ode_solve; from qutip.superoperator import liouvillian, mat2vec; from qutip.settings import debug. if debug:; import inspect. def _mesolve_const_super(H, E0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the super-operator `E0` using an ODE solver, for constant ; Liouvillian; """""". if debug:; print(inspect.stack()[0][3]). """"""; #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0); """""". #; # check initial value; #; if not E0.issuper:; raise TypeError(""Argument 'E0' should be a super-operator""). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(E0.full()).ravel(); # r = scipy.integrate.ode(cy_ode_rhs); r = scipy.integrate.ode(_rhs); # r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # not sure why I need to transpose L here:; r.set_f_params(L.trans().data); r.s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/384:3045,Evolve,Evolve,3045,https://qutip.org,https://github.com/qutip/qutip/issues/384,1,['Evolve'],['Evolve']
Modifiability,"t the following error . ```text; File ""<ipython-input-6-76f4206b44f0>"", line 1, in <module>; runfile('C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py', wdir='C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations'). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 827, in runfile; execfile(filename, namespace). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\spyder_kernels\customize\spydercustomize.py"", line 110, in execfile; exec(compile(f.read(), filename, 'exec'), namespace). File ""C:/Users/605912/OneDrive - BOOZ ALLEN HAMILTON/DARPA/John Burke/Quantum apertures/calculations/floquet.py"", line 27, in <module>; f_modes_0, f_energies = floquet_modes(H, T, args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\floquet.py"", line 102, in floquet_modes; U = propagator(H, T, [], args). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\propagator.py"", line 186, in propagator; _safe_mode=False). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 157, in sesolve; ss = _sesolve_QobjEvo(H, tlist, args, options). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\sesolve.py"", line 189, in _sesolve_QobjEvo; H_td.compile(omp=nthread). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo.py"", line 1559, in compile; self.tlist). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo_codegen.py"", line 124, in _compiled_coeffs; ""CompiledStrCoeff"", True). File ""C:\Users\605912\AppData\Local\Continuum\anaconda3\lib\site-packages\qutip\qobjevo_codegen.py"", line 82, in _import_str; ""tmpfile:"" + try_file + ext) from e. UnboundLocalError: local variable 'e' referenced before assignment; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1207:2421,variab,variable,2421,https://qutip.org,https://github.com/qutip/qutip/issues/1207,1,['variab'],['variable']
Modifiability,"te or e_ops values (but could also do other things); - a ``_post_init`` method that allows a result sub-class to override what processors are configured; - helper methods ``_store_state``, ``_store_final_state``, ``_pre_copy`` and ``_e_op_func`` that sub-classes can override if they use states that are not ``Qobj``.; - a ``.e_ops`` attribute that stores a dictionary of ``ExpectOP`` instances where ``.e_ops[k](t, state)`` will calculate the expected value and ``.e_ops[k].op`` returns the original object used to create the e_op.; - a ``.e_data`` attribute that store the ``.expect`` values as a dictionary rather than a list, so that ``.e_data[k]`` is ``.expect[i]``. Other changes:. - the normalization of states is now performed in the base solver class, rather than in results.; - the solver ``stats`` passed to the results are now *only for that solver .run call* rather than being a strange record of everything the solver has done so far.; These allow:. - The HEOM solver to implement a ``HEOMResult`` class and use the base solver ``.run`` method.; - The normalization of states to be applied when using the ``.step()`` solver method.; - Consistently expose ``.expect`` and a list of results (consistent with QuTiP 4 and useful when turning expectation values into a numpy array); - Provide a dictionary of expectation values via ``.e_data`` so that when e_ops are supplied as a dictionary, the results can be accessed by the same keys, e.g. ``.e_data[""nice-name""]``.; - Possibly allow the MC result classes to be refactored more easily. **Related issues or PRs**; - #1889 -- I think we could implement this PR more easily on top of the refactored result class.; - #1869 -- the v5 HEOM Solver can use much more of the base solver and results class with these changes . **Todo**; - [X] I would like to add more tests for the base result class, but it would be good to get a +1 on the general approach before I spend time on that. **Changelog**; Add a more flexible base result class for v5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907:1625,refactor,refactored,1625,https://qutip.org,https://github.com/qutip/qutip/pull/1907,3,"['flexible', 'refactor']","['flexible', 'refactored']"
Modifiability,"test_processor.py::TestCircuitProcessor::testGetObjevo PASSED [ 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; =======================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5110,config,config,5110,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['config'],['config']
Modifiability,"the code below is exactly `floquet_modes`, only I modified it to also accept Options that are then passed to `propagator` (by the way, is there a smarter way to do this without defining this new function?). . ### Code to Reproduce the Bug. ```shell; from qutip import *; import numpy as np; import numpy.linalg as la; from numpy import angle, pi. # create a modified floquet_modes that also accepts Options; def floquet_modes_mod(H, T, args=None, sort=False, U=None, options=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args, options = options). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1864:1781,variab,variables,1781,https://qutip.org,https://github.com/qutip/qutip/issues/1864,1,['variab'],['variables']
Modifiability,"thod using our data object. Coefficient creation is no longer hard coded, but use a dict of `type: callable`, each type is associated to a function that create a coefficient, allowing to add support for other coefficient types per project such as qutip-tensorflow. Also, function based coefficient no longer cast to complex, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1210,Variab,Variable,1210,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['Variab'],['Variable']
Modifiability,"tigation techniques [1-3].; > >; > > The tutorial notebooks can be found at; > > http://qutip.org/tutorials.html#nisq. A recent presentation on the; > FOSDEM; > > conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > > Github Project page for a collection of related issues and ongoing Pull; > > Requests.; > > Expected outcomes; > >; > > - More devices defined in the qutip.qip.device module. At the moment,; > > we have two models: spin chain and cavity QED. We would like to include; > > some other commonly used planform such as Superconducting system, Ion; > trap; > > system or silicon system. Each model will need a new set of control; > > hamiltonian and a compiler that find the control pulse of a quantum gate.; > > This part is gonna involve some physics and study of commonly used; > hardware; > > platforms. The related code can be found in qutip.qip.device and; > > qutip.qip.compiler; > > - Refactoring the circuit compiler to allow simple pulse scheduling,; > > e.g. Restriction one pulses that can be turned on at the same time.; > > - Features to perform error mitigation techniques in QuTiP, such as; > > zero-error extrapolation.; > > - APIs to allow import quantum circuits from other software packages; > > or commonly used language e.g. through quantum assembly language (qasm); > >; > > ------------------------------; > >; > > Also, the last outcomes have some overlap with the last project. Although; > > I also find this circuit importation very important, I guess two projects; > > should not have overlap if they are both selected.; > >; > > —; > > You are receiving this because you are subscribed to this thread.; > > Reply to this email directly, view it on GitHub; > > <; > https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA; > >,; > > or unsubscribe; > > <; > https://g",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:6266,Refactor,Refactoring,6266,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,1,['Refactor'],['Refactoring']
Modifiability,"tion purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either size. In general, `setuptools` likes to link dynamically (on Linux and Mac, but not Windows), and so the templates have to be made explicit, rather than allowing Cython to generate only the necessary one. _Note:_ I'll make a PR to push deprecation warnings onto `eseries`, `essolve` and all other removals or renames that don't already have one in `master`, ready for when we drop QuTiP 4.6.0. -----------. _Original top comment:_. Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332:3746,maintainab,maintainable,3746,https://qutip.org,https://github.com/qutip/qutip/pull/1332,1,['maintainab'],['maintainable']
Modifiability,"tl;dr We should go ahead and change it according to PEP8. I vaguely remembered that. ```; string_one == string_two; ```. and. ```; string_one is string_two; ```. do something different. According to [post on stackoverflow](http://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python) ""=="" tests for value equality, while ""is"" checks for whether the variables point to the same thing. Since ""None"" is a singleton the two are the same (except for some [oddball cases](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html)). The [post about the oddball case](http://jaredgrubb.blogspot.sg/2009/04/python-is-none-vs-none.html) also seems to suggest that ""is"" is faster. Anyway, it's a) safe to change and b) recommended, so we should do that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/10#issuecomment-10983787:378,variab,variables,378,https://qutip.org,https://github.com/qutip/qutip/issues/10#issuecomment-10983787,1,['variab'],['variables']
Modifiability,"to build a wheel with `python setup.py bdist_wheel` under the qutip directory. Which gave me the following log:. `running bdist_wheel; running build; running config_cc; unifing config_cc, config, build_clib, build_ext, build commands --compiler options; running config_fc; unifing config_fc, config, build_clib, build_ext, build commands --fcompiler options; running build_src; build_src; building py_modules sources; building extension ""qutip.cy.spmatfuncs"" sources; building extension ""qutip.cy.stochastic"" sources; building extension ""qutip.cy.sparse_utils"" sources; building extension ""qutip.cy.graph_utils"" sources; building extension ""qutip.cy.interpolate"" sources; building extension ""qutip.cy.spmath"" sources; building extension ""qutip.cy.heom"" sources; building extension ""qutip.cy.math"" sources; building extension ""qutip.cy.spconvert"" sources; building extension ""qutip.cy.ptrace"" sources; building extension ""qutip.control.cy_grape"" sources; building data_files sources; build_src: building npy-pkg config files; running build_py; copying qutip/version.py -> build/lib.linux-x86_64-3.5/qutip; copying build/src.linux-x86_64-3.5/qutip/__config__.py -> build/lib.linux-x86_64-3.5/qutip; running build_ext; customize UnixCCompiler; customize UnixCCompiler using build_ext; building 'qutip.cy.spmatfuncs' extension; compiling C sources; C compiler: gcc -pthread -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -mtune=generic -march=x86-64 -ftree-vectorize -g2 -O2 -pipe -fPIC -Wformat -Wformat-security -fno-omit-frame-pointer -fstack-protector-strong --param ssp-buffer-size=4 -fexceptions -D_FORTIFY_SOURCE=2 -feliminate-unused-debug-types -Wno-error -Wp,-D_REENTRANT -fPIC. compile options: '-I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/lib/python3.5/site-packages/numpy/core/include -I/home/jakeargent/anaconda3/include/python3.5m -c'; extra options:",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/639:3672,config,config,3672,https://qutip.org,https://github.com/qutip/qutip/issues/639,1,['config'],['config']
Modifiability,"tps://redirect.github.com/python-pillow/Pillow/issues/7242"">#7242</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit size even if one dimension is zero in decompression bomb check <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7235"">#7235</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Restored 32-bit support <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7234"">#7234</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed deleted file from codecov.yml and increased coverage threshold <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7232"">#7232</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed support for 32-bit <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7228"">#7228</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use --config-settings instead of deprecated --global-option <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7171"">#7171</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Better C integer definitions <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6645"">#6645</a> [<a href=""https://github.com/Yay295""><code>@​Yay295</code></a>]</li>; <li>Fixed finding dependencies on Cygwin <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7175"">#7175</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved checks in font_render <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7218"">#7218</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Change <code>grabclipboard()</code> to use PNG compression on macOS <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7219"">#7219</a> [<a href=""https://github.com/abey79""><code>@​abey79</code></a>]</li>; <l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:3248,config,config-settings,3248,https://qutip.org,https://github.com/qutip/qutip/pull/2237,1,['config'],['config-settings']
Modifiability,"tps://redirect.github.com/python-pillow/Pillow/issues/7883"">#7883</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improve speed of loading QOI images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7925"">#7925</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added RGB to I;16N conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7920"">#7920</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Add --report argument to <strong>main</strong>.py to omit supported formats <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7818"">#7818</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Added RGB to I;16, I;16L and I;16B conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7918"">#7918</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix editable installation with custom build backend and configuration options <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7658"">#7658</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix putdata() for I;16N on big-endian <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7209"">#7209</a> [<a href=""https://github.com/Yay295""><code>@​Yay295</code></a>]</li>; <li>Determine MPO size from markers, not EXIF data <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7884"">#7884</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved conversion from RGB to RGBa, LA and La <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7888"">#7888</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support FITS images with GZIP_1 compression <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7894"">#7894</a> [<a href=""https://github.com/radarhere""><code>@​radarhere",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:1990,config,configuration,1990,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['config'],['configuration']
Modifiability,"ts calculations. The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms. These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it. Regards,. Paul; On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:. > Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?; > ; > I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...; > ; > At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response.; > ; > Cheers,; > Qi; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-42092984:1953,variab,variables,1953,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-42092984,2,['variab'],['variables']
Modifiability,"ttered_state` and `scattering_probability` into a single class. It is a major design change of course. @bencbartlett If you think it is a good idea to bundle both methods into a single class called `PhotonScattering`, I can help with that. In the spirit of your excellent notebook example, you can add the Hamiltonian generating function which can be passed to a `PhotonScattering` class. Each time you call the `scattering_probability` method of this class, you supply the arguments for the particular Hamiltonian, i.e., pulse_length, area, `n_emission` etc. This is similar to the wrapping function that you wrote for your `pool` processes in the notebook. I need to understand the physics a little bit more to ascertain which are the quantitites that would form the arguments for the scattering_probability function and which ones would be fixed for an experiment (hamiltonian for instance). But the overall idea is that you make a class for a particular scattering experiment, give it a fixed Hamiltonian function and keep the calculations flexible wrt to the parameters of interest (pulses, gamma etc). A prototype example would then be:; ```; from qutip.scattering import PhotonScattering; from qutip.scattering import hamiltonian_tls, hamiltonian_rft; ...; scatter = PhotonScattering(hamiltonian_tls, tlist, c_ops, zero_state = psi0, effective_hamiltonian = True); prob_scatter = scatter.scattering_probability(n_emissions, gamma, pulse_length, pulse_area); ```; For a different hamiltonian, the example would be:; ```; scatter = PhotonScattering(hamiltonian_spdc, tlist, c_ops_spdc, zero_state = psi0); prob_scatter = scatter.scattering_probability(n_emissions, pulse_length=pulse_len); ```; I will be happy to help with this and discuss if you are interested, @bencbartlett. Adding these small changes from your notebook example into the main code could make your module more general and flexible. It is just a design choice and is usually followed in many Machine Learning modules (sklearn) ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384566684:1150,flexible,flexible,1150,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384566684,1,['flexible'],['flexible']
Modifiability,"u supply the arguments for the particular Hamiltonian, i.e., pulse_length, area, `n_emission` etc. This is similar to the wrapping function that you wrote for your `pool` processes in the notebook. I need to understand the physics a little bit more to ascertain which are the quantitites that would form the arguments for the scattering_probability function and which ones would be fixed for an experiment (hamiltonian for instance). But the overall idea is that you make a class for a particular scattering experiment, give it a fixed Hamiltonian function and keep the calculations flexible wrt to the parameters of interest (pulses, gamma etc). A prototype example would then be:; ```; from qutip.scattering import PhotonScattering; from qutip.scattering import hamiltonian_tls, hamiltonian_rft; ...; scatter = PhotonScattering(hamiltonian_tls, tlist, c_ops, zero_state = psi0, effective_hamiltonian = True); prob_scatter = scatter.scattering_probability(n_emissions, gamma, pulse_length, pulse_area); ```; For a different hamiltonian, the example would be:; ```; scatter = PhotonScattering(hamiltonian_spdc, tlist, c_ops_spdc, zero_state = psi0); prob_scatter = scatter.scattering_probability(n_emissions, pulse_length=pulse_len); ```; I will be happy to help with this and discuss if you are interested, @bencbartlett. Adding these small changes from your notebook example into the main code could make your module more general and flexible. It is just a design choice and is usually followed in many Machine Learning modules (sklearn) where an experiment is abstracted in a class with global parameters (a Hamiltonian or propagators for instance) and then the methods of the class are used to compute things on-the-fly by supplying the variables of interest (gamma, pulse_area etc). We can still add the code in the current form but nevertheless I would like to discuss this once. This gives more functionality to the tool and could make it very flexible and easy to use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384566684:2003,flexible,flexible,2003,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384566684,3,"['flexible', 'variab']","['flexible', 'variables']"
Modifiability,"uilt produces errors; ```python; In [1]: import qutip; Calibrating OPENMP threshold...; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-1-e01d5608f34f> in <module>; ----> 1 import qutip. ~/code/qutip/qutip/qutip/__init__.py in <module>; 277 print('Calibrating OPENMP threshold...'); 278 thrsh = calculate_openmp_thresh(); --> 279 qutip.configrc.write_rc_key(rc_file, 'openmp_thresh', thrsh); 280; 281 # Load the config file. ~/code/qutip/qutip/qutip/configrc.py in write_rc_key(key, value, section, rc_file); 169 config.read(rc_file); 170 if not config.has_section(section):; --> 171 config.add_section(section); 172 config.set(section, key, str(value)); 173. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in add_section(self, section); 1205 RawConfigParser.add_section by validating if the section name is; 1206 a string.""""""; -> 1207 self._validate_value_types(section=section); 1208 super().add_section(section); 1209. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in _validate_value_types(self, section, option, value); 1178 """"""; 1179 if not isinstance(section, str):; -> 1180 raise TypeError(""section names must be strings""); 1181 if not isinstance(option, str):; 1182 raise TypeError(""option keys must be strings""). TypeError: section names must be strings; ```. The issue is probably due to `__init__.py` being out-of-date with regards to the change to how the `qutiprc` file is written. The immediate fix should be very simple, however it highlights a larger problem with our testing - this should have been caught by the OpenMP tests. In this case, I believe that the tests don't see the issue because there is a test in `__init__.py` that doesn't trigger the OpenMP calibration if only there is only 1 CPU. Presumably, we only ever get allocated single-CPU VMs on Travis, so it hasn't got caught. That makes me worry a lot that the OpenMP code isn't even being tested correctly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470:1199,config,configparser,1199,https://qutip.org,https://github.com/qutip/qutip/issues/1470,1,['config'],['configparser']
Modifiability,"uld still follow the `ufunc` spec for broadcasting rules, and a given ufunc should have the same conceptual behaviour (mostly elementwise operations or reductions). Several libraries implement only these, but _not_ `__array__`, but given my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interfa",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:6688,extend,extends,6688,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,2,['extend'],['extends']
Modifiability,"ule to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularly effective for operations that can be divided into independent, smaller tasks.; - **Compatibility**: Ensured that the enhancements are backward-compatible with existing code by modifying only the internal execution strategy of the `correlation_2op_1t` function and by maintaining the original API signature.; - **Performance Considerations**: The parallel implementation can significantly reduce computation times, particularly for larger systems or longer `taulist` arrays, by leveraging multiple CPU cores concurrently. ### Conclusion. The enhancements to the `correlation_2op_1t` function in QuTiP are designed to harness the capabilities of modern multi-core processors, ther",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:2112,parameteriz,parameterization,2112,https://qutip.org,https://github.com/qutip/qutip/pull/2395,1,['parameteriz'],['parameterization']
Modifiability,use standardized XDG config dirs,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876:21,config,config,21,https://qutip.org,https://github.com/qutip/qutip/issues/1876,1,['config'],['config']
Modifiability,"uting**:; - **Implementation**: Utilized Python’s `concurrent.futures` module, specifically `ProcessPoolExecutor`, to parallelize the computation of correlation values over different tau values (`taulist`). Each tau value computation is independent of others, making this a suitable case for parallel execution.; - **Function Splitting**: Created a helper function `compute_single_tau_correlation` to handle the computation for a single tau. This function manages the setup of the quantum system, computes the correlation for its specific tau, and handles any exceptions that may occur, logging them accordingly.; - **Resource Management**: Used the `cpu_count` from the `os` module to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularl",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:1319,Enhance,Enhanced,1319,https://qutip.org,https://github.com/qutip/qutip/pull/2395,1,['Enhance'],['Enhanced']
Modifiability,"utip/qutip/issues/1750#issuecomment-1005876725 also ran into this. ### Code to Reproduce the Bug. ```shell; goerz@ophelia(r) main:~/Documents/qutipqip/> python3.8 -m venv venv; goerz@ophelia(r) main:~/Documents/qutipqip/qutip-qip> ../venv/bin/python -m pip install -e .[full]; goerz@ophelia(r) main:~/Documents/qutipqip/qutip-qip> ../venv/bin/python -m pip install joblib; goerz@ophelia(r) main:~/Documents/qutipqip/qutip-qip-paper> ../venv/bin/python dj_algorithm.py; ```. ### Code Output. ```shell; Traceback (most recent call last):; File ""dj_algorithm.py"", line 28, in <module>; from qutip_qip.device import OptPulseProcessor, LinearSpinChain, SCQubits; File ""/Users/goerz/Documents/qutipqip/qutip-qip/src/qutip_qip/device/__init__.py"", line 4, in <module>; from .processor import Processor, Model; File ""/Users/goerz/Documents/qutipqip/qutip-qip/src/qutip_qip/device/processor.py"", line 9, in <module>; import qutip; File ""/Users/goerz/Documents/qutipqip/venv/lib/python3.8/site-packages/qutip/__init__.py"", line 73, in <module>; (_blas_info() == ""OPENBLAS"" and platform.system() == 'Darwin'); File ""/Users/goerz/Documents/qutipqip/venv/lib/python3.8/site-packages/qutip/utilities.py"", line 430, in _blas_info; blas_info = config.blas_opt_info; AttributeError: module 'numpy.__config__' has no attribute 'blas_opt_info'; ```. ### Expected Behaviour. It should run the example :-). ### Your Environment. ```shell; goerz@ophelia(r) main:~/Documents/qutipqip/qutip-qip-paper> ../venv/bin/pip freeze; attrs==21.4.0; cycler==0.11.0; fonttools==4.28.5; iniconfig==1.1.1; joblib==1.1.0; kiwisolver==1.3.2; matplotlib==3.5.1; numpy==1.22.0; packaging==21.3; Pillow==9.0.0; pluggy==1.0.0; py==1.11.0; pyparsing==3.0.6; pytest==6.2.5; python-dateutil==2.8.2; qutip==4.6.2; -e git+git@github.com:qutip/qutip-qip.git@04962ded1f6f21620f06f52869b61c4f392e9dea#egg=qutip_qip; scipy==1.7.3; six==1.16.0; toml==0.10.2; ```. ### Additional Context. `import qutip` (for `qutip.about()`) also triggers the backtrace",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1753:1585,config,config,1585,https://qutip.org,https://github.com/qutip/qutip/issues/1753,1,['config'],['config']
Modifiability,"w the numbers they generate affect the non-deterministic functions/algorithms, which depend on the former. In such cases, I've either used a fixed seed (as you've mentioned in your [original post](https://github.com/qutip/qutip/issues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed exper",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:2080,coupling,coupling,2080,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,4,"['coupling', 'flexible']","['coupling', 'flexible']"
Modifiability,"which makes reading the code much easier, but bad because it adds unnecessary chaff which makes scanning lines take longer. I hadn't put much thought into it before, and I think I was just generally writing in my default style. #### Test ordering; I hadn't much considered this, but there are certainly ways of doing it. Essentially `pytest` goes through a few stages when you run `pytest` on the command line: discovery, generation, running, reporting, and it has lots of hook functions we can define to modify the state inbetween and during each of them. Default discovery is as you say: files in alphabetic order (I _think_ it's strictly shell globbing order, but generally that's alphabetical), then the contents of each file in order defined by the shared fixtures used. We tend not to need large amounts of state to be held in fixtures, so our files largely just run top-to-bottom. We can add in some logic into the collection-time hooks to re-order the tests. There's a `pytest` plugin called [`pytest-ordering`](https://github.com/ftobia/pytest-ordering), but it looks like it's not really actively maintained any more and the logic is pretty straightforwards, so perhaps not a terrible idea just to do it ourselves. Maybe I'm not javascript enough to enjoy a good micro-dependency?. It would also be quite nice if we could define the whole logical structure of the `qutip` package, to help keep everything in order as the package grows larger. By that I generally just mean the internal structure, though cutting down the amount of global names exported could also be done in a sort of organisation like this: we could get a little more aggressive at not exporting things like `enr_*` or `three_level_*` to the global namespace, but instead put them in submodules. While I think this isn't what you were asking, it's also quite easy to just run specific parts of the testing suite if you're doing it from the command line. You can do `pytest file.py` to run only those in a specific file, or ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386:1925,plugin,plugin,1925,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-601793386,2,['plugin'],['plugin']
Modifiability,"would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov` package, these would always be numpy arrays. As an explanation, see [the figure",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:1117,flexible,flexible,1117,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,2,['flexible'],['flexible']
Modifiability,"x, but the check in the coefficient function is still there. Since other type are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1566,variab,variable,1566,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Modifiability,"y given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (I think it would be best to combine this with other similar API-breaking refactorings in v5.0.). Personally, I think option 3 is the best way to proceed. I am committed to maintaining and updating this module in the long term and I do think that refactoring much of QuTiP to be more object-oriented will be a positive change to the framework. However, consider that: (1) properly rewriting this as a class-based module without losing functionality will take some time, (2) there are many other modules (for example, most solvers) which would benefit from being refactored into classes, and (3) rewriting these modules would be a breaking API change. . These reasons make me think it would be best to merge the current module now, including it in version 4.3 of QuTiP, and to refactor this (among many other modules) in version 5.0 of QuTiP. This option would make this module available quickly, would be most consistent with semantic versioning, and would keep this module's structure consistent with QuTiP in both pre-refactor v4.X and post-refactor v5.X.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:2860,refactor,refactoring,2860,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,5,['refactor'],"['refactor', 'refactored', 'refactoring']"
Modifiability,"y the implementation of a stochastic rhs function is relatively isolated from how the deterministic part is calculated (which right now is trivial, but which could become more complex when time-dependent systems are implemented). However, it also gives all the flexibility needed in the rhs function, and these deterministic rhs functions do not need to be used if it is not suitable in a particular stochastic rhs implementation. . I've added the changes to the rhs behavior to the https://github.com/qutip/qutip/tree/sme-rhs-restructuring and updated the gist with the variant of your notebook. http://nbviewer.ipython.org/6153688. Note that a few other things, like the rhs function signature, had to change in the process. I hope that this updated API will be flexible enough to let you implement implicit solver. Regards rhs implementation and d1,d2 function: Yes, I understand that not all possible rhs schemes might be compatible with the parameterization with d1 and d2 functions, but when it is possible it has the great advantage that the user do not need to worry about how the rhs is implemented, only define the SDE in terms of d1 and d2, and then possibly select a rhs solver using the solver argument to smesolve. This will not work in general for solvers like the milstein scheme, since it requires an analytical derivative (unless it can be evaluated numerically?), and in those cases it would be sufficient to implement problem specific rhs functions (like rhs_rho_milstein_homodyne etc). Regarding the use of expm: OK, I agree that it could be a nice method to have to be used on smallish system. However, since we are stepping with a small timestep dt, shouldn't it be sufficient to use an expansion of of expm as usual? Perhaps a second-order expansion would do if the first order isn't sufficient. Doing a full expm is fine too I guess, but if it can be avoided then the same method could be used on larger systems too. . Looking forward to seeing your new notebooks and the PR!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22156426:1819,parameteriz,parameterization,1819,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22156426,1,['parameteriz'],['parameterization']
Modifiability,y/random/tests; copying numpy/random/tests/test_regression.py -> build/lib.macosx-11.0-arm64-3.9/numpy/random/tests; creating build/lib.macosx-11.0-arm64-3.9/numpy/testing; copying numpy/testing/__init__.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing; copying numpy/testing/setup.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing; copying numpy/testing/utils.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing; copying numpy/testing/print_coercion_tables.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing; creating build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/nosetester.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/__init__.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/noseclasses.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/utils.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/parameterized.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; copying numpy/testing/_private/decorators.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/_private; creating build/lib.macosx-11.0-arm64-3.9/numpy/testing/tests; copying numpy/testing/tests/test_utils.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/tests; copying numpy/testing/tests/test_decorators.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/tests; copying numpy/testing/tests/__init__.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/tests; copying numpy/testing/tests/test_doctesting.py -> build/lib.macosx-11.0-arm64-3.9/numpy/testing/tests; creating build/lib.macosx-11.0-arm64-3.9/numpy/tests; copying numpy/tests/test_warnings.py -> build/lib.macosx-11.0-arm64-3.9/numpy/tests; copying numpy/tests/test_matlib.py -> build/lib.macosx-11.0-arm64-3.9/numpy/tests; copying numpy/tests/test_ctypeslib.py -> build/lib.macosx-11.0-arm64-3.9/numpy/tests; copying numpy/tests/test_nump,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:45549,parameteriz,parameterized,45549,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['parameteriz'],['parameterized']
Modifiability,"ype are not supported without new data layer, this feels like a proper balance. `QobjEvo` cython casting of coefficient's value to complex as been removing.; No tests are added since other types of coefficient are not supported by data layer.; But here is an example of auto differentiation with this branch:. ```; import qutip as qt; import numpy as np; import qutip_tensorflow as qtf; import tensorflow as tf; from qutip.core.coefficient import Coefficient, coefficient_builders; from qutip.solver.sesolve import SeSolver. # Create a new Coefficient for tf.Variable, ; # This should be added to qutip-tensorflow,; # Here I use a step interpolation.; class TfVarArgsCoefficient(Coefficient):; def __init__(self, variable, tlist, **_):; self.variable = variable; self._tlist = tlist; ; def __call__(self, t, _args=None, **_):; if t <= self._tlist[0]:; return self.variable[0]; if t >= self._tlist[-1]:; return self.variable[-1]; idx = np.searchsorted(self._tlist, t, 'right') - 1; return self.variable[idx]. coefficient_builders[tf.Variable] = TfVarArgsCoefficient. # Create a Coefficient as normal.; variable = tf.Variable(np.linspace(0.1,0.9,6), dtype=tf.complex128); coeff1 = qt.coefficient(variable, tlist=np.linspace(0,0.5,6)). N = 5; a = qt.destroy(N, dtype='tftensor'); num = qt.num(N, dtype='tftensor'); H = qt.qeye(N, dtype='tftensor') + qt.QobjEvo([a+a.dag(), coeff1]). solver = SeSolver(H, options={; 'method': 'vern7', # Only verner method support autodiff for now.; 'state_data_type': """", # The default is 'dense', so it must be overwritten.; 'first_step': 0.05, # Fixed step make auto-diff faster, but still slow.; 'min_step': 0.05,; 'max_step': 0.05,; 'atol': 1e-2,; }); tlist = np.linspace(0,0.5,6). with tf.GradientTape() as tape:; psi = qt.basis(N, N-1, dtype='tftensor'); solver.start(psi, 0); # Result' expect are numpy's array, so we need to compute them ourself.; out = solver.run(psi, tlist); expects = [qt.expect(num, state) for state in out.states[1:]]. %time tape.jacobian(e",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1816:1644,variab,variable,1644,https://qutip.org,https://github.com/qutip/qutip/pull/1816,1,['variab'],['variable']
Performance," (d.dag() * d * P_qe). row = np.array([1,1,2,2,3,3,3,3,4,4,4,4,5,5,6,6]); column = np.array([3,4,3,4,1,2,5,6,1,2,5,6,3,4,3,4]); data = np.array([-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1]). mapped=csr_matrix((data,(row,column)),shape=(N**4*2*2*2*2,N**4*2*2*2*2)); mapped=Qobj(mapped). n_ctrls=4 # Controls; ctrls = [sm.dag()*a+sm*a.dag()+sm.dag()*b+sm*b.dag()+zm.dag()*b+zm*b.dag()+zm.dag()*c+zm*c.dag()+tm.dag()*c+tm*c.dag()+tm.dag()*d+tm*d.dag()+qm.dag()*d+qm*d.dag()+qm.dag()*a+qm*a.dag(),1j*(sm.dag()*a-sm*a.dag())+1j*(sm.dag()*b-sm*b.dag())+1j*(zm.dag()*b-zm*b.dag())+1j*(zm.dag()*c-zm*c.dag())+1j*(tm.dag()*c-tm*c.dag())+1j*(tm.dag()*d-tm*d.dag())+1j*(qm.dag()*d-qm*d.dag())+1j*(qm.dag()*a-qm*a.dag()),sm+sm.dag()+zm+zm.dag()+tm+tm.dag()+qm+qm.dag(), 1j*(sm-sm.dag())+1j*(zm-zm.dag())+1j*(tm-tm.dag())+1j*(qm-qm.dag())]. # Set optimization parameters; U_0=tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)) # Initial gate; U_targ=mapped # Target gates. # Run the optimization. result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)). ```; For N=>3, instead of getting a printout of the optimized controls, I receive the following terminal output error:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 59, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 829, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anacon",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:3363,optimiz,optimization,3363,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimization']
Performance," /Users/shahnawaz/dev/qutip/qutip/__init__.py:; 33 from __future__ import division, print_function, absolute_import; 34 import os; 35: # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; 36 if 'OPENBLAS_MAIN_FREE' not in os.environ:; 37 os.environ['OPENBLAS_MAIN_FREE'] = '1'; ..; 149 # cpu/process configuration; 150 #; 151: import multiprocessing; 152 ; 153 # Check if environ flag for qutip processes is set; ...; 164 qutip.settings.num_cpus = info['cpus']; 165 else:; 166: qutip.settings.num_cpus = multiprocessing.cpu_count(); 167 ; 168 ; ...; 270 # Clean name space; 271 #; 272: del os, sys, numpy, scipy, multiprocessing. /Users/shahnawaz/dev/qutip/qutip/fortran/mcsolve_f90.py:; 83 serial : boolean; 84 If True (default is False) the solver will not make use of the; 85: multiprocessing module, and simply run in serial.; 86 ptrace_sel: list; 87 This optional argument specifies a list of components to keep when; ..; 226 ; 227 def parallel(self):; 228: from multiprocessing import Process, Queue, JoinableQueue; 229 ; 230 if debug:. /Users/shahnawaz/dev/qutip/qutip/hardware_info.py:; 36 import os; 37 import sys; 38: import multiprocessing; 39 ; 40 def _mac_hardware_info():; ..; 91 ncpus += int(cpu.Properties_['NumberOfCores'].Value); 92 except:; 93: ncpus = int(multiprocessing.cpu_count()); 94 return {'os': 'Windows', 'cpus': ncpus}; 95 . /Users/shahnawaz/dev/qutip/qutip/mcsolve.py:; 225 if config.options.num_cpus == 1:; 226 # fallback on serial_map if num_cpu == 1, since there is no; 227: # benefit of starting multiprocessing in this case; 228 config.map_func = serial_map; 229 ; ...; 264 time_type, h_stuff, c_stuff = _td_format_check(H, c_ops, 'mc'); 265 c_terms = len(c_stuff[0]) + len(c_stuff[1]) + len(c_stuff[2]); 266: # set time_type for use in multiprocessing; 267 config.tflag = time_type; 268 . /Users/shahnawaz/dev/qutip/qutip/parallel.py:; 33 """"""; 34 This function provides functions for parallel execution of loops and function; 35: mappings, using t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-270871889:1703,Queue,Queue,1703,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-270871889,1,['Queue'],['Queue']
Performance," 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3562,optimiz,optimize,3562,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['optimiz'],['optimize']
Performance," 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5189,cache,cacheprovider,5189,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cacheprovider']
Performance," </li>; <li>; <p>Determine MPO size from markers, not EXIF data <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7884"">#7884</a>; [radarhere]</p>; </li>; <li>; <p>Improved conversion from RGB to RGBa, LA and La <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7888"">#7888</a>; [radarhere]</p>; </li>; <li>; <p>Support FITS images with GZIP_1 compression <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7894"">#7894</a>; [radarhere]</p>; </li>; <li>; <p>Use I;16 mode for 9-bit JPEG 2000 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7900"">#7900</a>; [scaramallion, radarhere]</p>; </li>; <li>; <p>Raise ValueError if kmeans is negative <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7891"">#7891</a>; [radarhere]</p>; </li>; <li>; <p>Remove TIFF tag OSUBFILETYPE when saving using libtiff <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7893"">#7893</a>; [radarhere]</p>; </li>; <li>; <p>Raise ValueError for negative values when loading P1-P3 PPM images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7882"">#7882</a>; [radarhere]</p>; </li>; <li>; <p>Added reading of JPEG2000 palettes <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7870"">#7870</a>; [radarhere]</p>; </li>; <li>; <p>Added alpha_quality argument when saving WebP images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7872"">#7872</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/5c89d88eee199ba53f64581ea39b6a1bc52feb1a""><code>5c89d88</code></a> 10.3.0 version bump</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/63cbfcfdea2d163ec93bae8d283fcfe4b73b5dc7""><code>63cbfcf</code></a> Update CHANGES.rst [ci skip]</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/2776126aa9",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:12637,load,loading,12637,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['load'],['loading']
Performance," > > warnings.warn(msg, UmfpackWarning); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/t",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126:14427,load,loader,14427,https://qutip.org,https://github.com/qutip/qutip/issues/126,1,['load'],['loader']
Performance," Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2491,cache,cached,2491,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance," a given fixed Hermitian matrix and $\rho(T)$ is a time-evolved quantum state under given Hamiltonian and time interval $[0,T]$. You can also think about this as maximizing trace overlap between two quantum states, if we set $O$ to be another density matrix. I've used all three different fidelitycomputers, but apparently all of them failed to optimize the cost function properly. I'd appreciate it much if anyone can help me understanding what I've been doing wrong! I attached a simple example code below with explanations:. 1. First, I initialized setups such as defining Hamiltonian, initial state, and target observable $O$. Then by creating `create_pulse_optimizer` as follows, I defined/initialized the dynamics as `dyn` with some randomly chosen initial amps. I tried all possible choices of `fid_type`. (see code below). <img width=""977"" alt=""grape_example1"" src=""https://user-images.githubusercontent.com/55151494/170385354-f7efe678-11fc-47de-afa7-ac77359bb5e0.png"">. 2. I then ran the optimization using GRAPE and reported its results. As shown below and in particular the very last line of the figure, the cost function I wanted to estimate is just $0$, whereas my task wants to maximize $\text{Tr}(O\rho)$. While testing several things, I changed $O$ to a ket vector (e.g. $|00>$) and it worked very well. So in principle, I thought the code should work properly as we can think of $O$ being a quantum state (e.g. $|00><00|$). . <img width=""1013"" alt=""grape_2"" src=""https://user-images.githubusercontent.com/55151494/170385858-eeddb7fb-f821-4057-8503-ee2a52e27805.png"">; <img width=""968"" alt=""grape_3"" src=""https://user-images.githubusercontent.com/55151494/170385868-7816a7ee-cc90-4dba-83dd-3304cd2404d8.png"">. I'd be great if someone points out what I'm missing here. One of my guesses of why this is happening is perhaps because we evolve a ket statevector while the target observable is in full matrix form. If so though, I'm not sure how to cure this problem. Thank you in advance!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1900:1079,optimiz,optimization,1079,https://qutip.org,https://github.com/qutip/qutip/issues/1900,1,['optimiz'],['optimization']
Performance," add in any Windows tests because they're currently known to fail, but the intention is to turn them on. The blocking issue is currently a failure of the multiprocessing capabilities, which also affects mcsolve. We can now reasonably run coverage reporting on every test run, and upload all of them to Coveralls at the end, so we get accurate stats on what lines were actually tested. I've also turned pytest's timer, so it reports all tests that took longer than a second to run. This should really help identify where the real problems in our testing are - right now you should see that there's a `correlation` test that takes around 2 minutes to run, which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because I now install _all_ optional dependencies in most runners, so slightly more gets tested than before. Currently there's also a slowdown on several machines because `cvxpy` doesn't build many wheels, and none at all for Linux, on `pip`. I install all our dependencies except BLAS/LAPACK stuff that way, since it's easiest to read out the dependencies like that. We can potentially save some build time (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:1360,concurren,concurrent,1360,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['concurren'],['concurrent']
Performance," back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Consistency between transformations of kets and denstity matrices ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 2.84e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > correlation: compare spectrum obtained for eseries and fft methods ... /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.67e+12); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > Failure: ValueError (invalid literal for int() with base 10: '1post0') ... ERROR; > > > mcsolve_f90: Constant H with no collapse ops (expect) ... ok; > > > mcsolve_f90: Constant H with no collapse ops (states) ... ok; > > > mcsolve_f90: Constant H with constant collapse ... ok; > > > mcsolve_f90: Constant H with single collapse operator ... ok; > > > mcsolve_f90: Constant H w",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126:2175,Concurren,Concurrence,2175,https://qutip.org,https://github.com/qutip/qutip/issues/126,1,['Concurren'],['Concurrence']
Performance," basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anaconda.com/pkgs/pro/linux-64; https://repo.anaconda.com/pkgs/pro/noarch; https://conda.anaconda.org/conda-forge/linux-64; https://conda.anaconda.org/conda-forge/noarch; package cache : /home/user/anaconda2/pkgs; /home/user/.conda/pkgs; envs directories : /home/user/anaconda2/envs; /home/user/.conda/envs; platform : linux-64; user-agent : conda/4.5.4 requests/2.18.4 CPython/2.7.15 Linux/3.13.0-141-generic ubuntu/14.04 glibc/2.19; UID:GID : 1000:1000; netrc file : None; offline mode : False. ```. ```; >>> from qutip import *; >>> about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; A. J. Pitchford, P. D. Nation, R. J. Johansson, A. Grimsmo, and C. Granade. QuTiP Version: 4.2.0; Numpy Version: 1.13.3; Scipy Version: 1.1.0; Cython Version: 0.28.3; Matplotlib Version: 2.2.2; Python Version: 2.7.15; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Linux (x86_64); Installation path: /home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip. ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/888:3600,cache,cache,3600,https://qutip.org,https://github.com/qutip/qutip/issues/888,1,['cache'],['cache']
Performance," br_term_mult ... ok; control.pulseoptim: Hadamard gate with linear initial pulses ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (no stats) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (tau) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (Qobj) ... ok; control.pulseoptim: Hadamard gate with linear initial pulses (OO) ... ok; control.pulseoptim: Hadamard gate gradient check ... ok; control.pulseoptim: QFT gate with linear initial pulses ... ok; control.pulseoptim: QFT gate with linear initial pulses (bounds) ... ok; control: data dumping ... ok; control: unitarity checking (via dump) ... ok; control.pulseoptim: state-to-state transfer ... ok; control.pulseoptim: state-to-state transfer (Qobj) ... ok; control.pulseoptim: amplitude damping channel ... ok; control.pulseoptim: coupled oscillators (symplectic dynamics) ... ok; control.pulseoptim: Hadamard gate using CRAB algorithm ... ok; control.pulseoptim: Hadamard gate (loading config from file) ... ok; control.pulsegen: Check periodic control functions ... ok; control.pulseoptim: Hadamard gate with fixed and time varying drift ... ok; control.pulseoptim: Hadamard gate with fixed and time varying ctrls ... ok; correlation: legacy me and es for oscillator in coherent initial state ... ok; correlation: comparing me and es for oscillator in coherent initial state ... ok; correlation: comparing me and mc for driven oscillator in fock state ... ok; correlation: legacy me and es for oscillator in steady-state ... ok; correlation: comparing me and es for oscillator in steady-state ... ok; correlation: legacy spectrum from es and pi methods ... ok; correlation: comparing spectrum from es and fft methods ... ok; correlation: comparing spectrum from es and pi methods ... ok; correlation: comparing TLS emission corr., H td (str-list td format) ... ok; correlation: comparing TLS emission corr., H td (np-list td format) ... ok; correlation: comparing TLS emission ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:4439,load,loading,4439,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,2,['load'],['loading']
Performance," conference may help you get an overview (; > > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > > Github Project page for a collection of related issues and ongoing Pull; > > Requests.; > > Expected outcomes; > >; > > - More devices defined in the qutip.qip.device module. At the moment,; > > we have two models: spin chain and cavity QED. We would like to include; > > some other commonly used planform such as Superconducting system, Ion; > trap; > > system or silicon system. Each model will need a new set of control; > > hamiltonian and a compiler that find the control pulse of a quantum gate.; > > This part is gonna involve some physics and study of commonly used; > hardware; > > platforms. The related code can be found in qutip.qip.device and; > > qutip.qip.compiler; > > - Refactoring the circuit compiler to allow simple pulse scheduling,; > > e.g. Restriction one pulses that can be turned on at the same time.; > > - Features to perform error mitigation techniques in QuTiP, such as; > > zero-error extrapolation.; > > - APIs to allow import quantum circuits from other software packages; > > or commonly used language e.g. through quantum assembly language (qasm); > >; > > ------------------------------; > >; > > Also, the last outcomes have some overlap with the last project. Although; > > I also find this circuit importation very important, I guess two projects; > > should not have overlap if they are both selected.; > >; > > —; > > You are receiving this because you are subscribed to this thread.; > > Reply to this email directly, view it on GitHub; > > <; > https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA; > >,; > > or unsubscribe; > > <; > https://github.com/notifications/unsubscribe-auth/ADPF67EWECDUIOQMTKK2N2DREGE2LANCNFSM4KZUPCQQ; > >; > > .; > >; >; >; > —; > You are receiving this because you authored t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:6425,perform,perform,6425,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,2,['perform'],['perform']
Performance," could be re-adapted to be among other tutorials, with some title like ""Time-dependent `Qobj` with `QobjEvo`"". There could be much more commentary of the basics of `QobjEvo`. Some could be copy-pasted from the introductory comment in `qobjevo.py`. You are the best person to explain, with basic examples, of increasing complexity, what QobjEvo can do. Possibly taking a known physics problem, e.g., the damped harmonic oscillator with `mesolve`, could help the user. . * In [development-qobjevo.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo.ipynb), block 22 has the first check set to False, but this is both in the notebook I run locally and in the one online. So probably that's the expected behaviour. . In [development-qobjevo-adv.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-adv.ipynb), block 20 has a comment that is an unfinished sentence. In general, I think that examples could be much more descriptive, with comments, about the tests that are being performed. . * I wonder whether `qobjevo_codegen.py` should stay there. It stands out from all other modules, also because in the other cases the title are self-explanatory. ; Regarding this comment:; ```; Function to build cython code from str, compile and import it.; Used by cQobjEvo.; cy/codegen.py does the same thing for specific solver; ```; could then this file by moved to `qutip/cy/`?. * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), block 24 online has a printed error `TypeError: __call__() got an unexpected keyword argument 'args'`, yet on my machine runs fine, it can be replaced. I opened a PR, also running the last blocks and qutip.about(), https://github.com/qutip/qutip-notebooks/pull/72. . * In [development-qobjevo-timing.ipynb](https://github.com/qutip/qutip-notebooks/blob/master/development/development-qobjevo-timing.ipynb), `Time ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/969#issuecomment-489565751:2023,perform,performed,2023,https://qutip.org,https://github.com/qutip/qutip/pull/969#issuecomment-489565751,2,['perform'],['performed']
Performance," discussion is found at https://github.com/The-Compiler/pytest-xvfb/issues/11 . They indicate there that this error can be triggered if windows managed by Xvfb are not properly closed before completing tests. So it's likely it's related to tests using matplotlib. The only test using matplot lib is testPlot in test_processor.py. Sure enough, if testPlot is skipped then test_processor.py passes successfully without triggering the XIO error. **To Reproduce**. Run test_processor.py directly:; ```; python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; ```. The terminal output is; ```; $ python3 -m pytest /usr/lib/python3/dist-packages/qutip/tests/test_processor.py -v; =============================================================================================== test session starts ===============================================================================================; platform linux -- Python 3.9.2, pytest-6.0.2, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/home/drew/.hypothesis/examples'); rootdir: /usr/lib/python3/dist-packages/qutip/tests, configfile: pytest.ini; plugins: cov-2.10.1, mpi-0+unknown, doctestplus-0.9.0, remotedata-0.3.2, asyncio-0.14.0, filter-subpackage-0.1.1, arraydiff-0.3, astropy-header-0.1.2, hypothesis-5.43.3, openfiles-0.5.0, xvfb-1.2.0; collected 11 items . ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_modify_ctrls PASSED [ 9%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_save_read PASSED [ 18%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_evolution PASSED [ 27%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::test_id_with_T1_T2 PASSED [ 36%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitPr",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:2923,cache,cachedir,2923,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cachedir']
Performance," due to some downstream; lack of adherence to PEP 517. Should be removed in a future release; so please prepare accordingly.</li>; <li>Removed reliance on a symlink for the &quot;idna-data&quot; tool to comport; with PEP 517 and the Python Packaging User Guide for sdist archives.</li>; <li>Added security reporting protocol for project</li>; </ul>; <p>Thanks Jon Ribbens, Diogo Teles Sant'Anna, Wu Tingfeng for contributions; to this release.</p>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/kjd/idna/commit/1d365e17e10d72d0b7876316fc7b9ca0eebdd38d""><code>1d365e1</code></a> Release v3.7</li>; <li><a href=""https://github.com/kjd/idna/commit/c1b3154939907fab67c5754346afaebe165ce8e6""><code>c1b3154</code></a> Merge pull request <a href=""https://redirect.github.com/kjd/idna/issues/172"">#172</a> from kjd/optimize-contextj</li>; <li><a href=""https://github.com/kjd/idna/commit/0394ec76ff022813e770ba1fd89658790ea35623""><code>0394ec7</code></a> Merge branch 'master' into optimize-contextj</li>; <li><a href=""https://github.com/kjd/idna/commit/cd58a23173d2b0a40b95ee680baf3e59e8d33966""><code>cd58a23</code></a> Merge pull request <a href=""https://redirect.github.com/kjd/idna/issues/152"">#152</a> from elliotwutingfeng/dev</li>; <li><a href=""https://github.com/kjd/idna/commit/5beb28b9dd77912c0dd656d8b0fdba3eb80222e7""><code>5beb28b</code></a> More efficient resolution of joiner contexts</li>; <li><a href=""https://github.com/kjd/idna/commit/1b121483ed04d9576a1291758f537e1318cddc8b""><code>1b12148</code></a> Update ossf/scorecard-action to v2.3.1</li>; <li><a href=""https://github.com/kjd/idna/commit/d516b874c3388047934938a500c7488d52c4e067""><code>d516b87</code></a> Update Github actions/checkout to v4</li>; <li><a href=""https://github.com/kjd/idna/commit/c095c75943413c75ebf8ac74179757031b7f80b7""><code>c095c75</code></a> Merge branch 'master' into dev</li>; <li><a href=""https://github.com/kjd/idna/commit/60a0a4cb61ec6834d74306bd8a1f",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2392:2522,optimiz,optimize-contextj,2522,https://qutip.org,https://github.com/qutip/qutip/pull/2392,1,['optimiz'],['optimize-contextj']
Performance," href=""https://redirect.github.com/python-pillow/Pillow/issues/7823"">#7823</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow writing IFDRational to UNDEFINED tag <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7840"">#7840</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix logged tag name when loading Exif data <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7842"">#7842</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use maximum frame size in IHDR chunk when saving APNG images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7821"">#7821</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Prevent opening P TGA images without a palette <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7797"">#7797</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use palette when loading ICO images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7798"">#7798</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use consistent arguments for load_read and load_seek <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7713"">#7713</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Turn off nullability warnings for macOS SDK <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7827"">#7827</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix shift-sign issue in Convert.c <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7838"">#7838</a> [<a href=""https://github.com/r-barnes""><code>@​r-barnes</code></a>]</li>; <li>winbuild: Refactor dependency versions into constants <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7843"">#7843</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:6848,load,loading,6848,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['load'],['loading']
Performance," mixed initial states in `mcsolve`, it might be useful to allow sampling of initial states with frequencies or probabilities that are different from their true prefactor in the initial state. The ratio between the sampling frequencies and true prefactors would be weights on the trajectories. This also fixes some things in merging `McResult`s and `NmmcResult`s, and perhaps fixes the target tolerance computation for the ""improved sampling"" option. **Implementation**. A difficulty in the implementation is that the weights depend on the total number of trajectories in different ways. For example, the no-jump trajectory has a fixed weight that never changes, but all other trajectories come with prefactors $(1-p_0) / (N-1)$ where $p_0$ is the probability of the no-jump trajectory, and $N$ the total number of trajectories (including the one no-jump trajectory). For this reason, I separate weights into *absolute weights* (like $p_0$) and *relative weights* (like the others). The average is performed as follows:. $$ \bar\rho = \sum_{T: \text{abs}} w_a(T) w_r(T) \rho(T) + \frac{1}{N_{\text{rel}}} \sum _{T: \text{rel}} w_r(T) \rho(T) $$. where the first sum is over all trajectories T that have absolute weights, and the second sum over all other trajectories. Here, $w_a(T)$ and $w_r(T)$ are the absolute and relative weights, $\rho(T)$ the state associated with a trajectory, and $N_{\text{rel}}$ the number of trajectories that have not been assigned absolute weights. Intuitively, the idea is that absolute weights are for trajectories where the contribution to the full state is known exactly, and the trajectories without absolute weights are the stochastic part. **Things to do**; - [x] Update tests and create new ones; - [x] Update photocurrent to work with weights; - [x] Update target tolerance calculation to work with weights; - [x] Think about how result objects should be added if both contain trajectories with absolute weights; - [x] Double-check that this creates no problems",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2369:1714,perform,performed,1714,https://qutip.org,https://github.com/qutip/qutip/pull/2369,1,['perform'],['performed']
Performance," of bug fixes and other; improvements.</p>; <p>The Python versions supported for this release are 3.7-3.9. Official; support for Python 3.10 will be added when it is released.</p>; <p>:warning: Warning: there are unresolved problems compiling NumPy 1.21.0 with gcc-11.1 .</p>; <ul>; <li>Optimization level <code>-O3</code> results in many wrong warnings when running the tests.</li>; <li>On some hardware NumPy will hang in an infinite loop.</li>; </ul>; <h2>New functions</h2>; <h3>Add PCG64DXSM BitGenerator</h3>; <p>Uses of the PCG64 BitGenerator in a massively-parallel context have; been shown to have statistical weaknesses that were not apparent at the; first release in numpy 1.17. Most users will never observe this weakness; and are safe to continue to use PCG64. We have introduced a new; PCG64DXSM BitGenerator that will eventually become the new default; BitGenerator implementation used by <code>default_rng</code> in future releases.; PCG64DXSM solves the statistical weakness while preserving the; performance and the features of PCG64.</p>; <p>See <code>upgrading-pcg64</code> for more details.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/18906"">gh-18906</a>)</p>; <h2>Expired deprecations</h2>; <ul>; <li>The <code>shape</code> argument <code>numpy.unravel_index</code> cannot be; passed as <code>dims</code> keyword argument anymore. (Was deprecated in NumPy; 1.16.)</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/numpy/numpy/commit/b235f9e701e14ed6f6f6dcba885f7986a833743f""><code>b235f9e</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/19283"">#19283</a> from charris/prepare-1.21.0-release</li>; <li><a href=""https://github.com/numpy/numpy/commit/34aebc2824cf8c2bdbe19040b82f98f18557c8ba""><code>34aebc2</code></a> MAINT: Update 1.21.0-notes.rst</li>; <li><a href=""https://github.c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1767:1747,perform,performance,1747,https://qutip.org,https://github.com/qutip/qutip/pull/1767,1,['perform'],['performance']
Performance," passed `type` - nothing else is overwritten if passed explicitly - you could achieve all the same effects at approximately the same speed with correct application of the kwargs, such as; ```python; Qobj(data, dims=dims, copy=False, type='oper', isherm=...); ```; providing `data` is actually of a valid (`fast_csr_matrix`) format. Technically the `Qobj.data` attribute will be a new object that wraps the same numpy arrays as was passed, rather than the same `fast_csr_matrix`. In various forms, `expect` already does check the Hermicity, that's why `mc-dm` is careful to set it to avoid recalculating it. The expect functions in `qutip.expect` do this directly, and aren't aware of column-stacked density matrices - they'll just raise a TypeError. `mesolve` and `mcsolve` now bypass the `Qobj` stage and go direct to Cython - in 5.0 it might not be a terrible idea to route everything back through the `Qobj` form, since the performance issues there are solved (a column-stacked dense matrix can be directly wrapped by an f-ordered `Dense` type), and it's the natural central point of the code (and those parts are called from Python-space anyway, so no C concerns). Here though, the problem is actually that the expectation generator in `mesolve` correctly calculates the dtype of the output expectation array using both the state and the expectation operator, but then it does it incorrectly in the loop, and passes the hermicity down to Cython using only the expectation operator, which promptly throws out the complex part. So setting `fast='mc-dm'` in `Qobj` is a symptom of the same root cause as the problem here, rather than the cause itself. At the start of `mesolve` we don't assume that the state is Hermitian, but then inside the integration loop we do. We can still keep the speedup - if the output was created with a complex dtype, we can always safely say that we're passing in non-Hermitian operators, even if coincidentally at one timestep they happen to be anyway. See https://gith",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048:1159,perform,performance,1159,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048,1,['perform'],['performance']
Performance," pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3070,cache,cached,3070,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance," qeye(D)); result = mesolve(qeye(D**2), psi0,[0, 100e-9], [destroy(D**2)])```; ```; ```; (qutip) ➜ ~ python mwe.py ; [1] 83143 segmentation fault python mwe.py; ```. Changing `D = 13` to `D = 12` correctly raises a `ValueError`:; ```; (qutip) ➜ ~ python mwe.py; Traceback (most recent call last):; File ""mwe.py"", line 5, in <module>; result = mesolve(qeye(D**2), psi0,[0, 100e-9], [destroy(D**2)]); File ""/Users/colmrya/miniconda3/envs/qutip/lib/python3.8/site-packages/qutip/mesolve.py"", line 266, in mesolve; func(0., v, *ode_args) + v; ValueError: operands could not be broadcast together with shapes (20736,) (1728,) ; ```. Trying to get a little more info on the segfault:. ```; (qutip) ➜ ~ lldb --file python mwe.py; (lldb) target create ""/Users/colmrya/miniconda3/envs/qutip/bin/python""; Current executable set to '/Users/colmrya/miniconda3/envs/qutip/bin/python' (x86_64).; (lldb) settings set -- target.run-args ""mwe.py""; (lldb) r; Process 83317 launched: '/Users/colmrya/miniconda3/envs/qutip/bin/python' (x86_64); Process 83317 stopped; * thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x1168d1000); frame #0: 0x0000000113018acd spmatfuncs.cpython-38-darwin.so`__pyx_f_5qutip_2cy_10spmatfuncs_spmvpy(std::__1::complex<double>*, int*, int*, std::__1::complex<double>*, std::__1::complex<double>, std::__1::complex<double>*, unsigned int) + 157; spmatfuncs.cpython-38-darwin.so`__pyx_f_5qutip_2cy_10spmatfuncs_spmvpy:; -> 0x113018acd <+157>: movupd (%rcx,%rax), %xmm4; 0x113018ad2 <+162>: mulpd %xmm4, %xmm3; 0x113018ad6 <+166>: movddup (%rbx), %xmm5 ; xmm5 = mem[0,0] ; 0x113018ada <+170>: shufpd $0x1, %xmm4, %xmm4 ; xmm4 = xmm4[1,0] ; Target 0: (python) stopped.; ```. Not passing `c_ops` restores just raising a `ValueError`. ```python; from qutip import *. D = 13; psi0 = tensor(coherent(D, 100e-9), qeye(D)); result = mesolve(qeye(D**2), psi0,[0, 100e-9], []); ```; gives; ```; (qutip) ➜ ~ python mwe.py ; Traceback (most recent call last):; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1456:1406,queue,queue,1406,https://qutip.org,https://github.com/qutip/qutip/issues/1456,1,['queue'],['queue']
Performance," scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4174,cache,cached,4174,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance," scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; pandas 2.0.3 requires numpy>=1.20.3; python_version < ""3.10"", but you have numpy 1.17.3 which is incompatible.; Successfully installed cython-3.0.2 numpy-1.17.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:3114,cache,cached,3114,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance," site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1747,cache,cached,1747,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance," super-operator, by comparing the fidelity of the resulting states in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/404:1423,perform,performance,1423,https://qutip.org,https://github.com/qutip/qutip/pull/404,1,['perform'],['performance']
Performance," to 1.21.0.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/numpy/numpy/releases"">numpy's releases</a>.</em></p>; <blockquote>; <h2>v1.21.0</h2>; <h1>NumPy 1.21.0 Release Notes</h1>; <p>The NumPy 1.21.0 release highlights are</p>; <ul>; <li>continued SIMD work covering more functions and platforms,</li>; <li>initial work on the new dtype infrastructure and casting,</li>; <li>universal2 wheels for Python 3.8 and Python 3.9 on Mac,</li>; <li>improved documentation,</li>; <li>improved annotations,</li>; <li>new <code>PCG64DXSM</code> bitgenerator for random numbers.</li>; </ul>; <p>In addition there are the usual large number of bug fixes and other; improvements.</p>; <p>The Python versions supported for this release are 3.7-3.9. Official; support for Python 3.10 will be added when it is released.</p>; <p>:warning: Warning: there are unresolved problems compiling NumPy 1.21.0 with gcc-11.1 .</p>; <ul>; <li>Optimization level <code>-O3</code> results in many wrong warnings when running the tests.</li>; <li>On some hardware NumPy will hang in an infinite loop.</li>; </ul>; <h2>New functions</h2>; <h3>Add PCG64DXSM BitGenerator</h3>; <p>Uses of the PCG64 BitGenerator in a massively-parallel context have; been shown to have statistical weaknesses that were not apparent at the; first release in numpy 1.17. Most users will never observe this weakness; and are safe to continue to use PCG64. We have introduced a new; PCG64DXSM BitGenerator that will eventually become the new default; BitGenerator implementation used by <code>default_rng</code> in future releases.; PCG64DXSM solves the statistical weakness while preserving the; performance and the features of PCG64.</p>; <p>See <code>upgrading-pcg64</code> for more details.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/18906"">gh-18906</a>)</p>; <h2>Expired deprecations</h2>; <ul>; <li>The <code>shape</code> argument <code>numpy.unravel_index</code> cannot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1767:1020,Optimiz,Optimization,1020,https://qutip.org,https://github.com/qutip/qutip/pull/1767,1,['Optimiz'],['Optimization']
Performance," to work:; ```python; import numpy as np; import qutip. random_matrix = np.random.random((2, 2)) + 1j * np.random.random((2, 2)); complex_number = np.random.random((1, 1)) + 1j * np.random.random((1, 1)). qobj = qutip.Qobj(random_matrix); qobj*complex_number; ``` ; I used numpy `ndarray` instead of a `tf.Tensor` or `tf.Variable` for simplicity and so that the example is reproducible. . Currently this example raises: ; ""TypeError: incompatible dimensions [[2], [2]] and [[1], [1]]""; as `__mul__(self, other)` defaults to `__matmul__(self, other)` when `other` is not an instance of `numbers.Number`. . If instead we do:; ```python; complex_number*qobj; ```; The error raised is:; ""TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'Qobj'""; This error is different because `__rmul__` checks first for `other` being an instance of `numbers.Number` and if not, it raises `NotImplementedError`. It does not check whether `Qobj(other)` works. I would say this is undesired and that `__rmul__` should try first converting `other` into `Qobj` and not assume that other is already `Qobj`. . **Describe the solution you'd like**; I would like to suggest either:; 1) changing the behaviour of `matmul` dispatcher so that (1,1) shaped data is multiplied element wise by default. However this, although not terrible, it breaks conceptually what matmul is, as a (1,1) x (2,2) matrix multiplication can not happen. 2) Allow `mul` dispatcher to have as input a `Data` object. In this way we would raise an error when the `Data` for `mul` dispatcher is not of shape (1,1) and perform an elementwise multiplication when it is. I am not sure how difficult it is to code this. 3) Create `mul_elementwise` dispatcher to have as input two `Data` objects and perform elementwise multiplication. Another change that I would like to suggest is to add a check in `__rmul__` to see if `other` can be represented as a Qobj. . These two changes should probably go in a different PR. _Edit: added third option_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607:1706,perform,perform,1706,https://qutip.org,https://github.com/qutip/qutip/issues/1607,2,['perform'],['perform']
Performance,"""""""; .................................................................................................................................../Users/nathanshammah/github/qutip/qutip/control/optimizer.py:1070: DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working; elif not isinstance(self.pulse_generator, collections.Iterable):; ..............................................................................................................................................................SSSSSS.......................................................................................................................Segmentation fault: 11. kills nosetests, which do not even start doing QuTiP's tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-496380658:184,optimiz,optimizer,184,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-496380658,1,['optimiz'],['optimizer']
Performance,"## Discussed in https://github.com/qutip/qutip/discussions/2255. <div type='discussions-op-text'>. <sup>Originally posted by **shiv6510** November 2, 2023</sup>; Hi, I am encountering some strange dynamics with mesolve that I don't understand. I have a simple hamiltonian of a harmonic oscillator with resonant frequency of 5 GHz. If I evolve the initial state (|0> + |1>)/sqrt(2) under the system hamiltonian (no time dependence) I would expect the expectation values of the |0> and |1> to stay at 0.5. (Amplitudes of eigenstates should not change). . However, when I plot the expectation values, I see a splitting of overtime, where the expectation value of |0> grows linear over time and |1> shrinks linearly with time. Looking through the forums, I figured it was an issue with the ode solver but playing around with the options (max_steps, rtol, atol, etc.) only changes the rate at which the expectation value drops (or grows); it doesn't get rid of the splitting. Any insight into this problem would be of great help :). Code:; ***********************************************************************; import matplotlib.pyplot as plt; from numpy import *; from scipy.optimize import fsolve; from qutip import *. a = destroy(20); wr = 5 # GHz; H = wr * a.dag() * a. e_nrgs, e_states = H.eigenstates(). psi0 = (e_states[0] + e_states[1]).unit(); wait_time = 2000; t_list = arange(0,wait_time+0.02, 0.01). options = Options(max_step=1/(wr * 100)); output = sesolve(2 * pi * H, ; psi0, ; t_list, ; e_ops=[e_states[0].proj(), e_states[1].proj()], ; args=None,; options=options,; progress_bar=True); ***********************************************************************. Plot:. plt.plot(t_list, output.expect[0], color='red', label='<0>'); plt.plot(t_list, output.expect[1],label='<1>'); plt.xlabel('Time[ns]'); plt.ylabel('Expectation Value'); plt.legend(); plt.show(). <img width=""840"" alt=""image"" src=""https://github.com/qutip/qutip/assets/43760523/c55016b4-5fbc-4032-b8e0-d143152250bb"">. </div>",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2258:1174,optimiz,optimize,1174,https://qutip.org,https://github.com/qutip/qutip/issues/2258,1,['optimiz'],['optimize']
Performance,"### Bug Description. Call to `b.render()` errors after performing `b.add_vectors(vec)` where `b` is an instance of `qutip.Bloch()`. ### Code to Reproduce the Bug. ```shell; import qutip; b = qutip.Bloch(); b.make_sphere(); b.add_vectors([0,0,1]); b.render(); ```. ### Code Output. ```shell; /tmp/ipykernel_377526/3029128797.py in <module>; 2 b.make_sphere(); 3 b.add_vectors([0,0,1]); ----> 4 b.render(). ~/.conda/envs/myenv/lib/python3.8/site-packages/qutip/bloch.py in render(self); 503 self.plot_annotations(); 504 # Trigger an update of the Bloch sphere if it is already shown:; --> 505 self.fig.canvas.draw(); 506 ; 507 def plot_back(self):. ~/.local/lib/python3.8/site-packages/matplotlib/backends/backend_agg.py in draw(self); 434 (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 435 else nullcontext()):; --> 436 self.figure.draw(self.renderer); 437 # A GUI class may be need to update a window using this draw, so; 438 # don't forget to call the superclass. ~/.local/lib/python3.8/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer, *args, **kwargs); 71 @wraps(draw); 72 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 73 result = draw(artist, renderer, *args, **kwargs); 74 if renderer._rasterizing:; 75 renderer.stop_rasterizing(). ~/.local/lib/python3.8/site-packages/matplotlib/artist.py in draw_wrapper(artist, renderer); 48 renderer.start_filter(); 49 ; ---> 50 return draw(artist, renderer); 51 finally:; 52 if artist.get_agg_filter() is not None:. ~/.local/lib/python3.8/site-packages/matplotlib/figure.py in draw(self, renderer); 2808 ; 2809 self.patch.draw(renderer); -> 2810 mimage._draw_list_compositing_images(; 2811 renderer, self, artists, self.suppressComposite); 2812 . ~/.local/lib/python3.8/site-packages/matplotlib/image.py in _draw_list_compositing_images(renderer, parent, artists, suppress_composite); 130 if not_composite or not has_images:; 131 for a in artists:; --> 132 a.draw(renderer); 133 else:; 134 # Composite any adjacent ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1817:55,perform,performing,55,https://qutip.org,https://github.com/qutip/qutip/issues/1817,1,['perform'],['performing']
Performance,"### Bug Description. Hey! I've noticed there's a significant slowdown in executing the same codes for obtaining `steadystate` solutions in `v4.7` vs `v5.0` with iterative scipy solvers, especially while using `use_rcm=True`. After spending some time, I believe the main key difference between both versions comes from permutation done in the `_permute_rcm`, where indices are permuted with the indices obtained from the `reverse_cuthill_mckee` function, and this prevents us from getting the preconditioner efficiently. In `v5.0`, for permuting, we use `_data.permute.indices` for the Liouvillian matrix `L`. This gives us different results from what we used in `v4.7`, i.e.,`sp_permute` with the same permuting indices. . As per my understanding, `_data.permute.indices` performs somewhat the following - ; ``` py; A = L.copy(); A.indices = perm.take(A.indices); A = A.tocsc(A); A.indices = perm.take(A.indices); ```; where, we previously, the following was being done; ``` py; L[perm[:,None], perm]; ```; with `perm` are obtained from `reverse_cuthill_mckee`. . I am not sure which behavior is the correct one, but the performance degradation is quite a lot (more than 10x) and prevents reaching sufficient enough tolerance. ### Code to Reproduce the Bug. ```shell; import numpy as np; from qutip import (about, destroy, qeye, steadystate, tensor). # Paramaeters; # -----------; Nc, Nm = 4, 30; E, kappa = 0.1, 0.3; gamma, delta = 3e-4, -0.43. # Operators; # ----------; a = tensor(destroy(Nc), qeye(Nm)); b = tensor(qeye(Nc), destroy(Nm)). # Hamiltonian; # ------------; H = -delta * (a.dag() * a) + (b.dag() * b) + 2.4 * kappa * (b.dag() + b) * (a.dag() * a) + E * (a.dag() + a). # Collapse operators; # -------------------; cc = np.sqrt(kappa) * a; cm = np.sqrt(2 * gamma) * b; cp = np.sqrt(gamma) * b.dag(); c_ops = [cc, cm, cp]. precond_options = {'permc_spec': 'NATURAL', 'diag_pivot_thresh': 0.1, 'fill_factor': 100, 'options': {'ILU_MILU': 'smilu_2'}}; solver_options = {""use_precond"": False",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2443:772,perform,performs,772,https://qutip.org,https://github.com/qutip/qutip/issues/2443,1,['perform'],['performs']
Performance,"### Bug Description. I've encountered this bug when creating a clean environment, and installing `qutip` (and IPython as console) through mamba.; Next, I've opened an IPython console and ran `import qutip`, which resulted in the exception printed below - stating that the `format` attribute of the `fast_csr_matrix` cannot be set. I believe the latest `scipy` [release](https://github.com/scipy/scipy/releases) is the culprit (released 14 hrs ago at the time of writing) - reducing from `scipy==1.11.0` to `scipy==1.10.1` resolves the issue for me. ### Code to Reproduce the Bug. ```shell; import qutip; ```. ### Code Output. ```shell; Cell In[1], line 1; ----> 1 import qutip. File ~\mambaforge\envs\test-env-scipy-qutip\Lib\site-packages\qutip\__init__.py:106; 98 del matplotlib; 101 # -----------------------------------------------------------------------------; 102 # Load modules; 103 #; 104; 105 # core; --> 106 from qutip.qobj import *; 107 from qutip.qobjevo import *; 108 from qutip.states import *. File ~\mambaforge\envs\test-env-scipy-qutip\Lib\site-packages\qutip\qobj.py:2526; 2523 # TRAILING IMPORTS; 2524 # We do a few imports here to avoid circular dependencies.; 2525 from qutip.eseries import eseries; -> 2526 import qutip.superop_reps as sr; 2527 import qutip.tensor as tensor; 2528 import qutip.operators as ops. File ~\mambaforge\envs\test-env-scipy-qutip\Lib\site-packages\qutip\superop_reps.py:74; 61 return Qobj(dims=[[[2], [2]], [[2], [2]]],; 62 inpt=array([[1. - pe / 2., 0., 0., 1. - pe],; 63 [0., pe / 2., 0., 0.],; 64 [0., 0., pe / 2., 0.],; 65 [1. - pe, 0., 0., 1. - pe / 2.]]),; 66 superrep='choi'); 69 # CHANGE OF BASIS FUNCTIONS ---------------------------------------------------; 70 # These functions find change of basis matrices, and are useful in converting; 71 # between (for instance) Choi and chi matrices. At some point, these should; 72 # probably be moved out to another module.; ---> 74 _SINGLE_QUBIT_PAULI_BASIS = (identity(2), sigmax(), sigmay(), sigma",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2182:873,Load,Load,873,https://qutip.org,https://github.com/qutip/qutip/issues/2182,1,['Load'],['Load']
Performance,"### Bug Description. In `qutip.qobjevo.compile`, on line 1646, the `.pyx` file created by qutip is registered into the global variable `coeff_files` containing a `_file_list` object using the method `coeff_files.add(file_)`. The `add` method appends a `.pyx` extension on line 60 to the string `file_`; ```; self.files += [file_ + "".pyx""]; ```; However, the `file_` string generated by `_compiled_coeffs` already has the file extension, judging from the return value of `qutip.qobjevo_codegen._import_str`, on line 54; ```; return coeff_obj, try_file + ext; ```; I believe this causes `coeff_files.clean()` on line 1697 of `qutip.qobjevo.compile` to not delete the `.pyx` files after the cython class has been loaded. ### Code to Reproduce the Bug. ```shell; import qutip as qt; qt.sesolve([qt.identity(2), [qt.sigmax(), 'sin(t)']], qt.basis(2, 0),; tlist=[0, 2]); ```. ### Code Output. ```shell; creates the file cqobjevo_compiled_coeff_6095589624050.pyx in the working directory.; ```. ### Expected Behaviour. The `.pyx` file in the working directory should be deleted. ### Your Environment. ```shell; QuTiP Version: 4.7.2; Numpy Version: 1.25.2; Scipy Version: 1.11.2; Cython Version: 0.29.36; Matplotlib Version: 3.7.2; Python Version: 3.10.12; Number of CPUs: 4; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2231:710,load,loaded,710,https://qutip.org,https://github.com/qutip/qutip/issues/2231,1,['load'],['loaded']
Performance,"### Bug Description. In a fresh virtual environment, doing `pip install qutip` will cause the error. ```; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. I know this is quite an old OS and Python version, but that's what I have available. Numpy 1.24 should be supported in Python 3.8.10. ### Code to Reproduce the Bug. ```shell; $ python3 -m venv /tmp/test-venv. $ source /tmp/test-venv/bin/activate. $ pip install --upgrade pip; Collecting pip; Using cached pip-24.0-py3-none-any.whl (2.1 MB); Installing collected packages: pip; Attempting uninstall: pip; Found existing installation: pip 20.0.2; Uninstalling pip-20.0.2:; Successfully uninstalled pip-20.0.2; Successfully installed pip-24.0. $ pip list; Package Version; ------------- -------; pip 24.0; pkg_resources 0.0.0; setuptools 44.0.0. $ pip install qutip; Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Installing build dependencies ... done; Getting requirements to build wheel ... done; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. ### Code Output. _No response_. ### Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if i",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:670,cache,cached,670,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"### Bug Description. Installing `qutip` with `pip` on Python 3.11 fails at the ""Getting the requirements to build the wheel"" stage. Potentially related to [these changes](https://github.com/pypa/packaging/pull/407) in `packaging`, introduced in the latest update to `22.0`. ### Code to Reproduce the Bug. ```shell; pip install qutip --no-cache-dir; ```. ### Code Output. ```shell; Collecting qutip; Downloading qutip-4.7.0.tar.gz (3.6 MB); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 3.6/3.6 MB 18.2 MB/s eta 0:00:00; Installing build dependencies ... done; Getting requirements to build wheel ... error; error: subprocess-exited-with-error; ; × Getting requirements to build wheel did not run successfully.; │ exit code: 1; ╰─> [20 lines of output]; Traceback (most recent call last):; File ""/Users/hsilver/opt/miniconda3/envs/py311/lib/python3.11/site-packages/pip/_vendor/pep517/in_process/_in_process.py"", line 351, in <module>; main(); File ""/Users/hsilver/opt/miniconda3/envs/py311/lib/python3.11/site-packages/pip/_vendor/pep517/in_process/_in_process.py"", line 333, in main; json_out['return_val'] = hook(**hook_input['kwargs']); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""/Users/hsilver/opt/miniconda3/envs/py311/lib/python3.11/site-packages/pip/_vendor/pep517/in_process/_in_process.py"", line 118, in get_requires_for_build_wheel; return hook(config_settings); ^^^^^^^^^^^^^^^^^^^^^; File ""/private/var/folders/h9/04p7x4ds0hvfmd80jt8gx3kc0000gn/T/pip-build-env-dzdmg7x6/overlay/lib/python3.11/site-packages/setuptools/build_meta.py"", line 338, in get_requires_for_build_wheel; return self._get_build_requires(config_settings, requirements=['wheel']); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""/private/var/folders/h9/04p7x4ds0hvfmd80jt8gx3kc0000gn/T/pip-build-env-dzdmg7x6/overlay/lib/python3.11/site-packages/setuptools/build_meta.py"", line 320, in _get_build_requires; self.run_setup(); File ""/private/var/folders/h9/04p7x4ds0hvfmd80jt8gx3kc0000gn/T/pip-build-env-dzdm",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2036:338,cache,cache-dir,338,https://qutip.org,https://github.com/qutip/qutip/issues/2036,1,['cache'],['cache-dir']
Performance,"### Bug Description. Installing qutip with `pip install qutip` fails on a MacBook Pro with M1 Pro running macOS 12.0.1, due to the build dependency `numpy<1.20` failing to build. This happens both with miniconda python 3.9.6 and miniforge python 3.9.7. Same happens if I clone the master branch and build. If I edit `pyproject.toml` and `setup.cfg` to remove the `<1.20` in Numpy, then qutip builds correctly (then I get same problem as Issue #1606 when importing, but that's another story). ### Code to Reproduce the Bug. ```shell; conda create -n qutip_test; pip install qutip; ```. ### Code Output. ```shell; Collecting qutip; Using cached qutip-4.6.2.tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:636,cache,cached,636,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"### Bug Description. It seems that in new matplotlib version they separated classes `Axes` and `Axes3d`, so some plotting functions that have 3d aspects don't work as expected anymore. See example in the code below. ### Code to Reproduce the Bug. ```shell; from qutip import qpt_plot_combined; qpt_plot_combined(np.eye(4), [[""I"", ""X"", ""Y"", ""Z""]]); ```. ### Code Output. ```shell; ---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); Cell In[8], line 2; 1 from qutip import qpt_plot_combined; ----> 2 qpt_plot_combined(np.eye(4), [[""I"", ""X"", ""Y"", ""Z""]]). File ~\AppData\Local\pypoetry\Cache\virtualenvs\photonic-component-simulator-biULA8HA-py3.9\lib\site-packages\qutip\tomography.py:143, in qpt_plot_combined(chi, lbls_list, title, fig, ax, figsize, threshold); 140 if not title:; 141 title = r""$\chi$""; --> 143 matrix_histogram_complex(chi, xlabels, xlabels, title=title, ax=ax,; 144 threshold=threshold); 146 return fig, ax. File ~\AppData\Local\pypoetry\Cache\virtualenvs\photonic-component-simulator-biULA8HA-py3.9\lib\site-packages\qutip\visualization.py:820, in matrix_histogram_complex(M, xlabels, ylabels, title, limits, phase_limits, colorbar, fig, ax, threshold); 818 # x axis; 819 xtics = -0.5 + np.arange(M.shape[0]); --> 820 ax.axes.w_xaxis.set_major_locator(plt.FixedLocator(xtics)); 821 if xlabels:; 822 nxlabels = len(xlabels). AttributeError: 'Axes3D' object has no attribute 'w_xaxis'; ```. ### Expected Behaviour. There should be a plot and not an error. ### Your Environment. ```shell; QuTiP vesion: '4.7.3'; matplotlib version: '3.8.0'; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2233:658,Cache,Cache,658,https://qutip.org,https://github.com/qutip/qutip/issues/2233,2,['Cache'],['Cache']
Performance,"### Bug Description. Might just be me mis-using the new 5.X branch of Qutip. I get a memory error when upgrading to the new branch. It appears to fail when performing self._to_dm(state) for each state. My states are vectors of length 800 - so it runs out of memory. Is it possible to request the solver only stores the wavefunction at each timestep? I want the wavefunction for each trajectory for each timestep. Alternatively one could introduce a new ""proj"" data storage to make this more efficient. ### Code to Reproduce the Bug. ```shell; result = qutip.ssesolve(; hamiltonian_qobj,; initial_state_qobj,; times.times,; sc_ops=sc_ops,; e_ops=[],; options={; ""method"": ""euler"",; ""progress_bar"": ""enhanced"",; ""store_states"": True,; ""keep_runs_results"": True,; ""improved_sampling"": False,; ""dt"": times.delta_t / times.fundamental_n,; },; ntraj=n_trajectories, # cspell:disable-line; ); ```. ### Code Output. ```shell; File ""..."", line 270, in solve_stochastic_schrodinger_equation; result = qutip.ssesolve(; ^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\stochastic.py"", line 461, in ssesolve; return sol.run(; ^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\multitraj.py"", line 198, in run; map_func(; File ""...\.venv\Lib\site-packages\qutip\solver\parallel.py"", line 122, in serial_map; remaining_ntraj = reduce_func(result); ^^^^^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\solver\result.py"", line 645, in add ; op(trajectory); File ""...\.venv\Lib\site-packages\qutip\solver\result.py"", line 519, in _reduce_states; accu + self._to_dm(state); ~~~~~^~~~~~~~~~~~~~~~~~~~; File ""...\.venv\Lib\site-packages\qutip\core\qobj.py"", line 134, in out; return method(self, other); ^^^^^^^^^^^^^^^^^^^; File ""...\.venv\Lib\site-packages\qutip\core\qobj.py"", line 408, in __add__ ; return Qobj(_data.add(self._data, other._data),; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""qutip\\core\\data\\dispatch.pyx"", line 392, in qutip.core.data.dispatch.Dispatcher.__call__; File """,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2299:156,perform,performing,156,https://qutip.org,https://github.com/qutip/qutip/issues/2299,1,['perform'],['performing']
Performance,"### Bug Description. Running `import qutip` eagerly imports `scipy.fft` via `qutip.correlation`, causing all native dependencies of `scipy.fft`'s fftpack-based implementation to load. In particular when using SciPy 1.8.1 on Linux, fftpack requires `GLIBCXX_3.4.30` but contains a private copy of `GLIBCXX_3.4.29` such that the import fails unless another Python package provides its own implementation of `GLIBCXX_3.4.30` (typically, PyZMQ via `jupyter-client`). This in turn can cause `import qutip` to fail even when not using features backed by fftpack (e.g.: as happened in the case of https://github.com/microsoft/iqsharp/pull/676). ### Code to Reproduce the Bug. ```shell; import qutip; ```. ### Code Output. ```shell; # Example from build logs for https://dev.azure.com/ms-quantum-public/Microsoft%20Quantum%20(public)/_build/results?buildId=42116&view=logs&j=1c33f9fa-7159-5ed6-d128-ab2ed6cefd14&t=74d456a9-739b-5d92-ed57-026d8fef9427, ; $PREFIX/lib/python3.8/site-packages/zmq/backend/cython/../../../../.././libstdc++.so.6: version `GLIBCXX_3.4.30' not found (required by $PREFIX/lib/python3.8/site-packages/scipy/fft/_pocketfft/pypocketfft.cpython-38-x86_64-linux-gnu.so); ```. ### Expected Behaviour. `import qutip` should not cause native dependencies of `scipy.fft` to be imported eagerly. ### Your Environment. ```shell; (omitted --- `qutip.about()` failed to execute due to error running `import qutip`); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1915:178,load,load,178,https://qutip.org,https://github.com/qutip/qutip/issues/1915,1,['load'],['load']
Performance,"### Bug Description. The `plot_spin_distribution_2d` function allows to project a spin distribution function from the surface of a unit sphere to the unit disk. QuTiP uses `matplotlib.pyplot.pcolor` to perform this task and calculates a meshgrid `X, Y` to plot the function to. Due to some changes in `matplotlib` the current implementation is deprecated and will return errors in a few minor releases. We could quickly fix this by passing `shading='auto'` to the call of `ax.pcolor()` in the [visualization.py](https://github.com/qutip/qutip/blob/82c6704c6fea8a2801492865ad1ef7c1d73c8840/qutip/visualization.py#L1313). However, this raises another UserWarning that the center points are not monotonically sorted. The cleanest way to fix this bug would be to pass the edges of the quadrilaterals to `pcolor()`. But we can not calculate them exactly from the given points in `theta, phi`. Hence, we would need to redesign the interface to this function and to related functions like `plot_spin_distribution_3d` and `spin_q_function`. ### Code to Reproduce the Bug. ```shell; import qutip as qt; import numpy as np; import matplotlib.pyplot as plt. j = 5; psi = qt.spin_coherent(j, np.random.rand() * np.pi, np.random.rand() * 2 * np.pi); rho = qt.ket2dm(psi). theta = np.linspace(0, np.pi, 50); phi = np.linspace(0, 2 * np.pi, 50). Q, THETA, PHI = qt.spin_q_function(psi, theta, phi); fig, ax = qt.plot_spin_distribution_2d(Q, THETA, PHI); plt.show(); ```. ### Code Output. ```shell; MatplotlibDeprecationWarning: shading='flat' when X and Y have the same dimensions as C is deprecated since 3.3. Either specify the corners of the quadrilaterals with X and Y, or pass shading='auto', 'nearest' or 'gouraud', or set rcParams['pcolor.shading']. This will become an error two minor releases later.; ax.pcolor(X, Y, P.real, cmap=cmap); ```. ### Expected Behaviour. I expect the same plot, but without the warning which becomes an error in the future. ### Your Environment. ```shell; QuTiP Version: 5.0.0.de",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1973:202,perform,perform,202,https://qutip.org,https://github.com/qutip/qutip/issues/1973,1,['perform'],['perform']
Performance,"### Bug Description. The concurrence measure does not work with density matrix objects. ### Code to Reproduce the Bug. ```shell; import qutip. dm = qutip.maximally_mixed_dm(4); print(dm); print(qutip.entropy.concurrence(dm)); ```. ### Code Output. ```shell; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0.25 0. 0. 0. ]; [0. 0.25 0. 0. ]; [0. 0. 0.25 0. ]; [0. 0. 0. 0.25]]. raise Exception(""Density matrix must be tensor product of two qubits.""); Exception: Density matrix must be tensor product of two qubits.; ```. ### Expected Behaviour. One of two things is happening:; 1. The concurrence method is not compatible with the density matrix Qobj objects. I am not certain why this concurrence method requires [[2, 2], [2, 2]] dimensions instead of [4,4] if the concurrence method is acting on 2 qubit systems.; 2. The density matrix generators are not producing matrices which are consistent with the qutip required format. I tried this on other matrices by just casting numpy arrays to Qobj objects and I got the same error. . ### Your Environment. ```shell; QuTiP Version: 4.7.1; Numpy Version: 1.21.5; Scipy Version: 1.9.1; Cython Version: 0.29.32; Matplotlib Version: 3.5.2; Python Version: 3.9.13; Number of CPUs: 10; BLAS Info: OPENBLAS; OPENMP Installed: False; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2058:25,concurren,concurrence,25,https://qutip.org,https://github.com/qutip/qutip/issues/2058,5,['concurren'],['concurrence']
Performance,"### Bug Description. This issue originates from a [problem in the Help Group](https://groups.google.com/g/qutip/c/F7tOoZzMjto). Calculating the entropy of a density matrix in the Dicke basis leads to -Inf, while the standard calculation with ""entropy_vn"" returns a finite (more logical) result. ; I already tracked down the problem to the calculation of eigenvalues in `dicke_trace_function`. Due to numerical behaviour some eigenvalues have very small negative values, which lead to -Inf entropy. If these values are rounded to zero, the problem disappears. However, I am not sure, which way is the best way to perform this rounding. ; @nathanshammah @quantshah . ### Code to Reproduce the Bug. ```shell; from qutip import *; from qutip.piqs import *; import numpy as np; import numpy.random; from scipy.linalg import eig; from scipy.sparse import block_diag. N = 10; system = Dicke(N); [jx, jy, jz] = jspin(N,basis=""dicke""); jx=jx*2; jy=jy*2; jz=jz*2. V=3; g=1; system.emission = 1; system.hamiltonian = V/(2*(N-1)) * jz*jz + g/2 * jx; D_tls = system.liouvillian(); rho_ss = steadystate(D_tls,method='eigen',); vn_dicke=entropy_vn_dicke(rho_ss); vn_dicke_over=entropy_vn(Qobj(block_diag(dicke_blocks_full(rho_ss)))). print(vn_dicke,vn_dicke_over); ```. ### Code Output. ```shell; -inf 0.006061297461844266; ```. ### Expected Behaviour. The value for the entropy should not depend on the way it is calculated. I.e., we should have `vn_dicke == vn_dicke_over` up to numerical uncertainty. ### Your Environment. ```shell; uTiP Version: 5.0.0.dev0+ee51e50; Numpy Version: 1.21.0; Scipy Version: 1.6.2; Cython Version: 0.29.23; Matplotlib Version: 3.3.4; Python Version: 3.8.10; Number of CPUs: 4; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1919:612,perform,perform,612,https://qutip.org,https://github.com/qutip/qutip/issues/1919,1,['perform'],['perform']
Performance,"### Bug Description. Using `Python 3.12.2` and `Poetry 1.7.1`, when adding `qutip` as a dependency, the installation fails. ### Code to Reproduce the Bug. ```shell; poetry add qutip; ```. ### Code Output. ```shell; Updating dependencies; Resolving dependencies... (0.2s). Package operations: 4 installs, 0 updates, 0 removals. • Installing numpy (1.26.4); • Installing packaging (23.2); • Installing scipy (1.12.0); • Installing qutip (4.7.5): Failed. ChefBuildError. Backend subprocess exited when trying to invoke build_wheel. [...]. building 'qutip.cy.cqobjevo_factor' extension; error: Microsoft Visual C++ 14.0 or greater is required. Get it with ""Microsoft C++ Build Tools"": https://visualstudio.microsoft.com/visual-cpp-build-tools/. at ~\AppData\Roaming\pypoetry\venv\Lib\site-packages\poetry\installation\chef.py:164 in _prepare; 160│; 161│ error = ChefBuildError(""\n\n"".join(message_parts)); 162│; 163│ if error is not None:; → 164│ raise error from None; 165│; 166│ return path; 167│; 168│ def _prepare_sdist(self, archive: Path, destination: Path | None = None) -> Path:. Note: This error originates from the build backend, and is likely not a problem with poetry but with qutip (4.7.5) not supporting PEP 517 builds. You can verify this by running 'pip wheel --no-cache-dir --use-pep517 ""qutip (==4.7.5)""'.; ```. ### Expected Behaviour. Installing qutip successfully. ### Your Environment. ```shell; QuTiP version: 4.7.5; Python version: 3.12.2; Poetry version: 1.7.1; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2322:1277,cache,cache-dir,1277,https://qutip.org,https://github.com/qutip/qutip/issues/2322,1,['cache'],['cache-dir']
Performance,"### Bug Description. When trying to perform a trivial partial trace (of a ket) when no subsystem is traced over (all subsystems are kept), the result is a ket. ### Code to Reproduce the Bug. ```shell; from qutip import tensor,basis; psi = tensor(basis(2, 0), basis(2, 1)); print(psi.ptrace([0,1])); ```. ### Code Output. ```shell; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]; ```. ### Expected Behaviour. A density operator should be returned for consistency. The documentation (https://qutip.org/docs/latest/guide/guide-tensor.html) also mentions that: . > Note that the partial trace always results in a density matrix (mixed state), regardless of whether the composite system is a pure state (described by a state vector) or a mixed state (described by a density matrix). ### Your Environment. ```shell; QuTiP version: 4.7.1; ```. ### Additional Context. The issue seems to originate in _ptrace_dense (see https://qutip.org/docs/latest/modules/qutip/qobj.html), where the following code appears:; ```; if not dtrace:; # If we are keeping all dimensions, no need to construct an ndarray.; return Q.copy(); ```; A projector onto the state should be returned here instead of the copy of the state.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2129:36,perform,perform,36,https://qutip.org,https://github.com/qutip/qutip/issues/2129,1,['perform'],['perform']
Performance,"### Bug Description. When using qutip integrators with `mcsolve`, parallelizing fails with both `parallel` and `loky` map methods when one doesn't use improved sampling. Also, a side note - memory consumption seems to have gotten worse in setting up the mcsolve problem in v5.0 as compared to v4.7. I can provide some benchmarks later, but I am unable to go to similar truncation sizes as I could before. ### Code to Reproduce the Bug. ```py; import qutip as qp; import numpy as np; N = 2; a1 = qp.tensor(qp.destroy(N), qp.qeye(N)); a2 = qp.tensor(qp.qeye(N), qp.destroy(N)); H = -1j * 0.4 * ((a1.dag()*a1.dag() - a1 * a1) + (a2.dag()*a2.dag() - a2*a2)); psi01 = qp.tensor(qp.states.basis(N, 0), qp.states.basis(N, 0)); tlist = np.linspace(0.0, 30.0, 501); c_ops = [np.sqrt(5)*a1*a1, np.sqrt(5)*a2*a2]; result = qp.mcsolve(H, psi01, tlist, c_ops, ntraj=500, options=dict(map=""parallel"", method=""vern9"", improved_sampling=False)); ```. ### Code Output. ```shell; ---------------------------------------------------------------------------; _RemoteTraceback Traceback (most recent call last); _RemoteTraceback: ; """"""; Traceback (most recent call last):; File ""/lib/python3.10/multiprocessing/queues.py"", line 245, in _feed; obj = _ForkingPickler.dumps(obj); File ""/lib/python3.10/multiprocessing/reduction.py"", line 51, in dumps; cls(buf, protocol).dump(obj); File ""<stringsource>"", line 2, in View.MemoryView._memoryviewslice.__reduce_cython__; TypeError: no default __reduce__ due to non-trivial __cinit__; ```. ### Expected Behaviour. Parallelizing should work independently of the sampling method. . ### Your Environment. ```shell; QuTiP Version: 5.0.2; Numpy Version: 1.26.4; Scipy Version: 1.12.0; Cython Version: None; Matplotlib Version: 3.9.0; Python Version: 3.10.4; Number of CPUs: 8; BLAS Info: Generic; INTEL MKL Ext: False; Platform Info: Darwin (arm64); ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2450:1190,queue,queues,1190,https://qutip.org,https://github.com/qutip/qutip/issues/2450,1,['queue'],['queues']
Performance,"### Bug Description. While benchmarking [dynamiqs](https://github.com/dynamiqs/dynamiqs) vs QuTiP, I've noticed a large performance drop of `qutip.mesolve` when going from v4.7.6 to v5.0.1. On the example below, the benchmarks show:; ```; # QuTiP 4.7.6; # 1.42 s ± 3.17 ms per loop (mean ± std. dev. of 7 runs, 1 loop each); # QuTiP 5.0.1; # 14.5 s ± 2.32 s per loop (mean ± std. dev. of 7 runs, 1 loop each); ```; Found similar behavior on two different CPUs (mac M2, and AMD Ryzen 7). ### Code to Reproduce the Bug. ```python; import timeit. import numpy as np; import qutip as qt. def init(; kappa_2: float = 1.0,; g_cnot: float = 0.3,; nbar: float = 4.0,; num_tsave: int = 100,; N: int = 16,; ):; # time evolution; alpha = np.sqrt(nbar); gate_time = np.pi / (4 * alpha * g_cnot); tlist = np.linspace(0.0, gate_time, num_tsave). # operators; ac = qt.tensor(qt.destroy(N), qt.qeye(N)); nt = qt.tensor(qt.qeye(N), qt.num(N)). # Hamiltonian; H = g_cnot * (ac + ac.dag()) * (nt - nbar). # collapse operators; c_ops = [np.sqrt(kappa_2) * (ac**2 - nbar)]. # initial state; plus = (qt.coherent(N, alpha) + qt.coherent(N, -alpha)).unit(); psi0 = qt.tensor(plus, plus). kwargs = {'H': H, 'rho0': psi0, 'tlist': tlist, 'c_ops': c_ops}; return kwargs. kwargs = init(); %timeit qt.mesolve(**kwargs); ```. ### Your Environment. ```shell; Numpy Version: 1.25.2; Scipy Version: 1.11.2; Cython Version: 0.29.37; Matplotlib Version: 3.7.2; Python Version: 3.11.4; Number of CPUs: 8; BLAS Info: OPENBLAS; INTEL MKL Ext: False; Platform Info: Darwin (arm64); ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2406:120,perform,performance,120,https://qutip.org,https://github.com/qutip/qutip/issues/2406,1,['perform'],['performance']
Performance,"### Describe the Issue!. Hi, is it possible to illustrate an example code in which a quantum circuit is taken as an input and the qiskit backend properties are feed to a custom compiler to perform noisy simulation?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1923:189,perform,perform,189,https://qutip.org,https://github.com/qutip/qutip/issues/1923,1,['perform'],['perform']
Performance,"### Describe the Issue!. Hi,. I am studying quantum computers and quantum algorithms to solve combinatorial optimization problems. I wonder if I can use qutip to simulate quantum computers and algorithms ?. If yes, what are the main differences between qutip and the [pennylane](https://pennylane.ai/) framework ?. Regards",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2030:108,optimiz,optimization,108,https://qutip.org,https://github.com/qutip/qutip/issues/2030,1,['optimiz'],['optimization']
Performance,"### Describe the Issue!. I am currently using Qutip 5.0 prerelease. When performing calculations involving 4-mode operators like $e^{A\otimes B\otimes C\otimes D}$, and setting the Hilbert space dimension to be N=7, it takes forever to finish! However, when I use Qutip 4.7, it takes only 1 second to finish same calculations with N=20... This is giving me a serious problem because I need the .logm() function from Qutip 5.0... Anyone facing the same problem? Would be nice if someone can help me :)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2115:73,perform,performing,73,https://qutip.org,https://github.com/qutip/qutip/issues/2115,1,['perform'],['performing']
Performance,"### Describe the Issue!. I'm trying to follow the [CRAB / pulse optimizer tutorial](https://github.com/qutip/qutip-notebooks/blob/master/examples/control-pulseoptim-CRAB-QFT.ipynb) but realize that my Hamiltonian takes a slightly different form than the control form (""H_c"") they use. They use a list of QObjs w/ variable amplitude, whereas my Hamiltonian has the following term which seems challenging to input:. $$ ; f_j(t) (a_j e^{-i \phi_j(t)} - a^\dagger_j e^{i \phi_j(t)}); $$. Even for $j \in [1]$ only, how can I make it so that this term has two controls, one which controls the amplitude and one which controls the phase?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2297:64,optimiz,optimizer,64,https://qutip.org,https://github.com/qutip/qutip/issues/2297,1,['optimiz'],['optimizer']
Performance,"### Objective; The primary objective was to improve the computational efficiency of the `correlation_2op_1t` function in QuTiP. This function computes two-time correlations for quantum systems, which is computationally intensive, especially for large systems or long time arrays. The goal was to enhance performance by parallelizing these computations. ### Enhancements Overview. 1. **Parallel Computing**:; - **Implementation**: Utilized Python’s `concurrent.futures` module, specifically `ProcessPoolExecutor`, to parallelize the computation of correlation values over different tau values (`taulist`). Each tau value computation is independent of others, making this a suitable case for parallel execution.; - **Function Splitting**: Created a helper function `compute_single_tau_correlation` to handle the computation for a single tau. This function manages the setup of the quantum system, computes the correlation for its specific tau, and handles any exceptions that may occur, logging them accordingly.; - **Resource Management**: Used the `cpu_count` from the `os` module to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing T",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:304,perform,performance,304,https://qutip.org,https://github.com/qutip/qutip/pull/2395,2,"['concurren', 'perform']","['concurrent', 'performance']"
Performance,"### Problem Description. Hello, I am recently using `qt.propagator ` to calculate the time evolution of states with collapse operators. I am having memory usage problem due to qutip's matrix conversion.; This matrix conversion is especially memory intensive when performing propagator calculation with collapse operators. Current qutip propagator uses numpy array to store the **raw calculation data**.; `u = np.zeros([N * N, N * N, len(tlist)], dtype=complex)`. Qutip then converts matrices at each time list t at the end of this function.; ```; if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; ```. This conversion effectively requires the same memory usage as ""u"".; This behavior is problematic when raw results `u` consumes a lot of memory.; I would be happy if there is an optional argument to skip `Qobj(u[k])` process. ### Proposed Solution. Add a feature to select if qt.propagator performs conversion to Qobj or just return numpy array.; Rewrite the code of ""qutip/propagator.py"" around line 221 something like. ```; if not skip_qutip_conversion:; out = np.empty((len(tlist),), dtype=object); if unitary_mode == 'batch':; out[:] = [Qobj(u[k], dims=dims) for k in range(len(tlist))]; else:; out[:] = [Qobj(u[:, :, k], dims=dims) for k in range(len(tlist))]; else:; out = u; return out; ```. ### Alternate Solutions. _No response_. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2312:263,perform,performing,263,https://qutip.org,https://github.com/qutip/qutip/issues/2312,2,['perform'],"['performing', 'performs']"
Performance,"### Problem Description. Now that qutip-qip has moved to another package, gates are not available in the main repo. This is inconvenient for examples such as the control optimization ones, where one would need to install the qutip-qip package just to access say the Hadamard or CNOT for instance. ### Proposed Solution. The easiest solution would be just to copy the `gates.py` file from the QIP package into the main repo. Perhaps might confuse imports in qip? Also, I think that file has func defs that refer to 'controls' that might not make sense in this repo. ### Alternate Solutions. Have a file called `operations.py`. Just have a subset of the gates (operations), the most typical named unitaries - sounds less QIP like and would avoid import confusion. I think also `hadamard_transform` could be shortened to `hadamard`, but also include the original name. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2389:170,optimiz,optimization,170,https://qutip.org,https://github.com/qutip/qutip/issues/2389,1,['optimiz'],['optimization']
Performance,"### Problem Description. String based coefficients with time-dependent Hamiltonians in qutip 4.7 causes compiled files (.so, .o, .cpp files) to be stored into a hidden folder `.pyxbld` in the user's home directory. This is a problem because, when using qutip on an HPC cluster (the cluster uses Red Hat Enterprise Linux 8), I submit multiple qutip simulation jobs to the cluster, each of which generating cached file in my home directory and using up my storage. Qutip is not aware of these files and they are never deleted. The root cause of the problem is in the top level __init__.py, on line 72, `_pyxbuilder.install()`, which calls the install() function in qutip.cy.pyxbuilder, on line 47:. ```; def install():; """"""Install the pyximport interface.""""""; return pyximport.install(setup_args={'include_dirs': [np.get_include()]}); ```; Since the `build_dir` keyword argument is not supplied to `pyximport.install`, the default path is used. ### Proposed Solution. Supply an option in `qutip.settings`, or `qutiprc`, or `qutip.solver.Options` to specify a custom path for the compiled files. This path is then passed to `pyximport.install` as the `build_dir` argument when `__init__.py` is run, upon first import of qutip. ### Alternate Solutions. _No response_. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2230:405,cache,cached,405,https://qutip.org,https://github.com/qutip/qutip/issues/2230,1,['cache'],['cached']
Performance,"### Problem Description. The following paper was published a few week ago: [Arnoldi-Lindblad time evolution: Faster-than-the-clock algorithm for the spectrum of time-independent and Floquet open quantum systems](https://quantum-journal.org/papers/q-2022-02-10-649/). The results show an speed-up in the diagonalisation of arbitrary Liouvillian operators. It might be interesting to keep an eye on this and possibly implement it in the future. ### Proposed Solution. The authors themselves (@DHuybrechts) have uploaded the code used for the paper at https://github.com/DHuybrechts/Arnoldi-Lindblad-time-evolution so. if they agree, it would just imply organizing and possibly optimizing their code. ### Alternate Solutions. _No response_. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1833:675,optimiz,optimizing,675,https://qutip.org,https://github.com/qutip/qutip/issues/1833,1,['optimiz'],['optimizing']
Performance,"### Problem Description. `Qobj` and `QobjEvo` have the new property dtype that can greatly affect performance.; However, this new information can be hard to find. Having it included in the output of `__repr__` could help. ### Proposed Solution. An an dtype entry in `Qobj._str_header`. ### Alternate Solutions. _No response_. ### Additional Context. First advanced in #2328.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2339:98,perform,performance,98,https://qutip.org,https://github.com/qutip/qutip/issues/2339,1,['perform'],['performance']
Performance,"'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3313,cache,cached,3313,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2253,cache,cached,2253,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"(Apologies: this is a repost from the QuTiP Google group, but since this seems to be a possible bug with mesolve, I figured it was more appropriate to post it here. See the Google post [here](https://groups.google.com/forum/#!topic/qutip/KKqHcZxiAmg) for some images documenting this issue.). Hello,. I'm trying to simulate a system of qubits with a two-pulse periodic Hamiltonian and some dissipation using QuTiP's mesolve function. As a consistency check, I compared the results of setting c_ops = [], and setting c_ops as the zero matrix. These should give the same results, yet for certain basis states, setting c_ops as the zero matrix seems to give the wrong result. Here is a minimum working example that reproduces the effect:. ```; import numpy as np; from qutip import sigmax, sigmaz, mesolve, basis; from scipy import signal, optimize. ### Function definitions. def on_off_signal(t):; """"""; Generate a periodic signal that is +1 for half a period and 0 for the other half.; """""". return (1 + signal.square(2 * np.pi * t))/2. def off_on_signal(t):; """"""; Generate a periodic signal that is 0 for half a period and +1 for the other half.; """""". return (1 - signal.square(2 * np.pi * t))/2. ### Define Hamiltonian. H1 = sigmaz(); H2 = np.pi * sigmax() # H2 applied for time 0.5 results in a full spin flip; H = [[H1, on_off_signal],; [H2, off_on_signal]]. ### Start in a Z basis state. psi0 = basis(2,0). ### Set the collapse operator as the zero matrix (since 1/T_dephasing = 0). T_dephasing = np.inf; c_ops = (1/T_dephasing) * sigmaz(). ### Run simulation. tlist = np.linspace(0, 2, 10000); e_ops = [sigmaz()]; output = mesolve(H, psi0, tlist, c_ops = c_ops, e_ops = e_ops); Z_expectation = output.expect[0]; ```. ### Notes on system:. - The Hamiltonian is periodic and formed of two-pulses.; - H2 applies a full spin flip when applied for time 0.5, so if we start in a Z basis state then Z_expectation should change from +1 to -1 or vice versa. ### Problem:. - When I set c_ops = [], I get the ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/898:837,optimiz,optimize,837,https://qutip.org,https://github.com/qutip/qutip/issues/898,1,['optimiz'],['optimize']
Performance,"**Describe the bug**. Running tests for qutip 4.6.2, on linux (Debian unstable), all tests pass successfully, but overall tests return error code 1, which would be treated as test failure. For instance, running tests via `python3 -c ""import qutip.testing; qutip.testing.run()""`; ```; ============================= test session starts ==============================; platform linux -- Python 3.9.2, pytest-6.0.2, py-1.10.0, pluggy-0.13.0 -- /usr/bin/python3.9; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase('/home/drew/projects/misc/build/qutip/.pybuild/cpython3_3.9_qutip/build-test/.hypothesis/examples'); rootdir: /home/drew/projects/misc/build/qutip; plugins: cov-2.10.1, mpi-0+unknown, doctestplus-0.9.0, remotedata-0.3.2, asyncio-0.14.0, filter-subpackage-0.1.1, arraydiff-0.3, astropy-header-0.1.2, hypothesis-5.43.3, openfiles-0.5.0, xvfb-1.2.0; collecting ... collected 1996 items / 67 deselected / 1 skipped / 1928 selected. qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-real_hermitian] PASSED [ 0%]; qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-imaginary_hermitian] PASSED [ 0%]; qutip/tests/test_basis_transformation.py::test_transformation_to_eigenbasis_is_reversible[2-complex_hermitian] PASSED [ 0%]. ...; qutip/tests/test_wigner.py::test_wigner_fft_comparse_ket PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_fft_comparse_dm PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_clenshaw_iter_dm PASSED [ 99%]; qutip/tests/test_wigner.py::test_wigner_clenshaw_sp_iter_dm PASSED [100%]XIO: fatal IO error 0 (Success) on X server "":1029""; after 201 requests (201 known processed) with 4 events remaining.; ```. As far as I can tell this XIO error is related to the xvfb module (pytest-xvfb) used to manage graphical tests without display. Some relevant discussion is found at https://github.com/The-Compiler/pytest-xvfb/issues/11 . They",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:460,cache,cachedir,460,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cachedir']
Performance,"**Describe the bug**; Currently qutip is requiring scipy > 1.12 and in the CI checks scipy <1.5 is being checked. There was a bug in scipy 1.4 See [.Stackoverflow error](https://stackoverflow.com/questions/54314529/mkl-error-parameter-12-for-large-matrices-with-scipy-linalg-eigvalsh-in-an) , [bug report ](scipy/scipy#8205) that has been fixed by this [solution](scipy/scipy#11304) in the 1.5 release. This is related to the `linalg.eigh() API` which performs eigenvalue calculation, it causes error of this form `Intel MKL ERROR: Parameter 12 was incorrect on entry to ZHBRDB`, which mostly the get silenced, and instead of terminating it just outputs an array of zeros except for the last entry. This issue occurs exclusively when using the API with high dimensional tensors, which are probably not being handled in the tests, but will inevitably cause miscalculations for the users as eigenvalue finding of hermitics is pervasive. **To Reproduce**; Just as an illustration you cun run . `pytest qutip/tests/test_superop_reps.py -s -k SuperChoiChi`. from the codes in #1491 in an environment like the generated for `coverage` tests in the CI. The terminal out put is; ```; qutip/tests/test_superop_reps.py ..; Intel MKL ERROR: Parameter 12 was incorrect on entry to ZHBRDB.; F. ================================================================= FAILURES ==================================================================; _________________________________________________ TestSuperopReps.test_SuperChoiChiSuper[8] _________________________________________________. self = <qutip.tests.test_superop_reps.TestSuperopReps object at 0x7f01d2d5c6d0>, dimension = 8. @pytest.mark.parametrize('dimension', [2, 4, 8]); def test_SuperChoiChiSuper(self, dimension):; """"""; Superoperator: Converting two-qubit superoperator through; Choi and chi representations goes back to right superoperator.; """"""; superoperator = super_tensor(rand_super(dimension), rand_super(dimension)); ; choi_matrix = to_choi(superoper",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1495:452,perform,performs,452,https://qutip.org,https://github.com/qutip/qutip/issues/1495,1,['perform'],['performs']
Performance,"**Describe the bug**; I am trying to find the fidelity of the maximally mixed two qubit state. I got fidelity as one where it should be zero. I am attaching the file and the results. **To Reproduce**; I created a maximally mixed state as 1/2*|00> + 1/2*|01> + 1/2*|10> + 1/2*|11> . I want to check the relation between Concurrence and Fidelity. Concurrence is working correctly, but in case of Fidelity I am facing the issue. I calculated Fidelity using partial trace. Partial traces are giving the same results for both basis (0 and 1) and hence Fidelity is coming as one. ```python; def two_qubit_mixed_state(a, b, c):; ; if (a >= 0 and b >= 0 and c >= 0) and (a*a + b*b + c*c <= 1):; d = math.sqrt(1 - (a*a + b*b + c*c)); ; if d >= 0:; i = tensor(basis(2, 0), basis(2, 0)); j = tensor(basis(2, 0), basis(2, 1)); k = tensor(basis(2, 1), basis(2, 0)); l = tensor(basis(2, 1), basis(2, 1)); ; obj = a*i + b*j + c*k + d*l; pa = obj.ptrace(0); pb = obj.ptrace(1); qstate1 = (ket2dm(obj)); ; concurrence_measure = concurrence(qstate1); ; fidelity_m = fidelity(pa, pb); ; print(qstate1); print(pa); print(pb); print(concurrence_measure); print(fidelity_m); return obj; ; two_qubit_mixed_state(1/2, 1/2, 1/2)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1423:319,Concurren,Concurrence,319,https://qutip.org,https://github.com/qutip/qutip/issues/1423,3,"['Concurren', 'concurren']","['Concurrence', 'concurrence']"
Performance,"**Describe the issue**; In `mesolve`, all the intermediate result for each `t` in the `tlist` will be saved. If the given `tlist` is very long, this can be a bottleneck for time and memory. In the `Option` class, there is an option `store_states`, but it does not work as I expected. Setting it to False does not turn this off. https://github.com/qutip/qutip/blob/7a73b136cb74f832cf19f15e93c7268244674bdb/qutip/mesolve.py#L461-L463. According to the code above, there is no way to completely turn this off. One has to either save expectation values or save the intermediate states. **To Reproduce**; ```; from qutip import *; import numpy as np. options = Options(); options.store_states = False; print(options.store_states); result = mesolve(sigmax(), basis(2,0), np.linspace(0,1,10), options=options); print(options.store_states); ```; gives; ```; False; True; ```. @Ericgig @jakelishman",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1437:158,bottleneck,bottleneck,158,https://qutip.org,https://github.com/qutip/qutip/issues/1437,1,['bottleneck'],['bottleneck']
Performance,"**Description**. - Add the `reset` function to `qutip.settings` that is described in the documentation but was never implemented. ; - Add `save`, `load` to `qutip.settings`, allowing to save in alternate files.; - The list of configuration that can be saved in qutiprc is generated when loading the module.; - Ungraded the `configrc` functionalities to allow other filenames and support more than a few hard coded `qutip.settings`'s keys.; - Reading `qutiprc` will raise warning instead of errors when unknown keys. So if we remove keys in v5, old file will not cause crashes when importing qutip for the few that use qutiprc. . **Changelog**; Add `reset` to `qutip.settings`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1289:147,load,load,147,https://qutip.org,https://github.com/qutip/qutip/pull/1289,2,['load'],"['load', 'loading']"
Performance,"**Description**. Speed up `steadystate`, mainly for the `direct` method with the `dia` method, but some of the optimization affect most calls. - liouvillian(H) + lindblad_dissipator(c_ops) is slower that liouvillian(H, c_ops) by about 2x.; - Dia are bad with vectors, the `kron(bra, ket)` in `_steadystate_direct` alone was ~90% of the compute time. Using `CSR` instead is much faster.; - Dia to CSR conversion are about made 100x faster. Overall, the timing for `Dia` is about 20x faster and 10% faster for `CSR`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2254:111,optimiz,optimization,111,https://qutip.org,https://github.com/qutip/qutip/pull/2254,1,['optimiz'],['optimization']
Performance,"**Description**; - Added the possibility of providing a custom initial pulse in qutip.control functions. The user can now use the following syntax:. ```; init_pulse_params = {}; init_pulse_params['init_custom_pulse'] = my_init_pulse_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; init_pulse_type='CUSTOM', init_pulse_params=init_pulse_params); ```; The custom array should be passed in the init_pulse_params dictionnary, and should be of size (n_tslots x n_ctrls). - Added the possibility of giving a different upper and lower bound for every control at every time slot, instead of a single bound for all controls and all time slots. The upper and lower bound should be arrays of size (n_tslots x n_ctrls). The syntax is the following:; ```; lbound = np.zeros((num_tslots, num_ctrls)); lbound = my_lbound_array; ubound = np.zeros((num_tslots, num_ctrls)); ubound = my_ubound_array. # Run some optimization; result = optimize_pulse(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; amp_lbound = lbound, amp_ubound = ubound); ```. **Changelog**; Added new features for initial pulses to the qutip.control functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1369:251,optimiz,optimization,251,https://qutip.org,https://github.com/qutip/qutip/pull/1369,2,['optimiz'],['optimization']
Performance,"**Description**; A bug in the CSS of the readthedocs Sphinx theme causes equation numbers to be rendered *above* the equation, which is both surprising and looks terrible. This PR applies fixes that have been languishing in the RTD theme GitHub pull request queue. While working on this I discovered that our `site.css` file was not actually included in our generated HTML pages, so I added it in. **Related issues or PRs**; * RTD theme issue: https://github.com/readthedocs/sphinx_rtd_theme/issues/301; * RTD theme fix: https://github.com/readthedocs/sphinx_rtd_theme/pull/383/. **Changelog**; Fix the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1678:258,queue,queue,258,https://qutip.org,https://github.com/qutip/qutip/pull/1678,1,['queue'],['queue']
Performance,"**Description**; A gate (pulse) scheduler for quantum circuits (instructions). It schedules a `QubitCircuit` or a list of instructions to reduce the total execution time by exciting them parallelly. It uses heuristic methods mainly from https://doi.org/10.1117/12.666419. The scheduler aims at pulse schedule and therefore does not consider merging gates to reduce the gates number. It assumes that the input circuit is optimized at the gate level (e.g. has a minimal number of CNOT gates) and matches the hardware topology. The scheduler includes two methods, ""ASAP"", as soon as possible, and ""ALAP"", as late as possible. The later is commonly used in quantum computation because of the finite lifetime of qubits. **Methods**. - The scheduler first generates a quantum gates dependency graph, containing information about which gates have to be executed before some other gates because they do not commute. The graph preserves the mobility of the gates, i.e. commuting gates are not dependent on each other, even if they use the same qubits. ; - Next, it computes the longest distance of each node to the start and end nodes. The distance for each dependency arrow is defined by the execution time of the instruction (By default, it is 1 for all gates). This is used as a priority measure in the next step. The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; - In the last step, it uses a list-schedule algorithm with hardware constraint (e.g. gates using the same qubits) and priority and returns a list of cycles for gates.; - Since it's heuristics, sometimes it does not find the optimal. It offers an option that randomly shuffles the gates (if commuting) and repeats the scheduling a few times to get a better result. For scheduling quantum instructions, of which the runtime of different gates might differ, an additional step is required to compute the scheduled start time of each instruction.; It adds the additional dependency caus",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1273:420,optimiz,optimized,420,https://qutip.org,https://github.com/qutip/qutip/pull/1273,1,['optimiz'],['optimized']
Performance,"**Description**; Added one new public function `local_multiply_dense` in a new file qutip/qip/operations/local_operations.py, and tests at tests/test_local_operations.py. This can dramatically improve the speed for performing certain matrix multiplications, taking advantage the new Dense data layer. In particular, for cases where the density matrix/state has few zero's, and we want to multiply a local operator (e.g. one acting on only a small subset of the full system), this routine is expected to be faster. **What is does**; Using some standard tools, such as NumPy's einsum one can compute the local matrix operation directly, i.e. applying a one or two-local gate on a Qobj of many qubits. This is only really useful if one uses the Dense data layer, since otherwise there are conversion overheads which kill any speed-up (at the end of the day, we need NumPy arrays). The code has two 'backends', one using einsum as mentioned, and another using what I call a 'vectorization' approach (where the density matrix or vector is reshaped to a vector over the target qubits). Note: It will work on qudits in general (does not have to be qubits). **Performance**; I find, in systems where the state is dense (few zeros), one can get a speed-up of between 2 and up to around 10x faster (depends on the size and system etc). Of course, sometimes using the standard built in sparse routines are faster, so it really depends what one is doing. Attached is a wall-clock time comparison between the standard sparse way for a 1-local multiplication on a vector (using `gate_expand_1toN`), and the added code (dense local). N being the number of qubits. Here I made things as hard as possible for the sparse routine (all elements non-zero), so this is probably the limit of the speed-up. ![1_local_vector_adaptive_backend](https://user-images.githubusercontent.com/47875526/101932409-91f44900-3b8f-11eb-8b5b-7a00dabec2e4.png). **Other notes**; 1. I am a contractor for NASA, and they required a slight chan",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405:215,perform,performing,215,https://qutip.org,https://github.com/qutip/qutip/pull/1405,1,['perform'],['performing']
Performance,"**Description**; Added the possibility of providing a custom initial pulse in qutip.control functions. The user can now use the following syntax:; ```; init_pulse_params = {}; init_pulse_params['init_custom_pulse'] = my_init_pulse_array. # Run optimization; result = optimize_pulse_unitary(H_drift, H_control, uni_ini, uni_targ,; num_tslots, gate_time, ; init_pulse_type='CUSTOM', init_pulse_params=init_pulse_params); ```; when calling functions such as optimize_pulse_unitary() or optimize_pulse(). The custom array should be passed in the init_pulse_params dictionnary, and should be of size (n_tslots x n_ctrls). **Changelog**; Added the possibility of providing a custom initial pulse in qutip.control functions.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1367:244,optimiz,optimization,244,https://qutip.org,https://github.com/qutip/qutip/pull/1367,1,['optimiz'],['optimization']
Performance,"**Description**; Allow the dispatcher to accept specialisations on generic `Data`.; This as 2 uses:; - Simplify the creation of complex function using simpler ones: `inner` defined in term of `matmul`. ; - Allow us to create niche dispatched functions for some data layer without the need to be supported by all: blas' zgemm (matmul) can transpose and adjoint of each input matrix in the same operation. . The `Data` dispatched functions have less priority than direct specialization. They are used directly (no `_constructed_specialisation`) when the `Data` is in the inputs, but when the output data type is set, there will always be a conversion from `Data` to the desired type. . In this PR:; - Add dispatch on `Data`.; - Add direct tests for the dispatcher.; - Create `kron_transpose` which is `kron(left.T, tright)`. It's commonly used for superoperator and it can be optimized for `Dense` and `Jax` by doing it in one operation.; - Add `Data` specialization for `inner`, `inner_op`, `expect`, `expect_super` and `trace_oper_ket`.; - Make `zeros_like` and `identity_like` as dispatched function so the order is kept during operation for dense.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2157:874,optimiz,optimized,874,https://qutip.org,https://github.com/qutip/qutip/pull/2157,1,['optimiz'],['optimized']
Performance,"**Description**; Another cython release, another fix needed... The missing type definition in `dia.diags_` was causing an error during the cythonize step. The other changes are related to the new ""performance hint"".; `nogil` and `except *` do not work well together.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2247:197,perform,performance,197,https://qutip.org,https://github.com/qutip/qutip/pull/2247,1,['perform'],['performance']
Performance,"**Description**; Before this fix the following two situations were incosinsten:; ```python; matrix = np.random.random((2, 2)); qobj = qutip.Qobj(array). qobj * matrix # This would perform a matrix multiplication as `__mul__` tries to convert matrix into `Qobj`.; matrix * qobj # This would raise an error as `__rmul__` assumed that matrix was a `Qobj`.; ```. I assumed that `qobj * matrix` behaviour is the correct one as it is explicitly programmed to work like that. With this fix `matrix * qobj` will first try to convert matrix to `Qobj` and perform a matmul between matrix and `Qobj`. **Related issues or PRs**; Issue #1607 is related to this although this PR does not close that issue. **Changelog**; __rmul__ now accepts as `other` an array_like that is understood by `Qobj`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611:180,perform,perform,180,https://qutip.org,https://github.com/qutip/qutip/pull/1611,2,['perform'],['perform']
Performance,"**Description**; I optimized the dispatched by only supporting positional arguments for matrix to dispatch on:. The dispatcher was supporting any signature for dispatched functions.; Since each dispatchers is an instance of the `Dispatcher` class and cython does not support patching methods, it had to find the inputs matrix to convert from `__call__(*args, **kwargs)` and re-implemented the `_bind` method to do so.; But all our dispatched functions have the matrix as the first positional argument, by embracing this we get a nice speed up for small matrices. Also when the specialization existed, it would not call it directly, but call a `_constructed_specialisation` that called ti. Adding another unneeded layer to each calls. This was changed so it would call the function directly. For a 2x2 matrix:; | | Before | After |; |------------------|--------|-------|; | data.add_dense | 214ns | 210ns |; | data.add (dense) | 774ns | 388ns |; | data.add[Dense, Dense] | 541ns | 182ns |; | data.add_csr | 429ns | 447ns |; | data.add (csr) | 986ns | 649ns |; | data.add[CSR. CSR] | 744ns | 401ns |; | numpy | 473ns | - |. Sadly it will not improve the benchmarks that much since the `Qobj` operations overhead is quite large:; | | Before | After |; |------------------|--------|-------|; | Qboj + Qobj (dense) | 2430ns | 2070ns |; | Qboj + Qobj (csr) | 3070ns | 2330ns |",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2135:19,optimiz,optimized,19,https://qutip.org,https://github.com/qutip/qutip/pull/2135,1,['optimiz'],['optimized']
Performance,"**Description**; Make our integrator re-entrant. Scipy'ode is can only have one active instance active for some of the methods. This cuased no issue when the whole integration is done at once as when used in `mesolve`. But with solver as class, this mean using them will have side effect on other solver instances. This PR make the check for concurrent integrator usage before scipy does and force a reset if needed. Switching between system will be inefficient, but will return the expected results. In lsoda's integrator's `_backstep` we are catching a warning before acting on it, but catching the warnings still printed them at the end of tests, bloating the output. In this PR, I also do the check before scipy does so the warning is never raised. **Related issues or PRs**; Point raised in discussion with @hodgestar and @AGaliciaMartinez on #1710 . **Changelog**; Front run some safety check in scipy.ode",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1734:342,concurren,concurrent,342,https://qutip.org,https://github.com/qutip/qutip/pull/1734,1,['concurren'],['concurrent']
Performance,"**Description**; Merge `QobjEvo`, `cQobjEvo`, `QobjEvoFunc` into one cython class. (#1468). This remove the need to have both keep 2 objects (`QobjEvo`, `cQobjEvo`) by solver and the need to support 3 classes. It support any format for time-dependant system accepted by `mesolve`.; It keeps mostly the same interface as the present `QobjEvo`, the biggest changes being:; - `QobjEvo.mul_vec`, `QobjEvo.solver_set_args`, `QobjEvo._cdc` removed.; - `QobjEvo.mul` renamed to `QobjEvo.matmul` and only accept `Qobj` input (from `Qobj`, `Data`, `np.array`); - `QobjEvo.expect` only accept `Qobj` input (from `Qobj`, `Data`, `np.array`); - `cQobjEvo.matmul_dense` and `cQobjEvo.expect_dense` removed, use the `_data` version instead, they have optimization for `Dense` included.; - Some of `QobjEvo`'s attributes are no longer accessible: `cte`, `ops`. Instead of `A.cte.dims`, simply use `A.dims`. Same for `shape`, `issuper` and `isoper`.; - `shift` renamed to `_insert_time_shift`. It is meant for use in correlation only so I renamed to a longer name. . Internally, some of the logic have been moved to an `Element` class (pair `Qobj`, `Coefficient`) to support function format.; `matmul` is there to support the bloch redfield tensor. Function based `QobjEvo` reuse calls to the function: ; With `cdc = QobjEvo(f).dag() * QobjEvo(f)`, `cdc(t)` will call `f` only once. This remove the need of special code of `QobjEvoFunc` in superoperator. . ##### Leftover issues; The class keep a copy of `args` only for the `__call__(self, t, args)` method, since the coefficient have their own copy of `args`. It could be removed if we remove that functionality.; While coefficient with different `args` can be mixed, function cannot.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481:737,optimiz,optimization,737,https://qutip.org,https://github.com/qutip/qutip/pull/1481,1,['optimiz'],['optimization']
Performance,"**Description**; Replacing the v4 solver for v5's one as the default solver in dev.major is still a ~40 files PR, so I am making the transition in block, starting by propagator and scattering. **propagator.py:**; The function call the new solver and remove some options:; - batch: useless since __solve can evolve a propagator.; - parallel: Could still be useful, until we restore openmp support for data-layer, but should be managed by the data layer in v5.; - progress_bar: Now in options.; This result in a much simpler function. Add a new class `Propagator`, which replace the `Evolver` in scattering.; Like solver classes, it split the setup and utilization:; ```; U = Propagator(H); psi_t = U(t) @ psi_0; psi_t2 = U(t2, t) @ psi_t; ```; It save previous calls for efficiency, somewhat support `args`. It's not a `QobjEvo`, to support propagators with 2 times, but can be made one. **scattering.py:**; - `Evolver` replaced by the previous `Propagator`.; - matrix-matrix product are replaced by matrix-vector product in photon scattering computation.; - Do no create a `Qobj` to extract one value from an array.; This result in a speed up of about 5 times faster for even small (N=10) operators. **Changelog**; Rework propagator to use v5 solver and add a Propagator class.; Optimize scattering functions",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1792:1279,Optimiz,Optimize,1279,https://qutip.org,https://github.com/qutip/qutip/pull/1792,1,['Optimiz'],['Optimize']
Performance,"**Description**; The more flexible base class adds:. - a list of state processors that store the state or e_ops values (but could also do other things); - a ``_post_init`` method that allows a result sub-class to override what processors are configured; - helper methods ``_store_state``, ``_store_final_state``, ``_pre_copy`` and ``_e_op_func`` that sub-classes can override if they use states that are not ``Qobj``.; - a ``.e_ops`` attribute that stores a dictionary of ``ExpectOP`` instances where ``.e_ops[k](t, state)`` will calculate the expected value and ``.e_ops[k].op`` returns the original object used to create the e_op.; - a ``.e_data`` attribute that store the ``.expect`` values as a dictionary rather than a list, so that ``.e_data[k]`` is ``.expect[i]``. Other changes:. - the normalization of states is now performed in the base solver class, rather than in results.; - the solver ``stats`` passed to the results are now *only for that solver .run call* rather than being a strange record of everything the solver has done so far.; These allow:. - The HEOM solver to implement a ``HEOMResult`` class and use the base solver ``.run`` method.; - The normalization of states to be applied when using the ``.step()`` solver method.; - Consistently expose ``.expect`` and a list of results (consistent with QuTiP 4 and useful when turning expectation values into a numpy array); - Provide a dictionary of expectation values via ``.e_data`` so that when e_ops are supplied as a dictionary, the results can be accessed by the same keys, e.g. ``.e_data[""nice-name""]``.; - Possibly allow the MC result classes to be refactored more easily. **Related issues or PRs**; - #1889 -- I think we could implement this PR more easily on top of the refactored result class.; - #1869 -- the v5 HEOM Solver can use much more of the base solver and results class with these changes . **Todo**; - [X] I would like to add more tests for the base result class, but it would be good to get a +1 on the general",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907:825,perform,performed,825,https://qutip.org,https://github.com/qutip/qutip/pull/1907,1,['perform'],['performed']
Performance,"**Description**; The previous code converted both states to density matrices, which is both inefficient and numerically inaccurate. We propose to use the reduced fidelity formula for pure states, given by the modulus of their inner product. **Related issues or PRs**; Related to #361 and #925. Reusing @lucainnocenti example (https://github.com/qutip/qutip/issues/925#issuecomment-542318121):; ```python; import qutip as qt; import numpy as np. A = qt.Qobj(np.array([; 0.867314655330313 - 0.4576338188944636j,; 0.17267952805615244 - 0.09111291375544905j,; 0.013020232894921149 -0.006875138252288391j; ])); B = qt.Qobj(np.array([; 0.9806443568092577, 0.19524328915024022, 0.014720852555238875; ])). fid1 = np.abs(np.vdot(A.full(), B.full())); fid2 = np.abs((A.dag() * B)[0, 0]); fid3 = np.abs(A.overlap(B)); fid_qt = qt.fidelity(A, B); print(f'Correct:\n{fid1}\n{fid2}\n{fid3}'); print(f'Incorrect:\n{fid_qt}'); ```; ```; Correct:; 0.9999999999849929; 0.9999999999849929; 0.9999999999849929; Incorrect:; 1.0000000028441378; ```. Note that this PR does not fix the proposition from @lucainnocenti https://github.com/qutip/qutip/issues/925#issuecomment-542318121 to perform the general computation using `scipy.linalg.svdvals` at the cost of computing the square root of both matrices.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1964:1163,perform,perform,1163,https://qutip.org,https://github.com/qutip/qutip/pull/1964,1,['perform'],['perform']
Performance,"**Description**; There are presently 8 variations of `CQobjEvo`. There are `Cte` and `Td` variants, Dense and csr sparse and serial vs openmp versions. Adding a feature, (ex. AHS support) result in the need to modify all of them and QobjEvoFunc and AHS PRs will add new one. So as a first step, I am merging them the ones presently available.; Cte (no coefficient) are now limit case of Td (time-dependant). omp ones have been removed in favor of a `spmvpy` variant that switch between the serial and omp version at compilation. . Also reworked the compilation of `QobjEvo`:; - Simpler with only 3 variants instead of 8.; - Compilation of the coefficient and object are separated. (`H *= -1j` does not force recompiling the coefficients.); - But have the side effect of making temp file cleanup harder. File are erased at python close instead of object deletion.; - Moved the location of temp file to ~/.qutip/temp for now, but does this work on windows?; - Auto-cleanup on importing qutip, for files older than 7 days for now. But should be set by user, the temp file location also. Other to-do:; Dense versions of CQobjEvo could be more optimized and is not parallel. One option would be to use blas and hope the user's blas is parallel. (probably other PR). ps. Running tests for now. Do not merge.; **Changelog**; Cleaned CObjEvo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1231:1139,optimiz,optimized,1139,https://qutip.org,https://github.com/qutip/qutip/pull/1231,1,['optimiz'],['optimized']
Performance,"**Description**; Update HEOM for v5. Other changes:; - This resulted in a bit of a refactor of the Result class (#1907); - I found a few places where QobjEvo did not correctly set `.type` and fixed those (they were breaking the HEOM tests). Todos and questions:; - [X] Should HierarchyADOsState store ado_state as a Data object rather than a numpy array? (it can't be stored as a Data object because the ADOs have shape `n_ado, n, n` and the Data layer only supports 2-d arrays).; - [X] How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). (implemented); - [X] What should be done with the steady_state method? I guess it can just stay. Should other solvers also have this? (it should just stay, I think); - [x] Recheck the time-dependent case. (I also simplified the time-dependent case so that the Liouvillian is never added and so doesn't have to be subtracted off).; - [X] The HEOM can't really take new QObjEvo arguments each time `run` is called because calculating the RHS again is quite expensive. Maybe something can be done? (implemented -- passing new args to .run is now supported); - [X] In the base solver the new options seem to be set after retrieving the integrator -- is this right? (fixed); - [X] Compare performance to the HEOM in 4.7. (looks faster, yay!); - [X] We could also implement `.start()` and `.step()` for the HEOMSolver. Not quite sure of the use case yet though. (implemented and tested -- the implementation came for free after sorting out having .run inherit from the base solver).; - [x] Add some direct tests for the QobjEvo type errors that have been fixed.; - [x] Moved solver into `qutip.solver.heom`. . **Related issues or PRs**; - One of the todos from #1850; - In #1907 the Result class was changed largely to support extension by the HEOMSolver. **Changelog**; Update HEOM for v5.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869:1366,perform,performance,1366,https://qutip.org,https://github.com/qutip/qutip/pull/1869,1,['perform'],['performance']
Performance,"**Description**; User-facing changes:; - Solver's `Options` defaults can be set `qutip.settings.options`.; - Add the `save`, `load`, `reset` method to Options.; - The default `Options` are read from ""qutiprc"" when loading qutip.; - Options object can be initiated from a saved configuration. Example:; ```; import qutip.setting as qset; from qutip.solver import Options; qset.options.atol = 1e-10; qset.options.max_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Anot",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1297:126,load,load,126,https://qutip.org,https://github.com/qutip/qutip/pull/1297,3,['load'],"['load', 'loading']"
Performance,"**Description**; We use `imatmul_data_dense` for cython only, in-place `matmul` operation since the dispatcher can't handle in-place operation but they can't have nice impact on performance.; `imatmul_data_dense` had a bug that when data is not `Dense` or `CSR` it would use a wrong specialization of `matmul` and raise an error. . It work fine with all data layer in qutip/qutip so we can test it here, but some tests fails in qutip-jax (qutip/qutip-jax#14) because of it. **Related issues or PRs**; Blocking qutip/qutip-jax#14",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2137:178,perform,performance,178,https://qutip.org,https://github.com/qutip/qutip/pull/2137,1,['perform'],['performance']
Performance,"**Description**; When the number of excitations in `state_number_enumerate` is limited, instead of iterating over all states and discarding the ones with too many excitations, directly choose the limits to only iterate over allowed states. As a small additional optimization, do not redo the same sum every time, but keep track of the sum within the algorithm. For the tests I've made, this is a factor of ~4-10 faster than the current version. Together with #1593, this reduces the runtime of `enr_destroy` (which uses `state_number_enumerate`) from almost 4s to 15 ms for the case I just treated, and another much bigger case takes 2.5 s now, while it hadn't finished after more than an hour with the previous version. Note that since the two PRs (this one and #1593) are somewhat related, it might make sense to combine them into a single one. I'd be happy to do that. **Changelog**; Made state_number_enumerate somewhat faster.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1594:262,optimiz,optimization,262,https://qutip.org,https://github.com/qutip/qutip/pull/1594,1,['optimiz'],['optimization']
Performance,"**Description**; `parallel_map` did not propagate error of sub-procceses:; ```; def f(i):; raise Exception; return i. out = qutip.solver.parallel.parallel_map(f, range(5)); ```; would print: ; ```; ERROR:concurrent.futures:exception calling callback for <Future at 0x7fcdfb9b8e50 state=finished raised Exception>; concurrent.futures.process._RemoteTraceback: ; ...; raise Exception; ```; but it would return normally with `out = [None, None, None, None, None]`. This mean we can't use a `try` block to catch error coming from sub-process and only when the output is used, an error is risen. This change `parallel_map` so it raise the first error it encounter.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1969:204,concurren,concurrent,204,https://qutip.org,https://github.com/qutip/qutip/pull/1969,2,['concurren'],['concurrent']
Performance,"**Is your feature request related to a problem? Please describe.**. Sometimes qutip.mesolver generate `rhs_**.pyx` or `cqobjevo_compiled_coeff_**.pyx` files.; According to the docstring of `solver.Options` and `rhs_generate`, I guess rhs-things relate to string-format time-dependent Hamiltonian, but I couldn't find description about such files. I didn't know even a meaning of 'rhs' (abbreviation?).; So I suggest to add documents about them. Especially, I have the following question:; - Can I pickle the solver result with a single and portable format?. Saving solver result with pickle module, and loading it sometimes fail, for example:; (I'm so sorry I haven't reproduce this behavior with simplest code, so the following is a dummy-code); ```; out = mesolve(...); with open(filename, 'wb') as f:; pickle.dump(out, f); ```; ```; Exception ignored in: <function QobjEvo.__del__ at 0x7f9e406f4310>; Traceback (most recent call last):; File ""/home/mizuno.kosuke/venvs/default/lib/python3.8/site-packages/qutip/qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-22-e4ad332ebfe3> in <module>; 2 p_json = Path(filename); 3 with p_json.with_suffix('.result.pkl').open('rb') as f:; ----> 4 res = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_877182617539010'; ```; Note: I used pickle module instead of `qsave/qload`. I guess it's no difference because `qsave` uses pickle module internally.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1684:603,load,loading,603,https://qutip.org,https://github.com/qutip/qutip/issues/1684,2,['load'],"['load', 'loading']"
Performance,"**Is your feature request related to a problem? Please describe.**; In the device simulator of QuTiP (`qutip.qip.device`), a quantum computing device is characterized by the class `Processor` and its subclasses. It contains information about the available control pulses. In addition, a compiler is used to compile a set of universal quantum gates (e.g. RX, RY and ISWAP) into the corresponding control pulses. Together, they can automatically compiler an arbitrary quantum circuit into control pulses, create the time-dependent Hamiltonian representation and run the simulation using QuTiP solvers. However, in the current version, this compilation is done for each gate sequentially. At each time step, there is only one control pulse active. In practice, it is inefficient because usually several gates can be performed parallelly (e.g. X gate on qubit 0 and qubit 1). To make the compilation more practical, it is necessary to introduce a scheduler that schedules the control pulses. A similar example is https://qiskit.org/documentation/apidoc/pulse.html#schedules. **Describe the solution you'd like**; There is existing research (https://arxiv.org/pdf/1708.00023.pdf) on gate-level scheduling. It studies which gates can be performed at the same time. In the most general case, however, gate-level scheduling is not enough, since different gates often have different runtime (.e.g. CNOT usually takes longer time than X gate). Despite the difference, pulse-level scheduling can be done in a similar way as gate-level scheduling by generating a graph (see the reference above). The difference is that each pulse will have its own duration. The possible implementation in `qutip.qip` could be in two steps:; - Modernize the current compiler and create an `Instruction` class representing each compiled control instruction (pulse, qubit index, amplitude, duration).; - Implement the scheduling algorithm similar as in the above reference.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1243:813,perform,performed,813,https://qutip.org,https://github.com/qutip/qutip/issues/1243,2,['perform'],['performed']
Performance,"**Objective:**; Add `jax.grad` functionality to `qutip.core.metrics` and `qutip.entropy`. **Result:**; entropy_vn, entropy_linear, entropy_mutual, concurrence, participation_ratio, hilbert_dist, trace_dist work with this change while others do not. **Issues** ; For entropy funtions - ptrace and partial transpose pose issues; For metrics - sqrtm. **To Do**; Add dispatcher functions for these functions; Also add jax in requirements.txt",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2451:147,concurren,concurrence,147,https://qutip.org,https://github.com/qutip/qutip/pull/2451,1,['concurren'],['concurrence']
Performance,"**Summary of what was done:**. - Changes in floquet_master_equation_rates to make it faster.; - Corrected transposition errors in _floquet_master_equation_tensor_ and changes to make it faster. I also removed a line so that the ME is solved in the interaction picture, this implies a different basis change in the _floquet_markov_mesolve_ function.; - Correction in _floquet_markov_mesolve_. As explained in the point above, the Floquet-Markov ME was not being solved in the interaction picture, therefore I modified _floquet_master_equation_tensor_ and modified the basis change in _floquet_markov_mesolve_. This modification requires an additional variable in the entry of _floquet_markov_mesolve_ which can not be chosen by default. For the moment, if this variable is not given and _floquet_basis=False_, then the density matrix or expectation values are returned in the interaction picture, in the computational basis, and a warning message is sent. ; - Added integration options in: _floquet_modes, floquet_modes_t, floquet_modes_table, floquet_states_t, floquet_modes_t, floquet_wavefunction_t, fsesolve, floquet_master_equation_rates, fmmesolve_; - Added test functions to verify the dissipative dynamics:; a) Compare _fmmesolve_ and _mesolve_ for the cases: (NO drive but dissipation) and (Drive but NO dissipation); b) Compare numerical and analytical matrix elements for a driven-dissipative TLS with RWA. There are some places where the code could be modified to optimize the running time, especially in the basis change in _floquet_markov_mesolve_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949:1475,optimiz,optimize,1475,https://qutip.org,https://github.com/qutip/qutip/pull/1248#issuecomment-740126949,1,['optimiz'],['optimize']
Performance,+1 on getting rid of the print statements. I think we can just drop them entirely -- users can just print their object if they want to see what was loaded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457:148,load,loaded,148,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044423457,1,['load'],['loaded']
Performance,"+1. This looks like a good PR to me. Just a quick note: We have had some side-effect issues when changing how isherm and other cached attributes are handled in the past, in particular with respect to performance. I used to monitor the performance over time with the continous-benchmarking suite in one of the respositories in the project, and that was sometimes useful to find unexpected performance hits. . Hopefully this PR will only improve performance, but it could still be worthwhile to check that for example the unit test suite does not take longer time on this branch than on master.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130549106:127,cache,cached,127,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130549106,5,"['cache', 'perform']","['cached', 'performance']"
Performance,- Attempt to optimize the mcsolve algorithms before an eventual move to cython.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/263:13,optimiz,optimize,13,https://qutip.org,https://github.com/qutip/qutip/pull/263,1,['optimiz'],['optimize']
Performance,- Made qutip.entropy.concurrence work for pure states in addition to density matrices.; - Improved error checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/143:21,concurren,concurrence,21,https://qutip.org,https://github.com/qutip/qutip/pull/143,1,['concurren'],['concurrence']
Performance,- Restructure code to avoid multiple copies of code snippets.; - Optionally return dict with details on solution and solver details.; - Allow for building preconditioner separately so that different; iterative methods can be applied.; - Calculates inf-norm of residual at output.; - Returns number of iterations performed.; - Allow for inputing initial guess vector.; - Calculate a lower bound on the condition number of a preconditioner.; - Residual norm is given when iterative method fails to converge.; - Removed bicg method since it is not compatible.; - General docstring edits.; - Add tests for bicgstab method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221:312,perform,performed,312,https://qutip.org,https://github.com/qutip/qutip/pull/221,1,['perform'],['performed']
Performance,- The current choice of CFLAGS made generating the str-based c-code slower than necessary for little to no speed gain. Here we choose flags that optimize less since there is no benefit.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/559:145,optimiz,optimize,145,https://qutip.org,https://github.com/qutip/qutip/pull/559,1,['optimiz'],['optimize']
Performance,"- The debug setting is off by default so conditional loading of the; logging feature does not work. Here we load the logger by default, but; do not log anything unless the debug feature is set.; - Also got rid of the inspect stack as I do not see the point of that.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/261:53,load,loading,53,https://qutip.org,https://github.com/qutip/qutip/pull/261,2,['load'],"['load', 'loading']"
Performance,"- This pull contains a sparse kron function that does not need to convert to COO format to do the product. It is possible to get up to ~20x performance over the SciPy implementation.; - This function can likely be recast to use OPENMP on the outer-loop.; - Added random tests comparing this method vs the SciPy sparse kron. Here are speed ups for various random objects (dims in range [2,100]) with random densities:; ![oper-oper](https://cloud.githubusercontent.com/assets/1249193/18156290/76e1f8d4-6fd2-11e6-91b4-e898429ecf1c.png); ![oper-ket](https://cloud.githubusercontent.com/assets/1249193/18156291/784e4204-6fd2-11e6-95e1-221a90c3d20b.png); ![ket-ket](https://cloud.githubusercontent.com/assets/1249193/18156292/796a22fc-6fd2-11e6-9646-04214cdf3af4.png). The graphs show a relatively constant speedup. However, the results are a bit better than displayed here when using the `timeit` module directly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/530:140,perform,performance,140,https://qutip.org,https://github.com/qutip/qutip/pull/530,1,['perform'],['performance']
Performance,"--------------; TypeError Traceback (most recent call last); File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/pyplot.py:265, in _draw_all_if_interactive(); 263 def _draw_all_if_interactive() -> None:; 264 if matplotlib.is_interactive():; --> 265 draw_all(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/_pylab_helpers.py:131, in Gcf.draw_all(cls, force); 129 for manager in cls.get_all_fig_managers():; 130 if force or manager.canvas.figure.stale:; --> 131 manager.canvas.draw_idle(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backend_bases.py:1919, in FigureCanvasBase.draw_idle(self, *args, **kwargs); 1917 if not self._is_idle_drawing:; 1918 with self._idle_draw_cntx():; -> 1919 self.draw(*args, **kwargs). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/backends/backend_agg.py:387, in FigureCanvasAgg.draw(self); 384 # Acquire a lock on the shared font cache.; 385 with (self.toolbar._wait_cursor_for_draw_cm() if self.toolbar; 386 else nullcontext()):; --> 387 self.figure.draw(self.renderer); 388 # A GUI class may be need to update a window using this draw, so; 389 # don't forget to call the superclass.; 390 super().draw(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:95, in _finalize_rasterization.<locals>.draw_wrapper(artist, renderer, *args, **kwargs); 93 @wraps(draw); 94 def draw_wrapper(artist, renderer, *args, **kwargs):; ---> 95 result = draw(artist, renderer, *args, **kwargs); 96 if renderer._rasterizing:; 97 renderer.stop_rasterizing(). File ~/.local/share/virtualenvs/qutip-319cV_iJ/lib/python3.11/site-packages/matplotlib/artist.py:72, in allow_rasterization.<locals>.draw_wrapper(artist, renderer); 69 if artist.get_agg_filter() is not None:; 70 renderer.start_filter(); ---> 72 return draw(artist, renderer); 73 finally:; 74 if artist.get_agg_filter() is",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903:1332,cache,cache,1332,https://qutip.org,https://github.com/qutip/qutip/issues/2400#issuecomment-2142000903,1,['cache'],['cache']
Performance,"-build-env-dzdmg7x6/overlay/lib/python3.11/site-packages/setuptools/build_meta.py"", line 338, in get_requires_for_build_wheel; return self._get_build_requires(config_settings, requirements=['wheel']); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; File ""/private/var/folders/h9/04p7x4ds0hvfmd80jt8gx3kc0000gn/T/pip-build-env-dzdmg7x6/overlay/lib/python3.11/site-packages/setuptools/build_meta.py"", line 320, in _get_build_requires; self.run_setup(); File ""/private/var/folders/h9/04p7x4ds0hvfmd80jt8gx3kc0000gn/T/pip-build-env-dzdmg7x6/overlay/lib/python3.11/site-packages/setuptools/build_meta.py"", line 335, in run_setup; exec(code, locals()); File ""<string>"", line 247, in <module>; File ""<string>"", line 46, in process_options; File ""<string>"", line 130, in _determine_version; AttributeError: module 'packaging.version' has no attribute 'LegacyVersion'; [end of output]; ; note: This error originates from a subprocess, and is likely not a problem with pip.; error: subprocess-exited-with-error. × Getting requirements to build wheel did not run successfully.; │ exit code: 1; ╰─> See above for output. note: This error originates from a subprocess, and is likely not a problem with pip.; ```. ### Expected Behaviour. Should install `qutip` without errors. ### Your Environment. ```shell; QuTip Version: 4.7.0; Python version: 3.11.0; `packaging` version: 22.0; `pip` version: 22.3.1; ```. ### Additional Context. I explicitly mention Python 3.11 because I failed to replicate the issue on a fresh Python 3.10 environment. . EDIT: Looking deeper into the [qutip built distributions](https://pypi.org/project/qutip/#files), the reason why this is failing only for Python 3.11 is because earlier versions of Python have built distributions, unlike Python 3.11. . This indicates that building the wheel from source is generally broken, which I confirmed by forcing an installation from source on Python 3.10 with; ```bash; pip install qutip --no-cache-dir --no-binary :all:; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2036:3418,cache,cache-dir,3418,https://qutip.org,https://github.com/qutip/qutip/issues/2036,1,['cache'],['cache-dir']
Performance,". **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are not physics-related:; - 6 are related to plotting or visualization utilities ; - 6 are `Distribution` classes or subclasses, which seem to be only used for visualization; - 6 are related to solver options or results; - 3 are low-level classes that users typically wouldn't interact with; - This leaves only 4 physics-related occurrences: ; - `Evolver` (in this module), which is not exported and which I might rename to `_Evolver` (this is necessary to be a class for cacheing purposes); - `Cubic_Spline`, which only has __init__ and __call__ methods, and thus could (should?) be refactored into a function (this class also doesn't interact with `QObj`s, so one could argue that it is not physics-related); - `eseries`, which represents an exponential expansion of `QObj`s and thus refers to something at least loosely physical; - `QObj`, which is the basic representation of a physical object; - This would mean that the proposed `PhotonScatterer` class would be the **only** exported occurrence of using a class to represent computations related to a `QObj`. I think there are points to be made for both sides, but I'm not sure that having a few extra helper functions or requiring slightly shorter function calls would be worth introducing what seems to me to be a big inconsistency in the use of functions vs. classes in QuTiP. Once again, thank you @sahmed95 for your suggestions to this module and I look forward to hearing everyone's thoughts on the main issue of c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:4546,cache,cacheing,4546,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['cache'],['cacheing']
Performance,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1347:1369,perform,performance,1369,https://qutip.org,https://github.com/qutip/qutip/pull/1347,1,['perform'],['performance']
Performance,"./../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.; Original developers",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5412,cache,cache,5412,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,".17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4029,cache,cached,4029,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,".17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; p",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2969,cache,cached,2969,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,".3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1853,cache,cached,1853,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,".36s; Total run time: 5.51s; Total run time: 6.58s; Total run time: 9.64s; Total run time: 10.74s; Total run time: 12.29s; {'solver': 'pc-euler-2'}; Total run time: 1.54s; Total run time: 1.86s; Total run time: 2.50s; Total run time: 2.79s; Total run time: 3.36s; Total run time: 4.03s; Total run time: 4.98s; Total run time: 6.56s; {'solver': 'explicit1.5'}; Total run time: 5.28s; Total run time: 6.35s; Total run time: 7.74s; Total run time: 8.99s; Total run time: 10.34s; Total run time: 12.41s; Total run time: 15.40s; Total run time: 21.40s; {'solver': 'taylor1.5'}; Total run time: 3.30s; Total run time: 3.85s; Total run time: 4.52s; Total run time: 5.63s; Total run time: 7.22s; Total run time: 8.72s; Total run time: 9.51s; Total run time: 11.84s; {'solver': 'taylor1.5-imp'}; Total run time: 5.43s; Total run time: 6.81s; Total run time: 7.60s; Total run time: 10.05s; Total run time: 11.88s; Total run time: 12.88s; Total run time: 15.63s; Total run time: 22.31s. ```; ; **Minor issue: plots breaking notebook rendering**; Jupyter Notebooks have a broken rendering when cells with plots are run; refreshing the notebook sometimes works fine. This is sometimes fixed in the first place by adding; ```; plt.show(); plt.close(); ```; but not always. Maybe we can have a look at this minor issue in the development notebooks. . **Documentation**; It would really increase the adoption rate if the API doc and User Guide could be updated to highlight the stochastic solvers and new methods. The development notebooks are so well written that drawing from their examples should be simple. . Congratulations @Ericgig for this refurbishment, improvement, optimization and thorough benchmarking investigations of the stochastic solvers, which I hope will be widely tested by @nwlambert @ajgpitch @quantshah (and @fminga) for robustness once merged in the development master branch. I am merging this and the montecarlo split PR, hoping there are no incompatibility issues (#990 --> #991 --> #969).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/990#issuecomment-500396003:6241,optimiz,optimization,6241,https://qutip.org,https://github.com/qutip/qutip/pull/990#issuecomment-500396003,2,['optimiz'],['optimization']
Performance,".metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3614,cache,cached,3614,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,".metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are ins",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2554,cache,cached,2554,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,".tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmp8u8pmfcw_in_process.py build_wheel /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmpcrdfx79e; cwd: /private/",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:1651,cache,cached,1651,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,".toml`) defaults to 1.17.3, but `setup.cfg` requires `numpy>=1.19`. ### Code to Reproduce the Bug. ```shell; python -m pip install -v --upgrade qutip; ```. ### Code Output. ```shell; Using pip 24.0 from /home/defreule/.local/lib/python3.8/site-packages/pip (python 3.8); Defaulting to user installation because normal site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1431,cache,cached,1431,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"/code></a>]</li>; <li>Support reading BC4U and DX10 BC1 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6486"">#6486</a> [<a href=""https://github.com/REDxEYE""><code>@​REDxEYE</code></a>]</li>; <li>Optimize ImageStat.Stat.extrema <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7593"">#7593</a> [<a href=""https://github.com/florath""><code>@​florath</code></a>]</li>; <li>Handle pathlib.Path in FreeTypeFont <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7578"">#7578</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use list comprehensions to create transformed lists <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7597"">#7597</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Added support for reading DX10 BC4 DDS images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7603"">#7603</a> [<a href=""https://github.com/sambvfx""><code>@​sambvfx</code></a>]</li>; <li>Optimized ImageStat.Stat.count <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7599"">#7599</a> [<a href=""https://github.com/florath""><code>@​florath</code></a>]</li>; <li>Moved error from truetype() to FreeTypeFont <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7587"">#7587</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Correct PDF palette size when saving <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7555"">#7555</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed closing file pointer with olefile 0.47 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7594"">#7594</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>ruff: Minor optimizations of list comprehensions, x in set, etc. <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7524"">#7524</a> [<a href=""https://github.com/cclauss""><cod",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:8004,Optimiz,Optimized,8004,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['Optimiz'],['Optimized']
Performance,"/qutip-notebooks/pull/58), there are several instances where I create a 1- or 2-line helper function to multiprocess a parameter search of `scattering_probability` using `multiprocessing.pool.starmap`. . In my experience, implementing a parallelized parameter search will be much more difficult to do if `scattering_probability` is changed to become a class method. There are some [hacky workarounds to this](https://stackoverflow.com/questions/27318290/why-can-i-pass-an-instance-method-to-multiprocessing-process-but-not-a-multipro), but these add extra overhead to implementing multiprocessing and don't work with methods that are not functionally static. . Given that these scattering calculations are among the most computationally expensive in QuTiP, I don't think that making parallelism more difficult to work with is a direction we should go in. I am confident that, with significant effort, I can make a clean and parallelized way to perform a parameter search in a class-based version of this module; however, this will take some time, especially given that developing this module is no longer my primary research focus in grad school. There are a few ways we could proceed:; 1. I could refactor the functions into a `Scatterer` class and export only the class, without adding dedicated multiprocessing support. This would make parallelizing parameter searches much more difficult - see my thoughts above.; 2. I could export both the flat functions and the `Scatterer` class (sans multiprocessing) which wraps these functions, and users could use the former for parallel searches. I don't like this option, since it clutters up the module and introduces multiple ways to do things. (""There should be one-- and preferably only one --obvious way to do it."" ~ [the Zen of Python](https://www.python.org/dev/peps/pep-0020/#the-zen-of-python)); 3. We could merge the current version of the module as-is and I can refactor into a class with properly-implemented parallelism in a later version. (",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-386114501:1558,perform,perform,1558,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-386114501,1,['perform'],['perform']
Performance,"014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/ove",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3975,cache,cached,3975,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20,",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2915,cache,cached,2915,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"15-x86_64.egg/qutip; ==============================================================================; Please cite QuTiP in your publication.; ==============================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:2043,optimiz,optimizer,2043,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,2,['optimiz'],['optimizer']
Performance,"241 +1.18017809e+000j 0.00000000e+000 +1.33956231e+000j; 1.33956231e+000 +0.00000000e+000j 1.48170345e+000 +0.00000000e+000j; 1.84311049e+000 +0.00000000e+000j 9.48683298e-001 +0.00000000e+000j]]; Quantum object: dims = [[1], [10]], shape = (1, 10), type = bra; Qobj data =; [[ 0.31622777+0.j 0.76344136+0.j 0.00000000+0.j; 0.00000000+0.j 0.00000000+1.18017809j 0.00000000+1.33956231j; 1.33956231+0.j 1.48170345+0.j 1.84311049+0.j; ```; I did the same test on two machines and on my old laptop it works fine, so it probably is something architecture dependent. The output of lscpu is:; ```; Architecture: x86_64; CPU op-mode(s): 32-bit, 64-bit; Byte Order: Little Endian; CPU(s): 8; On-line CPU(s) list: 0-7; Thread(s) per core: 1; Core(s) per socket: 8; Socket(s): 1; NUMA node(s): 1; Vendor ID: GenuineIntel; CPU family: 6; Model: 63; Model name: Intel(R) Core(TM) i7-5960X CPU @ 3.00GHz; Stepping: 2; CPU MHz: 1199.890; CPU max MHz: 3500,0000; CPU min MHz: 1200,0000; BogoMIPS: 5989.11; Virtualization: VT-x; L1d cache: 32K; L1i cache: 32K; L2 cache: 256K; L3 cache: 20480K; NUMA node0 CPU(s): 0-7; Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm epb intel_ppin tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts; ```; I'll gladly provide any additional information that might be needed. It's definitely a possibility that I did something wrong in the build process of either qutip itself (this is the archlinux build script: https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=python-qutip) or one of its libraries. Any ideas?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/681:3033,cache,cache,3033,https://qutip.org,https://github.com/qutip/qutip/issues/681,4,['cache'],['cache']
Performance,"3eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2010,cache,cached,2010,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"4.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3514,cache,cached,3514,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"4.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2454,cache,cached,2454,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"585</a>; [radarhere]</p>; </li>; <li>; <p>Handle removing orientation from alternate types of EXIF data <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5584"">#5584</a>; [radarhere]</p>; </li>; <li>; <p>Make Image.<strong>array</strong> take optional dtype argument <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5572"">#5572</a>; [t-vi, radarhere]</p>; </li>; </ul>; <h2>8.3.0 (2021-07-01)</h2>; <ul>; <li>; <p>Use snprintf instead of sprintf. CVE-2021-34552 <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5567"">#5567</a>; [radarhere]</p>; </li>; <li>; <p>Limit TIFF strip size when saving with LibTIFF <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5514"">#5514</a>; [kmilos]</p>; </li>; <li>; <p>Allow ICNS save on all operating systems <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4526"">#4526</a>; [baletu, radarhere, newpanjing, hugovk]</p>; </li>; <li>; <p>De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4989"">#4989</a>; [gofr, radarhere]</p>; </li>; <li>; <p>Replaced xml.etree.ElementTree <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5565"">#5565</a>; [radarhere]</p>; </li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-pillow/Pillow/commit/8013f130a5077b238a4346b73e149432b180a8ea""><code>8013f13</code></a> 8.3.2 version bump</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/23c7ca82f09df6ba1047d2d96714eb825f0d7948""><code>23c7ca8</code></a> Update CHANGES.rst</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/8450366be331762ae327036e3c6658c517b05638""><code>8450366</code></a> Update release notes</li>; <li><a href=""https://github.com/python-pillow/Pillow/commit/a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:6600,load,loading,6600,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['load'],['loading']
Performance,"627</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Raise a warning if NumPy failed to raise an error during conversion <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6594"">#6594</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Only read a maximum of 100 bytes at a time in IMT header <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6623"">#6623</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Show all frames in ImageShow <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6611"">#6611</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow FLI palette chunk to not be first <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6626"">#6626</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>If first GIF frame has transparency for RGB_ALWAYS loading strategy, use RGBA mode <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6592"">#6592</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Round box position to integer when pasting embedded color <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6517"">#6517</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed EXIF prefix when saving WebP <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6582"">#6582</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Pad IM palette to 768 bytes when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6579"">#6579</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added DDS BC6H reading <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6449"">#6449</a> [<a href=""",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:6509,load,loading,6509,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['load'],['loading']
Performance,"6456</a></li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/psf/requests/blob/main/HISTORY.md"">requests's changelog</a>.</em></p>; <blockquote>; <h2>2.32.0 (2024-05-20)</h2>; <p><strong>Security</strong></p>; <ul>; <li>Fixed an issue where setting <code>verify=False</code> on the first request from a; Session will cause subsequent requests to the <em>same origin</em> to also ignore; cert verification, regardless of the value of <code>verify</code>.; (<a href=""https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56"">https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56</a>)</li>; </ul>; <p><strong>Improvements</strong></p>; <ul>; <li><code>verify=True</code> now reuses a global SSLContext which should improve; request time variance between first and subsequent requests. It should; also minimize certificate load time on Windows systems when using a Python; version built with OpenSSL 3.x. (<a href=""https://redirect.github.com/psf/requests/issues/6667"">#6667</a>)</li>; <li>Requests now supports optional use of character detection; (<code>chardet</code> or <code>charset_normalizer</code>) when repackaged or vendored.; This enables <code>pip</code> and other projects to minimize their vendoring; surface area. The <code>Response.text()</code> and <code>apparent_encoding</code> APIs; will default to <code>utf-8</code> if neither library is present. (<a href=""https://redirect.github.com/psf/requests/issues/6702"">#6702</a>)</li>; </ul>; <p><strong>Bugfixes</strong></p>; <ul>; <li>Fixed bug in length detection where emoji length was incorrectly; calculated in the request content-length. (<a href=""https://redirect.github.com/psf/requests/issues/6589"">#6589</a>)</li>; <li>Fixed deserialization bug in JSONDecodeError. (<a href=""https://redirect.github.com/psf/requests/issues/6629"">#6629</a>)</li>; <li>Fixed bug where an ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:4915,load,load,4915,https://qutip.org,https://github.com/qutip/qutip/pull/2434,1,['load'],['load']
Performance,"86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3715,cache,cached,3715,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2655,cache,cached,2655,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"; 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/pyximport/pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. /home/caidish1234/anaconda3/lib/python3.6/distutils/dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. /home/caidish1234/anaconda3/lib/python3.6/site-packages/Cython/Distutils/old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. /home/caidish1234/anaconda3/lib/python3.6/distutils/command/build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. /home/caidish1234/anaconda3/lib/python3.6/distutils/ccompiler.py in compile(self, sou",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697:3894,optimiz,optimization,3894,https://qutip.org,https://github.com/qutip/qutip/issues/697,1,['optimiz'],['optimization']
Performance,"; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2573,cache,cached,2573,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"; ```; Map(Space(Map(Space, Space)), Space(Map(Space, Space))); ```; to; ```; Super(Space(Map(Space, Space)), Space(Map(Space, Space)), rep='super'); ```; and I definitely like having the superop rep included in it. The user is never ever meant to write any of this themselves, so the literal length shouldn't be too much of a problem. You'd still specify dimensions using the exact same list syntax that we currently use, it's just we'd immediately parse it into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. Y",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:1480,perform,performance,1480,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,2,['perform'],['performance']
Performance,"========================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; brmesolve: input lis",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482:2222,load,loadparams,2222,https://qutip.org,https://github.com/qutip/qutip/issues/1124#issuecomment-552991482,2,['load'],['loadparams']
Performance,"> However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion. It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format?; > ; > In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. I guess this was mostly because I wasn't explicitly calling steadystate with sparse=False so it was getting converted back to CSR anyway, and slowing things down. Largely I see similar performance between CSR and dense (using sparse=False), unless I use very small systems (16x16 Liouvillians), though this seemed a bit scipy/method dependent. I guess as you said this also raises the question about whether stuff like eigenstates and steadystate() should default to using methods based on the data layer of the object, instead of kwargs? My feeling is not, since eigenstates+sparse can be bad and steadystate+largesystem+dense could be bad, so its worth having some default conversion cost in place. But I still like the idea of what gets returned to the user following default_dtype. but maybe we can see if this turns out to be an issue that people have in using data layers, could just be me!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192:770,perform,performance,770,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1953388192,2,['perform'],['performance']
Performance,"> I ran some comparisons to the old version, and everything looks good. There seems to be some speedup both to the RHS construction and the ODE solver for most cases. Thanks! I've now streamlined things a little more, so they might be slightly faster still. > Since each individual ADO is naturally a Qobj, having HierarchyADOsState store them an array or list of Qobjs makes sense I guess. I've put this down in the v5 TODO list (just to draw a line under this PR). > 2. How should the ado_state be stored on a results object? In particular, how should the change in e_ops signature be handled (for the HEOM solver the e_ops callables also take the full ADO state). I ended up always calling `e_ops` functions with `f(t, ado_state)`. This is a bit different to other solvers, but makes what the HEOMSolver considers the evolution state consistent. The density matrix part of the state is available as `ado_state.rho` so it's not a big hardship to retrieve just the system state. >> 3. Recheck the time dependent case.; > ; > From what I can see it looks good! Seems like basically you treat the entire RHS as an effective qobjevo? I ran through various > examples, and couldn't find any issues!. I simplified things a bit further. In the time-dependent case the RHS matrix is calculated without adding the Liouvillian to the diagonal and then the kron of the Liouvillian is added to the RHS at the end, resulting in a simpler QobjEvo. >> 4. The HEOM can't really take new QObjEvo arguments each time run is called because calculating the RHS again is quite expensive. Maybe something can be done?. Arguments are supported now because the full RHS is a QobjEvo!. >> 5. Compare performance to the HEOM in 4.7.; > ; > On the fermionic examples, with very-large system Hilbert space, there was a little slowdown in the RHS construction. Maybe the slowdown has gone away now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739:1677,perform,performance,1677,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1145125739,2,['perform'],['performance']
Performance,"> Knowing the tensor structure is still necessary for enforcing the Hilbert spaces are of the correct dimensions, even if the resulting state can't be written as a product of states on individual spaces. I think there's a lot more design to do to work out a sensible data structure which can really take advantage of this lazy representation, but my morning-after reaction to this is that it's very non-trivial without a lot of code duplication.; > ; > It's easy enough to imagine how it will work for operators of structure `[scalar, oper, scalar] * [scalar, scalar, oper] -> [scalar, oper, oper]` - in this case the final result is fully expanded in the last two states, and not in the first. It's much trickier dealing with `[oper, scalar, scalar] * [scalar, oper, oper] -> [oper, scalar, oper]`. In this case, since there's a subspace in between them, you need a specifically ""lazy"" Kronecker product. I suspect that this would have to be supported via either a completely separate `tensor` mechanism, or the mechanisms which currently underpin the data-layer `kron` would have to be revisited.; > ; > At least at first, I think that's a very large undertaking, and it would really need a lot of careful design to ensure that we don't slow anything down, or balloon the amount of code to be maintained. Both your and Boxi's comments point to the fact that this probably needs to be something on top of Qobj as a QIP-state object rather than part of Qobj itself! Once the details on these changes are fleshed out, I shall certainly look into this. It could potentially be very useful to have a slightly more customized/optimized QIP state layer on top of Qobj.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-658138964:1622,optimiz,optimized,1622,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-658138964,1,['optimiz'],['optimized']
Performance,"> Thanks @eendebakpt. This is a great improvement for a small change. I left one suggestion for adding a bit more of a description to the change log, but I think it looks good to merge. Are there any more changes you'd like to make?. I am creating a similar PR against dev.major. Perhaps there are more optimizations to be done (have not checked yet), but I think it is better to put it in a seperate PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615:303,optimiz,optimizations,303,https://qutip.org,https://github.com/qutip/qutip/pull/1980#issuecomment-1220046615,1,['optimiz'],['optimizations']
Performance,"> Thanks @jakobjakobson13. A few modules' tests fail, on all operating systems, https://travis-ci.org/github/qutip/qutip/jobs/746708587. I wonder why.; > ; I think I went a bit to far. Perhaps I will close this pull request and cut it down into smaller chunks. > By the way, what software did you use, `autoflake`?; >; No, `deepcode.ai` but I don't know really know how good or bad it performs in contrast to other static code checkers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114:385,perform,performs,385,https://qutip.org,https://github.com/qutip/qutip/pull/1394#issuecomment-735719114,1,['perform'],['performs']
Performance,"> The issue I see with `BathExponent` is that it contain a `Q` which seems to be usually shared for one Bath. While the exponent themselves can share an instance, `_spreQ`, `_spostQ`, `_s_pre_minus_post_Q` and `_s_pre_plus_post_Q` will be independent for each exponent. I don't know how many exponent per Bath you expect, if it's 1~2, it could be fine, but if it get large, you are computing and storing too many copies of these. Usually the number of exponents is less than 10. I have thought about optimizing the `_spreQ` lists so that they share the instances of the superoperators if the underlying Q are the same, but it seemed a complication for not a huge benefit:. The shape of the RHS is `(block * nhe, block * nhe)` where `(block, block)` is the shape of `spre(Q)` and `nhe` is the number of labels in the hierarchy. `nhe ~ k**cutoff` where `k` is the number of exponents and `cutoff` is the maximum hierarchy depth. So the overall size of the RHS is `~ k**(2*cutoff - 1)` times the size of the `_spreQ` list.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-965317784:500,optimiz,optimizing,500,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-965317784,1,['optimiz'],['optimizing']
Performance,"> pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py. Absolutely agree with this. > But it can be useful if the test code itself can be made robust with respect to the problem. Also yes - if I understand right, it's just the testing code that's a problem here, right, not the actual internal code? We can't swap to `pyplot.close('all')` in the library code (for obvious side-effect-y reasons), but if it's in the tests, then it shouldn't be an issue to change. I wonder why it caused a problem in the first place, though - if we could track it down (does `xvfb` do similar things to inline backends with respect to ""capturing"" images during construction/return?) it would be nice to use something slightly more targetted than `pyplot.close('all')`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005:31,load,loading,31,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909159005,2,['load'],"['loaded', 'loading']"
Performance,">; <li>Added PyPy 3.10 and removed PyPy 3.8 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7216"">#7216</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added in_place argument to ImageOps.exif_transpose() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7092"">#7092</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Corrected error code <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7177"">#7177</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use &quot;not in&quot; <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7174"">#7174</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Only call text_layout once in getmask2 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7206"">#7206</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed calling putpalette() on L and LA images before load() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7187"">#7187</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed unused INT64 definition <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7180"">#7180</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Updated xz to 5.4.3 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7136"">#7136</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed saving TIFF multiframe images with LONG8 tag types <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7078"">#7078</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not set size unnecessarily if image fails to open <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7056"">#7056</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2237:5291,load,load,5291,https://qutip.org,https://github.com/qutip/qutip/pull/2237,1,['load'],['load']
Performance,">The compound assignment operators have different semantics,. I suggest to reconsider such a wording a bit more. :thought_balloon: I imagine that the discussed assignment variants should logically be equivalent. >which may change the behaviour of the code. Some differences are documented. :thought_balloon: Would you find any “effects” on the software run time characteristics desirable?. >… certain operations that need to perform a copy no longer do. How would you like to identify (and eventually mark) the source code places where in-place data modifications should be excluded? :thinking:. >We already do use compound assignments in many places where we absolutely want the operation to be in-place. Thanks for such a background information. >For immutable types on the left, …, the compound assignment has no difference (other than evaluating subscripts only once). :thought_balloon: Can this information trigger any further development considerations?. >…, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. How do you think about to clarify evolving development views any further by corresponding test cases? :thinking:",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708:425,perform,perform,425,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972776708,1,['perform'],['perform']
Performance,"@Ericgig I'm just attempting some profiling with `cProfile` to make sure I'm optimising the right thing - do you know the best way to get it to work with the cython code. I've tried setting; ```; #cython: linetrace=True, profile=True, binding=True; #distutils: define_macros=CYTHON_TRACE_NOGIL=1; ```; But it doesn't appear to work.; When I use `pyinstrument` it appears that `_expect_csr_dense_ket` is the main performance bottleneck. This is probably because the function must iterate over all rows, even though most are empty. I think a COO format would be more suitable in this case - would you accept it if I added this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589:412,perform,performance,412,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1906241589,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:205,perform,perform,205,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,2,['perform'],['perform']
Performance,"@cgranade I'm really liking the overall look of the Instrument class -- it's a much easier way to deal with measurements than calling the measurement operations all the time & of combine measurement operations with other operations on Qobjs. I'm keen to hear feedback from others too, but in the mean time I'm going to note some thoughts here for when I come back to this:. * It would be good to think about how all the operations on Qobj match up with QuTiP version 5 (since this draft is based on v4 currently).; * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground.; * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases like this where there are essentially an infinite number of possible constructors, it makes sense to not ""bless"" any of them by sticking them on the class.; * It would be good to have one really nice use case that we could turn into a guide entry in the documentation. The current small examples are great, but it would be good to add one slightly bigger worked example that did something more ""exciting"".; * I would not push everything into the `qutip` namespace (largely because we would likely not want that in v5, although I should actually check what v5 is doing in `qutip.__init__` these days).; * We should decide whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release). Hoping to hear comments from others!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910:865,perform,performed,865,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-949022910,2,['perform'],['performed']
Performance,"@emilianomfortes Thanks! It looks good now. Is there anything we can do to make the sparse vs dense performance plotting block run faster? It has to run every time the documentation is built (i.e. on every PR) and it takes a minute or two to run locally (so likely longer on the GitHub action VMs). It's not so much of an issue by itself, but its easy for the length of the documentation build to get out of hand if we add a minute here and a minute there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449:100,perform,performance,100,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1125207449,1,['perform'],['performance']
Performance,"@hodgestar ; I added default values to options and a default `mcstep`. I added a doc-string entry for `integrator_options`, but please check it. About `mcstep` optimization for scipy's `ode`, I tested both the methods and there can be a factor 2 in timing between both, but it can be in both ways depending on the conditions. So I used `mcsolve`'s method for `zvode` and the new method for `lsoda`. This way, the default will run like `v4`, but you have an alternative when it's not ideal.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294:160,optimiz,optimization,160,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-933862294,1,['optimiz'],['optimization']
Performance,"@hodgestar I think it should work, but I never rendered retexet to html with sphinx, so maybe you could perform a quick check? (I travel to ireland tomorrow up until monday night, but im kind of excited for 4.7 so let me know, I can edit the file with my phone)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147:104,perform,perform,104,https://qutip.org,https://github.com/qutip/qutip/pull/1862#issuecomment-1100042147,1,['perform'],['perform']
Performance,"@hodgestar I will merge this as is since it block the tests from passing everywhere. The situation with `except * nogil` is not perfect, but it's not a bottleneck in our computations. If you look at the generated code, the issue is only when calling an `except * nogil` function returning complex or void within another `nogil` function. Therefore I removed the nogil from function that called other nogil functions, not those who did the work. If you see optimisation I missed, please open another PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168:152,bottleneck,bottleneck,152,https://qutip.org,https://github.com/qutip/qutip/pull/2247#issuecomment-1773058168,1,['bottleneck'],['bottleneck']
Performance,"@jakelishman this is great, also thanks @dweigand for this PR. I tried out the function and it is very fast and could be great for specific use cases. My idea was a bit more simple - precomputing the `coherent_dm` operators (using qutip.coherent_dm) and using the `expect` function. But that performs worse that the original `qfunc` as well as this implementation of course. So this is great. I would be happy to merge this but have one thought:. This new implementation is sacrificing the ease-of-understanding of how Q-functions are computed with a very efficient and fast, but complicated class-based implementation. This means that users who want to look under the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_d",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:292,perform,performs,292,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,2,['perform'],['performs']
Performance,"@jakelishman, about the two issues you raised:. 1. Import time related to `import qutip`; I agree with you that in order to make it frictionless for downstream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qu",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:234,load,loading,234,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['load'],['loading']
Performance,"@jfeist @Ericgig I've added this to the 4.6.3 release milestone. The result of `enr_destroy` was not incorrect, but I'm sure users will appreciate the drastic performance improvement. Even 4s is a long time to wait at a Jupyter notebook prompt even before one starts to call `enr_destroy` often or allow more excitations.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468:159,perform,performance,159,https://qutip.org,https://github.com/qutip/qutip/pull/1593#issuecomment-875447468,1,['perform'],['performance']
Performance,"@nonhermitian I went for the `overlap` solution, as timing using this approach were better than using the `c_op.matrix_element(f_mode_a, f_mode_b)` solution. For reference,. ```; from qutip import *. N = 20; f_mode_a = coherent(N, alpha=1); f_mode_b = coherent(N, alpha=0.5); c_op = destroy(N). for a in range(100):; for b in range(100):; c_op.matrix_element(f_mode_a, f_mode_b); ```. runs in 2.13s (± 0.03s). and. ```; from qutip import *. N = 20; f_mode_a = coherent(N, alpha=1); f_mode_b = coherent(N, alpha=0.5); c_op = destroy(N). for a in range(100):; ket_a = c_op * f_mode_a; for b in range(100):; ket_a.overlap(f_mode_b); ```; runs in 1.88s (± 0.04s). Additionnally, I replaced a manual `.dag()` construction with an `overlap` call in `floquet_state_decomposition`. Also, I have a few other changes to `floquet` module that I can contribute. I will open issues to discuss them in details. Finally, I got quite a large performance improvements by using `numba.jit` as most of the code of this module is pure Python and many `for` loops. This however requires the use of subfunctions and full numpy objects rather than sparse matrices. Not sure if this is something interesting or not. :/",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/766#issuecomment-337263367:926,perform,performance,926,https://qutip.org,https://github.com/qutip/qutip/pull/766#issuecomment-337263367,1,['perform'],['performance']
Performance,"@nonhermitian could you please have a look at _pseudo_inverse_sparse when you have time, and see if you can think of any better way of doing this, from your experience with optimizing the steadystate solver? Would an iterative method make sense here? I basically run into memory problems quite quickly when using splu (which seems to be the most efficient method by far for this particular problem, according to my tests).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/272#issuecomment-67125235:173,optimiz,optimizing,173,https://qutip.org,https://github.com/qutip/qutip/pull/272#issuecomment-67125235,1,['optimiz'],['optimizing']
Performance,"@nonhermitian please review and test this PR. As far as I have seen it my test it works well, but it would be great if you could try this PR on some other mcsolve example. Perhaps paying special attention to possible performance regressions, although I think there shouldn't be any, but who knows.. With this PR mcsolve can also be used with the IPython.parallel framework. Here are some examples:. http://nbviewer.ipython.org/gist/jrjohansson/f37aa019080f8fb84c46",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/276#issuecomment-66395472:217,perform,performance,217,https://qutip.org,https://github.com/qutip/qutip/pull/276#issuecomment-66395472,1,['perform'],['performance']
Performance,"@nonhermitian, @goerz: The lack of optimization in some `scipy.sparse` methods is indeed due to having a lot of formats to support and limited developer time. That said, we're always happy to accept faster implementations! The optimization for multiplying DIA * some sparse matrix would be especially nice.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-410124453:35,optimiz,optimization,35,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-410124453,2,['optimiz'],['optimization']
Performance,@nwlambert ; I think it depends on whether `sqrtm()` or `eigenenergies()` performs better (or less issues in general case) in `Qobj`.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610:74,perform,performs,74,https://qutip.org,https://github.com/qutip/qutip/pull/2371#issuecomment-2042763610,1,['perform'],['performs']
Performance,"@riccameng Hi!. I think this is very achievable. Depending a bit on your time scales, it might make sense to work with QuTiP 5, which is currently under development in the `dev.major` branch. Version 5 includes much better QobjEvo support, much cleaner and more pluggable solvers (which should be merged into `dev.major` later this week), and a pluggable data layer. Some of these might be very helpful to you. For the rest of the discussion I will assume we are targeting QuTiP 5 unless you tell me otherwise. Some questions and thoughts from my side:. * As a first step you might be able to use v5s sparse (csr) data layer and write a custom ODE solver that performs the low-level evolution across multiple cores.; * If that works nicely, it could be extended to work across multiple nodes.; * For quantum circuit simulation, I think you can just ask @BoxiLi in a separate issue in https://github.com/qutip/qutip-qip about adding support for sparse unitaries in circuit simulation. I'm not sure if there are reasons why this might be difficult, but let's open an issue there and see.; * If the operators or states are too big to be stored in main memory even when they're sparse, we'll also need to figure out how to store them. Possibly this would involve a new data layer of some sort, but let's cross that road when we get to it.; * One of the challenges with HPC support is how to ensure we don't break it while continuing to evolve QuTiP. There are two challenges here. The first is to make sure that the code runs correctly -- I'm guessing there is some way to run MPI nicely on a single machine in our unit tests. The second is to make sure that performance isn't negatively impacted by changes. Do you have any thoughts on either of these?. It's exciting to see QuTiP being used on really big hardware. Looking forward to working with you however we can.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428:660,perform,performs,660,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927737428,2,['perform'],"['performance', 'performs']"
Performance,"A faster isherm function. 3-5x faster if operator is Hermitian, 100x+ faster if not. Essentially does a modified adjoint calculation. This requires having a csr matrix in canonical format, which is not guaranteed under sparse multiplication. Since canonical format is important for time-dependent dynamics as well, fast_csr_matrix now does the indices and data sorting for canonical format after multiplication. This gives a slight performance hit, but having all Qobj in canonical format outweighs this.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/629:432,perform,performance,432,https://qutip.org,https://github.com/qutip/qutip/pull/629,1,['perform'],['performance']
Performance,"A few points which came up:. - We can make the solve call very similar to `mesolve` where the user specifies a Hamiltonian, the coefficients describing the system and the size of the system as an argument dictionary. ```; system = {""N"": 100, ""emmission"": 0.5, ""loss"": 0.1}; pisolve(H, tlist, c_ops, e_ops, args=system); ```; - However this only works for Hamiltonians constructed with some specific operators. As the method is for dicke states only, the distinction between this solver and `mesolve` should be stated clearly. This is to prevent someone trying to pass a generic Hamiltonian. - Checks have to be included to make sure that the Hamiltonian and the operators specified are proper for the dicke states. - Since the user will not be concerned with the matrix M which governs the evolution `dp/dt = Mp`, we should probably find better ways to represent it and perform the dot product to generate RHS. @nonhermitian We have the M matrix as a pure dictionary of {(row, col): val}. We can write our own function for the dot product just by using this dictionary. Or, is it better to convert it into a sparse matrix and use Scipy's dot product function ? Converting from the dictionary to sparse M has some overhead.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-332725530:870,perform,perform,870,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-332725530,2,['perform'],['perform']
Performance,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934:406,Perform,Performance,406,https://qutip.org,https://github.com/qutip/qutip/pull/934,3,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"A pull request would be most welcome. There are also two other functions in qutip.fileio that should probably be updated at the same time. Instead of using an if statement, I would write code like:; ```python; p = pathlib.Path(""filename""); ... # append suffix here; with p.open(...):; ... # load or save here; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324:291,load,load,291,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044365324,1,['load'],['load']
Performance,"A rationale for adding the operators to the language isn't the same as a reason to use them in a particular programme. The compound assignment operators have different semantics, which may change the behaviour of the code. For example,; ```python; >>> import numpy as np; >>> a = np.ones(5, dtype=np.int32); >>> a = a + 2.5; >>> a; array([3.5, 3.5, 3.5, 3.5, 3.5]); >>> b = np.ones(5, dtype=np.int32); >>> b += 2.5; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; numpy.core._exceptions.UFuncTypeError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int32') with casting rule 'same_kind'; ```; Swapping to in-place operations can also mean that certain operations that _need_ to perform a copy no longer do. This can mean that a function or class may start holding a reference to an object that something else holds a reference too, so it might get mutated out from underneath it. We already do use compound assignments in many places where we absolutely want the operation to be in-place. For immutable types on the left, such as `tuple` or `int`, the compound assignment has no difference (other than evaluating subscripts only once). Technical reasons for _not_ doing it aside, it's also just not a good idea to change existing code with no actual measured benefit from an engineering perspective. It just creates churn of the code, and any change can introduce a new bug.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-972675136:720,perform,perform,720,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-972675136,1,['perform'],['perform']
Performance,"A representation of a quantum circuit consiting of qubit initialisation (I), controlled NOT gates (C) and measurements (M) with respect to different bases. According to [1], the transformation of a circuit to the ICM representation provides a cannonical form for an exact and fault-tolerant, error corrected circuit needed for optimization prior to final implementation on a hardware model. The algorithm consists of magic qubit initializations, gate teleportation and conditional measurements on qubits. It can be a starting point for topological descriptions of quantum cirucuits important for fault-tolerant quantum computation and can become a part of a pipeline for optimization of topological quantum computing circuits. Check out the game (MeQuanics)[http://www.mequanics.com.au] which aims to do so using crowd sourcing. Several proposals exist for circuit optimizations once we have the topological circuit model (Machine learning, monte carlo search etc) and the ICM model can be a good starting point to get to the initial topological circuit (as far as I could understand). . The algorithm can be roughly described as follows : . ```; Require: Circuit C composed from {Toffoli,CNOT,H,P,T}; Replace the Toffoli gates with their decomposition; Replace the H gates with P V P (already implemented using `resolve_gates`); Implement P V P using gate teleportation outlined in [1]; ```. The final output is a quantum circuit only using qubit initialisations, CNOT and conditional measurements/correction. Once that is complete, maybe another addition can be a conversion to the topological model and visualizations. This is a work in progress. TODO; ------; [ ] Fix code errors; [ ] Write tests; [ ] Update examples and docs. References; ----------; .. [1] arXiv:1509.03962v1 [quant-ph]",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603:327,optimiz,optimization,327,https://qutip.org,https://github.com/qutip/qutip/pull/603,3,['optimiz'],"['optimization', 'optimizations']"
Performance,"About tests being very slow, I saw the following notice when I open the details:; ```; Please be aware travis-ci.org will be shutting down in several weeks, with all accounts migrating to travis-ci.com. Please stay tuned here for more information.; ```; I think we are still on `travis-ci.org`? Is this related to us? Maybe ""switch CI to GitHub Actions"" is more pressing than we thought.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788:215,tune,tuned,215,https://qutip.org,https://github.com/qutip/qutip/pull/1465#issuecomment-805920788,1,['tune'],['tuned']
Performance,Absolutely - it already helped a load on `master` to catch pending deprecations and old code. As soon as we've got the warnings fixed on `dev.major` we'll turn it right back on.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1574#issuecomment-861857564:33,load,load,33,https://qutip.org,https://github.com/qutip/qutip/pull/1574#issuecomment-861857564,1,['load'],['load']
Performance,"Added optional argument `integrator` to choose between `propagator` or `mesolve` (also a `parallel={True,False}` argument). Realized there is probably not much to gain from `mesolve` returning a sparse matrix for large systems, however. This is because in the memorycascade method there is some postprocessing of the propagator using the `tensor_contract` method (written by @cgranade) which does not support sparse matrices, so it gets converted to dense anyway. Still `mesolve` actually performs a bit faster for small systems and small times, so still useful to be able to choose the method I guess.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/502#issuecomment-230115449:489,perform,performs,489,https://qutip.org,https://github.com/qutip/qutip/pull/502#issuecomment-230115449,1,['perform'],['performs']
Performance,"Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2913,cache,cached,2913,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"Adds custom `csr.diags` and swaps `qdiags` over to use it to avoid using the `scipy` version with its large overhead. Constructing a tridiagonal matrix of dimension 100 gets approximately a 7x speed up (320µs to 45µs on my machine) and it's better for small dimensions - the `scipy` overhead has a constant component something around 280µs compared to a constant ~20µs in the new `csr` one. Not a big deal since it's hardly ever going to be a bottleneck, but it's just part of my work speeding up general QuTiP operations.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1419:443,bottleneck,bottleneck,443,https://qutip.org,https://github.com/qutip/qutip/pull/1419,1,['bottleneck'],['bottleneck']
Performance,"Ah, that seems like a good check. Given the current instability of Travis timings, I'll run a quick check on my local machine to see how this PR affects performance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130550000:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130550000,1,['perform'],['performance']
Performance,"All the same, I'd very much like to further reduce warnings. I've literally had Firefox crash trying to load the entire Travis logs.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/433#issuecomment-185792948:104,load,load,104,https://qutip.org,https://github.com/qutip/qutip/issues/433#issuecomment-185792948,1,['load'],['load']
Performance,An example is given in this gist https://gist.github.com/nathanshammah/f96f6c1db5c323243a4729467cb7351f. ; Some performance benchmarking was done in PR #1024.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168:112,perform,performance,112,https://qutip.org,https://github.com/qutip/qutip/issues/1032#issuecomment-533145168,1,['perform'],['performance']
Performance,"As far as the ""known issues"" go, these are discussed in #484.; I don't think the issues I saw recently are the same as in that one.; ```; Intel MKL FATAL ERROR: Cannot load libmkl_avx.so or libmkl_def.so.; ```; I think this is just an MKL install problem.; It's difficult to test at the moment, as I don't seem to be able to create a conda env with mkl blas",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/872#issuecomment-394304854:168,load,load,168,https://qutip.org,https://github.com/qutip/qutip/issues/872#issuecomment-394304854,1,['load'],['load']
Performance,Bug in control/optimizer.py,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353:15,optimiz,optimizer,15,https://qutip.org,https://github.com/qutip/qutip/issues/353,1,['optimiz'],['optimizer']
Performance,"Bumping an old topic with two major new considerations. Number one: Travis is [changing its pricing model for open source software](https://blog.travis-ci.com/2020-11-02-travis-ci-new-billing), and generally it seems like [it's going to become unfeasible for us](https://www.jeffgeerling.com/blog/2020/travis-cis-new-pricing-plan-threw-wrench-my-open-source-works). Over the past month or so, queue times on Linux builds have increased massively (from near-instant to up to 90 minutes), and the number of allowed concurrent builds has already limited the amount of testing we are able to do - we don't even have Windows tests because we couldn't fit them in. In around March 2021 we expect the old travis-ci.org that QuTiP is grandfathered onto to shut down completely, forcing us onto the new model on travis-ci.com. Number two: in November 2019, GitHub released their own CI, GitHub Actions. This is (as best as I can tell) completely free for open source, public repositories like QuTiP, and offers access to a large number of Linux, macOS and Windows containers. This completely free period of GitHub Actions might not last forever (you can imagine maybe they're just trying to drive adoption before increasing the cost), but especially with the new time pressure from Travis, this seems like the right choice for now. Our testing set up is fairly straightforward, so migrating to a new CI shouldn't be too difficult. I just wrote (#1429) a GitHub Actions workflow to build and distribute binary releases of QuTiP on Linux/Mac/Windows, and I'm pretty convinced by the power of their CI. It's got an awful lot of flexibility with a _lot_ of customisation so its initial learning curve is a little steep (or maybe I'm just not used to CI tools), but I'm impressed by what's available. I believe it comes with a degree of reusability as well; I think we can define a test as a single ""action"", and then reuse that in the PR-push workflow and the make-distribution workflow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959#issuecomment-770455542:393,queue,queue,393,https://qutip.org,https://github.com/qutip/qutip/issues/959#issuecomment-770455542,4,"['concurren', 'queue']","['concurrent', 'queue']"
Performance,"Bumps [babel](https://github.com/python-babel/babel) from 2.9.0 to 2.9.1.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/python-babel/babel/releases"">babel's releases</a>.</em></p>; <blockquote>; <h2>Version 2.9.1</h2>; <h1>Bugfixes</h1>; <ul>; <li>The internal locale-data loading functions now validate the name of the locale file to be loaded and only allow files within Babel's data directory. Thank you to Chris Lyne of Tenable, Inc. for discovering the issue!</li>; </ul>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-babel/babel/blob/master/CHANGES"">babel's changelog</a>.</em></p>; <blockquote>; <h2>Version 2.9.1</h2>; <p>Bugfixes</p>; <pre><code>; * The internal locale-data loading functions now validate the name of the locale file to be loaded and only; allow files within Babel's data directory. Thank you to Chris Lyne of Tenable, Inc. for discovering the issue!; </code></pre>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/python-babel/babel/commit/a99fa2474c808b51ebdabea18db871e389751559""><code>a99fa24</code></a> Use 2.9.0's setup.py for 2.9.1</li>; <li><a href=""https://github.com/python-babel/babel/commit/60b33e083801109277cb068105251e76d0b7c14e""><code>60b33e0</code></a> Become 2.9.1</li>; <li><a href=""https://github.com/python-babel/babel/commit/412015ef642bfcc0d8ba8f4d05cdbb6aac98d9b3""><code>412015e</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/python-babel/babel/issues/782"">#782</a> from python-babel/locale-basename</li>; <li><a href=""https://github.com/python-babel/babel/commit/5caf717ceca4bd235552362b4fbff88983c75d8c""><code>5caf717</code></a> Disallow special filenames on Windows</li>; <li><a href=""https://github.com/python-babel/babel/commit/3a700b5b8b53606fd98ef8294a56f9510f7290f8""><code>3a700b5</code></a> Run locale identifiers through <code>o",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1695:321,load,loading,321,https://qutip.org,https://github.com/qutip/qutip/pull/1695,4,['load'],"['loaded', 'loading']"
Performance,"Bumps [urllib3](https://github.com/urllib3/urllib3) from 1.26.4 to 1.26.5.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/releases"">urllib3's releases</a>.</em></p>; <blockquote>; <h2>1.26.5</h2>; <p>:warning: <strong>IMPORTANT: urllib3 v2.0 will drop support for Python 2</strong>: <a href=""https://urllib3.readthedocs.io/en/latest/v2-roadmap.html"">Read more in the v2.0 Roadmap</a></p>; <ul>; <li>Fixed deprecation warnings emitted in Python 3.10.</li>; <li>Updated vendored <code>six</code> library to 1.16.0.</li>; <li>Improved performance of URL parser when splitting the authority component.</li>; </ul>; <p><strong>If you or your organization rely on urllib3 consider supporting us via <a href=""https://github.com/sponsors/urllib3"">GitHub Sponsors</a></strong></p>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/blob/main/CHANGES.rst"">urllib3's changelog</a>.</em></p>; <blockquote>; <h2>1.26.5 (2021-05-26)</h2>; <ul>; <li>Fixed deprecation warnings emitted in Python 3.10.</li>; <li>Updated vendored <code>six</code> library to 1.16.0.</li>; <li>Improved performance of URL parser when splitting; the authority component.</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/urllib3/urllib3/commit/d1616473df94b94f0f5ad19d2a6608cfe93b7cdf""><code>d161647</code></a> Release 1.26.5</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2d4a3fee6de2fa45eb82169361918f759269b4ec""><code>2d4a3fe</code></a> Improve performance of sub-authority splitting in URL</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2698537d52f8ff1f0bbb1d45cf018b118e91f637""><code>2698537</code></a> Update vendored six to 1.16.0</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/07bed791e9c391d8bf12950f76537dc3c6f90550""><code>07bed79</code></a> Fix deprecation warnings for Py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1563:595,perform,performance,595,https://qutip.org,https://github.com/qutip/qutip/pull/1563,1,['perform'],['performance']
Performance,"But it seems to me that it would be best to avoid this type of issue when possible. For example, the squeezing operator is called squeez just to get around a namespace conflict. Otherwise people are bound to get errors that don't make any sense just because of the import order and then they will be emailing us. Of course we can not avoid all conflicts, but since loading scipy is so fundamental to what we do, having no conflicts with this package seems to be reasonable, at least to me. . On Wednesday, June 5, 2013 at 11:12 AM, Robert Johansson wrote:. > Yes, this can happen.. But I dont think this is a bug or error, although it can be confusing. There is always a risk of namespace collisions when importing different packages into the global namespace. For example, many conflicts of this kind occur between the math and numpy packages.. The only way to get around it safely is to import packages in different namespaces.; > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/25#issuecomment-18951570).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/25#issuecomment-18951920:365,load,loading,365,https://qutip.org,https://github.com/qutip/qutip/issues/25#issuecomment-18951920,1,['load'],['loading']
Performance,"CircuitProcessor::testGetObjevo PASSED [ 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5128,cache,cache,5128,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,Class for recording and reporting performance statistics of solvers,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454:34,perform,performance,34,https://qutip.org,https://github.com/qutip/qutip/pull/454,1,['perform'],['performance']
Performance,Clean up pulse optimization sparse solving support.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1621:15,optimiz,optimization,15,https://qutip.org,https://github.com/qutip/qutip/pull/1621,1,['optimiz'],['optimization']
Performance,"Collaboration is open all the time, that's what open-source is for ;) It is required that all applicants have interaction with the community before applying so it is also kind of mandatory. And it will significantly increase the success probability of the application. Just notice that works done before GSoC won't give a reduction of the working load during the GSoC period (Google will check the process).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1457#issuecomment-794421929:347,load,load,347,https://qutip.org,https://github.com/qutip/qutip/issues/1457#issuecomment-794421929,1,['load'],['load']
Performance,"Could we just reach `Data` objects to be multiplied by a scalar so that the Tensorflow backend can accept multiplication by a `tf.Tensor` and either raise an error if it's a not a `1x1` tensor or perform the scalar multiplication if it is? It feels like this is a quirk of Tensorflow that scalars are represented by `1x1` matrices, so it would be nice if the tensorflow backend could handle that quirk itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790:196,perform,perform,196,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-881323790,1,['perform'],['perform']
Performance,"Currently, `Qobj` has several attributes which are somewhat expensive to compute:; - `type`; - `isherm`; - `istp`; - `iscp`; - `ishp` (added in #452). Of these, `type` and `isherm` are cached by `Qobj._type` and `Qobj._isherm`, respectively. These should be unified, so that the other three are also cached properly. Moreover, we should add unit tests to make sure that this caching is properly invalidated under at least some reasonably common manipulations. For instance, with the caching of `type`, it can sometimes fail in unexpected ways to build an object up then redefine its `dims`:. ``` python; >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type). >>> rho = ket2dm(bell_state()); >>> rho_out = partial_transpose(rho, [0, 1]); >>> J = 2 * rho_out; >>> print(J.type); >>> J.dims = [[[2], [2]], [[2], [2]]]; >>> J.superrep = 'choi'; >>> print(J.type); ```. The first of these two snippets correctly prints `super`, while the extra `print(J.type)` in the second snippet causes it to cache `type` and print `oper` twice. An experienced user can of course invalidate the cache with `J._type = None`, but that is somewhat counter-intuitive.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/453:185,cache,cached,185,https://qutip.org,https://github.com/qutip/qutip/issues/453,4,['cache'],"['cache', 'cached']"
Performance,DLL load failed: The specified module could not be found,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1613:4,load,load,4,https://qutip.org,https://github.com/qutip/qutip/issues/1613,1,['load'],['load']
Performance,"Data-layer type creation, conversion and dispatch; =================================================. ## Background. Previously in #1332, the old `fast_csr_matrix` type was replaced by the new, custom `CSR` type as the data backing for `Qobj`, and all internal QuTiP data representations. This produced some speed-ups in some places due to improved algorithms and better cache usage in places, but its principle advantage was the massive reduction in overhead for function calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to defi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338:371,cache,cache,371,https://qutip.org,https://github.com/qutip/qutip/pull/1338,1,['cache'],['cache']
Performance,During test control.pulseoptim: Hadamard gate (loading config from file) this deprecation warning sometimes happens:; control.pulseoptim: Hadamard gate (loading config from file) ... C:\Users\Paul\A; naconda2\lib\site-packages\qutip\control\loadparams.py:92: DeprecationWarning: Y; ou passed a bytestring as `filenames`. This will not work on Python 3. Use `cp.r; ead_file()` or switch to using Unicode strings across the board.; Reported on pip install of 4.0.1 on macOS; Not able to reproduce on Linux (py2 or py3).,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/598:47,load,loading,47,https://qutip.org,https://github.com/qutip/qutip/issues/598,3,['load'],"['loading', 'loadparams']"
Performance,"ENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2807,cache,cached,2807,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,ENH: Optimize td-BR non-secular call,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/713:5,Optimiz,Optimize,5,https://qutip.org,https://github.com/qutip/qutip/pull/713,1,['Optimiz'],['Optimize']
Performance,ENH: Optimized cython for sparse_utils,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/568:5,Optimiz,Optimized,5,https://qutip.org,https://github.com/qutip/qutip/pull/568,1,['Optimiz'],['Optimized']
Performance,ENH: Simplified & optimized mcsolve codegen,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/541:18,optimiz,optimized,18,https://qutip.org,https://github.com/qutip/qutip/pull/541,1,['optimiz'],['optimized']
Performance,Fix in load params where 'pulsegen' was 'optim'; Fix to error handing when creating output directory; FileExistsError is new in Python 3; Hence swapped to OSError using errno for Python 2 compatability,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/317:7,load,load,7,https://qutip.org,https://github.com/qutip/qutip/pull/317,1,['load'],['load']
Performance,Fix the handling of file suffixes when saving and loading Qobjs,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1877:50,load,loading,50,https://qutip.org,https://github.com/qutip/qutip/issues/1877,1,['load'],['loading']
Performance,"For some reason my docs do not load on git. They work fine if loaded directly from my computer though. Seems some css files are not being found. A brief google search pulled up a variety of things. You seem to have had success with the 4.0.2 docs, so perhaps you can take a shot at uploading.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-285923373:31,load,load,31,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-285923373,2,['load'],"['load', 'loaded']"
Performance,"Good spot. A lot of changes were made to the Optimizer class when the CRAB algorithm, I think this slipped in then. You will see on line 518 that the base class method passes the bounds as you suggest. Therefore the if you specify optim_method='l-bfgs-b' in any of the pulseoptim methods then your bounds should work and you will be using L-BFGS-B. . I'll create a pull request with this fix now though. ; Thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353#issuecomment-122956029:45,Optimiz,Optimizer,45,https://qutip.org,https://github.com/qutip/qutip/issues/353#issuecomment-122956029,1,['Optimiz'],['Optimizer']
Performance,"Great feedback @hodgestar. Let me add this: It would be nice to clarify explicitly benchmarks from the beginning. ; A bit like you did when mentioning the 14 qubit cap for QFT gate simulation. ; For example, goals of this would be:; - For qutip/qutip: Faster `mesolve` (add details of a typical example with current times/bottlenecks); - - For qutip/qutip: More qubits simulated in `mesolve` and `steadystate` ; - For qutip/qutip-qip: Capability to simulate more qubits (add current example with benchmark + code). For all examples we could add details of a typical example with current times/bottlenecks (we could use gists). This can be of very wide interest, but finding physical examples of interests and use cases would be helpful. For example, qubit space nevertheless explodes exponentially. But adding even a bit more qubits in `steadystate` can impact state of the art simulation of dissipative phase transitions in many-body systems. I also think that having a sort of code design template could help. This is a more general point triggered by this issue. This may be a QuTiP idea but looks at some point more technical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489:322,bottleneck,bottlenecks,322,https://qutip.org,https://github.com/qutip/qutip/issues/1671#issuecomment-927913489,4,['bottleneck'],['bottlenecks']
Performance,"Hard-coding compiler flag `-march=native` in setup.py completely destroys possibility to set up Qutip on heterogeneous cluster. In general, it brings a lot of problems for people that don't have a good experience in debugging ""illegal instruction"" errors, that often happen, if you compile the module on different machine than you use. If you are sure you need optimized build for localhost, you might use; ```; export CFLAGS=""-O3 -march=native""; export CXXFLAGS=""$CFLAGS""; pip install qutip; ```; instead or provide separate option for setup.py script.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/920:361,optimiz,optimized,361,https://qutip.org,https://github.com/qutip/qutip/issues/920,1,['optimiz'],['optimized']
Performance,"Having `int64` integers for indexing could certainly be useful, although in this particular case I was tired/stupid, and trying to do something impossible. That being said, I wonder whether the use of sparse matrices in QuTiP could be encapsulated completely, allowing do drop in arbitrary (external) sparse-matrix implementations. Importing the desired implementation could happen dynamically at import-time. This would allow to use `int32`, `int64`, or infinite `bigint` implementations (if any exist), as well as allowing to switch between pure-python implementations and the standard cython-optimized ones. Pure-Python would obviously be slow, but it would get around the segfaults that happen occasionally (#674).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/853#issuecomment-382524680:595,optimiz,optimized,595,https://qutip.org,https://github.com/qutip/qutip/issues/853#issuecomment-382524680,1,['optimiz'],['optimized']
Performance,"Hello Nathan, in a couple of hours we will perform the final minor docstring improvements, since we reduced the Cognitive Complexity. Tomorrow is finally ready!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933:43,perform,perform,43,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-992488933,1,['perform'],['perform']
Performance,"Hello! This is the first of hopefully a few PRs to add measurement functions to qutip. This PR adds a new module named `qutip.measurement` that contains two functions:. * `measure(op, state)` that performs a classic quantum measurement as described in most introductory texts (measurement collapses a state to an eigenvector of an hermitian operator and the result is the corresponding eigenvalue). It is intended to simulate a simple measurement that could be performed in a real experiment. * `measurement_statistics(op, state)` returns information that is not available via a real experiment, but is nevertheless often useful in simulator (the eigenvalues and vectors or projection operators for the measurement operator and the probabilities of each measurement result). Both functions support either kets or density matrices and return sensible results based on the kind of input. Not currently supported:. * Partial measurements of a system.; * Destructive measurements (aka von Neumann measurements of the second kind); * Density matrix ensembles (applying the measurement probabilities to the density matrix rather than making a specific measurement); * Any custom support for qubit measurement (my plan is to add those to a `qutip.qip.measurements` module once we have the basics of this module agreed on). Questions / things I'd like feedback on:. * Do the inputs and outputs of the current functions seem intuitive / sensible?; * What are the most important other features to support?; * I don't want to have too many functions, but I also don't necessarily want to cram all possible kinds of measurements into one function. Any thoughts on how to split these up?; * What other unit tests should I be writing?; * I haven't given any thought to performance yet. Anything egregious I should fix now or any important cases to optimize for?. General stylistic feedback welcomed too.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1090:197,perform,performs,197,https://qutip.org,https://github.com/qutip/qutip/pull/1090,4,"['optimiz', 'perform']","['optimize', 'performance', 'performed', 'performs']"
Performance,"Hello,. I have some suggestions for improvements in some functions in `metrics.py`. I'd be happy to put together a PR. The current implementation of `average_gate_fidelity` is based on the Kraus representation of the input quantum channel. If the input is a superoperator, it is first converted to its Kraus representation (involving diagonalization) before computing the average gate fidelity, which sacrifices performance and accuracy. There is a direct formula starting from a superoperator, see, e.g., https://qiskit.org/documentation/stubs/qiskit.quantum_info.average_gate_fidelity.html relating the average gate fidelity to the process fidelity, and https://qiskit.org/documentation/stubs/qiskit.quantum_info.process_fidelity.html#qiskit.quantum_info.process_fidelity to compute that from a superoperator. I think it would be better to use that direct formula if the input is not already in Kraus form!. There is also a function `process_fidelity` in Qutip, but I'm having a hard time understanding what it's intended for. It doesn't seem to be the process fidelity explained in the Qiskit docs above. The arguments of Qutip's `process_fidelity` are called `U1` and `U2` suggesting they are expected to be unitary, but this is not checked. It is computed as `(U1 * U2).tr()`, which is not between 0 and 1, and doesn't give 1 as I'd expect if `U1==U2`. Does someone know the intended use of that function? If not, I'd implement the process fidelity as described in the Qiskit docs here, with several version depending on whether the input is Kraus, a superoperator, and maybe a chi matrix. Lastly, there is an issue with the tests - the lines; ```; class Test_dnorm:; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since it; # depends on them.; cvxpy = pytest.importorskip(""cvxpy""); cvxopt = pytest.importorskip(""cvxopt""); ```; actually skip all the tests in the file if cvxpy is not available, not just the ones in the `Test_dnorm` class. The test output, if `cvxpy` is not insta",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1703:412,perform,performance,412,https://qutip.org,https://github.com/qutip/qutip/issues/1703,1,['perform'],['performance']
Performance,"Hello,. I'm using qutip alongside another library, which does something like this:; ```py; import logging; logger = logging.getLogger(); logger.setLevel(logging.DEBUG); ```; Im not entirely sure why it does so, but nevertheless debug messages don't show up anywhere, since the root logger doesn't print anything without it being configured. If you run the above code in Ipython but add `import qutip` before it, `logging.debug(""foo"")` prints to the stderr (without qutip it doesn't). So when I started using the library with qutip, suddenly all debug messages started getting printed to stderr. Apparently, this is somewhat on purpose, by looking at the code [here](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/logging_utils.py#L99). I'm not entirely sure what tho think about that, because as shown above this causes something unexpected. Nevertheless, I thought I could work around this by setting `log_handler = ""null""` in my settings file, but that in turn causes qutip to crash, because the rc loader [expects](https://github.com/qutip/qutip/blob/eff1c3a606cad64b8d16f3232181b0463d65d746/qutip/configrc.py#L97) `log_handler` to be a boolean for some reason. Also, it took me a while to find this, since the `log_handler` option is [not documented](http://qutip.org/docs/latest/guide/guide-settings.html?highlight=log). I'm using python 3.7.4 and QuTiP 4.4.1 installed with pip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1156:1037,load,loader,1037,https://qutip.org,https://github.com/qutip/qutip/issues/1156,1,['load'],['loader']
Performance,"Hello. I'm working on a qutrit system (spin 1). Eventually need to do some pulse optimization but for testing I tried to propagate using a very simple Hamiltonian, namely just Sz^2 with D=2000. ; Units are µs for time (so MHz for frequency). . versions used:; ```python; matplotlib.pylab 1.16.4; qutip 4.4.1; matplotlib 3.1.1; numpy 1.16.4; scipy 1.3.1; CPython 3.7.3; IPython 7.5.0; ```. I solve with sesolve or mesolve with (|+. 1> + |0>)/sqrt(2) as initial state.; **expected:** quite trivially, population should stay 1/2 for any t for |+1> and |0>, 0 for |-1>; **result:** population of |+1> goes down linearly and |0> goes up ; a few observations: ; - if I make the coefficient of Sz^2 smaller, the population diverges less ; - with less time steps but same overall propagation time, I see the divergence less obviously because I see the beginning of it; - I am aware one can somehow optimize the number of time steps but this is about the convenient settings for the next steps for me; - I was thinking of increasing floating point precision or something like that but wasn't able to find a simple way to do that in the docs. it does not seem like having a coefficient on the order of 10000 or 10^5 time steps is that unreasonable, does it ?; anyway, this is about the right, convenient choice of unit for us here. any idea what's wrong ?. ```python; %load_ext watermark; import numpy as np; import scipy; import matplotlib; import matplotlib.pylab as plt; import qutip; %watermark -v --iversions; %matplotlib qt. #Spin 1 operators; S1_x = 1/np.sqrt(2)*qutip.Qobj([[0,1.,0],; [1.,0,1.],; [0,1.,0]]). S1_y = 1.j/np.sqrt(2)*qutip.Qobj([[0,-1.,0],; [1.,0,-1.],; [0,1.,0]]). S1_z = qutip.qdiags([1.,0,-1.], 0). #canonical basis with corresponding projectors; canon_100 = qutip.basis(3,0) #ket |+1>; canon_010 = qutip.basis(3,1) #ket |0>; canon_001 = qutip.basis(3,2) #ket |-1>. proj100 = qutip.ket2dm(canon_100); proj010 = qutip.ket2dm(canon_010); proj001 = qutip.ket2dm(canon_001). #Hamiltonian pa",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1085:81,optimiz,optimization,81,https://qutip.org,https://github.com/qutip/qutip/issues/1085,2,['optimiz'],"['optimization', 'optimize']"
Performance,Hey buddy. There is a much faster (100x or more) sparse solver in the `_mkl` folder. The call is `mkl_spsolve` and it is a replacement for the SUPERLU solver that comes with scipy. The mkl module is only loaded for the Anaconda and Intel Python distributions. So you will need to have an if statement to check for it. The setting `has_mkl` tells you if the module is found and can be loaded.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528#issuecomment-243981044:204,load,loaded,204,https://qutip.org,https://github.com/qutip/qutip/pull/528#issuecomment-243981044,2,['load'],['loaded']
Performance,"Hi @dev-aditya, did you try running the code with QuTiP 5.0.0? It is currently in a pre release which means you need to install it with `pip install --pre qutip`. This new version introduces many changes and since it is a pre release there may be some rough edges still. The main reason you will see a performance improvement for this issue is the new data layer implementation. In a nutshell, it now supports not only sparse arrays, already present in QuTiP 4, but also dense arrays (numpy-like arrays). Dense arrays are better suited for this operation and hence you should expect an improvement using them. I hope you can give a try to QuTiP 5 and feel free to let us know how it performs :smile:.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/818#issuecomment-1665893251:302,perform,performance,302,https://qutip.org,https://github.com/qutip/qutip/issues/818#issuecomment-1665893251,2,['perform'],"['performance', 'performs']"
Performance,"Hi @dweigand, this looks interesting. It would you be nice to push this forward, adding some tests for this and integrating @Ericgig suggested changes. I am wondering whether there is a more intuitive (explicit) option than `qfunc_amat `. Something like a Boolean `precompute`?. Writing some documentation for this, in https://github.com/qutip/qutip-doc, would allow users to discover this option more easily at http://qutip.org/docs/latest/guide/guide-visualization.html#husimi-q-function, it's very nice you have some performance checks.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934#issuecomment-536368295:520,perform,performance,520,https://qutip.org,https://github.com/qutip/qutip/pull/934#issuecomment-536368295,2,['perform'],['performance']
Performance,"Hi @michelinesoley,. Your bug report inspired me to dig into the `qutip.control.optimize_pulse` sparse matrix support which lead to some fixes in #1621. When you increase `N` in your example from 2 to 3, it changes the internal type used by the optimizer to represent propagators. You can also make the `N = 2` case fail by changing the last line to:. ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=True)); ```. Your example can be made to work for `N = 3` (albeit slowly) by changing the following lines:. ```python; mapped = Qobj(mapped, dims=[[N]*4 + [2]*4] * 2); ```; (which was a bug in the example itself -- it created a Qobj with the right shape but wrong dimensions) and the last line to . ```python; result = cpo.optimize_pulse_unitary(..., dyn_params=dict(oper_dtype=Qobj, sparse_eigen_decomp=False)); ```; For me the `N = 3` case was slower with `sparse_eigen_decomp=True`, but perhaps it will be better for your full problem. If you would like to try `sparse_eigen_decomp=True` you are welcome to try the patch in PR #1621 and I would appreciate feedback on any performance issues for larger systems. We are currently working to support bigger systems in QuTiP 5 by using the new flexible Qobj data layer (which supports both sparse and dense matrices already and will hopefully support GPU and TensorFlow matrices in the near future).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386:245,optimiz,optimizer,245,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-885064386,4,"['optimiz', 'perform']","['optimizer', 'performance']"
Performance,"Hi Louis,. There is work in development that will allow `QobjEvo` to be build from callback also, not just list. This will make callback work anywhere easily. . I was in the impression that H callback worked already for mcsolve. I rewrote part of mcsolve and broke it. Looking at your commit, I inverted `_funcrhs_with_state` and `_funcrhs`...; Sorry to have you take time to correct it. The 20x is big, but the list format allows for optimizations that are hard to do with a callback. A big one is that you don't need to create a new matrix/Qobj when calling `mul_vec`, just use it. With this code, I see a 20x between `mul_vec` and creating a Qobj a python function. . ```; import numpy as np; import qutip as qt. qoe = qt.QobjEvo([qt.qeye(3),[qt.destroy(3), lambda t,_:np.sin(t)]]); qoe.compile(). o1 = qt.qeye(3); o2 = qt.destroy(3) ; def H(t):; return o1 + o2 * np.sin(t). v = np.ones(3)+0j; %timeit qoe(0); %timeit qoe.mul_vec(0, v); %timeit H(0); %timeit H(0).data * v; ```. One optimization you could do is having the callback return a `np.array` instead of a Qobj. In `mcsolve`, this would probably be simple to implement and I expect some speed gain. But it can't really be officially supported in Qutip, for now. . ps. All those 'redundant' argument setting are for reusing the system (`ss`) in multiple call of `mcsolve` with different args, used in `correlation`. Using string coefficient, the compilation step can take a few second, so it is set to be able to reuse a compiled system, changing the `psi0`, `args`, `e_ops`, etc. This will become a less obscure feature in v5 when solver object are available.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634:435,optimiz,optimizations,435,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634,4,['optimiz'],"['optimization', 'optimizations']"
Performance,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:384,perform,performance,384,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['perform'],['performance']
Performance,"Hi friends,. I'm going to import qutip as . from qutip import *. but i get this error:. Traceback (most recent call last):; File ""D:\py\Master_solve.py"", line 4, in <module>; import qutip; File ""C:\Users\Phd-02\AppData\Roaming\Python\Python36\site-packages\qutip\__init__.py"", line 149, in <module>; from qutip.qobj import *; File ""C:\Users\Phd-02\AppData\Roaming\Python\Python36\site-packages\qutip\qobj.py"", line 60, in <module>; from qutip.fastsparse import fast_csr_matrix, fast_identity; File ""C:\Users\Phd-02\AppData\Roaming\Python\Python36\site-packages\qutip\fastsparse.py"", line 423, in <module>; from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult); ImportError: DLL load failed: The specified module could not be found. Any suggestion?Thanks in advance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1613:694,load,load,694,https://qutip.org,https://github.com/qutip/qutip/issues/1613,1,['load'],['load']
Performance,"Hi paul,. Thanks for the feedback. I think maybe Rob had originally included the mkl stuff, but I took it out when I was bug fixing. Will put it in, I didn't realize it gave such a big performance boost. thats cool. I will also follow your advice and stick in a finite frequency to make sure all the solvers work. . I had a poke around in discussion forums for numpy and scipy, and it seems like the problem is that they throw an exception when they decide L is ""exactly singular"" (which technically it is). Sometimes numerical rounding errors prevent this exception, as occurs in larger systems, or adding a finite frequency, so it tries to solve it anyway and succeeds, because the projector Q on the right-hand side guarantees a solution. Conversely, matlab will just throw a warning, and try and solve it anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/528#issuecomment-243988381:185,perform,performance,185,https://qutip.org,https://github.com/qutip/qutip/pull/528#issuecomment-243988381,2,['perform'],['performance']
Performance,"Hi!. About the comments: yes, absolutely I'll leave more. It's a bit silly that I haven't yet, since one thing that was frustrating me previously was not understanding what was trying to be done! I think as time goes by I'm getting a bit better about being clearer in the code - some of the earlier parametrizations I did were too aggressive because I wasn't used to the tools yet. The `test_control_pulseoptim` parts are very complex, in part because the underlying calling convention of that code is complex too. I'll try and add more comments to it to ease that along, especially in the part where I just defined a load of systems to test. That certainly should have been commented. There are general comments about what I was using the `pytest` tooling for in the commit messages, but I didn't necessarily want to leave ""intro to pytest"" comments throughout, because it would mostly crowd out the actual tests, and the `pytest` documentation online is probably going to be a better explanation than what I can do. I'm also learning `pytest` by doing this (I'd not used it before I opened the first PR)!. About the PRs: I'm happy with whatever workflow works best for you guys - I don't have any control over when the PR gets merged. It might be a little difficult for me to maintain two branches at once (i.e. if the first PR with ~10 tests is awaiting merging), because there's likely to be conflicts in `conftest.py` (in particular). Even if I branched the new PR off the previous one on the expectation that it would be merged, I'd have to keep adding merge commits into (or force-rebasing) the other branch to keep it up-to-date, which wouldn't be completely ideal in that it would make a bit of a mess in the git log. If you want to merge this one (after I've gone through and put some more comments in), I'm happy to start a new one. I can also start a new one on a new branch, I think it might just make a bit more of a mess than it solves. I think this one only got big because I had a goo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241:618,load,load,618,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-591413241,2,['load'],['load']
Performance,"Hi!. I'd like to report an installation issue on CentOS/RHEL platforms. I've tested various Python versions (2.7, 3.4) on both RHEL 6.x and 7.x, and the error is consistent, and happens during compilation of some Cython files. The error is: `ambiguous overloaded method` referring to the `abs()` function, and happens in two different places. Full installation output:; ```; $ pip install qutip; Collecting qutip; Using cached qutip-4.1.0.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef double * col_sum = <double *>PyDataMem_NEW_ZEROED(ncols, sizeof(double)); cdef double max_col = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; k = ind[jj]; col_sum[k] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:316:29: ambiguous overloaded method; ; Error compiling Cython file:; ------------------------------------------------------------; ...; cdef size_t ii, jj; cdef double * row_sum = <double *>PyDataMem_NEW_ZEROED(nrows, sizeof(double)); cdef double max_row = 0; for ii in range(nrows):; for jj in range(ptr[ii], ptr[ii+1]):; row_sum[ii] += abs(data[jj]); ^; ------------------------------------------------------------; ; qutip/cy/sparse_utils.pyx:335:30: ambiguous overloaded method; Compiling qutip/cy/spmatfuncs.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/stochastic.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/sparse_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/graph_utils.pyx because it depends on /home/kilian/qutip/lib/python2.7/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/cy/interpolate.pyx because it depen",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/723:420,cache,cached,420,https://qutip.org,https://github.com/qutip/qutip/issues/723,1,['cache'],['cached']
Performance,"Hi, I was reading about builder patterns and came across this [discussion](https://stackoverflow.com/questions/11977279/builder-pattern-equivalent-in-python) which seems to suggest that builder patterns are not necessarily needed in Python. Instead, all the functions could probably be bundled into a single ```PulseOptimizer``` class and whatever the wrapper functions are doing right now can be methods of this class. The input arguments can be initialised in the __init__ of this class. This you could have something like. ```; from qutip.control.pulseoptim import PulseOptimizer. optimizer = PulseOptimizer(drift="""", ctlr="""", ....); crab = optimizer.opt_pulse_crab(args, ...); unitary_crab = optimizer.opt_pulse_crab_unitary(args,...); ```. @MichalKononenko - if you are suggesting something like [this](https://sourcemaking.com/design_patterns/builder/python/1) then perhaps it is that same as what I suggested on top.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/692#issuecomment-313407939:584,optimiz,optimizer,584,https://qutip.org,https://github.com/qutip/qutip/issues/692#issuecomment-313407939,3,['optimiz'],['optimizer']
Performance,"Hi, this is just a refactoring of @nwlambert 's code for a generic HEOM solver which takes in a set of exponents and coefficients for a spectral density function and can be used to work with arbitrary spectral density functions. In comparison, the current `heom` solver in QuTiP is specialized. . Specific quantum systems in the `qutip/models` sub-module could have the following signature:; ```; model = System(hamiltonian, **params); result = model.solve(initial_state, tlist, options); ```; System specific functions could be in the model class. For instance,; ```; model._rhs(); ```; gives the RHS (a matrix equivalent to an effective Liouvillian) of the density matrix evolution equation. If any system can be written down as the evolution of an initial density matrix as dp/dt = (RHS)p, and there is an optimised way to solve, it can be written down as a qutip.model. The other necessary function would be a basis change map or a lookup dictionary for translating a state tuple to the index in the larger density matrix which is used for the evolution using the effective Liouvillian. This is the `_heom_state_dictionaries` in this case and `jmm1_dictionary` in case of the WIP #753 . The code in the current form is good enough to be used but it needs to be optimized further. The next steps are:; - [x] Tests for RHS generation and the solve function; - [ ] Optimize the generation of the effective Liouvillian (RHS) similar to the `heom` solver; - [ ] Refactoring and deciding on the API (how to pass in the coefficients etc)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/793:1265,optimiz,optimized,1265,https://qutip.org,https://github.com/qutip/qutip/pull/793,2,"['Optimiz', 'optimiz']","['Optimize', 'optimized']"
Performance,"Hi,. I recently had to animate a Wigner plot, to show the evolution of the Wigner function in time. It looks like QuTip does not any specific methods to ease this, at least when doing it in a Jupyter notebook. Typically, the `qutip.plot_wigner` method is really handy to plot Wigner functions, as it deals with everything, from the Wigner generation to the correct plotting. However, using it in an animation function callback from `matplotlib.animation.FuncAnimation` is not doable if you want it to be plotted live in the notebook. And to use `qutip.wigner.wigner` you have to manually reproduce lots of code from `qutip.plot_wigner`. I can think about two solutions to this issue:; 1. Enhancing `qutip.plot_wigner` so that it supports the first parameter to be a list of ket / density matrices, and in such a case it would render an animation rather than a single plot.; 2. Splitting `qutip.plot_wigner` in different methods that could be called independently. Typically, a first method to initialize the Wigner plot (that is set the correct colormap, labels for axis and so on), another one to compute a wigner function to render and a last one to perform the plot itself which would call all the other methods and have the same behavior as the current `qutip.plot_wigner` method. This way, if one wishes to render an animation of a Wigner function time evolution, he can call the first method to setup the matplotlib figure accordingly, then precomputes all the wigner arrays to plot on the animation and handle the animation part on his own, typically with a `FuncAnimation` animation. Thanks!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/544:1152,perform,perform,1152,https://qutip.org,https://github.com/qutip/qutip/issues/544,1,['perform'],['perform']
Performance,"Hmmm... Well since we deal with complex numbers by default, perhaps it is best to use numpy by default and then mention that one can get a little better performance using cmath.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-45703141:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-45703141,1,['perform'],['performance']
Performance,How does the performance of the using the C math functions compare to using cmath and the numpy functions?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/251#issuecomment-61602992:13,perform,performance,13,https://qutip.org,https://github.com/qutip/qutip/pull/251#issuecomment-61602992,1,['perform'],['performance']
Performance,"How to start the quantum optimal control optimization, say GRAPE, from a custom initial pulse instead of LIN/ZERO/RND?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1117:41,optimiz,optimization,41,https://qutip.org,https://github.com/qutip/qutip/issues/1117,1,['optimiz'],['optimization']
Performance,"I agree that performing a ufunc like `np.sin(...)` on a `QObj` and getting an `np.array` back is not that useful since presumably one would like a QObj back (otherwise why not just call `.full()` and work with the resulting numpy array directly). Likely this is a breaking change for some people, so we should document whatever approach we take.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772330954:13,perform,performing,13,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772330954,1,['perform'],['performing']
Performance,"I am distributing some qutip code to several cores. I want to enforce that qutip only uses one core per job with qutip.settings.num_cpus=1, but it is not working, the processes still take all the processors of my machine, so that if I have N cores, the multiprocessing ends up using N*N threads, slowing things down a lot! How can I force qutip to use only 1 core? Currently loading like this:. ```; from qutip import create, destroy, Qobj, expect, tensor, qeye, fidelity, basis, variance, settings; from pathos.multiprocessing import ProcessingPool. settings.num_cpus = 1; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1175:375,load,loading,375,https://qutip.org,https://github.com/qutip/qutip/issues/1175,1,['load'],['loading']
Performance,"I am running a IPython/Jupyter Notebook via [supervisor](http://supervisord.org/) which does not export the `$HOME` environment variable (this is of course easily fixable). When importing qutip, I get the following warning message:. ```; WARNING:qutip.settings:Error loading RC file.; Traceback (most recent call last):; File ""/home/mvd/miniconda3/lib/python3.4/site-packages/qutip/__init__.py"", line 138, in <module>; os.environ['HOME'], "".qutiprc""; File ""/home/mvd/miniconda3/lib/python3.4/os.py"", line 633, in __getitem__; raise KeyError(key) from None; KeyError: 'HOME'; ```. Since this is just a warning, does it mean that there are no problems, or will it have some effects?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/365:267,load,loading,267,https://qutip.org,https://github.com/qutip/qutip/issues/365,1,['load'],['loading']
Performance,"I am trying to perform this simple operation <a href=""https://www.codecogs.com/eqnedit.php?latex=(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?(H^{\otimes&space;2}&space;\otimes&space;I^{\otimes&space;2}&space;)&space;\times&space;\psi"" title=""(H^{\otimes 2} \otimes I^{\otimes 2} ) \times \psi"" /></a>; where ; <a href=""https://www.codecogs.com/eqnedit.php?latex=H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?H&space;=&space;\frac{1}{\sqrt{2}}&space;\times&space;\begin{bmatrix}&space;1&space;&&space;1\\&space;1&space;&&space;-1&space;\end{bmatrix}&space;,&space;I&space;=&space;\begin{bmatrix}&space;1&space;&&space;0&space;\\&space;0&space;&&space;1&space;\end{bmatrix}"" title=""H = \frac{1}{\sqrt{2}} \times \begin{bmatrix} 1 & 1\\ 1 & -1 \end{bmatrix} , I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}"" /></a>; and ; <a href=""https://www.codecogs.com/eqnedit.php?latex=\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" target=""_blank""><img src=""https://latex.codecogs.com/gif.latex?\psi&space;=&space;\left|0\right\rangle^{\otimes&space;4}"" title=""\psi = \left|0\right\rangle^{\otimes 4}"" /></a>; I do that as follow: ; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); ```; and i got the following : . ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/888:15,perform,perform,15,https://qutip.org,https://github.com/qutip/qutip/issues/888,1,['perform'],['perform']
Performance,"I am using GRAPE to identify optimal pulse sequences to produce a desired unitary, and am running into an error when I use optimize_pulse_unitary for sparse matrices of size 1296x1296 and larger. . For example, the following code works for N=2 but fails for N=>3:. ```python; import numpy as np; from qutip import *; from scipy.sparse import csr_matrix; import qutip.logging_utils as logging; logger = logging.get_logger(); #Set this to None or logging.WARN for 'quiet' execution; log_level = logging.INFO; #QuTiP control modules; import qutip.control.pulseoptim as cpo; import math. # Set parameters; chi = 2.2 * 2 * np.pi # coupling strength; N = 3 # number of cavity states; n_ts = 21 # number of discrete time steps; evo_time = 4. # Length of time; fid_err_targ = 1e-10 # Target fidelity error; max_iter = 0 # # Maximum iterations for the optimization algorithm; max_wall_time = 0 # Maximum (elapsed) time; min_grad = 1e-20 # Minimum gradient; p_type = 'SINE' # pulse type (RND|ZERO|LIN|SINE|SQUARE|SAW|TRIANGLE); f_ext = ""pulsedata.txt"" # output file. # Set operators and Hamiltonians. # operators; a = tensor(destroy(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); b = tensor(qeye(N), destroy(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); c = tensor(qeye(N), qeye(N), destroy(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)); d = tensor(qeye(N), qeye(N), qeye(N), destroy(N), qeye(2), qeye(2), qeye(2), qeye(2)); sm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), destroy(2), qeye(2), qeye(2), qeye(2)); zm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), destroy(2), qeye(2), qeye(2)); tm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), destroy(2), qeye(2)); qm = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), destroy(2)); P_se = tensor(qeye(N), qeye(N), qeye(N), qeye(N), basis(2, 1) * basis(2, 1).dag(), qeye(2), qeye(2), qeye(2)); P_ze = tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), basis(2, 1) * basis(2, 1).d",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:843,optimiz,optimization,843,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimization']
Performance,"I apologize to all for the delay, but I just added checks for regression on this issue. They currently fail due to a problem with `to_chi` and multiple qubits. ``` python; ======================================================================; ERROR: Failure: TypeError (Incompatible Qobj shapes); ----------------------------------------------------------------------; Traceback (most recent call last):; File ""C:\Anaconda\lib\site-packages\nose\loader.py"", line 251, in generate; for test in g():; File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\tests\test_qobj.py"", line 671, in test_dag_preserves_superrep; yield case, to_chi(qobj); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 435, in to_chi; return to_chi(to_choi(q_oper)); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 432, in to_chi; return choi_to_chi(q_oper); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\superop_reps.py"", line 258, in choi_to_chi; return Qobj(B.dag() * q_oper * B, superrep='chi'); File ""C:\Users\Chris\Dropbox\software-projects\qutip\qutip\qobj.py"", line 455, in __mul__; raise TypeError(""Incompatible Qobj shapes""); TypeError: Incompatible Qobj shapes. ----------------------------------------------------------------------; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/375#issuecomment-152945134:447,load,loader,447,https://qutip.org,https://github.com/qutip/qutip/pull/375#issuecomment-152945134,1,['load'],['loader']
Performance,"I believe the issue is on lines 833-835:. ``` python. if ODE.t > tlist[k]:; ODE.set_initial_value(y_prev, t_prev); ODE.integrate(tlist[k], step=0); ```. removing these lines gives similar performance.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64523119:188,perform,performance,188,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64523119,1,['perform'],['performance']
Performance,"I believe this is the only `-march=native` we have. It will cause problem if left here so it's better to remove it. . However it may create a bigger slowdown than expected. If you look at [qutip/cy/src/zspmv.cpp](https://github.com/qutip/qutip/blob/master/qutip/cy/src/zspmv.cpp), you will see low level optimization that only activate on certain cpus. This is the main function used in solver (mat*vec) and can be 30% slower or faster than than scipy's version depending on the situation. Without this low level optimization, we are essentially doing the same thing as scipy so should get similar times.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463470158:304,optimiz,optimization,304,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463470158,2,['optimiz'],['optimization']
Performance,I believe we are not supporting any changes to the Fortran code now that the mcsolver is on par performance wise. Thus closing this question.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/213#issuecomment-186705504:96,perform,performance,96,https://qutip.org,https://github.com/qutip/qutip/issues/213#issuecomment-186705504,1,['perform'],['performance']
Performance,"I can reproduce this problem.; (Note: environment is different of my previous reply, but qutip is latest 4.6.2). I attached a notebook:; https://gist.github.com/KosukeMizuno/5f879603b6343a18fdf0dc50f3f8b7b0#file-checkpyx-ipynb. How to reproduce:; 1. run this notebook; - A `cqobjevo_compiled_coeff_xxx.pyx` file is generated at cell[2].; 2. save output by pickle (cell[4]); 3. load pickled file (cell[5]); - it succeeds.; 4. restart kernel; - At this timing, `pyx` file was automatically removed.; 5. run cell[5] (load pickled file); - it fails. ```; Exception ignored in: <function QobjEvo.__del__ at 0x000001E0295BC4C0>; Traceback (most recent call last):; File ""c:\users\mizuno\research\py38\lib\site-packages\qutip\qobjevo.py"", line 624, in __del__; for file_ in self.coeff_files:; AttributeError: 'QobjEvo' object has no attribute 'coeff_files'; ---------------------------------------------------------------------------; ModuleNotFoundError Traceback (most recent call last); <ipython-input-1-ca5f267c7a72> in <module>; 1 with Path('mesolvedat.pkl').open('rb') as f:; ----> 2 out2 = pickle.load(f). ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_5082571634280'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770:377,load,load,377,https://qutip.org,https://github.com/qutip/qutip/issues/1684#issuecomment-934241770,3,['load'],['load']
Performance,"I can't really see an application for checking whether two Gates are equal. Even if all the parameters are the same, but it will not be in the same place in the circuit, so it won't be doing the same job. This does not mean that there is not one. I just can't think of one. However if there exists a `__eq__` method, then it should just be checking whether the two gates would perform the same unitary operation, which I guess means comparing the name, arg_label and arg_value. If you want to check whether it is the same Gate in the network, then can you not use `is` as it should be the same object.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/612#issuecomment-270284097:377,perform,perform,377,https://qutip.org,https://github.com/qutip/qutip/issues/612#issuecomment-270284097,1,['perform'],['perform']
Performance,"I completely agree with you that random tests really aren't the right way to go in general, but right now our problem is that basically QuTiP's entire testing suite is based on randomised tests, and that's an awful lot of technical debt to overcome any time soon :(. . The `dnorm` tests have historically been a huge problem, even though basically nobody's worked on `dnorm` for a long long time now (for context, see in particular #880 and #874). We don't actually even know if the failures in `dnorm` are deterministic and reproducible, although it turns out that I had a brief look into this when I joined as a GSoC student about a year ago... I don't remember doing it at all!. I know this is super inelegant and not the perfect method, but it's kind of a nasty trade-off - I don't have time to really dig into `dnorm` (a topic I know almost nothing about) to work out an appropriate solution to temperamental errors, we do want `dnorm` to be tested since we're shipping it, and the slight flakiness keeps causing us test suite failures about 1 in 10 times. I'm somewhat opposed to fixing the random seed because having the variance over several test runs does actually help us cover more ground (eventually) - fixing it to a ""known good"" seed actually seems to me to be more of a mask of potential problems than this. Of note: the pytest plugin I'm using reports the number of reruns it performed in the analysis at the bottom - they show up in a yellow alongside the ""skips"" and ""xfails"" - so it's not completely hidden. I'd love to have a property-based testing suite like hypothesis up and running - that definitely seems like the proper solution to this in the end. In the meantime, I'm open to swapping to a fixed random seed if you think that's much better - testing is one place where I'm really aware of my lack of formal experience in software engineering, so I'm basically just learning as I go.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227:1392,perform,performed,1392,https://qutip.org,https://github.com/qutip/qutip/pull/1490#issuecomment-815317227,2,['perform'],['performed']
Performance,"I do not think that much can be done for the mesolver. The update here ; just addresses the resetting of the ODE solver, which is not done in the ; mesolver. I still think that spawning ntraj processes is not a very ; efficient thing to do. So I am working on cleaning that up. However, ; you are correct, moving the ODE creation outside of the mc_alg routine ; does have little effect. > Robert Johansson mailto:notifications@github.com; > December 1, 2014 at 13:48; > ; > Nice speed up! Is there anything here that we could also benefit from ; > in mesolve? Or is it specific to mcsolve in that it mostly affect the ; > ODE restart?; > ; > I doubt that the initial setup of an ODE instance before spawning ; > processes would have any significant impact on the performance (note ; > that multiprocessing does not use threads, it uses processes, so there ; > is no sharing of ODE instances between processes). Creating the ODE ; > instance once in the parent processor, or N times in N processes in ; > parallel therefore should not make much difference, if any.; > ; > —; > Reply to this email directly or view it on GitHub ; > https://github.com/qutip/qutip/pull/264#issuecomment-65020496.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020643:763,perform,performance,763,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020643,1,['perform'],['performance']
Performance,"I don't have xvfb (pytest-xvfb) installed specifically for qutip, but it is used by other packages (The general use of pytest-xvfb is to facilitate testing of GUI, graphical or windowing functionality without having an normal Xserver active. That is, it can be useful for automated CI testing of gui packages, for instance in chroots or cloud CI infrastructure). Since qutip doesn't use xvfb directly this bug won't be a problem for general CI testing, where only qutip is loaded on a cloud instance (for instance Debian testing done at https://ci.debian.net/packages/q/qutip/). But before I upload a package to the Debian infrastructure, I like to run the tests on my own system to be confident they're likely to pass. So this is where the problem happens, running tests on my own system, where I have pytest-xvfb installed for testing other packages. (pytest has this bad habit of loading all available plugins whether or not they're actually used by the tests being run. It's quite annoying actually. It would be better if it only loaded plugins specified in conftest.py). So the use case is running the qutip tests on my own system, where pytest-xvfb simply happens to be installed for other purposes not related to qutip. There are ways of working around the problem, for instance the `--no-xvfb` option could be explicitly added to the `pytest` command line. But it can be useful if the test code itself can be made robust with respect to the problem (e.g. in this case just replacing `plt.clf()` with `plt.close('all')`)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791:473,load,loaded,473,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-909115791,6,['load'],"['loaded', 'loading']"
Performance,"I don't think it breaks the functional API at all - in fact it almost makes it stronger, since everything is a ""function"" at every stage. This kind of partial application is classic part of functional programming. Perhaps I don't understand _why_ you want to move to a class-based API? I'd be quite strongly against having the user have to instantiate classes to do very simple parts like creating operators. Certainly in Python programming, I don't think a class-based interface is de facto the right sort to aim for, and procedural is much more ""Pythonic"". For one, it's a lot of unnecessary boilerplate for simple operations. It adds cognitive complexity for the advanced user to decide ""should I use `displace` or `Displacer`?"", and in the strong majority of use-cases, the operator creation is not a computational bottleneck so we'd be adding it for no gain. A lot of operators have no meaningful reason to live in a class, like `sigmax` and so on, so now you have a split between operators that need a class and operators that don't, or you do something really crazy like requiring the user to do; ```python; sx_builder = qutip.operators.SigmaX(); sx = sx_builder.get_operator(); sy_builder = qutip.operators.SigmaY(); sy = sy_builder.get_operator(); sz_builder = qutip.operators.SigmaZ(); sz = sz_builder.get_operator(); ```; when all they wanted was `qutip.sigmax(), qutip.sigmay(), qutip.sigmaz()`. Obviously that example is a bit facetious, but what benefit does the user derive from having to write boilerplate to access simple functionality?. All the operators already share a class in `Qobj`, and things like `displace` and `sigmax` are factory methods of `Qobj`. What shared functionality do the factory methods possess that means they should be classes?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332:819,bottleneck,bottleneck,819,https://qutip.org,https://github.com/qutip/qutip/issues/1293#issuecomment-646631332,2,['bottleneck'],['bottleneck']
Performance,"I dont think that there would be a performance issue. If everything builds​ fine, then that is what we should do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647#issuecomment-279448031:35,perform,performance,35,https://qutip.org,https://github.com/qutip/qutip/issues/647#issuecomment-279448031,1,['perform'],['performance']
Performance,"I guess not. But my original motivation was to try to do the mcsolver in; cython. Perhaps the scipy blas calls work just as good in cython. I; already ran into these blas difficulties on the mac. You would think the; calling structure would be uniform by now.; On Aug 10, 2013 6:08 PM, ""Robert Johansson"" notifications@github.com; wrote:. > Now with a8b79f7https://github.com/qutip/qutip/commit/a8b79f7bd2ad58713e9ed7b104e204b155fcdc20it works again on my machine. Is there a big difference in performance; > between accessing the blas stuff through scipy instead of directly from a; > cython module? If not it would be good to let the scipy ppl worry about the; > linking to blas and not have to deal with that in qutip.; > ; > —; > Reply to this email directly or view it on GitHubhttps://github.com/qutip/qutip/issues/39#issuecomment-22436635; > .",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436693:494,perform,performance,494,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436693,1,['perform'],['performance']
Performance,"I had a quick play with the feature, for the cases I had stumbled on before, with `eigenstates()' ignoring default_dtype, using the scope of 'full' covers it now. I understand having this work with just 'creation' scope is problematic because you want to make sure the dtype is not used on results lists. heom+full breaks with dia and dense, as expected!. speaking of heom, manually converting the RHS to jaxdia and doing stuff it worked fine. i think generalizing the RHS construction in heom away from csr is probably very difficult without huge performance drop in the construction, so perhaps some kind of wrapper or option to do conversion of types after construction would be fine?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815:548,perform,performance,548,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2418554815,1,['perform'],['performance']
Performance,"I had to move faster and complete the full implementation in a rather quick and unstructured manner for my lab. I will finish it and then systematically build this PR so that it becomes easy for review. I have a working implementation of the ICM model now and a partial implementation of [Pauli tracking](https://www.date-conference.com/files/proceedings/2014/pdffiles/05.6_7_ip2-19.pdf) which pushes all the corrections and measurement to the end of the circuit.; ### Circuit with a rotation gate (V gate). ![v](https://cloud.githubusercontent.com/assets/6968324/21744357/3fe6c324-d557-11e6-8829-7202ff6d3760.png). ### Pauli tracked ICM representation of circuit. ![v_p](https://cloud.githubusercontent.com/assets/6968324/21744360/48959432-d557-11e6-8a5e-02b47b33698f.png). Thus, we get a quantum circuit with qubit initializations in the begining, a mesh of CNOT gates in the middle and measurements in the end. This seems to be very useful as the starting point of topological quantum circuit optimization. Future work: . 1. Represent qubit initializations in some way. Right now I consider everything as a gate. (Perhaps make new objects for qubit intializations, measurement, correction etc.). 2. Better visualization such that all initializations, measurements and corrections can be stacked in one line. 3. Representing the information regarding P_dagger, T_dagger, V_dagger gate teleportation in some way. The difference is just based on the interpretation of the measurement. 4. Complete the Pauli tracking algorithm to get the gate sequence for correction based on measurement. Tests, tests and more tests.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-271102783:996,optimiz,optimization,996,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-271102783,1,['optimiz'],['optimization']
Performance,"I have a simple task of maximizing $\text{Tr}(O \rho(T))$ using GRAPE where $O$ is a given fixed Hermitian matrix and $\rho(T)$ is a time-evolved quantum state under given Hamiltonian and time interval $[0,T]$. You can also think about this as maximizing trace overlap between two quantum states, if we set $O$ to be another density matrix. I've used all three different fidelitycomputers, but apparently all of them failed to optimize the cost function properly. I'd appreciate it much if anyone can help me understanding what I've been doing wrong! I attached a simple example code below with explanations:. 1. First, I initialized setups such as defining Hamiltonian, initial state, and target observable $O$. Then by creating `create_pulse_optimizer` as follows, I defined/initialized the dynamics as `dyn` with some randomly chosen initial amps. I tried all possible choices of `fid_type`. (see code below). <img width=""977"" alt=""grape_example1"" src=""https://user-images.githubusercontent.com/55151494/170385354-f7efe678-11fc-47de-afa7-ac77359bb5e0.png"">. 2. I then ran the optimization using GRAPE and reported its results. As shown below and in particular the very last line of the figure, the cost function I wanted to estimate is just $0$, whereas my task wants to maximize $\text{Tr}(O\rho)$. While testing several things, I changed $O$ to a ket vector (e.g. $|00>$) and it worked very well. So in principle, I thought the code should work properly as we can think of $O$ being a quantum state (e.g. $|00><00|$). . <img width=""1013"" alt=""grape_2"" src=""https://user-images.githubusercontent.com/55151494/170385858-eeddb7fb-f821-4057-8503-ee2a52e27805.png"">; <img width=""968"" alt=""grape_3"" src=""https://user-images.githubusercontent.com/55151494/170385868-7816a7ee-cc90-4dba-83dd-3304cd2404d8.png"">. I'd be great if someone points out what I'm missing here. One of my guesses of why this is happening is perhaps because we evolve a ket statevector while the target observable is in full matrix",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1900:427,optimiz,optimize,427,https://qutip.org,https://github.com/qutip/qutip/issues/1900,1,['optimiz'],['optimize']
Performance,"I have noticed some performance benefits with openblas but nothing noticeable for the sparse matrix routines. Multithreading gets some extra performance but the scaling is sublinear for sure. Just a couple of percent. From what I understand many sparse routines are limited by memory bandwidth. This is usually discussed in the context of the spmv. The biggest benefit when going to openblas is the removal of the umfpack out of memory errors. I dont think this has anything to do with the actual openblas functions but somewhere in the build process (suitesparse, metis, or something) the memory limitation is removed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/55#issuecomment-25365509:20,perform,performance,20,https://qutip.org,https://github.com/qutip/qutip/issues/55#issuecomment-25365509,2,['perform'],['performance']
Performance,"I have recently started to use QuTiP to compute unitary and Hamiltonian evolutions. Most of the calculations involved Hamiltonians (or circuits) defined on separate regions of the Hilbert space plus some other Hamiltonians used to couple the different systems together. When performing the simulations I have found that the requirement that Qobjs must have the same dims attribute to be summed or multiplied tends to make the code quite convoluted (the convolution might also come from my inexperience with QuTiP). For example (I will use circuits but the same issues applies to Hamiltonians). Let |psi> be a random 4-qubit state and C a random unitary on the first two qubits. In order to compute C|psi> one must specify the tensor structure of the random objects and not use qeye(8) but the tensor product of three qeye(2):. `C = tensor(rand_unitary_haar(4, dims = [[2,2],[2,2]]), tensor(qeye(2),qeye(2),qeye(2)))`; `psi = rand_ket(32, dims = [[2,2,2,2,2], [1,1,1,1,1]])`. I understand that the tensor product structure in the Qobj class might yield lots of advantages but it might be interesting to consider if in some cases it is possible to allow the summation or multiplication of Qobs of different dims but with the same shape. In this case, the above example would simplify to:. `C = tensor(rand_unitary_haar(4), qeye(8))`; `psi = rand_ket(32)`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1253:275,perform,performing,275,https://qutip.org,https://github.com/qutip/qutip/issues/1253,1,['perform'],['performing']
Performance,"I have tried to address this in #464. It defaults to a dense method that runs about 10x faster. Also, as already discussed, one can use the MKL to get a performance benefit when the dimensionality becomes large.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/462#issuecomment-209203520:153,perform,performance,153,https://qutip.org,https://github.com/qutip/qutip/issues/462#issuecomment-209203520,1,['perform'],['performance']
Performance,"I have written a parallel spmv that performs quite well. Sadly, only compiles on linux since it uses openmp. Will create a pull tonight",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/438#issuecomment-215176723:36,perform,performs,36,https://qutip.org,https://github.com/qutip/qutip/issues/438#issuecomment-215176723,1,['perform'],['performs']
Performance,"I might oppose to the fact that it should be default. The reason is that majority of people don't read the documentation and don't know what ""segfault: illegal instruction"" means. It might better to note somewhere that `CFLAGS=""-march=native"" pip install qutip` will lead to 30% increased performance in certain scenarios.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/951#issuecomment-463772270:289,perform,performance,289,https://qutip.org,https://github.com/qutip/qutip/issues/951#issuecomment-463772270,1,['perform'],['performance']
Performance,I personally haven't used mcf90 for a looong time. If it is true that it does not give much of a performance improvement any more I think it makes sense to phase it out.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/439#issuecomment-221096657:97,perform,performance,97,https://qutip.org,https://github.com/qutip/qutip/issues/439#issuecomment-221096657,1,['perform'],['performance']
Performance,I see. `propagator` performed better with a system of d=2^5 in a simple test. I better do some testing of even larger systems then before merging this. Any thoughts on why `propagator` might be slower also for small systems and short integration times? Some overhead related to parallelization? Thanks for the info.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/502#issuecomment-230108497:20,perform,performed,20,https://qutip.org,https://github.com/qutip/qutip/pull/502#issuecomment-230108497,2,['perform'],['performed']
Performance,"I seems there is a few issues with Nonetypes in for loops, but otherwise this is a great speed up. We never got around to optimizing this function nor the floquet solver (I think) and it is about time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/336#issuecomment-94270233:122,optimiz,optimizing,122,https://qutip.org,https://github.com/qutip/qutip/pull/336#issuecomment-94270233,1,['optimiz'],['optimizing']
Performance,"I think it should be possible to do this within the pytest framework without touching the package `setup.py` or `MANIFEST`. [`pytest.fixture`](https://docs.pytest.org/en/stable/fixture.html#sharing-test-data) seems a natural choice for loading data. For file accessibility, [this](https://stackoverflow.com/questions/46019170/how-do-you-properly-integrate-unit-tests-for-file-parsing-with-pytest) might help. Porbably @jakelishman knows more about the natural way of doing this with pytest?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508:236,load,loading,236,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-655970508,1,['load'],['loading']
Performance,"I think it would be great to have a fast implementation of tensor contraction. However, QuTiP has moved on since this PR and I think the right way to implement this now would be to add a new specialization to the data layer for tensor contraction (maybe something like einsum) and to implement that instead (or even just to re-implement methods for the new CSR representation). @IIAOPSW If you're up for giving that a try, that would be awesome. If not, I might close this PR and we can revisit it after QuTiP v5 alpha has been released. @IIAOPSW Separately, I've read through the code the PR, but I'd still like to get a high-level summary of the algorithm you're implementing (or a reference). Quite a lot of work has been done in optimizing these contractions in recent years, and it would be nice to implement a good algorithm in QuTiP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-983852684:733,optimiz,optimizing,733,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-983852684,1,['optimiz'],['optimizing']
Performance,"I think that typically you don't gain much by using more processes than the number of cores, even if hyperthreading is available. In some cases you even get a performance degradation, so that's the reason why we dont default to cores*threads. However if you want to you can set the num_cpu flag explicitly.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/260#issuecomment-63587960:159,perform,performance,159,https://qutip.org,https://github.com/qutip/qutip/issues/260#issuecomment-63587960,1,['perform'],['performance']
Performance,"I think that you may have issues with xrange in Python3 as well. I believe it was dropped, as range in Python3 does what xrange does in Python2. I think the qutip philosophy is that we should be developing for Python3, but backwards compatible. As in this case, using range will have a performance hit in Python2, but not Python3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/358#issuecomment-128331704:286,perform,performance,286,https://qutip.org,https://github.com/qutip/qutip/pull/358#issuecomment-128331704,1,['perform'],['performance']
Performance,I think that's a good thing that we've tested that - we need to work out why performance is so bad on mac with Python 3.8.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1348#issuecomment-680004224:77,perform,performance,77,https://qutip.org,https://github.com/qutip/qutip/pull/1348#issuecomment-680004224,1,['perform'],['performance']
Performance,I think there are some optimized Cython routines which for some of the solvers which need cython in run-time. Not completely sure about it. Let me check.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/893#issuecomment-403675579:23,optimiz,optimized,23,https://qutip.org,https://github.com/qutip/qutip/issues/893#issuecomment-403675579,1,['optimiz'],['optimized']
Performance,"I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. It might be faster already if you evaluate the piecewise varying parts into one ""constant"" part at each point. This isn't guaranteed, because it involves copying rather more data _before_ the call (to construct the constant matrix once), but if the integrator would need to take many intermediate time steps, I expect it would win out. Would something like this work for you?; ```python; times = [0, ...]; # Liouvillians for parts you have control over; control_liouvillians = [qutip.liouvillian(h) for h in control_hamiltonians]; # The time-dependent Hamiltonian for stuff you're not controlling; base_hamiltonian = qutip.QobjEvo([H0, [H1, time_dependence], ...]); # Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:481,perform,perform,481,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,2,['perform'],['perform']
Performance,I try to `pip install qutip==4.0.2` (all the latest versions cannot be installed and have even more complicated error). The error seems to be easier to diagnosed. But I still cannot find out which part goes wrong and why the error happened. The error is:; ```; Collecting qutip==4.0.2; Using cached https://files.pythonhosted.org/packages/c1/de/2efee1b7f6cadd45426ef7b0759cdc3e522672a509d1c75bb317cc4be6cb/qutip-4.0.2.tar.gz; Complete output from command python setup.py egg_info:; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:2:10: cimported module has no attribute 'float64'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ; DTYPE = np.float64; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:5:10: cimported module has no attribute 'int32'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.float64_t DTYPE_t; ; ITYPE = np.int32; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:8:10: cimported module has no attribute 'complex128'; ; Error compiling Cython file:; ------------------------------------------------------------; ...; ctypedef np.int32_t ITYPE_t; ; CTYPE = np.complex128; ctypedef np.complex128_t CTYPE_t; ; CTYPE = np.int64; ^; ------------------------------------------------------------; ; qutip/cy/parameters.pxi:11:10: cimported module has no attribute 'int64'; ```; Thank you very much.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/911:292,cache,cached,292,https://qutip.org,https://github.com/qutip/qutip/issues/911,1,['cache'],['cached']
Performance,"I understand completely!. I'd probably just go to `int64` with your internal CSR implementation for the moment. Would it be very easy to have the `int32`/`int64` boiled down to a single compile-time flag, for those people that compile QuTiP manually and feel they really need the smaller `int32` matrices? The pre-compiled pip/conda releases could be `int64`. That might be a simple way to provide some support for ""both"". Somehow, I thought that SciPy would put a lot more emphasis on performance, and do things like Kronecker products without conversion. It would seem that SciPy should be the place to really optimize the sparse linear algebra implementation, including all the possible combinations like `CSR * DIA`. Then everyone could build on top of that, making custom sparse-matrix implementation unnecessary. Maybe when someone gets some serious funding for working on QuTiP, encapsulating all of this better would be doable. So, just something to keep in mind before bolting on too many things onto the existing custom implementation (like multiple sparse and full storage formats). Once you open up that can of worms, it just might be better to re-design `Oobj.data` to have a very broad base (e.g. SciPy), and keep the custom CSR as an optional, highly efficient implementation for the special case, maybe in a separate package. Either way, it's going to be a lot of work, and not something for a minor-version release.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384094285:486,perform,performance,486,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384094285,4,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"I wanted to follow up on the previous message. Are there indeed important performance reasons why basis(N, n) is by default implemented densely:. `dtype = dtype or settings.core[""default_dtype""] or _data.Dense`. as opposed to . `dtype = dtype or settings.core[""default_dtype""] or _data.CSR` ?. I similarly have run into issues where much of my existing code using collapse operators of the form `basis(N, n) * basis(N, n).dag()` takes significantly longer to run (or runs out of memory) in 5.0.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978:74,perform,performance,74,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-2028822978,1,['perform'],['performance']
Performance,"I was not referring to the implementation, I agree that the method you implemented is clearly much better, because as you say it only calculates matrix-vector product and trace in one go. However, you could have kept the same function API as previous cy_expect_rho_vec function and I doubt it would make any difference in the performance (perhaps a a small difference, and in that case we can keep both, but then the old cy_expect_rho_vec should use the same implementation as the one you suggested for cy_expect_rho_vec_fast).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25358782:326,perform,performance,326,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25358782,2,['perform'],['performance']
Performance,"I will have to go back and take a look, but I could not get the compiled gcc code to go faster than the intrinsics. Also the plain c code version under clang was quite slow, sometimes performing worse that the Cython version. . Also note that the vector data in the spmv is fetched out of order, so I am not sure if grabbing multiple elements as can be done in AVX is going to give a performance benefit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-254813399:184,perform,performing,184,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-254813399,2,['perform'],"['performance', 'performing']"
Performance,I will take a look. That module underwent some optimizations that may be the cause.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/572#issuecomment-265288312:47,optimiz,optimizations,47,https://qutip.org,https://github.com/qutip/qutip/issues/572#issuecomment-265288312,1,['optimiz'],['optimizations']
Performance,"I would agree with what @quantshah had said. Builder patterns are useful in those languages like Java, where named parameters is not in-built. All functions bundled into a single class would be better alternative. This would help when adding new methods that differs in optimization algorithm to the class.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/692#issuecomment-612210011:270,optimiz,optimization,270,https://qutip.org,https://github.com/qutip/qutip/issues/692#issuecomment-612210011,1,['optimiz'],['optimization']
Performance,"I'm glad you like! As for squashing, I think that can make sense, yeah. I'd like to hold off on doing so with this PR I have the current test failures fixed (seems as though the difference-of-unitaries optimization still needs a bit of work). After that, though, I agree that'd make for a much more legible commit history.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/456#issuecomment-198569367:202,optimiz,optimization,202,https://qutip.org,https://github.com/qutip/qutip/pull/456#issuecomment-198569367,1,['optimiz'],['optimization']
Performance,I'm not too sure how to perform cascading PRs on a forked repository ... ?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875:24,perform,perform,24,https://qutip.org,https://github.com/qutip/qutip/pull/2012#issuecomment-1291128875,1,['perform'],['perform']
Performance,"I'm wondering whether setting `auto_tidyup` per data type is a good idea? One expects the mathematical operations performed by different data backends to give the same results but setting `auto_tidyup` to `[""CSR""]` by default will break that assumption quite badly. For example, matrices might become singular when sparse and not when dense. There is also a danger of making some benchmarks artificially fast. If we're going to compare backends, we should probably look at both backends with tidyup on or off. Is there a reason that tidyup cannot just be specialized for the new backends that need it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573:114,perform,performed,114,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-881301573,1,['perform'],['performed']
Performance,"I've just noticed that @BOBO1997's [proposed solution](https://github.com/qutip/qutip/issues/1497#issue-855992475) is effectively the same as what I've implemented in my PR. I also like that his solution takes care of possibly unsorted inputs - I've borrowed that idea and updated my PR accordingly. Thanks, @BOBO1997!. I've also noticed that there are multiple instantiations of the same `gate` object upon each loop iteration, but I suspect those probably need to be kept distinct, unless the desired behaviour would be that changing one of those objects affects equivalently the other ones. In my PR I have the gate instantiation behaviour as it originally was (i.e., not adding references to the same `gate` object, but creating a new object upon each iteration). Please, let me know if this should be changed to perform only one instantiation and insert multiple references to the same object instead. @BoxiLi, I hope my #1892 doesn't interfere with https://github.com/qutip/qutip-qip/discussions/15. Please, feel free to close/reject the PR, if it does.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-1124338701:817,perform,perform,817,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-1124338701,1,['perform'],['perform']
Performance,"I've lost the plot a bit with a whole load of changes to `Coefficient` now merged into this PR. Is there a chance we can split that out into its own PR?. I would expect `QobjEvo.__call__` to be thread-safe/re-entrant. The fact that coefficients seemingly don't support this immediately is worrying to me. A simple call like that changing ""global"" state of the object is dangerous; it has a habit of leaking out even in single-threaded applications, just like the bug I described previously with a call to `mesolve` modifying an existing `QobjEvo` in place. In this case I don't see an immediate bug, but it's very non-obvious behaviour and it would be easy to accidentally introduce one in it in the future (or maybe I just can't think of one now). Having `_BaseElement` be mutable makes all time-dependent operations of `QobjEvo` unresolvably thread-unsafe without copying on every operation. That said, looking again, I'm not sure I understand `_BaseElement`: it seems like `_EvoElement` and `_FuncElement` do entirely different things on `call`? What's the purpose of it, and if we put all speed considerations aside what would the signature and behaviour of `_BaseElement._call` be?. Could you write some docstrings on all the elements to explain their use-cases as well, so we've got it all stored for the future?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122:38,load,load,38,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122,2,['load'],['load']
Performance,"If it helps in the future, you can use `pycodestyle` (available in `pip` and `conda`) to check pep8 compliance on your end before pushing a commit. As to the actual command, we might not actually want to remove the usage of `convert` - it's quite possible that a lot of people are still using ImageMagick 6, since for most people it's just a dependency that got installed by something else, and isn't frequently updated. `qutip` doesn't list it as an official dependency, so it wouldn't get updated on our behalf. We could catch which version of `ImageMagick` to use with something like; ```python; def _magick_comamnd():; for command in ['magick', 'convert']:; try:; subprocess.run((command, '--version'), capture_output=True); return command; except OSError:; pass; raise FileNotFoundError(""Couldn't locate system ImageMagick""); ```; and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; ```python; subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); ```; or something like that.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473:840,cache,cache,840,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-585236473,1,['cache'],['cache']
Performance,"If you click into ""Files changed"" you can just tick the files as you've looked at them. To make it easier for you, I'd suggest having a copy of the old version next to them and reading the full commit message, because I usually explain what I'm doing in them and why I'm doing it that way. If you're worried about the size of the PR in total, then I'd strongly recommend _not_ squashing this PR if/when it's merged, but instead just rebasing it onto `master` or doing a direct merge. That way it doesn't look huge, it looks like a series of commits which each change one file, which is what you'd get if the PR was initially split. The review doesn't end at the point the code is merged - somebody in the future may very well want to see why I made certain changes. I know I've spent a long time looking through the old `git` logs to work out why tests were the way they were, and it's always much much more difficult when you've got one of those squash commits with like 30 sub-parts. The commits in this PR are already modular, and with the exception that 7a0d6e6 could be squashed into ; 1d60b46, they all represent an isolated unit of progression and there aren't any ""work in progress"" commits. I didn't perform that squash locally because I would have had to force-push over 10+ commits. Squashing the PR does make sense when there are a lot of wip commits for a small unit of work, but for a very large unit of work like this one, it's much better to interactive rebase to keep it neat locally (I've already done that for the most part), and never push wip commits in the first place.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-605494875:1209,perform,perform,1209,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-605494875,1,['perform'],['perform']
Performance,"If you're concerned about the solvers, a) they skip tidyup til the end anyway and b) _technically_ the computational complexity of CSR * dense vector is identical to tidyup (though tidyup is a little more cache efficient), but really it's the constant factors that could kill you for small systems. For example, the ""naive"" way of implementing a relative tolerance would take the absolute value of a complex number, but that involves a floating-point square root, which is a very slow operation. That's likely partly why the current version compares real and imaginary components separately, even though the sparsity structure is only improved if _both_ go to zero. In a two-pass operation you'd sqrt twice for every entry (naively - all the square roots are very avoidable), and I'd start to worry that that really _could_ dominate small system operations. Or maybe you should just ignore me when assigning ""good first issues"" - I'm probably too opinionated about performance characteristics without enough experience at managing other people's code!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141:205,cache,cache,205,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"If; ```python; qutip.testing.run(); ```; was called twice in the same Python session, then cases where a consumable iterator (such as `itertools.permutations` or `itertools.chain`) was used in the test parametrisation would fail on subsequent runs. This is because the iterator is consumed when the module is loaded, and cannot be re-run after. This was not caught in CI because naturally CI only runs the testing suite once in a session.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1430:309,load,loaded,309,https://qutip.org,https://github.com/qutip/qutip/pull/1430,1,['load'],['loaded']
Performance,"ImageMagick is only mentioned in our tutorial page and not listed elsewhere. So we didn't specify a required version for it. . > We could catch which version of `ImageMagick` to use with something like; > ; > ```python; > def _magick_comamnd():; > for command in ['magick', 'convert']:; > try:; > subprocess.run((command, '--version'), capture_output=True); > return command; > except OSError:; > pass; > raise FileNotFoundError(""Couldn't locate system ImageMagick""); > ```; > ; > and cache the result on import (below into the variable `_magick`). There could also be logic based on OS if needed. The convert command would become; > ; > ```python; > subprocess.run((_magick, ""-density"", 100, filename + "".pdf"", filename + "".png"")); > ```. This solution looks neat. One minor thing is that maybe we should use `check=True` instead of `capture_output=True` since the latter one is only available from Python 3.7+. Despite those has already been discussed above, the plot sill does not work for me. I find the following lines also wrong on Windows; ``` python; os.system(""rm -f %s.aux %s.log"" % (filename, filename)). os.system(""mv %s-tmp.pdf %s.pdf"" % (filename, filename)); ```; because `rm` and `mv` are not Windows command. We should probably replace it by python script `os.remove` and `os.replace` to make it system independent.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793:485,cache,cache,485,https://qutip.org,https://github.com/qutip/qutip/pull/1179#issuecomment-592993793,1,['cache'],['cache']
Performance,"Implement an option for using array-like coefficients as step-function instead of cubic-spline:; e.g. ; ```; tlist = np.array([0., 1., 2., 3.]); coeff = np.array([1., 2., 3., 3.]); ```; The coefficient is 1 in the time interval [0,1), 2 in [1,2) and so on. The last element in `coeff` is just a place holder and has no effect. @Ericgig Do you think the following might be useful?; 1. In `inter.pyx` many functions have two versions, one for complex input and one for float. Now there are 4 pairs of them, will it helps if I try to merge them with fused type in Cython?; 2. For non-uniform `tlist`, `_binary_search` is used to find the current index inside the method such as `_spline_float_t_second`, but very often we call this method within a loop for the same `t`. It would improve the performance if `_binary_search` is called outside once for all `t`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1050:789,perform,performance,789,https://qutip.org,https://github.com/qutip/qutip/pull/1050,1,['perform'],['performance']
Performance,Improve performance of Stochastic Schrodinger Equation with sparse sc_ops,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298:8,perform,performance,8,https://qutip.org,https://github.com/qutip/qutip/issues/2298,1,['perform'],['performance']
Performance,"In [3e530c0](https://github.com/qutip/qutip/pull/1854/commits/3e530c01d9cf686fc195c38c2cc26d0ee5bccfa8) I borrowed @nonhermitian's suggestion and switched to `concurrent.futures.ProcessPoolExecutor` in the hopes that the core Python developers have figured out how to make that works on Windows too. It also simplifies the management of the pool of workers, which is a win by itself.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175:159,concurren,concurrent,159,https://qutip.org,https://github.com/qutip/qutip/pull/1854#issuecomment-1168954175,2,['concurren'],['concurrent']
Performance,"In file [propagator.py](https://github.com/qutip/qutip/blob/master/qutip/propagator.py), near line 119:; ```python; td_type = _td_format_check(H, c_op_list, solver='me')[2]; if td_type > 0:; rhs_generate(H, c_op_list, args=args, options=options); ```; The performance would be improved if this code checked for the presence of an already compiled tdfunc like this:; ```python; if td_type > 0 and config.tdfunc is None:; ...; ```; which only requires an additional import of the config object from qutip.solver",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/555:256,perform,performance,256,https://qutip.org,https://github.com/qutip/qutip/issues/555,1,['perform'],['performance']
Performance,"In general in pytest we use the bare keyword `assert` for almost everything. All the functions in `np.testing` are from the ""before times"", when test tooling wasn't as good as it is nowadays - they were a big improvement on available warning messages back before 2015. Nowadays, though, `pytest` does introspection on assertion failures, so it has even better message reporting than the `np.testing` functions, and it lets you write much clearer code. For example, `assert_equal(x, y)` is much better spelled in pytest as `assert x == y`, because it's much faster to read and pytest does better error reporting for it. Similarly, testing for exceptions is better with; ```python; with pytest.raises(ValueError):; call_that_raises(1, ""hello, world""); ```; as opposed to the numpy form `np.testing.assert_raises(ValueError, call_that_raises, 1, ""hello, world"")` - the pytest one is much easier to read, and the error message is better. The only numpy one we still use is `np.testing.assert_allclose` when we're comparing several numpy arrays. That's just because `pytest` doesn't have a good function that's aware of multidimensional arrays (at least not one that I know). This file still has a load of old numpy testing code in it (e.g. `np.testing.assert_equal`) because it was written quite a long time ago, when that was the recommended way of doing things. We're changing over slowly, so we can take advantage of all the nice features of pytest. In this case, I changed `np.testing.assert_allclose(x, y, atol=tol)` to `assert abs(x - y) < tol`. I removed `np.testing.assert_allclose`, because that gives the mistaken impression that we're comparing arrays (we're not, we're comparing two scalars). I could have changed it to `assert x == pytest.approx(y, tol=tol)`, except in this case the test file hasn't been converted to `pytest` style yet, and I wanted to keep the total change of this PR as small as possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822737671:1193,load,load,1193,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822737671,2,['load'],['load']
Performance,"In general the biggest thing you should consider is readability, and to be fair, that's a little subjective. You're welcome to comment on my PR if you think I've done anything that's unreadable. You can scope fixtures at whatever level is appropriate. In this particular case, I scoped the `dimension` fixture at the module level, because there's loads of places that needed to test varying dimensions, and it's very convenient to define it just once. In the few cases where we needed to override that (e.g. in `dnorm`), I overrode it by providing a definition in a tighter scope - either at class level or per-function (via `pytest.mark.parametrize` directly). The correct scoping just depends a lot on the type of tests you're writing - if you're going to have to overwrite something constantly then module scoping isn't good, but if you have lots of different functions to test, and every test for a given function will want the same parametrisation, then class scoping might be a good choice. If you only need the parametrisation once, then it's best to put it right next to the place it's used (like in the case of mine that you've highlighted). It means that if you've opened that file to read the tests, then everything you need to understand `Test_fidelity.test_known_cases` will be on your screen if you just scroll to it. That makes it much easier for the next person who has to come along to edit your code. I used a couple of temporary variables in that case just to aid readability - my cases wouldn't have nicely fit on one line if I'd shoved the `qutip.basis(2, 0)` stuff inside the `pytest.param` constructors, and it would be hard to read. This way you can easily verify that the code is correct bit-by-bit; you can see clearly that the names are descriptive and match exactly what they say, and that means you can trust them when they then appear in the parametrisation. I won't pretend to be perfect at any part of coding, and particularly testing. I rewrote all the testing files s",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706:347,load,loads,347,https://qutip.org,https://github.com/qutip/qutip/pull/1487#issuecomment-815044706,2,['load'],['loads']
Performance,"In response to #920, and following the discussion in #949, we need some way to make the compile flags optional during setup. The `-march=native` is the probable cause of issues with the conda-forge build #647, and also causes problems for some installing in a cluster environment. However, for most people installing on a local machine, `-march=native` is likely to have significant performance advantages. The suggestion is then to have some cmd line option to choose compile flags where the default is 'optimal', which would include `-march=native`. @Ericgig we can discuss this next week",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/951:383,perform,performance,383,https://qutip.org,https://github.com/qutip/qutip/issues/951,1,['perform'],['performance']
Performance,"Interesting, sounds like some cached values of the previous test corrupted the next one. Since the other two tests also use parameterization, the reason might even be the same, except for `test_countstat.py::test_dqd_current`, which looks like numerical instability.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135:30,cache,cached,30,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1007395135,1,['cache'],['cached']
Performance,"Is there any performance reason why we should not compile the extensions using C++ ?. We are having issues with the conda forge packages:; conda-forge/qutip-feedstock#16; I am sure than this problem would not occur if we were compiling using MS compilers.; We are receiving lots of support requests on the Google group for help installing on Windows; We do not have a solution for python>=3.5 on Windows. I posted a question on the Cython help group asking about accessing complex functions on Windows. One suggestion was to try C++, importing functions from `complex` rather than `complex.h`. I made a small test project that imported `conj` and it compiled using MS compilers and worked on Windows 10 with both Python 2.7 and 3.5. We only have one small C source file. I guess it could be rewritten in C++ quite easily.; I can do further tests to check performance if we consider C++ compilation is an option for qutip.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647:13,perform,performance,13,https://qutip.org,https://github.com/qutip/qutip/issues/647,2,['perform'],['performance']
Performance,"It appears that they have removed hw.cpufrequency on these things (About this mac doesn't show a freq. either). I don't know what is their policy in this regard but I did find these two related issues: https://github.com/giampaolo/psutil/issues/1892 and https://github.com/shirou/gopsutil/pull/999. My workaround was to comment out the code and hard-wire a random value in there :-) A quick grep didn't seem to show any use of cpu_freq elsewhere in the code but then I didn't look too much in depth. I don't personally use qutip, my partner does, she's the physicist, I'm just the geek helping hand :). It does look like this code could use some error handling and put some ""reasonable"" default values if the sysctl's fail indeed. Happy to test a patch and report. She's currently away so there will be some latency (I can occasionally ssh into her laptop but it takes preparation), so I can't really submit a PR myself at this point.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664:808,latency,latency,808,https://qutip.org,https://github.com/qutip/qutip/issues/1606#issuecomment-880308664,1,['latency'],['latency']
Performance,It certainly look interesting. Fast diagonalisation of Liouvillian operators is certainly something we could make good use of. However we should wait for v5 of qutip. Some of the new features we are working on match well with this algorithm and should have a visible impact on performance.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673:277,perform,performance,277,https://qutip.org,https://github.com/qutip/qutip/issues/1833#issuecomment-1065202673,1,['perform'],['performance']
Performance,"It looks as though NumPy keeps some metadata on MKL if it was compiled with MKL support. The `numpy.__config__` module in particular gives a path to the directory that NumPy loads its MKL libraries from. On my Linux box, for instance:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_intel_lp64', 'mkl_intel_thread', 'mkl_core', 'iomp5', 'pthread']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['/home/cgranade/anaconda/lib']; ```. The case seems to be worse for Anaconda on Windows (naturally), with `C:\aroot\stage\` taking the place of the actual Anaconda root:. ``` python; In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ['mkl_core_dll', 'mkl_intel_lp64_dll', 'mkl_intel_thread_dll']. In [3]: print(numpy.__config__.mkl_info['library_dirs']); ['C:\\aroot\\stage\\Library\\lib']; ```. In the case that NumPy is compiled without MKL support, it seems to just omit the `mkl_info` dict entirely:. ``` bash; cgranade@berith:~$ source activate py27-nomkl; discarding /home/cgranade/anaconda/bin from PATH; prepending /home/cgranade/anaconda/envs/py27-nomkl/bin to PATH; cgranade@berith:~$ ipython; Python 2.7.11 |Anaconda custom (64-bit)| (default, Dec 6 2015, 18:08:32); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 4.0.3 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import numpy.__config__. In [2]: print(numpy.__config__.mkl_info['libraries']); ---------------------------------------------------------------------------; AttributeError Traceback (most recent call last); <ipython-input-2-ebe4f6e784e1> in <module>(); ----> 1 print(numpy.__config__.mkl_info['libraries']). AttributeError: 'module' object has no attribute 'mkl_info'; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/459#issuecomment-204251671:174,load,loads,174,https://qutip.org,https://github.com/qutip/qutip/pull/459#issuecomment-204251671,1,['load'],['loads']
Performance,"It seems the entire idea of printing from different threads in python is deeply troublesome. https://stackoverflow.com/questions/3029816/how-do-i-get-a-thread-safe-print-in-python-2-6. My guess is that the appropriate solution is to move all the printing to a single thread and use `Queue`, but I am not quite certain of that. I will see what I can do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42067292:283,Queue,Queue,283,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42067292,1,['Queue'],['Queue']
Performance,"It would be hard to enforce since we accept functions returning `Qobj`.; If someone passed `dtype` in `args`, there is nothing we can do.; Also since the most common use case is `part @ state`, they don't interact much together and each part can be optimized for it's sparsity without issue. Mixed case are not that rare. Per default `sigmax` is `CSR` and `qeye` is `Dia` and I can't say what is `sigmax & qeye` without checking. So `QobjEvo([sigmax(), [qeye(2), f]])` mixes `CSR` and `Dia`.; How do we decide which one we quietly transform? Everything else just work with whatever type is used. So we can't have this raise an exception. Personally I think we should only mix in a family of dtypes, `Dense`, `Dia` and `CSR` can be mixed, but no mixing of jax with CSR, etc. But we don't have what we need to enforce it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688:249,optimiz,optimized,249,https://qutip.org,https://github.com/qutip/qutip/pull/2325#issuecomment-1944589688,1,['optimiz'],['optimized']
Performance,"It would be really nice if qutip coud support the numba jit compiler (https://numba.pydata.org/) in some future releases. This would also enable, to perform calculations using the GPU very easily.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/900:149,perform,perform,149,https://qutip.org,https://github.com/qutip/qutip/issues/900,1,['perform'],['perform']
Performance,"Just a small additional comment, the ODE solver is probably slow in your case because of the large disparity in parameters (particularly the very large dephasing rate), which makes it a bit stiff I guess (and hence maybe why BDF works a little better than adams in this case?). I will close this issue, but if you have any comments/updates on improving the performance of your example, feel free to comment or re-open it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271:357,perform,performance,357,https://qutip.org,https://github.com/qutip/qutip/issues/1591#issuecomment-900015271,1,['perform'],['performance']
Performance,"Just to add, I tried to benchmark Eric's jax data layer a bit more with an Ising model, the example is at the end of this colab notebook we made for a tutorial talk, which shows some crossover in performance at certain system sizes: https://colab.research.google.com/drive/1RcgX7oEzGjzPAF8Ryus54Q5UmyMddmLA?usp=sharing. ![benchmark](https://github.com/qutip/qutip/assets/5094429/15d2dfaa-b269-44f7-8334-878b8e2c5910). Note colab does not have free GPUs, so you will have to download and use it locally. also in the actual ising example, replace ; `with jax.default_device(jax.devices(""cpu"")[0]):` ; with; `with jax.default_device(jax.devices(""gpu"")[0]):`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917:196,perform,performance,196,https://qutip.org,https://github.com/qutip/qutip/issues/2320#issuecomment-1940278917,1,['perform'],['performance']
Performance,"Just to get the ball rolling, I will go ahead and ask my question here and migrate it if necessary. . My code performs quantum annealing on a transverse-field Ising Hamiltonian as inspired by D-Wave Systems devices which is explained briefly [here](https://docs.dwavesys.com/docs/latest/c_gs_2.html), but the essential equation is; ![D-Wave-hamiltonian](https://user-images.githubusercontent.com/29308150/61193322-bdb48c00-a688-11e9-94ac-22c5d093b47a.png).; The A(s) and B(s) factors dictate the time-evolution from the initial Hamiltonian to the final Hamiltonian where s is a linear function of time, i.e. s(t) is linear with slope between 0 and some max and 0 <= s <= 1. In my code, my sesolve command looks like 'results = qt.sesolve(listH, init_state, discretized_times_list)' where 'listH = [[Hx, A(s(t))], [Hz, B(s(t))]]' and A(s(t)) and B(s(t)) and created by using QuTiP's interpolate.Cubic_Spline function that dictates what the A and B parameters should be at each point in time. . When I make successive calls, it is to do several different things. For example, I may change coupling (h and J) values to create a new spin-glass, adjust number of qubits (larger or smaller H), or anneal for a longer or shorter time. I am not sure how to directly relate this to what has been posted so far, but perhaps I am not fully understanding the point made in https://github.com/qutip/qutip/issues/966#issuecomment-474569011.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/966#issuecomment-511266095:110,perform,performs,110,https://qutip.org,https://github.com/qutip/qutip/issues/966#issuecomment-511266095,1,['perform'],['performs']
Performance,"Looks interesting! Possibly a bit out of scope for qutip? In principle you could put this progress bar in a separate module and still use it with qutip (as long as it supports qutip's basic progressbar interface). Then it could also be used in non-qutip related projects. . If its to be included in qutip, I think it should not be added to qutip/ui/progressbar, but as an module of its own that would not be loaded by default, so a user would have to load it explicitly when using it, like the way the current ipynbtools and picloud modules work. . Perhaps it would make sense to move these ""extras"" or ""extensions"" modules to a subdirectory of their own, say ""qutip/extensions"" or ""qutip/ext"" to keep the import paths manageable. In that case I think that qutip.picloud should be moved to that directory as well. I think this would keep these extensions reasonably isolated for the core qutip modules, which I think we should prioritize if we are to allow these kind of peripheral modules to increase in number in the future. @nonhermitian any opinions on this?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/255#issuecomment-63268318:408,load,loaded,408,https://qutip.org,https://github.com/qutip/qutip/pull/255#issuecomment-63268318,4,['load'],"['load', 'loaded']"
Performance,"Looks like there were breaking changes introduced in CVXPY 1.1 that changed some sort of matrix handling? I think the entirely of the `dnorm` function was written by Chris Granade about 5 years ago, and they're off at Microsoft now. As an immediate workaround, you can pin the version of CVXPY in conda to 1.0 (`conda install 'cvxpy=1.0'`) to fix it. Otherwise, probably there's a solution in swapping over a load of `*` to `@` in `qutip/semidefinite.py` and `qutip/metrics.py`, but that might be a bit nontrivial to solve. If you succeed, please do make a pull request. The reason that the ""simple"" cases work is that QuTiP detects them as known results and has fast paths avoiding `cvxpy`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713:409,load,load,409,https://qutip.org,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713,2,['load'],['load']
Performance,"Many of the features in the pulse optimization module are difficult to use, or poorly documented. For example, for the functions `optimize_pulse` and `optimize_pulse_unitary` there are 'params' arguments for many of the underlying classes, but it's not at all clear what count as valid key value pairs for each class.; ```python; Parameters; ----------; alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. . dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ```. As a further example, `dyn_params` is passed to a `Dynamics` object which stores it locally in `self.params`, but there isn't any checking of valid keys and values, and I can't find a function which actually uses whatever these params are set to. It's really difficult to run a top-le",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1284:34,optimiz,optimization,34,https://qutip.org,https://github.com/qutip/qutip/issues/1284,3,"['Optimiz', 'optimiz']","['Optimizer', 'optimization', 'optimize']"
Performance,"Matrix exponentiation is a costly operation. See [1][Nineteen Dubious Ways to Compute the Exponential of a Matrix, Twenty-Five Years Later∗](https://www.cs.cornell.edu/cv/ResearchPDF/19ways%2B.pdf). In a quantum optics, the displacement operator is one of the most basic. It is used to create coherent states from vacuum and forms one of the two gates for universal control of a cavity (Displacement + SNAP gates) [2] [Efficient cavity control with SNAP gates](https://arxiv.org/abs/2004.14256). When we want to write an optimisation routine that finds best displacement parameters in a routine similar to the paper above [2], it would be nice if we can compute the operator faster without doing matrix exponentiation as qutip does now:; https://github.com/qutip/qutip/blob/master/qutip/operators.py#L732. I have some notes from a colleague who calculated an analytical formula to compute the matrix elements of the displacement operator without having to do matrix exponentiation [3]: ; [Displacement_operator.pdf](https://github.com/qutip/qutip/files/4791455/Displacement_operator.pdf). A PR to implement this in QuTiP would be great. We could first write a `_displace_analytical` function that calculates the displacement matrix using the [Scipy Laguerre polynomial](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.genlaguerre.html) and have it as an option as `displace(N, alpha, offset, method=`analytical` )`. Could it also come in handy for optimal control? @ajgpitch . In the paper above [2], the authors use gradient descent to fine tune the parameters of a gate sequence containing displacement gates and SNAP gates to target some Bosonic quantum state. We wish to do similar things for @araza6 s GSoC project.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293:1561,tune,tune,1561,https://qutip.org,https://github.com/qutip/qutip/issues/1293,1,['tune'],['tune']
Performance,"Moving out _binary_search would could be done, but I don't believe it will make visible speed increase. I most cases the matrix operations are the bottleneck. Fused types are a good idea, but if you still have a lot to do in your project, they are not a priority.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1050#issuecomment-514654597:147,bottleneck,bottleneck,147,https://qutip.org,https://github.com/qutip/qutip/pull/1050#issuecomment-514654597,1,['bottleneck'],['bottleneck']
Performance,"Nice speed up! Is there anything here that we could also benefit from in mesolve? Or is it specific to mcsolve in that it mostly affect the ODE restart?. I doubt that the initial setup of an ODE instance before spawning processes would have any significant impact on the performance (note that multiprocessing does not use threads, it uses processes, so there is no sharing of ODE instances between processes). Creating the ODE instance once in the parent process, or N times in N processes in parallel therefore should not make much difference, if any.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65020496:271,perform,performance,271,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65020496,1,['perform'],['performance']
Performance,"Nice, I will do it in the following days. On a side note, I'd propose to make the printing optional in `qload` with a `debug` flag for instance. As it is a bit messy when you are loading a lot of objects.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997:179,load,loading,179,https://qutip.org,https://github.com/qutip/qutip/issues/1811#issuecomment-1044402997,1,['load'],['loading']
Performance,"Nice, good job!! How does the performance look like for small problems? Does it make any sense to add an option to select bicgstab or lmgres, or does lmgres beat bicgstab in all cases you have looked at? Anyways, performance for systems is not that important, but we badly need better performing steadystate solvers for large systems so your benchmarks looks very promising :-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/29#issuecomment-20392672:30,perform,performance,30,https://qutip.org,https://github.com/qutip/qutip/issues/29#issuecomment-20392672,3,['perform'],"['performance', 'performing']"
Performance,"No, this is not included in my project. The commit above seems to be lost so I can't see the original proposal. It is easy to add a new option to let some gates remain as they are (and I think this is what was proposed). To resolve other multiqubit gates into TOFFOLI basis needs, however, much more work :). If resolving gate becomes a high demand, it might be a good idea to refactor the current `resolve_gate` method as it is quite long and hard to maintain. An optimized gate resolving method needs more complex logic such as merging single-qubit gate.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/614#issuecomment-532940297:465,optimiz,optimized,465,https://qutip.org,https://github.com/qutip/qutip/issues/614#issuecomment-532940297,1,['optimiz'],['optimized']
Performance,"Not directly testing for commuting operators, but Qobj implements **eq** and **ne** which means that you can test for commuting operators simply by doing. ```; if a * b == b * a:; # a and b commutes; ```. Maybe it could be useful with function that performs this test for two Qobj instances, but currently we do not have such a function. The PR looks good so I'll merge it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/41#issuecomment-22768490:249,perform,performs,249,https://qutip.org,https://github.com/qutip/qutip/pull/41#issuecomment-22768490,2,['perform'],['performs']
Performance,"Not extremely familiar with pytest parametrizations, but I've just been reading it and performing some changes. Will keep doing it with the new suggestions. I'll add a couple of tests for bad instances of inputs just in case. . I agree with the with the bound functions part. I'll try to perform as many improvements as possible today. And thanks a lot for all of these <code>sx_list[i] == x_gate(N, i)</code> code improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417:87,perform,performing,87,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1044755417,2,['perform'],"['perform', 'performing']"
Performance,"Not sure if I can answer your specific question but I have used QUTIP GRAPE before. I would first suggest opening a pull request or linking to your fork, so it's easier to compare your modifications to the original code.; I have briefly looked at your code and I would suggest dropping numba as qutip doesn't currently have numba as a dependency. I am confused about why you choose the cnot notebook as your example? There is an example of quantum optimal control using open quantum systems, control-pulseoptim-Lindbladian.ipynb .; Nonetheless, I believe grape.py is definitely not the place to place your additional support for open quantum systems. Grape is an optimization method, you should be looking extending support for open quantum systems in the pulseoptim class.; If you are interested you can also take a look at the quantum optimal control tool I built, QUTIP's quantum optimal control didn't satisfy my needs. ; https://github.com/lifeishard/PADQOC",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845:663,optimiz,optimization,663,https://qutip.org,https://github.com/qutip/qutip/issues/1031#issuecomment-541810845,1,['optimiz'],['optimization']
Performance,"Note that the same holds for Cython:. ``` zsh; % pip install qutip; Collecting qutip; Using cached qutip-3.1.0.tar.gz; Complete output from command python setup.py egg_info:; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 159, in <module>; configuration=configuration; File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/core.py"", line 135, in setup; config = configuration(); File ""/tmp/pip-build-hg437fn6/qutip/setup.py"", line 135, in configuration; config.add_subpackage('qutip'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 908, in _get_configuration_from_setup_py; config = setup_module.configuration(*args); File ""qutip/setup.py"", line 8, in configuration; config.add_subpackage('cy'); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 1002, in add_subpackage; caller_level = 2); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 971, in get_subpackage; caller_level = caller_level + 1); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/site-packages/numpy/distutils/misc_util.py"", line 883, in _get_configuration_from_setup_py; ('.py', 'U', 1)); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 234, in load_module; return load_source(name, filename, file); File ""/home/phyks/.local/share/virtualenvs/physique/lib/python3.5/imp.py"", line 172, in load_source; module = _load(spec); File",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/426#issuecomment-183253786:92,cache,cached,92,https://qutip.org,https://github.com/qutip/qutip/issues/426#issuecomment-183253786,1,['cache'],['cached']
Performance,"Note: This appears broken on my M1 MacBookPro running Big Sur... there is no sysctl hw.cpufrequency at all on this machine, so it blows up (some error handling in that function would be good :-). ```$ sysctl hw; hw.ncpu: 8; hw.byteorder: 1234; hw.memsize: 17179869184; hw.activecpu: 8; hw.optional.amx_version: 2; hw.optional.arm64: 1; hw.optional.armv8_1_atomics: 1; hw.optional.armv8_2_fhm: 1; hw.optional.armv8_2_sha3: 1; hw.optional.armv8_2_sha512: 1; hw.optional.armv8_crc32: 1; hw.optional.breakpoint: 6; hw.optional.floatingpoint: 1; hw.optional.neon: 1; hw.optional.neon_fp16: 1; hw.optional.neon_hpfp: 1; hw.optional.ucnormal_mem: 1; hw.optional.watchpoint: 4; hw.cacheconfig: 8 1 1 0 0 0 0 0 0 0; hw.cachelinesize: 128; hw.cachesize: 3616980992 65536 4194304 0 0 0 0 0 0 0; hw.cpu64bit_capable: 1; hw.cpufamily: 458787763; hw.cpusubfamily: 2; hw.cpusubtype: 2; hw.cputype: 16777228; hw.ephemeral_storage: 0; hw.l1dcachesize: 65536; hw.l1icachesize: 131072; hw.l2cachesize: 4194304; hw.logicalcpu: 8; hw.logicalcpu_max: 8; hw.osenvironment: ; hw.packages: 1; hw.pagesize: 16384; hw.pagesize32: 16384; hw.physicalcpu: 8; hw.physicalcpu_max: 8; hw.serialdebugmode: 0; hw.tbfrequency: 24000000; hw.use_kernelmanagerd: 1; hw.use_recovery_securityd: 0; hw.targettype: J293; ```; Big Sur 11.4 on MacBookPro M1. Actually I'll open a separate issue...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1401#issuecomment-879469970:673,cache,cacheconfig,673,https://qutip.org,https://github.com/qutip/qutip/pull/1401#issuecomment-879469970,3,['cache'],"['cacheconfig', 'cachelinesize', 'cachesize']"
Performance,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:312,load,loads,312,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861,1,['load'],['loads']
Performance,"Nothing too clever here. As in cached flag cleared whenever unitarity threatened; The check could probably be more efficient, but as not expected to be used intensively, then this would seem acceptable.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/817#issuecomment-364163769:31,cache,cached,31,https://qutip.org,https://github.com/qutip/qutip/pull/817#issuecomment-364163769,2,['cache'],['cached']
Performance,Now with a8b79f7bd2ad58713e9ed7b104e204b155fcdc20 it works again on my machine. Is there a big difference in performance between accessing the blas stuff through scipy instead of directly from a cython module? If not it would be good to let the scipy ppl worry about the linking to blas and not have to deal with that in qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/39#issuecomment-22436635:109,perform,performance,109,https://qutip.org,https://github.com/qutip/qutip/issues/39#issuecomment-22436635,1,['perform'],['performance']
Performance,"Numpy Version: 1.13.3; Scipy Version: 1.0.0; Cython Version: 0.27.3; Matplotlib Version: 2.1.2; Python Version: 3.6.4; Number of CPUs: 4; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1458,optimiz,optimizer,1458,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,2,['optimiz'],['optimizer']
Performance,"Oh yeah, that's a good point we should push out the change sooner rather than later. With how the data-layer classes are implemented, ufunc handling on them wouldn't actually add any memory footprint, but it does add complexity whenever someone wants to implement a new data-layer class. It's hard to fit general ufunc machinery into the Dispatcher spec, because the ufunc interface is rather general, and we don't want to entirely reimplement numpy. You also can't dispatch on ""unary"" / ""binary"" / ""arbitrary"" ufuncs as groups (could have been an alternative), because (e.g.) `sin` has very different performance characteristics to `cos` on sparse matrices. If the dispatchers aren't in use, then having a separate function (`apply_ufunc`) doesn't make a performance difference over defining `__array_ufunc__` in a Cython class in speed or memory, but it does make it harder for a user. Class functions like that in Cython are actually implemented as separate C-backed functions - you can't override them on an instance-by-instance basis, so the instances aren't carrying around extra vtables or anything like that. One option for user convenience there could be to allow unary ufuncs on data-layer objects and forbid binary+ ones. We can do that with `__array_ufunc__`. It's not so difficult to keep track of the few numpy ufuncs that have f(0) = 0 so different sparse structures can optimise based on that. *Edit*: oh, I think I misunderstood what you were saying about ""lightness"" - do you mean the spec of what they have to support is light, or their memory impact is light?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-774106830:602,perform,performance,602,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-774106830,2,['perform'],['performance']
Performance,"Oh, also to answer the question more explicitly about `_qfunc_alpha_matrix.__call__`: _that_ function always re-computes the matrix of alphas, returning the relevant bits of the Fock space. The caching behaviour is in the `QFunc` class itself, which manages how many Fock states it needs (see `QFunc._alphas`, which tries to pull the matrix from a cache, or expands the cache if necessary). `QFunc.__call__` calculates the Q function of any quantum state over the given phase-space coordinates, no matter how large the size of Hilbert space of the state is - that means it's got feature parity with `qfunc` in the sense that both; ```python; iterative = functools.partial(qutip.qfunc, xvec=xs, yvec=ys); classbased = qutip.QFunc(xs, ys); ```; can be called with the same objects, and will return the same result, even if the objects change size in between. I see this as sensible functionality in general - if you're plotting a few graphs, it's quite possible that you haven't calculated all your states with the same amount of Fock-space truncation (I frequently scaled the calculation sizes in my PhD for speed), so it's not very useful if the class-based version can only handle fixed Hilbert spaces.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741:348,cache,cache,348,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877266741,2,['cache'],['cache']
Performance,"Oh, sorry I forgot to reply to you Boxi. In theory it's not such a difficult change, but it does have quite some performance implications - doing it properly will involve writing Cython, and we need to make sure that there's no major regressions. The swap to relative amplitudes necessarily makes the code ~twice as slow (from a one-pass to two-pass algorithm), but we do need to take care that it's as fast as possible, because this code is called _all_ the time.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793761801:113,perform,performance,113,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793761801,1,['perform'],['performance']
Performance,Ok so as I read it currently there is no iadd_ function for CSR matrices. Am I also right that there is no add_ operation for Dense + CSR? How does the current code deal with adding a Dense to a CSR matrix (I'm looking in `core/data/add.pyx`). I think replacing add_ with iadd and making a specialised iadd impl should help improve performance a lot.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250:332,perform,performance,332,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904583250,1,['perform'],['performance']
Performance,"Ok, let's drop the tensor thing then. I'll make a new patch which includes the time-dependence syntax that you suggest, indeed a more convenient way. Do you think it would be necessary to perform linear interpolation as I did or would just rounding to the nearest point be ok. It looks like I'll need to add code to sesolve and mesolve, and these files seem to have some duplicate code already, do you think it would be useful to make a new file with some shared helper functions (mostly for generating the cython code)?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44796169:188,perform,perform,188,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44796169,1,['perform'],['perform']
Performance,"Ok, so I did some benchmarking at https://nbviewer.ipython.org/gist/goerz/34af142b78d7e344417d838bbea78aaf/06_example_3states_benchmark.ipynb ([gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf)), based on [one of the example notebooks from the Krotov package](https://qucontrol.github.io/krotov/v1.2.1/notebooks/06_example_3states.html). I'll be referring to the numbered cells in that notebook in the discussion below. @jakelishman in https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:. > I think you might be able to achieve a lot of what you want already. The pseudo-code looks like it's not using `mesolve` super efficiently, though maybe it's only because of simplifications to make a MWE. For example, if your controls are piecewise constant, then it might be inefficient to represent those terms as ""time dependent""; doing so means you incur the cost of multiplying each term by a scalar at every intermediate step the integrator chooses to take, then you have to perform the matrix-vector product for each one individually and add them up. That's certainly worth trying: when calling `mesolve` in a loop over the time grid, I did indeed see a significant speedup when summing the Lindbladian into a single constant `Qobj`, see `In [21]` vs `In [24]`. On the other hand, it doesn't always give a speedup: in the low-level [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) it actually makes the propagation slower, see `In [29]` vs `In [32]`. It's a bit surprising, but then, as you say:. > [...] This isn't guaranteed, because it involves copying rather more data _before_ the call. So that's ok. > Would something like this work for you? [...]; >; > By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately. To be clear, I personally never use collapse operators (and the Krotov documentation heavily discourages it). Inst",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:1007,perform,perform,1007,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['perform'],['perform']
Performance,"Okay, involving writing Cython itself already makes it unsuitable for most new contributors I guess. I think even if the time of tidy up doubles it still won't be a significant bottleneck for solvers? Matrix multiplication itself will be O(dim^3) in the worst case, this one is at most O(n^2). But I do agree that we need to be very careful with such a low-level function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793947542:177,bottleneck,bottleneck,177,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793947542,1,['bottleneck'],['bottleneck']
Performance,"One can also think about moving the fortran solver to its own installer as a qutip add-on. With the recent performance gains of the Python based solver, this change is not so bad in my opinion.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/283#issuecomment-66561013:107,perform,performance,107,https://qutip.org,https://github.com/qutip/qutip/issues/283#issuecomment-66561013,1,['perform'],['performance']
Performance,"One more.; For dense matrix operation, do you intend to write the code or use blas/lapack? Using the libraries is less work and leave advanced user the ability to link optimized version for there systems, or gpu accelerated one if they want, with no more effort on our side.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648259130:168,optimiz,optimized,168,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648259130,1,['optimiz'],['optimized']
Performance,"One thing to consider is that CSR and Dense already _dno't_ return the same result for every operation. For example, for matmul:; ```python; size = 100; random = np.random.random((size, size)); a = qt.data.Dense(random); b = qt.data.to['CSR'](a); np.all((a).to_array() == (b).to_array()) # True; np.all((a+a).to_array() == (b+b).to_array()) # True; # This one is different for Dense and CSR even though the operation is the same. ; # This seems to be due to the order at which the operations are performed with Dense; # and CSR matmul and the fact that floating point addition is not associative. ; # (something I learned by reading the test_mathematics in qutip); np.all((a@a).to_array() == (b@b).to_array()) # False.; ```; Although the change in `auto_tidyup` will probably make the difference bigger, given that with tidy-up ""all"" we can not ensure the same output for every operation, I would say that it should be ok to set auto_tidyup to `[CSR]`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839:496,perform,performed,496,https://qutip.org,https://github.com/qutip/qutip/pull/1610#issuecomment-882012839,2,['perform'],['performed']
Performance,"OpenMP handling is broken in the current `master`. It is likely caused by changes made in #1289. Trying to `import qutip` with OpenMP built produces errors; ```python; In [1]: import qutip; Calibrating OPENMP threshold...; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-1-e01d5608f34f> in <module>; ----> 1 import qutip. ~/code/qutip/qutip/qutip/__init__.py in <module>; 277 print('Calibrating OPENMP threshold...'); 278 thrsh = calculate_openmp_thresh(); --> 279 qutip.configrc.write_rc_key(rc_file, 'openmp_thresh', thrsh); 280; 281 # Load the config file. ~/code/qutip/qutip/qutip/configrc.py in write_rc_key(key, value, section, rc_file); 169 config.read(rc_file); 170 if not config.has_section(section):; --> 171 config.add_section(section); 172 config.set(section, key, str(value)); 173. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in add_section(self, section); 1205 RawConfigParser.add_section by validating if the section name is; 1206 a string.""""""; -> 1207 self._validate_value_types(section=section); 1208 super().add_section(section); 1209. ~/.anaconda3/envs/qutip-dev/lib/python3.8/configparser.py in _validate_value_types(self, section, option, value); 1178 """"""; 1179 if not isinstance(section, str):; -> 1180 raise TypeError(""section names must be strings""); 1181 if not isinstance(option, str):; 1182 raise TypeError(""option keys must be strings""). TypeError: section names must be strings; ```. The issue is probably due to `__init__.py` being out-of-date with regards to the change to how the `qutiprc` file is written. The immediate fix should be very simple, however it highlights a larger problem with our testing - this should have been caught by the OpenMP tests. In this case, I believe that the tests don't see the issue because there is a test in `__init__.py` that doesn't trigger the OpenMP calibration if only there is only 1 CPU. Presumably, we only ever get allocate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1470:627,Load,Load,627,https://qutip.org,https://github.com/qutip/qutip/issues/1470,1,['Load'],['Load']
Performance,Optimization flags in setup.py should be completely avoided,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/920:0,Optimiz,Optimization,0,https://qutip.org,https://github.com/qutip/qutip/issues/920,1,['Optimiz'],['Optimization']
Performance,Optimize `numpy_backend`,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2509:0,Optimiz,Optimize,0,https://qutip.org,https://github.com/qutip/qutip/pull/2509,1,['Optimiz'],['Optimize']
Performance,Optimize dispatcher by using positional only arguments,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2135:0,Optimiz,Optimize,0,https://qutip.org,https://github.com/qutip/qutip/pull/2135,1,['Optimiz'],['Optimize']
Performance,"Optimize slow spre, spost action: use `np.dot`",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/831:0,Optimiz,Optimize,0,https://qutip.org,https://github.com/qutip/qutip/issues/831,1,['Optimiz'],['Optimize']
Performance,Optimizer approx_grad,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/342:0,Optimiz,Optimizer,0,https://qutip.org,https://github.com/qutip/qutip/pull/342,1,['Optimiz'],['Optimizer']
Performance,"Our tests could still be shortened, but right now the `pytest.mark.slow` marker does allow for a reasonable run time without sacrificing too much, and we have reduced our Travis load to only 5 concurrent tests by merging MKL and OpenMP tests. With `Coefficient` on `dev.major` we have a lot more scope for re-using compiled coefficients, which are typically the slow parts, but for now I think our testing is much faster than it was when this issue was first opened.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-809323357:178,load,load,178,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-809323357,2,"['concurren', 'load']","['concurrent', 'load']"
Performance,"Partially tracing either system out of a maximally mixed state _should_ be the same matrix (and is, in QuTiP), so the fidelity being 1 is correct from a matrix view. QuTiP doesn't track what systems used to exist before a partial trace, so a partial trace from 2 qubits to 1 qubit appears to live in the same Hilbert space no matter which qubit is traced out. This is the expected behaviour - it's generally the most convenient, rather than doing something odd like giving back the remaining systems tensored with a maximally mixed state on the parts we just traced out. I'm not sure of the relation between quantum state fidelity and concurrence that you're referring to, so I can't really comment on that. By the way, your code doesn't actually use a maximally mixed state, but the result is the same anyway. Being able to write (|00> + |01> + |10> + |11>)/2 in ket form like that shows it's pure over the basis you've defined. The maximally mixed state over this complete basis would be (|00><00| + |01><01| + |10><10| + |11><11|)/4, which isn't the same as the projector onto your state (which also has crossterms like |00><11| and so on).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1423#issuecomment-767739076:635,concurren,concurrence,635,https://qutip.org,https://github.com/qutip/qutip/issues/1423#issuecomment-767739076,1,['concurren'],['concurrence']
Performance,Patch qutip.entropy.concurrence for pure states,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/143:20,concurren,concurrence,20,https://qutip.org,https://github.com/qutip/qutip/pull/143,1,['concurren'],['concurrence']
Performance,Performance drop in QuTiP 5.0.1 vs QuTiP 4.7.6,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2406:0,Perform,Performance,0,https://qutip.org,https://github.com/qutip/qutip/issues/2406,1,['Perform'],['Performance']
Performance,"Perhaps a bit more computationally efficient solution (although, it probably wouldn't make more than a marginal difference, at any reasonable order of number of indices, at which insertion is to be performed): insert at an index `i + k` , where `i` is the original index as per the `index` list, and `k` is the number of insertions performed so far, as part of the insertion loop. I'll raise a PR with the proposed fix. **Update:** The PR in question is https://github.com/qutip/qutip/pull/1892.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1497#issuecomment-1123990033:198,perform,performed,198,https://qutip.org,https://github.com/qutip/qutip/issues/1497#issuecomment-1123990033,2,['perform'],['performed']
Performance,"Pseudocode for entrypoint suggestion:; ```python; entrypoints = importlib.metadata.entrypoints(group=""qutip.about""); for ep in entrypoints:; about_func = ep.load(); try:; title, lines = about_func(); except Exception as exc:; title, lines = ep.name, [str(exc)]; print(title); print(""-"" * title); print(); for line in lines:; print(line); print(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005:157,load,load,157,https://qutip.org,https://github.com/qutip/qutip/pull/1870#issuecomment-1110986005,1,['load'],['load']
Performance,Pulse optimization documentation and usage is unclear,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1284:6,optimiz,optimization,6,https://qutip.org,https://github.com/qutip/qutip/issues/1284,1,['optimiz'],['optimization']
Performance,"Qobj.expm() is currently not working properly for diagonal states which have a zero in the diagonal (these zeros don't become ones). An example:. ``` python; >>> foo = qutip.Qobj([[1.,0.],[0.,0.]]); >>> foo.expm(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 0. ]]; ```. While the correct result should have been (notice the element in second row, second column):. ``` python; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 1. ]]; ```. On analysing the source code I found the the function `sp_expm` in `sparse.py` is responsible for this computation. The particular code is reproduced below:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A.data = np.exp(A.data); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. Since `A.data` is stored in sparse matrix format, only non-zero elements are exponentiated. A way to avoid this problem would be to either completely remove the case of optimizing for diagonal states or modifying the appropriate code as:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A = sp.diags(np.exp(A.diagonal()),format='csr'); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. I am running qutip 3.2.0.dev-cb698ef; Python 3.5.1, numpy 1.10.4, scipy 0.17.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/493:1172,optimiz,optimizing,1172,https://qutip.org,https://github.com/qutip/qutip/issues/493,1,['optimiz'],['optimizing']
Performance,Qtrl load params general,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/403:5,load,load,5,https://qutip.org,https://github.com/qutip/qutip/pull/403,1,['load'],['load']
Performance,"Qtrl load params list, Qobj and ndarrays",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/350:5,load,load,5,https://qutip.org,https://github.com/qutip/qutip/pull/350,1,['load'],['load']
Performance,"QuTiP development is now based on a large community of continuous users and a smaller group of sporadic developers. Some developers continuously contribute to the development. . The nature of QuTiP, at the frontier of quantum physics research, implies that the development of new modules sometimes overlaps or stems from research projects. It could be nice to enhance the rate of contribution and mentoring from the users community in the spirit of openness and scalability. . ## GSoC and Wiki; An example of project ideas has been provided by the [Google Summer of Code 2019](https://numfocus.org/programs/google-summer-code), for which various researchers and coders, even if not directly part of the lead development team, proposed new projects on the [Wiki](https://github.com/qutip/qutip/wiki//Google-Summer-of-Code-2019). Two of these ideas were eventually brought forth by two students to develop their own projects over the summer. . The details are here https://gsoc2019-boxili.blogspot.com/ and here https://latticemodelfunctions.blogspot.com/. ## KWoC; I applied to the Kharagpur Winter of Code ([KWoC](https://kwoc.kossiitkgp.org/)) where mainly BSc and also MSc / PhDs can participate over the winter to a project on QuTiP. QuTiP just got selected and there is the opportunity for students projects over the winter. I will begin with proposing mine, but this is an opportunity also for mentors to propose their projects, beginning in priority from the lead developers. . ## Other Funding Schemes; Similarly, I have been writing NumFOCUS [small development grants](https://numfocus.org/blog/fall-2018-open-source-development-grants), which have a different goal but can be set up similarly. Also, in the future we may apply again to [Google Season of Docs](https://developers.google.com/season-of-docs). . ## Future Opportunities; Several senior researchers and team leaders have aired the desire to contribute to the project more actively. Setting up a space where they can propose projec",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1132:462,scalab,scalability,462,https://qutip.org,https://github.com/qutip/qutip/issues/1132,1,['scalab'],['scalability']
Performance,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/997:901,perform,performed,901,https://qutip.org,https://github.com/qutip/qutip/issues/997,1,['perform'],['performed']
Performance,"R: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. ### Code Output. _No response_. ### Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2193,cache,cached,2193,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"Remove `Coefficient.argument` which modify the object inplace for `Coefficient.replace` which return a modified copy.; `Copy` of string coefficient is optimized.; Initially from #1481, more discussion there. Some circular import in unrelated files have been moved inside function as they are causing problem in tests.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1507:151,optimiz,optimized,151,https://qutip.org,https://github.com/qutip/qutip/pull/1507,1,['optimiz'],['optimized']
Performance,Running it through the profiler suggests that cy_expect_psi_csr is only responsible for a small part of the time (accumulative time 4.2 sec as compared to total run time of 148 sec). ```; Wed Nov 26 15:04:59 2014 profile.out; 5155120 function calls (5143582 primitive calls) in 148.280 seconds; Ordered by: cumulative time; List reduced from 3097 to 100 due to restriction <100>; ncalls tottime percall cumtime percall filename:lineno(function); 441/1 0.014 0.000 148.283 148.283 {built-in method exec}; 1 0.001 0.001 148.283 148.283 mcsolve-performance.py:1(<module>); 2 0.000 0.000 147.463 73.732 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:69(mcsolve); 2 0.000 0.000 147.411 73.706 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:446(run); 2 0.000 0.000 147.411 73.705 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:423(parallel); 2 0.011 0.006 147.411 73.705 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:415(serial); 1000 8.867 0.009 147.340 0.147 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/qutip/mcsolve.py:757(_mc_alg_evolve); 453518 1.543 0.000 130.497 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:376(integrate); 453518 127.846 0.000 128.245 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:859(run); 395940 0.709 0.000 74.413 0.000 /home/rob/py-envs/py3-devel/lib/python3.4/site-packages/scipy/integrate/_ode.py:747(step); 171960 4.219 0.000 4.219 0.000 {built-in method cy_expect_psi_csr}; ```,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64519867:542,perform,performance,542,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64519867,1,['perform'],['performance']
Performance,"Running on Python 2.7 (Ubuntu 14.10) on my local system, this change significantly increased the performance. For some reason, the change was less pronounced using Python 3.4 on the same system (under 1 second change), but in both cases, this PR resulted in test times that were at least as fast as master. ```; cgranade@berith:~/Dropbox/software-projects/qutip (master u=)$ time nosetests qutip; ..............................................................................................SSSSSSS............................................................................................................................................................................................................................................/home/cgranade/Dropbox/software-projects/qutip/qutip/qobj.py:434: UserWarning: Multiplying superoperators with different representations; warnings.warn(msg); .............................................; ----------------------------------------------------------------------; Ran 382 tests in 292.925s. OK (SKIP=7). real 4m54.023s; user 11m20.584s; sys 0m5.356s; cgranade@berith:~/Dropbox/software-projects/qutip (master u=)$ git checkout fix-isherm-lazy ; Switched to branch 'fix-isherm-lazy'; cgranade@berith:~/Dropbox/software-projects/qutip (fix-isherm-lazy)$ time nosetests qutip; ..............................................................................................SSSSSSS.............................................................................................................................................................................................................................../home/cgranade/Dropbox/software-projects/qutip/qutip/qobj.py:436: UserWarning: Multiplying superoperators with different representations; warnings.warn(msg); .............................................; ----------------------------------------------------------------------; Ran 369 tests in 283.042s. OK (SKIP=7). real 4m43.554s; user 10m51.428s; sys 0m",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/359#issuecomment-130556638:97,perform,performance,97,https://qutip.org,https://github.com/qutip/qutip/pull/359#issuecomment-130556638,1,['perform'],['performance']
Performance,"Scipy 1.5 changed the methods of performing the matrix multiplication to; avoid copying the `indptr` matrix multiple times. This is actually not an; issue at all for us, because we only allow int32 indices (so if the; indices were to upcast, we just throw and exception), but the underlying; private Cython call structure also changed, and our `fast_csr_matrix` was; a direct clone. We add try/catch blocks to switch on the correct types (the overhead; from a failed lookup is trivial compared to the matrix multiplication; time), because we have to support more than just the most recent version; of scipy. We could look up the version of scipy installed, but the; ""try it and see"" approach is more typical Python. This problem should be eliminated by the move to the new data types, as; we will stop relying on private scipy code. See: commit scipy/scipy@53fac7a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1298:33,perform,performing,33,https://qutip.org,https://github.com/qutip/qutip/pull/1298,1,['perform'],['performing']
Performance,"Should fix tests/test_propagator.py::testPropHOStrTd sometime failing, ran it 100 times with the patch without error.; Cause: compiling the same string by multiple process at once resulted in them writing temp files with the same filename, resulting in a race condition and random fails. Not sure why it was not caught before.; @nathanshammah, @ajgpitch",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1169:255,race condition,race condition,255,https://qutip.org,https://github.com/qutip/qutip/pull/1169,1,['race condition'],['race condition']
Performance,Simply setting compiler flags and add link-time optimizations.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/308:48,optimiz,optimizations,48,https://qutip.org,https://github.com/qutip/qutip/pull/308,1,['optimiz'],['optimizations']
Performance,"Since I have been using GCC 4.8 for a while now, i did not think about compilers back to 4.4. I will take a look at this code on Monday, but my initial thinking is just to drop the optimization and leave it at that. This would save us from having to run an extra test suite on Travis. The only compiler flags that matter at the end are O3 and the fast math. Everything else is just a few percent improvement at best. . Paul. > On Feb 21, 2015, at 06:42, Dominic Meiser notifications@github.com wrote:; > ; > gcc 4.4 does not support the -flto option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6.; > ; > In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to setup.py to enable or disable link time optimization.; > ; > I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.; > ; > You can view, comment on, or merge this pull request online at:; > ; > https://github.com/qutip/qutip/pull/318; > ; > Commit Summary; > ; > Remove -flto compilation flags.; > Add gcc4.4 and clang builds to travis build matrix.; > File Changes; > ; > M .travis.yml (8); > M qutip/control/setup.py (4); > M qutip/cy/setup.py (2); > Patch Links:; > ; > https://github.com/qutip/qutip/pull/318.patch; > https://github.com/qutip/qutip/pull/318.diff; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318#issuecomment-75334652:181,optimiz,optimization,181,https://qutip.org,https://github.com/qutip/qutip/pull/318#issuecomment-75334652,3,['optimiz'],['optimization']
Performance,"Since this branch is unfortunately rather old, I didn't want to squash the early commits, but the most recent batch have been squashed down to just one. I think that this feature is now in a state I feel comfortable with reviewing, so I'll add the label. In the future, I would like to generalize the difference of unitaries optimization, but I think that will take a bit of Cython work to implement.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/456#issuecomment-198632131:325,optimiz,optimization,325,https://qutip.org,https://github.com/qutip/qutip/pull/456#issuecomment-198632131,1,['optimiz'],['optimization']
Performance,Small inquiry on the optimizations using GRAPE,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1900:21,optimiz,optimizations,21,https://qutip.org,https://github.com/qutip/qutip/issues/1900,1,['optimiz'],['optimizations']
Performance,"So I did an update of my conda environment to the latest version and now also the installation via pip has a problem, producing an `ImportError` (but not a segfault!) in the same location:. goerz@mlhpc2 develop:~/Documents/Programming/QNET> ipython; Python 3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00); Type ""copyright"", ""credits"" or ""license"" for more information. IPython 5.1.0 -- An enhanced Interactive Python.; ? -> Introduction and overview of IPython's features.; %quickref -> Quick reference.; help -> Python's own help system.; object? -> Details about 'object', use 'object??' for extra details. In [1]: import qutip; ---------------------------------------------------------------------------; ImportError Traceback (most recent call last); <ipython-input-1-ad45215f3e51> in <module>(); ----> 1 import qutip. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/__init__.py in <module>(); 169; 170 # core; --> 171 from qutip.qobj import *; 172 from qutip.states import *; 173 from qutip.operators import *. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/qobj.py in <module>(); 58 import qutip.settings as settings; 59 from qutip import __version__; ---> 60 from qutip.fastsparse import fast_csr_matrix, fast_identity; 61 from qutip.cy.ptrace import _ptrace; 62 from qutip.permute import _permute. /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/fastsparse.py in <module>(); 404 #Need to do some trailing imports here; 405 #-------------------------------------; --> 406 from qutip.cy.spmath import (zcsr_transpose, zcsr_adjoint, zcsr_mult). ImportError: /home/goerz/.conda/envs/default/lib/python3.6/site-packages/qutip/cy/spmath.cpython-36m-x86_64-linux-gnu.so: undefined symbol: _ZTINSt8ios_base7failureB5cxx11E. The verbose log file from the installation (`pip install -v --no-cache-dir qutip`) is here: [pip_log.txt](https://github.com/qutip/qutip/files/914669/pip_log.txt)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/674#issuecomment-293395036:1861,cache,cache-dir,1861,https://qutip.org,https://github.com/qutip/qutip/issues/674#issuecomment-293395036,1,['cache'],['cache-dir']
Performance,"So far:; I have created the 4.1.x branch; Created the gztar and zip via sdist; (there was a problem with missing hpp files, now fixed); I have uploaded the packages to the website and updated the links.; I have updated the conda-forge recipe. I am waiting to see how the packages work out before going any further. The Windows ones take about 24 before they get processed in the queue",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-285766694:379,queue,queue,379,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-285766694,1,['queue'],['queue']
Performance,"So now tests do run properly. They do not seem to fail. I did add an extra test for the case for the parameter `sparse=True`. This led me to a bug in `eigs_csr` that is now fixed. @jakelishman let me know if you are ok with this implementation. I am not very familiar with Cython so I am not sure how to handle the GIL in this case. I also find quire surprising to need the `sparse` argument in `trace_csr`. Shouldn't this function just perform a sparse computation of the trace norm (sparse always `True`?). Also, should the specialisation `traces_dense`, that currently does not exist, be mapped to the function `_trace_dense` I just wrote?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261:437,perform,perform,437,https://qutip.org,https://github.com/qutip/qutip/pull/1635#issuecomment-898738261,1,['perform'],['perform']
Performance,"So, while I agree that having a flexible storage format is a good way to go, the truth of the matter is that no one has time to implement such a big change. SciPy supports both 32 and 64-bit ints, and checks to see which ones are needed at runtime. e.g. a tensor product of two sparse matrices with int32, may need int64 in the result since their shape is larger. We could also do a similar thing, but it is a lot of work. The reason why we no longer use standard SciPy sparse objects is: 1) They tend to have a sizeable overhead when being created and/or manipulated do to redundant safety checks. 2) Many of the sparse operations are not well optimized. Because SciPy supports many different sparse formats, they had to generalize many of their core operations, making them slower. For example, the sparse kronecker product first converts to COO format, does the tensoring, and then converts back to the original format. Our method is much faster. Supporting more than just the current CSR format is also problematic. As already mentioned, there would be type checks, conditionals, and format conversions everywhere. e.g. what happens when DIA * CSR. As usual, available time is the limiting factor here. Support for both int32 and int64 is not that hard, but would take some time. Just int64 would make smaller matrices larger, but would allow for much greater system dimensions. In this later case, it would be a simple switch `int` -> `int64` and `size_t` -> `uint64` in the Cython code, and the fastsparse module (plus probably other places.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-384005667:645,optimiz,optimized,645,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-384005667,2,['optimiz'],['optimized']
Performance,"Sorry for the slow response... It seems to me like @Ericgig summed it up pretty concisely. Although I'm not sure I understand how #1123 fits in: what is the plan for `Qobjevofunc`, and how would it fit in to specifying time-dependent Hamiltonians?. The only thing that's ever really bothered me was the mandatory `args` as part of the signature, even if it's not used. That's lead to the need for workarounds like the `allow_args` parameter in; https://github.com/qucontrol/qdynpylib/blob/f7b54af3e586683cdfd9b3dd666c5cf540d843e1/src/qdyn/pulse.py#L555. If there's a future `f(t)` option, I should be happy. In the abstract, `f(t, **args)` and `f(t, state_vec, **args)` would be the most elegant, but if there's a severe performance hit, that could be a problem. I'm surprised, though: I would have thought that `f(t, **args)` and `f(t, args)` should be almost the same thing in the Python internals, since you can modify `args` inside of `f` and pass it to lowerlevel function as `**args` again. Even from the user's perspective any current code with signature `f(t, args)` could have its signature replaced with `f(t, **args)` without requiring any change to the function body. But I'm clearly missing something. Can you point me to lines in the code where this becomes a bottleneck?. I'm also quite in favor of introspection to accept a wide variety of signatures: you can even introspect argument names, so the possibilities are endless. The introspection is probably slow, but if it only has to be done in a very high level function, that might be alright.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562812696:721,perform,performance,721,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562812696,4,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"Specifically this test `test_interpolate.test_interpolate_brevolve3()` followed by `test_mcsolve.test_MCCollapseTimesOperators` generates an error or the form; ```; Process SpawnPoolWorker-1:; Traceback (most recent call last):; File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 249, in _bootstrap; self.run(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\process.py"", line 93, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\pool.py"", line 108, in worker; task = get(); File ""C:\Anaconda2\envs\q4_2-py35\lib\multiprocessing\queues.py"", line 345, in get; return ForkingPickler.loads(res); ImportError: No module named 'rhs47600'; ```; The rhs... file in generated by the brevolve3 test. The test appears to finish fine. But somehow it looks like some process is hanging around. Why this is triggered by the MCCollapseTimesOperators test is a bit of a mystery.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/728:613,queue,queues,613,https://qutip.org,https://github.com/qutip/qutip/issues/728,2,"['load', 'queue']","['loads', 'queues']"
Performance,Test error is an unrelated correlation test failure (it looks like a coefficient generation race condition?).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081:92,race condition,race condition,92,https://qutip.org,https://github.com/qutip/qutip/pull/1857#issuecomment-1098120081,1,['race condition'],['race condition']
Performance,"Thank you for reporting.; There seems to be an issue with our detection of mkl for a while.; Since it's an optional dependancy, the related tests have been quietly skipped for a while... You could probably manually import it until we make a patch:; ```; from ctypes import cdll; import sys; import os. qutip.settings._mkl_lib = cdll.LoadLibrary( os.path.dirname(sys.executable) + r'\Library\bin\mkl_rt.dll' ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367:333,Load,LoadLibrary,333,https://qutip.org,https://github.com/qutip/qutip/issues/2496#issuecomment-2243309367,1,['Load'],['LoadLibrary']
Performance,Thanks @Ericgig for feedback.; I see (having read more carefully) in; https://github.com/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb; there is an example showing the equivalence of using `smesolve` and `general_stochastic` with a clear performance enhancement in the former. So I think I can easily switch my example to use `smesolve`. Thanks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581:272,perform,performance,272,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-547215581,2,['perform'],['performance']
Performance,"Thanks Jake, I understand better how the cache is working. Okay let me suggest a few comments within the code so that we (or at least I) can keep track of how this implementation works. If you think they are sensible then feel free to accept and then we can merge this.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877273495:41,cache,cache,41,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877273495,1,['cache'],['cache']
Performance,"Thanks Robert. As far as the problems with the sparse solver in scipy, I have read around a bit and found that the solver doesn't perform well for finding eigenvalues with small magnitude. From a scipy tutorial:. http://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html. > Note that ARPACK is generally better at finding extremal eigenvalues: that is, eigenvalues with large magnitudes. In particular, using which = 'SM' may lead to slow execution time and/or anomalous results. A better approach is to use shift-invert mode."". See also the example on that page. I tried using the 'shift-invert mode' as suggested, and that gave better results. But, they are still pretty bad for the problem I want to solve: I'm trying to find the low lying spectrum for a very large Liouvillian, as I vary a single external Hamiltonian parameter. The smallest one (in magnitude) is always zero, and all others are negative. Supposedly, the vanishing of the real part of the eigenvalue with the second largest (closest to zero) real part can be useful for characterizing phase transitions, see, for example, this recent paper: http://prl.aps.org/abstract/PRL/v110/i15/e150401. I attach a plot where I have computed the eigenvalue with second largest real part (which is also the one with second smallest magnitude; the two criteria coincide) using 1) scipy.linalg.eigvals (green line) and 2) scipy.sparse.linalg.eigs (blue line): https://dl.dropboxusercontent.com/u/6042643/liouvspec.png. As you can see, the results from the sparse solver are pretty poor (I assume the dense solver results are correct). . As far as the physics goes: Another thing to notice is that the system goes through phase transitions at -2.0, 0.5 and 2.0 for the parameter along the x-axis, and there are no signs of that in the plot. On a side note, I also wasn't able to reproduce Fig 2(a), middle panel, of the PRL paper I linked to, although I got qualitative agreement if I tried with different parameters than what is quoted in th",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/16#issuecomment-16416062:130,perform,perform,130,https://qutip.org,https://github.com/qutip/qutip/issues/16#issuecomment-16416062,2,['perform'],['perform']
Performance,"Thanks simon! On the tests we have one that checks the dynamics for the bosonic solver, and one that checks the steady state for the fermionic stuff, but not vice versa. I will try and construct something. I think for the HSolverDL backwards compatibility test, we can reuse the old test (which is essentially the same test I put in for the bosonic solver). In bofin.py itself, I think we can replace _pad_csr() with the cy_pad_csr cythonised version in qutip already (that HSolverDL was already using), its a bit faster (I didn't do it so far because of bug checking, but it should be ok to change now). There are probably lots of small places where things can be optimized a little as well.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769:665,optimiz,optimized,665,https://qutip.org,https://github.com/qutip/qutip/pull/1601#issuecomment-875287769,1,['optimiz'],['optimized']
Performance,"Thanks! I used git checkout for ecca45c and reinstalled with python setup.py install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Us",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:931,optimiz,optimizer,931,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212,1,['optimiz'],['optimizer']
Performance,"That is what I did in fact, but I had to add it myself. That is load them in from CPATH or C_INCLUDE_PATH. They were not included automatically. I am not suggesting that we do that in this PR, but maybe extending rather than overwriting the CFLAGS might be better. Unless there is good reason not to?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/570#issuecomment-265068820:64,load,load,64,https://qutip.org,https://github.com/qutip/qutip/pull/570#issuecomment-265068820,1,['load'],['load']
Performance,"That's the only two problems I ran into when testing the code, but I didn't test everything. About performance of numpy/lists for small arrays; I wouldn't worry much about that in this case. On a different note: Since we don't have unit tests for the plot functions in qutip it would be great if you could consider adding an ipython notebook to qutip/qutip-notebooks that demonstrates how to use these plot function, with some suitable input states.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/105#issuecomment-43740558:99,perform,performance,99,https://qutip.org,https://github.com/qutip/qutip/pull/105#issuecomment-43740558,1,['perform'],['performance']
Performance,"The QIP module is a set of tools for simulating quantum computing, from the high-level of algorithms, down to individual qubit control sequences in a particular physical architecture. So far it has functions for common quantum information processing tasks, including pre-defined quantum gates, along with functions for applying arbitrary 1, 2, and 3 qubit gates to arbitrary target and control qubits in a register of N qubits, circuit representations, a library of quantum algorithms, and models for some common physical QIP architectures. Our goal is to have a set of tools to analyse the influence of unexpected noise sources on a given algorithm realized on a particular architecture, as well as being used as an educational tool for teaching QIP concepts. . QIP module enhancements we plan to implement include:; 1. Simulation of stabilizer circuits and quantum error correction codes.; 2. Simulation of common quantum algorithms - Shor's Factorization, Grover's Search, Quantum Teleportation, and more...( http://math.nist.gov/quantum/zoo/ ); 3. Extend platform to simulate specific quantum computing architectures - Create models to simulate different experimental quantum computing setups like Xmons, including typical environmental noise sources, and limitations on control and readout associated with each example.; 4. Combine the qip and qcontrol modules to optimize circuit and gate decomposition and find ideal fast control pulses to realize particular gates, given physically available limitations of a particular architecture. ; 5. Platform for simulating quantum chemistry on a quantum computer - Create example codes for calculating the ground state of molecules, following specific examples found in DOI: 10.1126/science.1113479 and elsewhere. ; 6. Combine the qip and HEOM/RC solvers to investigate the effect of a non-markovian and nonperturbative environment on error correction and common algorithms.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/441:1369,optimiz,optimize,1369,https://qutip.org,https://github.com/qutip/qutip/issues/441,1,['optimiz'],['optimize']
Performance,"The Qobj data that represents the state or operator is stored as a sparse (csr) array. In most cases this makes sense, as the memory requirements for many solvers would be excessive. There are many cases though for small systems where memory would not be an issue, and significant performance improvements could be gained. This has been demonstrated in the optimal control modules. Many matrix operations are much faster in the dense representation. Originally suggested in #26. This is now more urgent. In answer to #370 I submitted #397. However, it was found that significant performance degradation occurred in the control evolution calculation for small systems, and as such a retrofit of ndarray option for internal operator type was made. This leads to pretty untidy code, and means that subclasses for propagator and gradient calculations, fidelity, and evolution calculations all need to implement conditional methods. Implementation of a dense Qobj would resolve these problems, and as mentioned above, could lead to performance improvements in many of the other solvers. Many of the solvers assume sparsity, and so they too may need changes to support dense states and operators. . In general, great care would need to be undertaken in implementing the dense Qobj. Those methods that did not support it would need to check the Qobj type when called",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/437:281,perform,performance,281,https://qutip.org,https://github.com/qutip/qutip/issues/437,3,['perform'],['performance']
Performance,The commit af17ded3dec6d712eb852575bf6d5a6c5bbaf832 introduced a performance regression in Qobj.expm. https://github.com/qutip/continuous-benchmark#qobj_expm_20,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/50:65,perform,performance,65,https://qutip.org,https://github.com/qutip/qutip/issues/50,1,['perform'],['performance']
Performance,"The current test implementation is taking 3 seconds locally. But the times are quite bigger on the CI.I am positive that the test I implemented is minimal both in dimensions and requirements, as the alternativeof limiting the number of `eigvals` claculated and checking distinct from 0 on unitary matrices impacts the performance negatively on my side.; Maybe we should ship this without tests?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-821186337:318,perform,performance,318,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-821186337,1,['perform'],['performance']
Performance,The difference in performance is huge for large dimensions. In the case of cy_expect_rho_vec we calculate n*(n-1) unnecessary values which we drop immediately with trace operation.; I didn't replace the cy_expect_rho_vec because of the API change. I don't know exactly where it is used. Maybe it make sense to use cy_expect_rho_vec as a wrapper for cy_expect_rho_vec_fast?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25357042:18,perform,performance,18,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25357042,1,['perform'],['performance']
Performance,"The green line is after the first commit of this pull request where I used a for loop. The orange line is after the second commit when I switched to using numpy.cumprod.; The red line is from the quantum optics framework written in julia that I'm currently working on (https://github.com/bastikr/QuantumOptics.jl). While doing some benchmarks I realized that for large N qutips coherent function failed which is why I wrote this patch. I don't know where the constant offset in the benchmark originates from but I think the speed is fine now, creating coherent states is probably never a bottleneck anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/683#issuecomment-292929031:588,bottleneck,bottleneck,588,https://qutip.org,https://github.com/qutip/qutip/pull/683#issuecomment-292929031,1,['bottleneck'],['bottleneck']
Performance,"The installation seems to succeed, but there seems to be a problem when the tests are run (or when I go into python, trying to load anything like `from qutip import *` gives an error. The script gives the following error (which can be reproduced by just running `import qutip.testing as qt` in python):. ```; [. . .]; Successfully installed qutip-3.1.0; Running QuTiP unit tests; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; /Users/justin/.pyxbld/temp.macosx-10.10-x86_64-2.7/pyrex/qutip/cy/spmatfuncs.c:250:10: fatal error: 'numpy/arrayobject.h' file not found; #include ""numpy/arrayobject.h""; ^; 1 error generated.; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/usr/local/lib/python2.7/site-packages/qutip/__init__.py"", line 213, in <module>; from qutip.qobj import *; File ""/usr/local/lib/python2.7/site-packages/qutip/qobj.py"", line 60, in <module>; from qutip.ptrace import _ptrace; File ""/usr/local/lib/python2.7/site-packages/qutip/ptrace.py"", line 38, in <module>; from qutip.sparse import sp_reshape; File ""/usr/local/lib/python2.7/site-packages/qutip/sparse.py"", line 49, in <module>; from qutip.cy.sparse_utils import (_sparse_profile, _sparse_permute,; File ""/usr/local/lib/python2.7/site-packages/qutip/cy/__init__.py"", line 1, in <module>; from qutip.cy.spmatfuncs import *; File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 431, in load_module; language_level=self.language_level); File ""/usr/local/lib/python2.7/site-packages/pyximport/pyximport.py"", line 209, in load_module; inplace=build_inplace, language_level=language_level); File ""/usr/local/lib/python2.7/site-packages/pyximpo",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348:127,load,load,127,https://qutip.org,https://github.com/qutip/qutip/issues/348,1,['load'],['load']
Performance,"The last thing that needs to be done is too better optimize the parallel processing. Right now we spawn ntraj threads, each creating a ODE instance. This is major overkill since we really need a single instance per thread.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64838151:51,optimiz,optimize,51,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64838151,1,['optimiz'],['optimize']
Performance,"The negative values problem is definitely present when `state` is a density matrix, and right now that is the only case I have tested. . I understand it will be very slow for larger systems (exponentially so), but in my application is seems to be much slower even than the time evolution of the function, which seems like it should be more computationally complex. Given that, I suspect there is some room for optimization. . What's the best way to tell if there are any relevant differences between 4.7.2 and the 5.0.x alpha?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769:410,optimiz,optimization,410,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819970769,1,['optimiz'],['optimization']
Performance,"The new version of expm that I grabbed from Expokit does not behave quite as well as the SciPy version. After a bit of testing, the SciPy version performs the best overall. For our purposes, I think that either method would be sufficient. However, the SciPy version is the current best algorithm, and replacing as much code as possible with SciPy code is probably a good thing. This code still defaults to the dense method.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/466:146,perform,performs,146,https://qutip.org,https://github.com/qutip/qutip/pull/466,1,['perform'],['performs']
Performance,"The performance hit come from filtering the args. This is pretty much what I am doing:; ```; def f(t, args):; args_now = {key:args[key] for key in dict if not key.startswith(""_"")}; return original(t, **args_now); ```; With some work, I should be able to remove the need for `args_now` and get much faster. But there is still an extra layer. ; Introspection only need to be done once at setup, not at each call so it should have a great effect.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-563011840:4,perform,performance,4,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-563011840,1,['perform'],['performance']
Performance,"The plugin was already enabled by default, so this does not turn it on. However, it also defaults to Python 2, which means it produces a lot of syntax errors, and the run (silently) failed every time. This may cause our CodeClimate score to drop, not because we actually got worse, but because we suddenly start seeing a load of duplication that was previously hidden. I'm hoping that getting these parser errors fixed will mean that the ""Progress report"" tab on CodeClimate will start getting populated. **Changelog**: (developer changes) fixed Python version for duplication detection in CodeClimate",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577:321,load,load,321,https://qutip.org,https://github.com/qutip/qutip/pull/1577,1,['load'],['load']
Performance,"The problem seems pretty simple, I think I could take care of it. However, I don't have much experience in collaborative programming, in particular I don't know what the local customs are. (I know how to use git, but I'm not familiar with the layout of the library, what tests should I perform [or even add my own, since this issue wasn't noticed before 5.0.0] etc.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457:286,perform,perform,286,https://qutip.org,https://github.com/qutip/qutip/issues/2129#issuecomment-1483294457,2,['perform'],['perform']
Performance,"The qutip.fortran module seems to be built and installed in the TravisCI environment, but for some reason loading it after install fails, so the tests are skipped. . See for example the build log at https://travis-ci.org/qutip/qutip/jobs/19551778",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/80:106,load,loading,106,https://qutip.org,https://github.com/qutip/qutip/issues/80,1,['load'],['loading']
Performance,"The stochastic solver are not thought for a lot of noise operators.; In v4, operations are all `CSR @ Dense_1D_array`.; In v5, you have more control on which storage is used for each operators, we support dense, csr, dia format (+ plugin for cupy, jax, tensor network in development.). But I fail to see how you can use sparsity for speed it up in this case in particular.; Could you write the equations / logic of the optimization here?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503:419,optimiz,optimization,419,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904360503,1,['optimiz'],['optimization']
Performance,"There appears to be a bug in OptimizerLBFGSB.run_optimization . At line 901, _build_bounds_list is called and correctly constructs the list of upper and lower bound tuples and sets self.bounds, however there is no return value. At line 939, the empty variable 'bounds' is passed to scipy.fmin_l_bfgs_b and therefore the constraints are not active. . Easy solution is to change ""bounds=bounds"" to ""bounds=self.bounds"" in line 939.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353:29,Optimiz,OptimizerLBFGSB,29,https://qutip.org,https://github.com/qutip/qutip/issues/353,1,['Optimiz'],['OptimizerLBFGSB']
Performance,"There's another interesting technique that's sometimes applicable in these sort of repeating cases. Rather than passing a list of the same elements to `tensor`, you can also consider building up the tensor product manually, going up in powers of two. So you go along with something like:; ```python; out, tmp = H, H; for i in n.bit_length():; tmp = tensor(tmp, tmp); if n & (1 << i):; out = tensor(out, tmp); ```; (very very approximately - I've almost certainly got the indexing wrong). The idea is that you only perform `lg(n)` tensor products. Now, this might not actually give you much of a speed up in this case, because the calculation is still going to be dominated by the final tensor product, since the output matrix keeps getting larger. But in things like integer matrix powers, bigint calculations, or binomial expansions, this type of thing can be super useful! QuTiP 5 uses an algorithm like this for matrix powers. (I imagine SciPy does too, but for all the normal reasons, we don't use their implementation.). *edit*: here it is: https://github.com/qutip/qutip/blob/559387e68eb2b07064d2ae6099fbdc81ea96d67c/qutip/core/data/pow.pyx#L17-L39",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997:514,perform,perform,514,https://qutip.org,https://github.com/qutip/qutip/pull/1688#issuecomment-942580997,1,['perform'],['perform']
Performance,"There's no rabbit hole - it's just a bug on line 511 of `mesolve.py` and 526 of `mcsolve.py`. The output dtype is correctly calculated, it's just a bug in generating values for the output array. There's a similar bug in the states output caused by the use of `fast='mc-dm'` that requires a more effort to fix, and should be at some point, but that's not so important right now. Having `qutip.expect` return real values for Hermitian operators and states I'd say is the correct behaviour. It's by far the most common use-case, and it allows them to be directly plotted without generating a load of warnings.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796887930:589,load,load,589,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796887930,1,['load'],['load']
Performance,"This PR addresses #433 by manually setting `Qobj.superrep` to suppress warnings in `chi_to_choi`. The change of basis for chi → choi is currently represented as a `superrep='super'`, as that makes sense in several other contextx, such that spurious warnings were raised when performing this conversion.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/436:275,perform,performing,275,https://qutip.org,https://github.com/qutip/qutip/pull/436,1,['perform'],['performing']
Performance,"This PR suggests enhancing the `qutip.metrics` module by adding a new distance b/w quantum states: the quantum Hellinger distance (QHD), implemented as new function `qutip.metrics.hellinger_dist()`. Excellent description is provided for example in:; _Geometric measures of quantum correlations with Bures and Hellinger distances_, D. Spehner, F. Illuminati, M. Orszag, W. Roga, https://arxiv.org/abs/1611.03449. Albeit a bit less popular than already implemented Bures and trace distances, the QHD is actively studied, eg:; https://arxiv.org/abs/1903.10455; https://arxiv.org/abs/1806.10814; https://arxiv.org/abs/1510.06995. The PR contains tests of properties of the QHD as outlined in arXiv:1611.03449. I am of course keen on performing additional tests, code refactoring, documentation of this feature etc.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/998:729,perform,performing,729,https://qutip.org,https://github.com/qutip/qutip/pull/998,1,['perform'],['performing']
Performance,"This class allows counts and timings (and general messages) to be collected about solver performance.; These can then be reported at the end.; I could not see anything similar already in qutip. I hope I have not duplicated effort. I have been outputting some counts and timings in hsolve in order to look for efficiency improvements. They are a bit untidy at the moment, so I wanted a more tidy way to achieve the same. . Hopefully this can be used in other solvers too. I intend to make the control stats subclass from this at some point.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454:89,perform,performance,89,https://qutip.org,https://github.com/qutip/qutip/pull/454,1,['perform'],['performance']
Performance,"This fixes the calls to the `qutip.configrc` module in `qutip/__init__.py` when setting up OpenMP. Also, this tidies up a lot of very old code out of `__init__.py` that was testing for ancient versions of SciPy and Numpy. Since we have hard requirements at installation time for those, it's fine for us not to test their versions at initialisation. We still should check the version of Cython because it's an optional dependency, so isn't always constrained by the package manager. Some of the changes deliberately make `qutip/__init__.py` less forgiving of exceptions, especially when it comes to loading up `pyximport`. This is deliberate, even though it may make a couple more errors surface that have previously gone undetected. As it stands right now, the file will causes several errors to be silently ignored, even if they weren't the error we were testing for. That masks problems for a short while, but they usually resurface during use when they're much harder to debug. We should be solving the underlying problems, not sweeping them under the rug. In particular, we've frequently had complaints about `pyximport` failing, or trying to import OpenMP modules that have previously been compiled but aren't currently active, and things like that. This patch won't fix all those problems, but it hopefully will make some of them easier to debug when they do appear. There is more explanation to the logic behind each change in the commit messages. Fix #1470.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1471:598,load,loading,598,https://qutip.org,https://github.com/qutip/qutip/pull/1471,1,['load'],['loading']
Performance,"This has been going on for a while now - `test_diag_liou_mult` fails about ~5-10% of the time on Travis runs, with only 1 or 2 elements of the huge matrix differing by a small relative tolerance. I _think_ this started around the time that scipy 1.5 was released, which changed how `scipy.linalg.eigh` chose its underlying LAPACK driver, and broke a load of tests that relied on our custom `eigh` functions reproducing the `scipy` behaviour exactly (#1299). At the time we fixed those tests (#1298, #1301), but this intermittent failure of `test_diag_liou_mult` may have slipped through. Equally, at the same time on `dev.major` I think I was moving the `brtools` internals to use the new `CSR` types, which involved rewriting things like `diag_liou_mult`. I don't think this is the cause (though I may have done at the time), because we see the intermittent test failures still on `master`, which does not use the new types yet. I'm not absolutely certain the `eigh` changes are the cause, which is why I don't want to just bump up `atol`/`rtol` in the test without going through and calculating what the acceptable tolerance _should_ be. This is a note for posterity. I'll look into it myself and try and determine the true root cause, and PR an appropriate change.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1431:350,load,load,350,https://qutip.org,https://github.com/qutip/qutip/issues/1431,1,['load'],['load']
Performance,"This is a tidied up and completed version of #934. The first commit is credited to the original author (although I fixed up some little concerns in the PR and rebased it), because it's logically built off that PR, although in the end it's a complete reimplementation. This is a complete rewrite of the Husimi Q calculations, to make a more formal split between the iterative (low-memory) and precomputed (faster) algorithms, giving full access to both of them. It's a bit easier to use from a user's perspective, and it's faster than #934 as well. The concept of the precomputed matrix is encapsulated into a class with a cached tensor, so that the same precomputed system can be used for many states of different sizes, and autoexpands (up to the memory limit) to accommodate larger states. This is called `QFunc` as opposed to the standard function interface `qfunc`. It also adds rather more error checking on its inputs, and adds a complete testing suite for the new implementation. Closes #934. ## Examples. Let's say we have some states, and the phase-space coordinates we want to calculate the Husimi Q function at.; ```python; >>> import qutip; >>> states = [qutip.rand_dm(32, density=0.2) for _ in [None]*100]; >>> xs = np.linspace(-2, 2, 401); ```. Now the normal way of calculating the Q distribution for a single state is; ```python; >>> qutip.qfunc(states[0], xs, xs); array( ... ); ```. This already has some speed advantages over the pre-PR version of `qfunc`, because it caches a lot of its intermediary results, to avoid recomputing them. This results in calculating more matrix-vector products than before, but far fewr FLOPS overall. By default, `qfunc` issues a warning if it exceeds a certain amount of memory, and falls back to the low-memory version. You can control this limit with the `precompute_memory` option:; ```python; >>> qutip.qfunc(states[0], xs, xs, precompute_memory=0); qutip/qutip/wigner.py:822: UserWarning: Falling back to iterative algorithm due to lack of mem",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583:622,cache,cached,622,https://qutip.org,https://github.com/qutip/qutip/pull/1583,1,['cache'],['cached']
Performance,"This is just a comment - by coincidence, I also had a situation yesterday where my code was very slow because the matrices I used were accidentally dense. In my case, the reason was that I created operators like; ```; basis(N, i) * basis(N, j).dag(); ```; The default_dtype applies here but, if I hadn't been primed by seeing this issue, it might have taken me a long time to understand what is going on. It is somewhat surprising that qutip would, by default, create vectors / operators with only one non-zero entry as dense. I am sure there are good performance reasons for that, but it would be good to think about how we can help users not to run into such traps. Applying the default_dtype (or several of them) more broadly is certainly good. Has it been considered to include the dtype information in the output of printed `Qobj`s?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625:552,perform,performance,552,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1955804625,1,['perform'],['performance']
Performance,"This is post for discussion over whether it might be beneficial to consider additional continuous integration (CI) tools for QuTiP, beyond Travis CI. . Some open-source projects use multiple CI tools, possibly to do different tasks and test different configurations. For example by adding QuTiP to the list of projects using Sphinx for the documentation I noticed they use concurrently Travis CI, CircleCI and [Appveyor](https://github.com/marketplace/appveyor). . [Stackshare](https://stackshare.io/stackups/circleci-vs-jenkins-vs-travis-ci) allows to compare multiple developers tools.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/959:373,concurren,concurrently,373,https://qutip.org,https://github.com/qutip/qutip/issues/959,1,['concurren'],['concurrently']
Performance,This is ready to be reviewed and added to QuTiP. Notebooks are in : https://github.com/nathanshammah/piqs/blob/master/notebooks/notebook_piqs.ipynb. One would need to change the import statement to `from qutip.models.dicke import *`. Perhaps some more testing could be done for the states and operators but I want to get this merged first before trying to optimize. The Liouvillian created here works with QuTiP's solver (thanks to Neill's suggestion). Thus one can easily work with ensembles of spins or even ensembles coupled to bosonic cavities and take full advantage of QuTiP machinery. We have an optimized solver for diagonal Hamiltonians which is faster and perhaps there is a scope to make this even faster with the correct RHS calculation. Please have a look and review the changes to get this merged. @nwlambert @nonhermitian @ajgpitch,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/753#issuecomment-360766438:356,optimiz,optimize,356,https://qutip.org,https://github.com/qutip/qutip/pull/753#issuecomment-360766438,2,['optimiz'],"['optimize', 'optimized']"
Performance,This is very interesting! I was looking for some time already a way to incorporate assembler here. Now it is possible to use FMA (fused multiply add) which should greatly improve speed of almost anything or there is a very neat implementation of complex number product with FMA which is exact (avoids loss of precision) with almost no performance penalty.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/551#issuecomment-253969071:335,perform,performance,335,https://qutip.org,https://github.com/qutip/qutip/pull/551#issuecomment-253969071,1,['perform'],['performance']
Performance,This is weird it is showing an apparently unrelated failure while saving and loading pickles. And the CI times seem longer.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498#issuecomment-822631709:77,load,loading,77,https://qutip.org,https://github.com/qutip/qutip/pull/1498#issuecomment-822631709,1,['load'],['loading']
Performance,"This issue is mostly obseleted by the merging of #1465, since the complete build structure is now different. In that we didn't necessarily implement the complete change requested here (we don't have `pytest` as a requirement), but we do have the PEP-517-approved way of fully specifying build requirements, so getting a correct build environment is automated. I will note that `pip install -e .` doesn't play very nicely with packages with Cython components to build; at the time of writing, `pip` would tend to install dependencies and perform the build in a venv regardless of what was installed in the activated Python environment (especially if conda), which meant that the complete set of Cython files needed to be re-compiled every time this command was run. That's fine if you just want to edit the Python files, but `setup.py develop` would correctly remember which Cython files actually _needed_ to be re-compiled, so remains much more useful for low-level QuTiP development for practical purposes right now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1263#issuecomment-809340570:537,perform,perform,537,https://qutip.org,https://github.com/qutip/qutip/issues/1263#issuecomment-809340570,1,['perform'],['perform']
Performance,"This may seem like a pedantic change, but is does (very slightly) improve performance in hsolve, and also avoids addressing an array index as a non-integer. Seems to make sense for the state numbers to be integers anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/446:74,perform,performance,74,https://qutip.org,https://github.com/qutip/qutip/pull/446,1,['perform'],['performance']
Performance,"This moves our entire testing apparatus over to GitHub Actions, since Travis has changed its pricing model and we can no longer rely on it. This actually has several advantages for us right now:; - better integration with other GitHub Actions workflows; - more concurrent jobs; - more access to Windows and macOS machines; - easier job dependency graphs within our resources. This first commit does not add in any Windows tests because they're currently known to fail, but the intention is to turn them on. The blocking issue is currently a failure of the multiprocessing capabilities, which also affects mcsolve. We can now reasonably run coverage reporting on every test run, and upload all of them to Coveralls at the end, so we get accurate stats on what lines were actually tested. I've also turned pytest's timer, so it reports all tests that took longer than a second to run. This should really help identify where the real problems in our testing are - right now you should see that there's a `correlation` test that takes around 2 minutes to run, which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:261,concurren,concurrent,261,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['concurren'],['concurrent']
Performance,"This relaxes the amount of sorting required in the `add_csr` operation. In the current version in `dev.major`, both the left and right matrices are sorted in all cases. This PR makes `add_csr` an `Accumulator` operation, which straight away reduces the number of sorts required to one. Second, I add a track inside `scatter` to know whether the scatters were in sorted order; if so, there's no need to sort within `gather`, which removes the other sort from `add_csr`. Effectively, this means that `add_csr` is O(n) when both input matrices are sorted (the most common) and O(n lg(n)) when either isn't, and we don't actually have to perform a separate test to decide between them. In practice, this is around a 2x speedup for most common sparse matrices, and goes up from there. I have also made `Accumulator` a C struct, and all the operations on it header-file only. This allows them to be operated on without holding the GIL (though threaded access to the same one would be unsafe anyway), and it also allows them to be inlined - if they are defined in the `pyx` file, then they will be compiled into a separate object and so must be called. We had talked about making `CSR` have a ""guarantee"" that it is always sorted, but I haven't implemented that here. Because of the changes to `scatter`, that would no longer give an algorithmic speedup in this case for matrices that are sorted (although we could avoid the use of `Accumulator` which would be more efficient). All of the operations I have written return a sorted matrix, so generally matrices will tend to become sorted over time anyway.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1362:634,perform,perform,634,https://qutip.org,https://github.com/qutip/qutip/pull/1362,1,['perform'],['perform']
Performance,This seems like a good idea to me though! It might also help with the upcoming TensorFlow backend (where we'll probably need to mostly create TF backend QObjs in order to get reasonable performance).,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809210105:186,perform,performance,186,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809210105,1,['perform'],['performance']
Performance,"This seems like a really good start, thanks! Building on this, we may want to explore taking a more unified approach to performance testing, as there's a number of performance-sensitive features in QuTiP. One avenue may be to write performance testing into the unit testing builds, that seems to be an [older extension for Nose](https://github.com/disqus/nose-performance), not sure if there's a better one out there.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/454#issuecomment-193501554:120,perform,performance,120,https://qutip.org,https://github.com/qutip/qutip/pull/454#issuecomment-193501554,4,['perform'],"['performance', 'performance-sensitive']"
Performance,"To generate a random ket and have it be in the tensor product space of 3 qubits I would use. ket = qutip.rand_ket(8, dims=[[2, 2, 2], [1, 1, 1]]); so to have the `dims` form I would get by actually taking the tensor product of three 1-qubit kets.; However this will fail due to the check performed of [L652](https://github.com/qutip/qutip/blob/master/qutip/random_objects.py#L652) of `random_objects.py`:. if not isinstance(dims, list) or isinstance(dims[0], list):; Did I understood wrong how the `dims` parameter of `rand_ket` is supposed to work? or is there a simple typo in the above line and it was instead supposed to be something like:. if not (isinstance(dims, list) or isinstance(dims[0], list)):; ?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/617:288,perform,performed,288,https://qutip.org,https://github.com/qutip/qutip/issues/617,1,['perform'],['performed']
Performance,Use of iteritems removed in apply_params to make compatible with Python3; fixes #367 ; Also some changes to the way max_metric_corr and accuracy_factor method_params are applied in the optimizer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/372:185,optimiz,optimizer,185,https://qutip.org,https://github.com/qutip/qutip/pull/372,1,['optimiz'],['optimizer']
Performance,"Using `tempfile.TemporaryDirectory()` as a context manager doesn't change the current directory, so we should be allowed to `cd` into the directory it returns... The documentation doesn't mention anything about not being able to as far as I can see, and regardless, if it fails it should raise an `OSError` and not crash the interpreter. I need to get a Windows box to try and debug this myself - it's difficult to know how to proceed without working out exactly what the problem is. We could try using the `cwd` kwarg of `subprocess.run`, but if you're not allowed to change into a temporary directory on Windows in any manner, then that may also fail. We don't want to run `pdflatex` in the user's directory, but ""officially"" we don't know exactly what files it will produce, so we can't reliably clean them all up. That's also not to mention the potential race condition that we get if two processes are trying to draw circuits simultaneously.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605333270:859,race condition,race condition,859,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605333270,1,['race condition'],['race condition']
Performance,"Very nice! The fortran stuff never worked on travis. In fact, it builds and install ok, but fails to load when the tests are ran. Perhaps some missing library path?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/300#issuecomment-68425677:101,load,load,101,https://qutip.org,https://github.com/qutip/qutip/pull/300#issuecomment-68425677,1,['load'],['load']
Performance,"WIP: Qobj cleanups, optimization and improvements.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/95:20,optimiz,optimization,20,https://qutip.org,https://github.com/qutip/qutip/pull/95,1,['optimiz'],['optimization']
Performance,"We can't implement `__hash__` for `Qobj`, sorry - it's just not possible while following the [Python data model](https://docs.python.org/3/reference/datamodel.html#object.__hash__). The two principle points that a hash function must follow from there are; 1. objects which compare equal with `__eq__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs an",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:847,cache,cache,847,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,4,['cache'],['cache']
Performance,"We don't use the same code for the sparse addition as in `v4`. v5 sparse addition is quite faster. But I expect it to be slower for 100 additions of 50 elements since you need to allocate memory for the 100 intermediate results, while for 1 addition with 5000 elements, there is only one memory allocation. But if you want to have a go at optimizing our basic operations, we will welcome any improvements.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811:339,optimiz,optimizing,339,https://qutip.org,https://github.com/qutip/qutip/issues/2298#issuecomment-1904497811,1,['optimiz'],['optimizing']
Performance,"Weird CI error on f56d27f - the build log suggests there was an error in setup (looks like `numpy` failed to load?), but I don't think that commit actually caused it, since it doesn't touch `setup.py`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1181#issuecomment-586401030:109,load,load,109,https://qutip.org,https://github.com/qutip/qutip/pull/1181#issuecomment-586401030,1,['load'],['load']
Performance,"Welcome, and thanks for filing your first issue. `measurement_statistics_observable` determines the eigenvalues and eigenstates of the supplied operator, so it's likely to be slow as the size of the system grows. If there is a means to speed it up, we'd be happy to give that a try. You could also try the alpha release of QuTiP 5 (`pip install qutip==5.0.0a2`) and compare performance there. Are you only seeing the negative probabilities when `state` is a density matrix? Perhaps we can make the code a bit better and explicitly tidy up the small unphysical negative probabilities.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808:374,perform,performance,374,https://qutip.org,https://github.com/qutip/qutip/issues/2265#issuecomment-1819949808,1,['perform'],['performance']
Performance,Well the performance depends strongly on the number of elements in tlist. For the given example the only calls that change is the increased number of expectation value calculations and a larger number of times the overall for-loop is run.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-64520234:9,perform,performance,9,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-64520234,1,['perform'],['performance']
Performance,"Well, `-march=native` gives you couple of percents of performance in the compiled binary (I wonder, did anyone benchmark how much, actually?), but it is a promise ""I will never run this binary on another machine, than this"". It is better not to do it by default. Even worse if it propagates somewhere on Conda: typically it uses some modern Intel-based servers to build packages, and if one has AMD CPU, it will definitely segfault with an illegal instruction. I vaguely remember such problems with conda-forge packages, but not sure if it was QuTiP or some other package with the same problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/949#issuecomment-463255325:54,perform,performance,54,https://qutip.org,https://github.com/qutip/qutip/pull/949#issuecomment-463255325,1,['perform'],['performance']
Performance,"Well, the default implementation for states is actually nearly completely unchanged (the only difference is that I replaced `np.fliplr(array)` with `array[::-1]`, which I think is a more readable idiom for ""backwards""). You're right that in the new form, basically the method is that you cache various parts of the `np.polyval` call into a 3D tensor, rather than recomputing this large polynomial each time. The `np.polyval` call is how you actually go from an array of different values of `alpha` (which comes from the meshgrid) to the coherent state, but doing it with `polyval` means you construct the coherent state and do the dot product simultaneously to save memory. If you need to repeat the calculations a bunch, and you've got enough memory to spare, you can build up all the `alpha**n / sqrt(factorial(n))` tensor once, then just dot it against every state. Since we're dealing with _complex_ Hilbert spaces, the inner product isn't a straight dot product, it needs the conjugate of one of the sides, so we only store the conjugate of the alpha tensor. You can see in the timings that this isn't _always_ the biggest win you'd expect; in some cases, the additional memory usage causes you to be more heavily bound by memory bandwidth issues rather than CPU pipelined stuff, which is another reason we allow forcing either method to be used. If you're interested in the most readable implementation, you might want to look at the test:; https://github.com/qutip/qutip/blob/a20c26307e2f6e738f87efd75abafc3dff4daad5/qutip/tests/test_wigner.py#L251-L260",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212:288,cache,cache,288,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877254212,1,['cache'],['cache']
Performance,"Well, your opinion is definitely important, especially regarding core :) Performance is a top requirement there. Technically I think there is no need for square root at all because we can just compare the squared value to the squared tolerance. But I get your point that constant factor may dominate the performance of a small system. It's best to avoid Cython in ""good first issues"", so this one won't be on my list anyway.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401:73,Perform,Performance,73,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-794400401,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"Why not replace the current cy_expect_rho_vec instead of adding a new function cy_expect_rho_vec_fast? If we need both then a more descriptive name difference than _fast would be desirable. The key difference in the API is that one takes a sparse matrix and the other its data, idx and ptr components as arguments. I recall not seeing much performance difference between these two options so I opted for the sparse matrix as argument because it makes it more convenient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/56#issuecomment-25355844:340,perform,performance,340,https://qutip.org,https://github.com/qutip/qutip/pull/56#issuecomment-25355844,1,['perform'],['performance']
Performance,"Why though? It _is_ a badly written function and it should be changed. It's a true error, and I wouldn't be confident that there isn't an edge-case bug in it, because it's got so many branches I can't separate them easily in my head when reading it. There's loads of ways to write the same functionality where it's decomposed into smaller bits that are all much easier to check for correctness individually (`mul_dense`, `mul_scalar`, `mul_sparse`, etc) - way easier to verify the top-level dispatching logic into those bits, and then way easier to verify each individual component within them. Also, as long as we have the ""TODO"" error filter turned on, it would be wrong to silence the error that comes from adding a new one, right? If we wanted to skip it, we should turn it off globally (which I'm not against for the TODO thing). If it's in, this way at least lets us use codeclimate properly to see when certain errors were introduced, or when issues in funny-looking functions might have been affected. At any rate, the many-return function is completely removed in `dev.major` since we completely rewrote the backing types.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390:258,load,loads,258,https://qutip.org,https://github.com/qutip/qutip/pull/1506#issuecomment-826657390,1,['load'],['loads']
Performance,"Wow! Thanks for getting on this!. Let me elaborate a little. First,. > How useful would something like this be to you? Do you think you'd keep an implementation based on this long term? Or would you end up implementing your own thing in the end anyway?. It would be *extremely* useful. It would become the default propagator for the krotov package. I would expect that with the ability to propagate single time steps with `mesolve`, optimization becomes feasible for any system that `mesolve` can propagate over the entire time grid in less than a few seconds. That would be a huge improvement over the current situation, where the lack of a good propagator limits the optimization effectively to toy problems. We *may* still try to implement in Cython some polynomial propagators (propagators that evaluate `exp[-i H dt] Ψ` or `exp[L dt] ρ` via expansion into a polynomial series - think Taylor series but faster converging, through the use of Chebychev or Newton polynomials). That work hasn't really been going anywhere lately, though. It may or may not end up being faster than `mesolve`, but it's certainly less flexible. So even then, an mesolve that can do single steps would still be great. I would also think that being able to do time steps would be exceedingly useful to *any* gradient-based optimal control scheme. Wouldn't it greatly simplify your own GRAPE implementation? I'm referring to the ""Object model"" in [Optimal Quantum Control in QuTiP](https://qutip.org/docs/latest/guide/guide-control.html?highlight=grape#optimal-quantum-control-in-qutip), specifically the `TimeslotComputer` (in fact, we looked at whether `TimeslotComputer` could be used for krotov at the time, but couldn't quite figure it out). I elaborated a little bit in https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563 on the requirements: beyond yielding the propagated states, we'll also have to modify the controls, i.e. the time-dependencies for QuTiP's nested-list format. Within the `krotov",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:433,optimiz,optimization,433,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,4,['optimiz'],['optimization']
Performance,"Yeah I agree. Functionality should come first, performance is secondary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/154#issuecomment-45703206:47,perform,performance,47,https://qutip.org,https://github.com/qutip/qutip/pull/154#issuecomment-45703206,1,['perform'],['performance']
Performance,"Yeah, definitely there's no point running tests that aren't really testing the package properly. I would hope that if we're much more aggressive about converting time-dependent lists into QobjEvo objects inside `mesolve`, `mcsolve` and `sesolve` (or the class-based versions of them), we could significantly reduce the amount of testing that needs to be done with them. Most of the tests of time-dependent formats would then occur in the QobjEvo tests. We could still test all the configurations of the solvers without too heavy a time penalty. If we only use a small number of different time-dependent operators, we can compile them all only once, and have `pytest` manage the resources through shared fixtures. That would really cut down the run times, especially for the current ""slow"" tests. Another avenue for cutting down run time is if we could merge say the MKL and OpenMP tests into one Travis job - the setup time for one job is about 2.5 minutes, and that's before any tests have run at all. I would hazard a guess that having MKL but not OpenMP is a pretty rare case (maybe more common on high-performance clusters where people submit single-cpu jobs?).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182:1106,perform,performance,1106,https://qutip.org,https://github.com/qutip/qutip/issues/1217#issuecomment-604348182,1,['perform'],['performance']
Performance,"Yeah, it was not a fresh conda, but one that I did not previously install QuTiP in. However, that warning is essentially telling me that it is trying to build the Cython openmp stuff at init. It should not be doing this, but will do so if it is trying to load a Cython generated file that was not built yet.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670133651:255,load,load,255,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670133651,1,['load'],['load']
Performance,Yes I would agree that this is not something that we will add to qutip at least not directly. Of course if someone wants to add such features then more power to them. Like Rob I think that time is better spent optimizing qutip.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/48#issuecomment-27613005:210,optimiz,optimizing,210,https://qutip.org,https://github.com/qutip/qutip/pull/48#issuecomment-27613005,1,['optimiz'],['optimizing']
Performance,"Yes, I have not been able to install mcf90 under anaconda.; I think I remember seeing some discussion suggesting that the mcf90 has little or any performance improvement over the standard mcsolver. I have not tried myself. Being an anaconda user, this would take some effort for me.; I think that if it is not offering much greater performance, then we should just exclude it from the conda package.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/439#issuecomment-186524698:146,perform,performance,146,https://qutip.org,https://github.com/qutip/qutip/issues/439#issuecomment-186524698,2,['perform'],['performance']
Performance,"Yes, it is a code clean-up issue, not performance related (since the time spent on setting up multiprocessing is negligible compared to the compute time we don't have anything much to gain here). But factoring out multiprocessing from mcsolve is nonetheless something I think would be important, but obviously not necessary for this PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264#issuecomment-65052972:38,perform,performance,38,https://qutip.org,https://github.com/qutip/qutip/pull/264#issuecomment-65052972,1,['perform'],['performance']
Performance,"Yes, the Tavis tests fail due to the missing Normalize class from Matplotlib. This caused the failure in #248 and is why I resorted to the try statement on loading.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/249#issuecomment-61443740:156,load,loading,156,https://qutip.org,https://github.com/qutip/qutip/pull/249#issuecomment-61443740,1,['load'],['loading']
Performance,"You are probably installing with the Anaconda Python package. It points to a location that does not exist for the mkl blas libraries, which it doesnt ship with. . The fortran solver is somewhat dated, and the Python solver is now close in performance. You should probably use the latter one.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/491#issuecomment-224636252:239,perform,performance,239,https://qutip.org,https://github.com/qutip/qutip/issues/491#issuecomment-224636252,1,['perform'],['performance']
Performance,"You can see from the attached figure that it works pretty good, even at lower Hilbert space sizes. I would be hesitant to add both options because the bicgstab method fails not because of too few iterations, but because of some ""breakdown"" that can not be figured out. Since the current method works so well, and the only issues are the number of iterations, which is taken care of by using a preconditioner, it seems that the LMGRES method is the way to go. . On Wednesday, July 3, 2013 at 11:52 AM, Robert Johansson wrote:. > Nice, good job!! How does the performance look like for small problems? Does it make any sense to add an option to select bicgstab or lmgres, or does lmgres beat bicgstab in all cases you have looked at? Anyways, performance for systems is not that important, but we badly need better performing steadystate solvers for large systems so your benchmarks looks very promising :-); > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/29#issuecomment-20392672).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/29#issuecomment-20393941:558,perform,performance,558,https://qutip.org,https://github.com/qutip/qutip/issues/29#issuecomment-20393941,3,['perform'],"['performance', 'performing']"
Performance,You'll see I had to make a coupled of other small changes to ensure the bounds passed in pulseoptim methods are applied to the Optimizer as well as the PulseGen. Thanks again for reporting this.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/353#issuecomment-123288016:127,Optimiz,Optimizer,127,https://qutip.org,https://github.com/qutip/qutip/issues/353#issuecomment-123288016,1,['Optimiz'],['Optimizer']
Performance,[![Coverage Status](https://coveralls.io/builds/41895317/badge)](https://coveralls.io/builds/41895317). Coverage increased (+0.1%) to 65.914% when pulling **d6f993ef42c77803c6628914f381cc9933338623 on hodgestar:feature/remove-control-optimization-csr-support-and-fix-qobj-with-sparse-eigens** into **0eab37a0c49cb4cab31cd69c30ef14fb30089429 on qutip:master**.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1621#issuecomment-892573655:234,optimiz,optimization-csr-support-and-fix-qobj-with-sparse-eigens,234,https://qutip.org,https://github.com/qutip/qutip/pull/1621#issuecomment-892573655,1,['optimiz'],['optimization-csr-support-and-fix-qobj-with-sparse-eigens']
Performance,_init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/dump.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/optimconfig.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/symplectic.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/stats.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/termcond.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/optimizer.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/errors.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/propcomp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/grape.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/pulsegen.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/tslotcomp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/loadparams.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/dynamics.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; creating build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/memorycascade.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/transfertensor.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/heom.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; creating build/lib.macosx-10.9-x86_64-3.7/qutip/_mkl; copying qutip/_mkl/spmv.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/_mkl; copying qutip/_mkl/spsolve.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/_mkl; copying qutip/_mkl/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/_mkl; copying qutip/_mkl/utilities.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/_mkl; creating build/lib.macosx-10.9-x86_64-3.7/qutip/,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404:10121,load,loadparams,10121,https://qutip.org,https://github.com/qutip/qutip/issues/1404,1,['load'],['loadparams']
Performance,"_level); 190 setup_args=sargs,; 191 inplace=inplace,; --> 192 reload_support=pyxargs.reload_support); 193 assert os.path.exists(so_path), ""Cannot find: %s"" % so_path; 194 . F:\Anaconda3\lib\site-packages\pyximport\pyxbuild.py in pyx_to_dll(filename, ext, force_rebuild, build_in_temp, pyxbuild_dir, setup_args, reload_support, inplace); 100 try:; 101 obj_build_ext = dist.get_command_obj(""build_ext""); --> 102 dist.run_commands(); 103 so_path = obj_build_ext.get_outputs()[0]; 104 if obj_build_ext.inplace:. F:\Anaconda3\lib\distutils\dist.py in run_commands(self); 953 """"""; 954 for cmd in self.commands:; --> 955 self.run_command(cmd); 956 ; 957 # -- Methods that operate on its Commands --------------------------. F:\Anaconda3\lib\distutils\dist.py in run_command(self, command); 972 cmd_obj = self.get_command_obj(command); 973 cmd_obj.ensure_finalized(); --> 974 cmd_obj.run(); 975 self.have_run[command] = 1; 976 . F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in run(self); 183 optimization.disable_optimization(); 184 ; --> 185 _build_ext.build_ext.run(self); 186 ; 187 def build_extensions(self):. F:\Anaconda3\lib\distutils\command\build_ext.py in run(self); 337 ; 338 # Now actually compile and link everything.; --> 339 self.build_extensions(); 340 ; 341 def check_extensions_list(self, extensions):. F:\Anaconda3\lib\site-packages\Cython\Distutils\old_build_ext.py in build_extensions(self); 191 for ext in self.extensions:; 192 ext.sources = self.cython_sources(ext.sources, ext); --> 193 self.build_extension(ext); 194 ; 195 def cython_sources(self, sources, extension):. F:\Anaconda3\lib\distutils\command\build_ext.py in build_extension(self, ext); 531 debug=self.debug,; 532 extra_postargs=extra_args,; --> 533 depends=ext.depends); 534 ; 535 # XXX outdated variable, kept here in case third-part code. F:\Anaconda3\lib\distutils\_msvccompiler.py in compile(self, sources, output_dir, macros, include_dirs, debug, extra_preargs, extra_postargs, depends); 302 ; 30",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/854:7166,optimiz,optimization,7166,https://qutip.org,https://github.com/qutip/qutip/issues/854,1,['optimiz'],['optimization']
Performance,"_tlist.txt"",dtype=np.float64); ax0.plot(tlist, coef.real, label=f""{wavedata_name}""); ax1.plot(tlist, coef.imag, label=f""{wavedata_name}""); ax0.legend(); ax1.legend(); ; ax0.set_title(r""$\sigma_x$ coefficient""); ax1.set_title(r""$\sigma_y$ coefficient""); ```. <div align=""center"">; <img width=""314"" alt=""image"" src=""https://github.com/user-attachments/assets/b07b3a64-a2d4-458b-a04e-4c83c0c4c093"">; </div>; Despite these small differences, the simulation results show significant and unexpected variations. ; Below is simulation code and results. ```; import qutip; import numpy as np; import matplotlib.pyplot as plt. sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); psi0 = qutip.fock(2,0); psi1 = qutip.fock(2,1). def Hrot(coef,tlist): ; return qutip.QobjEvo([[sx,coef.real/2],[sy,coef.imag/2]],tlist=tlist). Omega0 = 10e6 * 2 * np.pi; for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt(f""{wavedata_name}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt(f""{wavedata_name}_tlist.txt"",dtype=np.float64); H = Hrot(coef=coef*Omega0,tlist=tlist); result = qutip.mesolve(H,psi0,tlist=tlist); print(f""{wavedata_name}"",np.abs(psi0.dag()@result.final_state)**2); ```. ```; index92 1.9513183436107076e-10; index93 0.49999366030208936; index94 1.0264492246902099e-13; ```. I would appreciate any insights into the potential causes of these errors and guidance on how to prevent such issues in future simulations. Additional Information:; scipy version: 1.13.0; python version: 3.12.2; qutip version: 5.0.1; numpy version: 1.26.4; Operating system: macOS 15.1. The files with the preselected coefficients and tlist are provided for reproducibility.; [index92_coef.txt](https://github.com/user-attachments/files/17613505/index92_coef.txt); [index92_tlist.txt](https://github.com/user-attachments/files/17613506/index92_tlist.txt); [index93_coef.txt](https://github.com/user-attachments/files/17613507/index93_coef.txt); [index93_tlist.txt](https://github.com/user-attachments",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552:2342,load,loadtxt,2342,https://qutip.org,https://github.com/qutip/qutip/issues/2552,1,['load'],['loadtxt']
Performance,"` vs `v5.0` with iterative scipy solvers, especially while using `use_rcm=True`. After spending some time, I believe the main key difference between both versions comes from permutation done in the `_permute_rcm`, where indices are permuted with the indices obtained from the `reverse_cuthill_mckee` function, and this prevents us from getting the preconditioner efficiently. In `v5.0`, for permuting, we use `_data.permute.indices` for the Liouvillian matrix `L`. This gives us different results from what we used in `v4.7`, i.e.,`sp_permute` with the same permuting indices. . As per my understanding, `_data.permute.indices` performs somewhat the following - ; ``` py; A = L.copy(); A.indices = perm.take(A.indices); A = A.tocsc(A); A.indices = perm.take(A.indices); ```; where, we previously, the following was being done; ``` py; L[perm[:,None], perm]; ```; with `perm` are obtained from `reverse_cuthill_mckee`. . I am not sure which behavior is the correct one, but the performance degradation is quite a lot (more than 10x) and prevents reaching sufficient enough tolerance. ### Code to Reproduce the Bug. ```shell; import numpy as np; from qutip import (about, destroy, qeye, steadystate, tensor). # Paramaeters; # -----------; Nc, Nm = 4, 30; E, kappa = 0.1, 0.3; gamma, delta = 3e-4, -0.43. # Operators; # ----------; a = tensor(destroy(Nc), qeye(Nm)); b = tensor(qeye(Nc), destroy(Nm)). # Hamiltonian; # ------------; H = -delta * (a.dag() * a) + (b.dag() * b) + 2.4 * kappa * (b.dag() + b) * (a.dag() * a) + E * (a.dag() + a). # Collapse operators; # -------------------; cc = np.sqrt(kappa) * a; cm = np.sqrt(2 * gamma) * b; cp = np.sqrt(gamma) * b.dag(); c_ops = [cc, cm, cp]. precond_options = {'permc_spec': 'NATURAL', 'diag_pivot_thresh': 0.1, 'fill_factor': 100, 'options': {'ILU_MILU': 'smilu_2'}}; solver_options = {""use_precond"": False, ""atol"": 1e-10, **precond_options}. rho_ss = steadystate(H, c_ops, method=""direct"", solver=""gmres"", use_rcm=True, **solver_options); ```. ### C",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2443:1121,perform,performance,1121,https://qutip.org,https://github.com/qutip/qutip/issues/2443,1,['perform'],['performance']
Performance,"`Qobj` also supports `tr()`. It would be nice for performance reasons to stay in QuTiP if possible. But if you do want to get the raw data, `Qobj.data` returns you a custom version of scipy's sparse matrix (at least for qutip 4.7). `qobj.data.trace()` already works for me. You need to use `scipy.sparse.csr_matrix(qobj.data)` to make it compatible with the default scipy csr matrix before using anything in `scipy.sparse.linalg` I think.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976:50,perform,performance,50,https://qutip.org,https://github.com/qutip/qutip/issues/2176#issuecomment-1594313976,1,['perform'],['performance']
Performance,"```python; from qutip import *; import numpy as np; from numpy import*; from math import*; from random import*; from scipy.optimize import*; from scipy import optimize; from scipy.optimize import minimize_scalar; import random ; ket0=basis(2,0); ket1=basis(2,1); ket00=tensor(ket0,ket0);ket01=tensor(ket0,ket1);ket10=tensor(ket1,ket0);ket11=tensor(ket1,ket1);; angle = np.linspace(0.0, 2 * np.pi, 100); def B1(x):; b1=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket0*ket0.dag()+(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); -(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket1*ket1.dag(); return b1. def B2(x):; b2=(cos(x[0]/2)**2+ x[3]**2*sin(x[0]/2)**2)*ket1*ket1.dag()-(1j*(x[1]-1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)-1j*x[3]*sin(x[0]/2)))*ket0*ket1.dag(); +(1j*(x[1]+1j*x[2])*sin(x[0]/2)*(cos(x[0]/2)+1j*x[3]*sin(x[0]/2)))*ket1*ket0.dag()+((x[1]**2+ x[2]**2)*sin(x[0]/2)**2)*ket0*ket0.dag(); return b2. rho=0.25*ket00*ket00.dag()+0.25*ket00*ket11.dag()+0.25*ket01*ket01.dag()+0.25*ket01*ket10.dag()+0.25*ket10*ket01.dag()+0.25*ket10*ket10.dag()+0.25*ket11*ket00.dag()+0.25*ket11*ket11.dag(). def P1(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); return p1. def P2(x):; p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); return p2. def S(x):; p1=1/(tensor(qeye(2),B1(x))).tr()*tensor(qeye(2),B1(x))*rho*tensor(qeye(2),B1(x)); p2=1/(tensor(qeye(2),B2(x))).tr()*tensor(qeye(2),B2(x))*rho*tensor(qeye(2),B2(x)); s=1/(tensor(qeye(2),B1(x))).tr()*entropy_vn(p1)+1/(tensor(qeye(2),B2(x))).tr()*entropy_vn(p2); return s; list3=[];list4=[];list5=[];. for i in range(100):; t=uniform(0,1); y=uniform(0,1); z=uniform(0,1); if t**2+y**2+z**2==1:; continue; list3.append(t); list4.append(y); list5.append(z); #print(t,y,z); for x in zip(angle,list3,list4,list5):; x0=[0,0,0,0]; res = minimize(S,x0, method='Nelder-Mead',options={'xtol': ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1111:123,optimiz,optimize,123,https://qutip.org,https://github.com/qutip/qutip/issues/1111,3,['optimiz'],['optimize']
Performance,"`general_stochastic` is very manual, halfway to scipy's ode solver. It can be used for both open and closed system and does not correspond to any particular physics equation. It the function that you use if you do weird stuff that does not fit already available template and I would discourage it's use. ; If other type of stochastic evolution are commonly used, it would be better to make a new specialized function than use `general_stochastic`. Old example should be adapted to `smesolve` as much as possible. The solver does not know if it is solving an close or open system (or something else). So e_ops are not touched. ; d1, d2 are working in array for performance issue. We could easily have them work in Qobj, but I would expect a significant slowdown. These function, taking no args, and being call many time at each step could benefit from being compiled with numba.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283:660,perform,performance,660,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546958283,1,['perform'],['performance']
Performance,"a mixture of several different types, and matrix multiplication wants to be able to contract scalar product spaces so that `bra * ket` gives a scalar. ## Problems with dimension handling. The current dimension handling in QuTiP is simple and intuitive until tensor-product structures are considered. At this point, it starts to become more complicated. In particular, the `type` of a `Qobj` is tied to its dimensions, but it becomes difficult to define this once there is tensor product structure. Some of this is because QuTiP allows us to construct objects which do not have a really rigourous mathematical backing to them, such as `I . |g>` - the tensor product of an operator and a ket. QuTiP assigns this a type `'oper'`, though the way it reaches this decision is more like:; 1. is it a ket? [no]; 2. is it a bra? [no]; 3. is it a super-operator? [no]; 4. if here, it must be an operator. Such objects do have a use. Let's say we have a system with two computational qubits and one ancillary qubit, we've performed a calculation on it and ended up in some state `|x> = |a>.|b>.|c>`, and we want to extract the computational subspace when the ancilla bit is projected onto `|0>`. We can do this in a mathematically rigourous way with; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).proj()); >>> (projector * x).ptrace([0, 1]); Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; ...; ```; which will always return a density matrix. Alternatively, we can instead define the operator (note `proj()` to create `|g><g|` has become `dag()` to simply make `<g|`) as; ```python; >>> projector = qutip.tensor(qutip.qeye([2, 2]), qutip.basis(2, 0).dag()); >>> projector * x; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; ...; ```; which gets us what we wanted. This is not necessarily _common_, but it is useful in some circumstances. ## Other problem discussions. There have been some cases of complaint about the han",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320:4556,perform,performed,4556,https://qutip.org,https://github.com/qutip/qutip/issues/1320,1,['perform'],['performed']
Performance,"a that coding in qutip should be as similar to writing in dirac notation as possible (within reason). As an example, here is how you can do a partial trace:. ```; In [14]: rho = rand_dm(4,dims=[[2,2],[2,2]]). In [15]: out = Qobj(). In [16]: for i in range(2):; out += tensor(qeye(2),basis(2,i).dag())*rho*tensor(qeye(2),basis(2,i)); ....:. In [17]: out; Out[17]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]. In [18]: rho.ptrace(0); Out[18]:; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0.39666875+0.j 0.13801792+0.01223399j]; [ 0.13801792-0.01223399j 0.60333125+0.j ]]; ```. Of course you can do far more general things than that.. you can pretty much do anything you can write in dirac notation. Similar behavior on the level of super-operators and operator-vectors, as suggested by @jrjohansson, earlier in this thread, would be similarly very powerful. For example, in the language of tensor networks, it would allow you to do arbitrary wire-bending operations using the maximally entangled state, as in the [paper](http://arxiv.org/abs/1111.6950) by Chris Wood et al., that @cgranade mentioned in relation to #238. As of now there is no convenient (i.e., ""index free"") way to do this (correct me if I am wrong), except explicitly performing the corresponding partial transpose directly on the underlying matrix data. 2) In the absence of this functionality it is a bad idea to assume something else. Assuming conjugation is unexpected behavior, and besides it is something the user can easily do him/herself by using `to_super()`. It is way better to ""force"" the user to be explicit about things by throwing an `Exception`, than assuming something that might be unexpected. It enforces good coding style, giving more readable code, and avoids code that will break if the functionality is changed in the future.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58035991:1978,perform,performing,1978,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58035991,1,['perform'],['performing']
Performance,additional arguments added to load_parameters so that a general object attributes can be loaded from a configuration file. For a example a custom fidelity computer,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/403:89,load,loaded,89,https://qutip.org,https://github.com/qutip/qutip/pull/403,1,['load'],['loaded']
Performance,"alse; INTEL MKL Ext: True; Platform Info: Windows (AMD64); Installation path: C:\ProgramData\Anaconda3\lib\site-packages\qutip. DEBUG:qutip.logging_utils:Creating logger for qutip.control.grape with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimconfig with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dynamics with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.dump with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.tslotcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.fidcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.propcomp with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.optimizer with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulsegen with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.loadparams with policy basic.; DEBUG:qutip.logging_utils:Creating logger for qutip.control.pulseoptim with policy basic.; Transform 2-level to eigenbasis and back ... ok; Transform 10-level real-values to eigenbasis and back ... ok; Transform 10-level to eigenbasis and back ... ok; Transform 10-level imag to eigenbasis and back ... ok; Consistency between transformations of kets and density matrices ... ok; Check diagonalization via eigenbasis transformation ... ok; Check Qobj eigs and direct eig solver transformations match ... ok; Check Qobj eigs and direct eig solver reverse transformations match ... ok; brmesolve: simple qubit ... ok; brmesolve: c_ops alone ... ok; brmesolve: c_ops with a_ops ... ok; brmesolve: harmonic oscillator, zero temperature ... ok; brmesolve: harmonic oscillator, finite temperature ... ok; brmesolve: harmonic oscillator, finite temperature, states ... ok; brmesolve: Jaynes-Cummings model, zero temperature ... ok; brmesolve: Check for #572 bug. ... ok; td_brmesolve: passes",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:1637,load,loadparams,1637,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,2,['load'],['loadparams']
Performance,"amd64-2.7\Release\pyrex\rhs14883.c: In function '__pyx_pw_8rhs14883_1cy_td_ode_rhs':; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t_off' may be used uninitialized in this function [-Wmaybe-uninitialized]; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_tp' may be used uninitialized in this function [-Wmaybe-uninitialized]; > C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t' may be used uninitialized in this function [-Wmaybe-uninitialized]; > ok; > correlation: comparing TLS emission correlations (fn-list td format) ... ok; > correlation: comparing TLS emission correlations (fn td format) ... ok; > Counting statistics: current and current noise in a DQD model ... ok; > Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; > Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; > Diagonalization of random two-level system ... ok; > Diagonalization of composite systems ... ok; > Excitation-number-restricted state-space: full state space ... ok; > Excitation-number-restricted state space: single excitations ... ok; > Excitation-number-restricted state space: two excitations ... ok; > Excitation-number-restricted state space: fock states ... ok; > Excitation-number-restricted state space: identity operator ... ok; > Excitation-number-restricted state space: thermal density operator (I) ... ok; > Excitation-number-restricted state space: thermal density operator (II) ... ok; > Entropy: von-Neumann entropy ... ok; > Entropy: Linear entropy ... ok; > Entropy: Concurrence ... ok; > Entropy: Mutual information ... C:\Anaconda3\envs\qutip_py2\lib\site-packages\qutip\ptrace.py:111: RuntimeWarning: invalid name encountered in remainder np.fix(counter / np.prod(dims[sel[k + 1:]])), dims[sel[k]]) + 1; > ; > —; > Reply to this email directly or view it on GitHub.; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148786885:27527,Concurren,Concurrence,27527,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148786885,1,['Concurren'],['Concurrence']
Performance,"ame time different versions of the interface, however, and there’s value in doing so. > To me, this is absolutely one of the mistakes that Numpy made in their implementation, and we shouldn't be copying it. I don't know enough of the history behind numpy current api, but I see your point. however I'd like to reiterate that this is not what I am proposing. ; I think there is considerable difference between supporting arbitrary operations `new_obj = Qobj + netket_operator*5` (though if you are going to export dispatch hooks in `5.0`, this would be possible in a consistent way, I think) and `qutip.mesolve(netket_operator, ...)`. ; In the first, I do agree with your point that the nature python's `__add__/__radd__` is not commutative, leading to surprising behavior. From my point of view, no package really owns `+` so any conversion would be implicit.; But `qutip.groundstate(netket_operator)` is in itself an explicit cast. I am explicitly asking to qutip `please give me the ground state of this object`. I do expect to get a Qobj out, and qutip to make an effort converting this object to whatever format he internally wants to work with. Same goes with time evolution. . > For greater discussion, here's an alternate approach: instead of objects defining __qutip_qobj__, instead we expose an entry-point qutip.Qobj.register_conversion_function(converter, type, priority, version=None), and downstream libraries register functions rather than defining methods on their classes. I do prefer such an approach. I just did not think that was an option in QuTiP.; In fact we have redesigned NetKet to allow for something similar using multiple dispatch. (I’m not familiar with Tensorflow either.). I do agree with all your points, especially the first. As for your last point, about downstream packages having to import qutip: This is indeed a potential issue. I’ll try to investigate this: maybe there is a solution whereby a callback executed on package load can be registered with importlib?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742:4188,load,load,4188,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830113742,2,['load'],['load']
Performance,"approx_grad attribute added to the Optimizer object that forces the; optimisation method to use the gradient approximation; (rather than any exact method). The motivation for this is to allow adding of custom fidelities that do not have an exact gradient formula.; As an aside: The CRAB algorithm already used these approximate gradient methods, and is most likely to be faster with these custom fidelities",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/342:35,Optimiz,Optimizer,35,https://qutip.org,https://github.com/qutip/qutip/pull/342,1,['Optimiz'],['Optimizer']
Performance,"are only provided for Python; 3.8 and 3.9 on Windows, all other wheels are 64 bits on account of; Ubuntu, Fedora, and other Linux distributions dropping 32 bit support.; All 64 bit wheels are also linked with 64 bit integer OpenBLAS, which should fix; the occasional problems encountered by folks using truly huge arrays.</p>; <h2>Expired deprecations</h2>; <h3>Deprecated numeric style dtype strings have been removed</h3>; <p>Using the strings <code>&quot;Bytes0&quot;</code>, <code>&quot;Datetime64&quot;</code>, <code>&quot;Str0&quot;</code>, <code>&quot;Uint32&quot;</code>,; and <code>&quot;Uint64&quot;</code> as a dtype will now raise a <code>TypeError</code>.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19539"">gh-19539</a>)</p>; <h3>Expired deprecations for <code>loads</code>, <code>ndfromtxt</code>, and <code>mafromtxt</code> in npyio</h3>; <p><code>numpy.loads</code> was deprecated in v1.15, with the recommendation that; users use <code>pickle.loads</code> instead. <code>ndfromtxt</code> and <code>mafromtxt</code> were both; deprecated in v1.17 - users should use <code>numpy.genfromtxt</code> instead with; the appropriate value for the <code>usemask</code> parameter.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19615"">gh-19615</a>)</p>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/numpy/numpy/commit/4adc87dff15a247e417d50f10cc4def8e1c17a03""><code>4adc87d</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/20685"">#20685</a> from charris/prepare-for-1.22.0-release</li>; <li><a href=""https://github.com/numpy/numpy/commit/fd66547557f57c430d41be2fc0764f74a62e8ccf""><code>fd66547</code></a> REL: Prepare for the NumPy 1.22.0 release.</li>; <li><a href=""https://github.com/numpy/numpy/commit/125304b035effcd82e366e601b102e7347eaa9ba""><code>125304b</code></a> wip</li",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:2526,load,loads,2526,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['load'],['loads']
Performance,"ata.todense(); Ldense[0, :] = +np.diag(weight*np.ones(n)).reshape((1, n ** 2)); rho1 = np.linalg.solve(Ldense, b). Weight 1.0000000000000001e-16. # Proposed modified version; weight = np.mean(np.abs(L.data).max(0)).real # added .real to get a float ; print('Weight',weight); b[0] = weight; Ldense = L.data.todense(); Ldense[0, :] = +np.diag(weight*np.ones(n)).reshape((1, n ** 2)); rho2 = np.linalg.solve(Ldense, b). Weight 1.0; ```. The current version leads to a very small weight because the imaginary part is discarded. Also, the mean is not doing anything. The proposed modification computes the modulus before evaluating the maximum for each line and then takes the mean. This may change the final steady state in some circumstances, but I could not rapidly find a situation where this is actually important. In this example, the two steady states are the same even though the weights are very different.; ```; np.linalg.norm(rho1-rho2); >> 1.1102230246251565e-16; ```. 2 ) Construction of the matrix to obtain the steady state; As mentioned by @fminga, this should not change anything in most situations. But the proposed modification will make the matrix identical to the one computed by the algorithm when the sparse option is chosen. Here is an example, where the proposed modification performs slightly better than the current version. ; ```; H = identity(2); c_op_list = [sigmam(), 1e-8*sigmap()]; L = liouvillian(H, c_op_list); weight = 1.0; n = 2; b = np.zeros(n ** 2); b[0] = weight; ```. The current version gives:; ```; Ldense = L.data.todense(); Ldense[0, :] = np.diag(weight*np.ones(n)).reshape((1, n ** 2)); np.linalg.solve(Ldense, b); >> array([0.+0.j, 0.-0.j, 0.-0.j, 1.+0.j]); ```. The proposed modification gives:; ```; Ldense = L.data.todense(); Ldense[0, :] += np.diag(weight*np.ones(n)).reshape((1, n ** 2)); np.linalg.solve(Ldense, b); >> array([1.e-16+0.j, 0.e+00-0.j, 0.e+00-0.j, 1.e+00+0.j]); ```; This is a better result than the one obtained with the current version.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1275#issuecomment-987894724:2104,perform,performs,2104,https://qutip.org,https://github.com/qutip/qutip/pull/1275#issuecomment-987894724,1,['perform'],['performs']
Performance,"ator to annihilation/creation operator formalism.; However, when comparing with the Lindblad-Master equation based simulation, the outcome is quantitatively quite different. ![Figure 2023-02-18 142921](https://user-images.githubusercontent.com/47425237/219868478-8210e6d6-155a-4587-9afd-0b0ec505fc09.png). It seems that the function ""floquet_master_equation_rates"" might be an issue, but I do not know how to fix this problem. Any help is appreciated!; Thank you very much!!. QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.7.0; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.32; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 12; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64). ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; from IPython.display import Image; import math. from scipy.optimize import least_squares; from scipy.optimize import curve_fit. from Ham_tools import Ham_tools; ###--------------------physical constants-----------------------; hbar = 1.055*10**(-28) ##(*[J µs]*); ###-------------------waste mode--------------------------; ww = 2* np.pi* 7.609* 10**3 #(*[MHz] waste mode cavity frequency*); gdw = 2* np.pi* 16.6 #12 #(*[MHz]external decay rate of waste mode*). ###definitions; def J_cb(omega):; """""" Noise spectral density """"""; #print ""evaluate J_cb for omega ="", omega; return 0.5 * gdw /(2*np.pi) # 2*gdw/(np.pi**2). def cos_drv(t, args):; return np.cos(wd*t); ###=========================================================================================================; ###Set the dimensions of the Hilbert space of each participating quantum system; ###=========================================================================================================; ### resonator; d1 = 3; ### create ""annihilation operator; aw = destroy(d1). #%%=======================================================================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2097:1660,optimiz,optimize,1660,https://qutip.org,https://github.com/qutip/qutip/issues/2097,1,['optimiz'],['optimize']
Performance,"ax_step = 1; qset.save(); print(Options().atol); >>> 1e-10; ```; `atol = 1e-10` and `max_step = 1` will be kept as default in future sessions. `qset.options.reset` to go back to qutip's default. I believe that loading custom settings when importing qutip will be appreciated with support of both `dense` and `sparse` most researchers will have a preference depending on their domain. This also brings all settings in one place: `qutip.settings...` even if we split the code in ""core"", ""solver"", ""qip?"", etc. Lastly, creating and moving around an `Options` object is no longer needed, changing the default before using the solver has the same effect. . For developers:; Principally @jakelishman as I expect you to add settings for core. ; I went with an implementation similar to python `dataclass`. To add `core`'s settings to `qutip.settings` you would do ""; ```; from qutip.settings import QtOptionClass. @QtOptionClass(""core""); class CoreOptions:; basetype = ""Dense""; auto_tidyup = True; ...; ```; And it would create the `__init__`, `__repr__`, `save`, `load` and `reset` methods, and create the default instance as `qutip.settings.core`. All attributes that do not start with ""_"" and are one of `bool`, `str`, `int`, `float`, `complex` will be in tagged to be saved and loaded. Those are the only types available now, but other can be added if needed. In `__init__` all these + properties with a setter can be initiated as keyword arguments. '__repr__' 'print' all the saved attributes and properties.; This is for the likes of `has_openmp`, I would make it a read only property. Another way of doing this would have been to use a parent class and a ""register"" functions. I went with this one because the signature of `__init__` in help was cleaner. I have both implemented so if qip of control want to use the base without registering to `qutip.settings`, I can change the PR. (@ajgpitch, @BoxiLi ). Build on top of #1289. . **Changelog**; Solver options can be set in `qutip.settings.options`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1297:1470,load,load,1470,https://qutip.org,https://github.com/qutip/qutip/pull/1297,2,['load'],"['load', 'loaded']"
Performance,"base class]( https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.spmatrix.html#scipy.sparse.spmatrix)? Then the `Qobj` constructor would probably need an additional parameter `format` for the class that should be used to convert the `inpt` argument to the `data` attribute. The onus would then be on Scipy to provide a full matrix that is a subtype of `scipy.spmatrix` (just to keep the interface contract), and also to have `int64` versions of all their existing sparse classes. From a community standpoint, it would seem like one would get much more bang for the buck to have this problem solved inside SciPy, instead of doing a lot of low-level stuff in QuTiP -- at least if they're amenable to pull requests, but worst case you can still define necessary new `scipy.spmatrix` subclasses externally. Take all of my musings with a little grain of salt... I never really looked too deep into QuTiP's low-level internals, specifically where QuTiP is using Cython. Naively, I would sort of think that Cython would remain at the level of sparse linear algebra operations (and thus mostly in scipy) and that QuTiP could be mainly pure Python. Obviously, once you start implementing higher level things like time propagation or even optimal control in Cython, everything becomes a bit of a mess, because then you really do have to manually implement everything for every possible storage format (again, something I'm familiar with from Fortran, and it's *a lot* of work). Generally, though, I've personally come to the conclusion that the lowest-level thing to really optimize for quantum dynamics simulations (in any language) is the application of a (time-dependent) operator to a Hilbert space state, respectively the commutator with a density matrix (in QuTiP, the operators would be the nested ``[H0, (u(t), H1), ...]`` lists). Everything higher level is probably fine at Python speed, as long as the algorithms are sound and you avoid allocating temporary storage as much as possible.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/850#issuecomment-383937610:2602,optimiz,optimize,2602,https://qutip.org,https://github.com/qutip/qutip/issues/850#issuecomment-383937610,1,['optimiz'],['optimize']
Performance,"be a ""low-level"" function to prepare a master equation problem (and a Schrodinger equation one, etc), and then there'll be a `step` method instead of calling the ""high-level"" interface function `mesolve`, but functionally it'll do largely the same, just with a lot less data copying than the current form has to do. In the new system, it's likely that the function `mesolve` itself will keep the exact same interface it has now, just internally most of its processing will be split into modular components, each of which will be accessible (with different names) to the user to compose themselves, if they want low-level access. That sounds perfect! I might wait for QuTiP 5 to come out, or if these things are already in `master`, I'll see if I can maybe revisit `DensityMatrixODEPropagator` and maybe also add something for the Hilbert space case (whatever `sesolve` is doing internally). As an aside, I was actually surprised how much better `DensityMatrixODEPropagator` performs compared to looping over `mesolve` (`In [29]` vs `In [21]`): Since the `DensityMatrixODEPropagator` also re-initializes `scipy.integrate.ode` in every time steps, it would seem like the only difference between the two is the overhead of `mesolve` deciding that it has to handle the specific case of density matrix propagation. That might be something to keep an eye on in future QuTiP development: Ideally, calling `mesolve` would have negligible overhead compared to manually doing whatever `mesolve` does internally for a particular case. > We're unlikely to add `yield` to `mesolve` directly because that's a very breaking change to one of QuTiP's core functions (we can't return from a generator, or at least not ergonomically), but we are splitting up the `mesolve` monolith into a much more modular architecture, and making it more user-accessible. The other advantage of this is that the integrator component will just be one element of a composable system, so we'll not be tied to scipy integrators any more. ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:8997,perform,performs,8997,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['perform'],['performs']
Performance,"but that's another story). ### Code to Reproduce the Bug. ```shell; conda create -n qutip_test; pip install qutip; ```. ### Code Output. ```shell; Collecting qutip; Using cached qutip-4.6.2.tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:1476,cache,cached,1476,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"c 'import sys, setuptools, tokenize; sys.argv[0] = '""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""'; __file__='""'""'/tmp/pip-install-69anjthq/qutip/setup.py'""'""';f=getattr(tokenize, '""'""'open'""'""', open)(__file__);code=f.read().replace('""'""'\r\n'""'""', '""'""'\n'""'""');f.close();exec(compile(code, __file__, '""'""'exec'""'""'))' egg_info --egg-base /tmp/pip-install-69anjthq/qutip/pip-egg-info; cwd: /tmp/pip-install-69anjthq/qutip/; Complete output (5 lines):; Traceback (most recent call last):; File ""<string>"", line 1, in <module>; File ""/tmp/pip-install-69anjthq/qutip/setup.py"", line 52, in <module>; from Cython.Build import cythonize; ModuleNotFoundError: No module named 'Cython'; ----------------------------------------; ERROR: Command errored out with exit status 1: python setup.py egg_info Check the logs for full command output. ** Installing cython fixes it **. jevon@bb8:~$ pip3 install cython; Collecting cython; Downloading Cython-0.29.17-cp38-cp38-manylinux1_x86_64.whl (2.0 MB); |████████████████████████████████| 2.0 MB 721 kB/s ; Installing collected packages: cython; Successfully installed cython-0.29.17; jevon@bb8:~$ pip3 install qutip; Collecting qutip; Using cached qutip-4.5.0.tar.gz (3.5 MB); Requirement already satisfied: cython>=0.21 in ./.local/lib/python3.8/site-packages (from qutip) (0.29.17); Requirement already satisfied: numpy>=1.12 in ./.local/lib/python3.8/site-packages (from qutip) (1.18.3); Requirement already satisfied: scipy>=1.0 in ./.local/lib/python3.8/site-packages (from qutip) (1.4.1); Building wheels for collected packages: qutip; Building wheel for qutip (setup.py) ... done; Created wheel for qutip: filename=qutip-4.5.0-cp38-cp38-linux_x86_64.whl size=17905114 sha256=3f461cbc07b40c0de96b709ea20bca495c7ffe1b6060a533a1ab733107c161ab; Stored in directory: /home/jevon/.cache/pip/wheels/3a/4d/bf/1c8e9f7874f26a6510d78790d3ba518c98e674e5771110fe1e; Successfully built qutip; Installing collected packages: qutip; Successfully installed qutip-4.5.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1246:1655,cache,cached,1655,https://qutip.org,https://github.com/qutip/qutip/issues/1246,2,['cache'],"['cache', 'cached']"
Performance,"chi * (a.dag() * a * P_se) + chi * (b.dag() * b * P_ze) + chi * (c.dag() * c * P_te) + chi * (d.dag() * d * P_qe). row = np.array([1,1,2,2,3,3,3,3,4,4,4,4,5,5,6,6]); column = np.array([3,4,3,4,1,2,5,6,1,2,5,6,3,4,3,4]); data = np.array([-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1]). mapped=csr_matrix((data,(row,column)),shape=(N**4*2*2*2*2,N**4*2*2*2*2)); mapped=Qobj(mapped). n_ctrls=4 # Controls; ctrls = [sm.dag()*a+sm*a.dag()+sm.dag()*b+sm*b.dag()+zm.dag()*b+zm*b.dag()+zm.dag()*c+zm*c.dag()+tm.dag()*c+tm*c.dag()+tm.dag()*d+tm*d.dag()+qm.dag()*d+qm*d.dag()+qm.dag()*a+qm*a.dag(),1j*(sm.dag()*a-sm*a.dag())+1j*(sm.dag()*b-sm*b.dag())+1j*(zm.dag()*b-zm*b.dag())+1j*(zm.dag()*c-zm*c.dag())+1j*(tm.dag()*c-tm*c.dag())+1j*(tm.dag()*d-tm*d.dag())+1j*(qm.dag()*d-qm*d.dag())+1j*(qm.dag()*a-qm*a.dag()),sm+sm.dag()+zm+zm.dag()+tm+tm.dag()+qm+qm.dag(), 1j*(sm-sm.dag())+1j*(zm-zm.dag())+1j*(tm-tm.dag())+1j*(qm-qm.dag())]. # Set optimization parameters; U_0=tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)) # Initial gate; U_targ=mapped # Target gates. # Run the optimization. result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)). ```; For N=>3, instead of getting a printout of the optimized controls, I receive the following terminal output error:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 59, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:3199,optimiz,optimization,3199,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimization']
Performance,"cipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3917,cache,cached,3917,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"cipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2857,cache,cached,2857,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,concurrence measure does not work for density matrices,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2058:0,concurren,concurrence,0,https://qutip.org,https://github.com/qutip/qutip/issues/2058,1,['concurren'],['concurrence']
Performance,"ction calls between Python and C space, which largely affected small objects. The full aim, however, is to have QuTiP 5 support many different data representations as the backing of `Qobj`, and use the most suitable representation for the given data. This will not require every single QuTiP function to have an exponential number of versions for every possible combination of inputs, but only to have specialisations for the most common data combinations. This concept is the ""data layer"". All code examples in this PR are prefixed with. ```python; >>> from qutip.core import data; ```. ## Specification. The core to achieving this is fast, fully specified inter-conversion between all known data types, and efficient multiple-dispatch for mathematical operations. There are then four principle components of the data-layer:. 1. a creation routine which returns an appropriate data-layer type given some arbitrary Python object (`data.create`); 2. a routine which can perform the conversion from any data-layer type to any other data-layer type (`data.to`); 3. completely specialised mathematical operations (e.g. `data.add_csr_dense_dense(CSR, Dense) -> Dense`); 4. an object which provides multiple dispatch operations on its input arguments to use an exact specialisation (defined in item 3) if known, or uses the conversion routine (item 2) to convert the inputs into ones matching a specialisation if not: `data.Dispatcher`. The exported mathematical functions will all be instances of this type. The minimum work needed to define a new data-layer type is to provide `data.to` with two conversion functions; one into the new type from a current data-layer type, and one which converts the new type _into_ a current data-layer type. Once this is done, every single QuTiP component will be able to use the new data-layer type, although until specialisations are given which use it, it will always be achieved by conversion to another type, and conversion back. In this way, a new type can be added",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1338:1436,perform,perform,1436,https://qutip.org,https://github.com/qutip/qutip/pull/1338,1,['perform'],['perform']
Performance,"cuitProcessor::testSpline PASSED [ 54%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testGetObjevo PASSED [ 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5019,cache,cache,5019,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,"d build. If I edit `pyproject.toml` and `setup.cfg` to remove the `<1.20` in Numpy, then qutip builds correctly (then I get same problem as Issue #1606 when importing, but that's another story). ### Code to Reproduce the Bug. ```shell; conda create -n qutip_test; pip install qutip; ```. ### Code Output. ```shell; Collecting qutip; Using cached qutip-4.6.2.tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Build",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:1324,cache,cached,1324,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"d scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/mul.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4317,cache,cached,4317,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"d scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; pandas 2.0.3 requires numpy>=1.20.3; python_version < ""3.10"", but you have numpy 1.17.3 which is incompatible.; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-70.0.0 wheel-0.43.0; Installing build dependencies ... done",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:3257,cache,cached,3257,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"d support for reading DX10 BC4 DDS images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7603"">#7603</a> [<a href=""https://github.com/sambvfx""><code>@​sambvfx</code></a>]</li>; <li>Optimized ImageStat.Stat.count <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7599"">#7599</a> [<a href=""https://github.com/florath""><code>@​florath</code></a>]</li>; <li>Moved error from truetype() to FreeTypeFont <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7587"">#7587</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Correct PDF palette size when saving <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7555"">#7555</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed closing file pointer with olefile 0.47 <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7594"">#7594</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>ruff: Minor optimizations of list comprehensions, x in set, etc. <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7524"">#7524</a> [<a href=""https://github.com/cclauss""><code>@​cclauss</code></a>]</li>; <li>Build Windows wheels using cibuildwheel <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7580"">#7580</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Raise ValueError when TrueType font size is zero or less <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7584"">#7584</a> [<a href=""https://github.com/akx""><code>@​akx</code></a>]</li>; <li>Install cibuildwheel from requirements file <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7581"">#7581</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:8813,optimiz,optimizations,8813,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['optimiz'],['optimizations']
Performance,"dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. ### Code Output. _No response_. ### Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x8",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2402,cache,cached,2402,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"e complex128. Here, `m_ops` is a list with `len(m_ops) = 27` and every `m_ops[i]` is a quantum object of shape. In [91]: m_ops[1].shape; Out[91]: (1048576, 1048576). Ok, I can see that I am trying to convert a QuTiP object into a numpy array but this object is so big that I have a memory issue. My question is simple: is there any way to overcome this issue? can I 'cut' the object in smaller pieces to convert it and then put the ""pieces back together""?. I really have no idea. Maybe I am not doing in the optimal way but I was working with really smaller matrix until this one and I didn't foresaw this problem. Any help or reference will be highly appreciated. This is really important for me. ----------------------------------------------------------------. EDIT with the full code:. """""".""""""; import numpy as np; import tensorflow as tf; from qutip import tensor; from qutip import sigmax, sigmaz, sigmay; from qutip import coherent, coherent_dm, expect, Qobj, fidelity, hinton; from tqdm.auto import tqdm. #%load_ext autoreload; tf.keras.backend.set_floatx('float64') # Set float64 as the default. # Local paths:; local_path = ""0_qst_master/cgan_tf_20qb/%s""; data_path = ""0_qst_master/cgan_tf_20qb/data/%s"". # Reading projectors; projs_settings = np.loadtxt(data_path % 'measurement_settings.txt', dtype=str). X = sigmax(); Y = sigmay(); Z = sigmaz(). m_ops = [] # measurement operators. def string_to_operator(basis): ; mat_real = []; ; for j in range(len(basis)):; if basis[j] == 'X':; mat_real.append(X) ; if basis[j] =='Y':; mat_real.append(Y) ; if basis[j] =='-Y':; mat_real.append(-Y) ; if basis[j] == 'Z':; mat_real.append(Z) ; return mat_real. for i in range(27):; U = string_to_operator(projs_settings[i]); U = tensor(U); m_ops.append(U). ops_numpy = [op.full() for op in m_ops] # convert the QuTiP Qobj to numpy arrays. Another EDIT:. The `measurement_settings.txt` is a .txt file with the following:. [![enter image description here][1]][1]. [1]: https://i.stack.imgur.com/YtF6j.png",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2176:1606,load,loadtxt,1606,https://qutip.org,https://github.com/qutip/qutip/issues/2176,1,['load'],['loadtxt']
Performance,"e systems or long time arrays. The goal was to enhance performance by parallelizing these computations. ### Enhancements Overview. 1. **Parallel Computing**:; - **Implementation**: Utilized Python’s `concurrent.futures` module, specifically `ProcessPoolExecutor`, to parallelize the computation of correlation values over different tau values (`taulist`). Each tau value computation is independent of others, making this a suitable case for parallel execution.; - **Function Splitting**: Created a helper function `compute_single_tau_correlation` to handle the computation for a single tau. This function manages the setup of the quantum system, computes the correlation for its specific tau, and handles any exceptions that may occur, logging them accordingly.; - **Resource Management**: Used the `cpu_count` from the `os` module to dynamically determine the number of available processors and limited the number of worker processes to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel ex",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:1256,load,load,1256,https://qutip.org,https://github.com/qutip/qutip/pull/2395,2,"['load', 'perform']","['load', 'performance']"
Performance,"e whether to target QuTiP 4.7 or 4.7 and 5 for this. Target just v5 means not having to worry about making it nice in both, but will mean it'll be a bit more of a delay before release).; > . I'll admit I've not kept up as much with the 5.0 changes as I should have, but I'm happy either way; I can definitely see the benefit to targeting 5.0 and keeping code maintenance down, or to getting the feature out for folks to use sooner at the cost of more development work. > * I'd like to think about removing `Seq` and `Par` and replacing them with some simple rules for sequences, strings and numbers. Honestly, agreed; I tried a few different designs to try and get rid of those two classes, but they all felt a bit awkward and special-cased. Happy to revise, though, to lower the barrier to using the new feature. > This would match, e.g., `qutip.ket(""01"")` and `qutip.basis([2, 2], [0, 1])`. `Seq` and `Par` do however make it really clear that in one case measurements follow each other on the same subspaces and in the other they are performed simultaneously on different subspaces, so I'm not quite sure. Maybe there is some middle ground. My initial thought was to do something like use tuples instead of `Seq` and lists instead of `Par`, but that then ran into a couple issues. Namely, it wasn't as obvious what each kind of container meant, and it was harder to automatically flatten (e.g.: `Seq(1, Seq(2, 3), 4)` is identical to `Seq(1, 2, 3, 4)` and `Seq(1, Par(2), 3)` is identical to `Seq(1, 2, 3)` but distinct from `Seq(1, Par(2, 3))`). One alternative may be to have a single subclass `Outcome` of `tuple` instead of both, then overload operators like `|` to mean parallel. Internally, could use two subclasses like `Seq` and `Par` but display visually as `Outcome(1, 2 | 3, 4)` instead of `Outcome(1, Par(2, 3), 4)`. > * In QuTiP it's more normal to have the helper constructors not on the class as classmethods. I do like secondary constructors as classmethods, but I think in cases l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562:1612,perform,performed,1612,https://qutip.org,https://github.com/qutip/qutip/pull/1687#issuecomment-951352562,2,['perform'],['performed']
Performance,"e/releasenotes/10.2.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/10.2.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>Add <code>keep_rgb</code> option when saving JPEG to prevent conversion of RGB colorspace <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7553"">#7553</a> [<a href=""https://github.com/bgilbert""><code>@​bgilbert</code></a>]</li>; <li>Trim negative glyph offsets in ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7672"">#7672</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Removed unnecessary &quot;pragma: no cover&quot; <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7668"">#7668</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Trim glyph size in ImageFont.getmask() <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7669"">#7669</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix loading IPTC images and update test <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7667"">#7667</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Allow uncompressed TIFF images to be saved in chunks <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7650"">#7650</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Concatenate multiple JPEG EXIF markers <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7496"">#7496</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Changed IPTC tile tuple to match other plugins <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7661"">#7661</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Do not assign new fp attribute when exiting context manager <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7566"">#7566</a> [<a href=""https://github.com/radarhere""><code>@​",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:1317,load,loading,1317,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['load'],['loading']
Performance,"e_final_state</code> are True there is a small bug --> **Fixed the store twice problem**. * [x] Infinite loop at stagnant =0 --> **Added a raise ValueError if its <0.**. * [x] __all__ should be defined to filter functions seen by the user --> **set to =<code>krylovsolve</code> and <code>lanczos_algorithm</code>**. * [x] Why not call <code>_make_partitions</code> directly instead of having this method --> **Removed when deprecating <code>KSolve</code> class**. * [x] tlist is already stored, are those needed? (lines 152-155) --> **Removed when deprecating <code>KSolve</code> class**; * [x] The Result has a tag to the solver that created it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] T",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:2137,optimiz,optimizer,2137,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,4,['optimiz'],"['optimize', 'optimizer']"
Performance,"ector (using `gate_expand_1toN`), and the added code (dense local). N being the number of qubits. Here I made things as hard as possible for the sparse routine (all elements non-zero), so this is probably the limit of the speed-up. ![1_local_vector_adaptive_backend](https://user-images.githubusercontent.com/47875526/101932409-91f44900-3b8f-11eb-8b5b-7a00dabec2e4.png). **Other notes**; 1. I am a contractor for NASA, and they required a slight change to the license for the code I added. This is why I made two new files for this work specifically (instead of putting it in e.g. gates.py), which now includes a Copyright NASA sentence. I will talk privately with someone about this. 2. ~~I actually think that we could make a wrapper function `local_multiply` which can additionally take a backend 'sparse', so that it is easier to compare the above code, to one using the default sparse way (e.g. using the `expand_operator` type functions). I didn't do this yet as thought i'd see what thoughts are on this -- I can easily add this.~~ **Update (20/12/20)**: I just added some basic functionality for this. Will need to add more tests and maybe re-work it a bit still. 3. Currently the input local operator is expected to be square, and we do not take output dimension arguments. This means it keeps the system dimensions the same. This can be relaxed easily, but we probably need an additional output dimension list, which needs to be consistent with the input operator. Again, this is easy to do, but was not sure if it is needed. If I get time I might add this anyway. 4. There are some examples of the code in the docstring to see how to run it (and also in the tests of course). I also have offline a script to perform certain speed comparisons (vs the sparse routine), I can share some more results of that. I figured this type of script shouldn't go into the project, but I can also add this. **Changelog**; Added a local multiplication routine, to speed up certain dense matrix operations.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405:3270,perform,perform,3270,https://qutip.org,https://github.com/qutip/qutip/pull/1405,1,['perform'],['perform']
Performance,"ed features for a pulse-level description of quantum circuits and noise models. A new class `Processor` and several subclasses are added to represent different platforms for quantum computing. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Best; Boxi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940:2202,perform,perform,2202,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590737940,2,['perform'],['perform']
Performance,"ef=""https://redirect.github.com/python-pillow/Pillow/issues/7619"">#7619</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Import plugins relative to the module <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7576"">#7576</a> [<a href=""https://github.com/deliangyang""><code>@​deliangyang</code></a>]</li>; <li>Translate encoder error codes to strings; deprecate <code>ImageFile.raise_oserror()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7609"">#7609</a> [<a href=""https://github.com/bgilbert""><code>@​bgilbert</code></a>]</li>; <li>Updated readthedocs to latest version of Python <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7611"">#7611</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support reading BC4U and DX10 BC1 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/6486"">#6486</a> [<a href=""https://github.com/REDxEYE""><code>@​REDxEYE</code></a>]</li>; <li>Optimize ImageStat.Stat.extrema <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7593"">#7593</a> [<a href=""https://github.com/florath""><code>@​florath</code></a>]</li>; <li>Handle pathlib.Path in FreeTypeFont <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7578"">#7578</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use list comprehensions to create transformed lists <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7597"">#7597</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Added support for reading DX10 BC4 DDS images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7603"">#7603</a> [<a href=""https://github.com/sambvfx""><code>@​sambvfx</code></a>]</li>; <li>Optimized ImageStat.Stat.count <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7599"">#7599</a> [<a href=""https://github.com/florath""><code>@​florath</code></a>]</li>; <li>",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2302:7208,Optimiz,Optimize,7208,https://qutip.org,https://github.com/qutip/qutip/pull/2302,1,['Optimiz'],['Optimize']
Performance,"em PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco Nori and Will Zeng.;",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5401,cache,cache,5401,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,enblas-devel; - openssl; - packaging; - pandas; - pandoc; - pandocfilters; - pango; - pari; - parso; - patsy; - pbr; - pcre; - perl; - pexpect; - pickleshare; - pillow; - pip; - pixman; - prometheus_client; - prompt_toolkit; - protobuf; - psutil; - ptyprocess; - pycodestyle; - pycparser; - pyflakes; - pygments; - pylint; - pyopenssl; - pyparsing; - pyqt; - pyrsistent; - pysocks; - python; - python-dateutil; - python-symengine; - pytz; - pyyaml; - pyzmq; - qt; - qtawesome; - qtconsole; - qtpy; - qutip; - r-base; - r-clisymbols; - readline; - reportlab; - requests; - rope; - scikit-learn; - scipy; - send2trash; - setuptools; - simplegeneric; - sip; - six; - snowballstemmer; - sphinx; - sphinxcontrib; - sphinxcontrib-applehelp; - sphinxcontrib-devhelp; - sphinxcontrib-htmlhelp; - sphinxcontrib-jsmath; - sphinxcontrib-qthelp; - sphinxcontrib-serializinghtml; - sphinxcontrib-websupport; - spyder; - spyder-kernels; - sqlite; - symengine; - symmetrica; - sympow; - sympy; - tensorboard; - tensorflow; - tensorflow-base; - tensorflow-estimator; - termcolor; - terminado; - testpath; - tk; - tktable; - tornado; - traitlets; - typed-ast; - typing; - urllib3; - wcwidth; - webencodings; - werkzeug; - wheel; - wrapt; - wurlitzer; - xz; - yaml; - zeromq; - tqdm; - zlib; - zstd; - pytest; - numba; - hypothesis; - pytest-cov; - mypy; - pytest-xdist; - watchdog; - pytest-runner; - coveralls; - doctr; - gitpython; - pre-commit; - tox; - cookiecutter; - pdbpp; - sphinx-autobuild; - sphinx-autodoc-typehints; - sphinx_rtd_theme; - travis-encrypt; - twine; - nbval; - nbsphinx; - watermark; - ipyparallel; - unittest2pytest; - pytest-benchmark; - pytest-repeat; - pytest-subtests; - fastcore; - fastscript; - asttokens; - cached-property; - crayons; - executing; - flask; - humanize; - ipywidgets; - itsdangerous; - jsonpickle; - jupyter; - littleutils; - nbconvert; - outdated; - portpicker; - sqlalchemy; - widgetsnbextension; - nbdime; - rich; - mayavi; - pip:; - birdseye; - icecream; - nbdev==1.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563:3333,cache,cached-property,3333,https://qutip.org,https://github.com/qutip/qutip/pull/1558#issuecomment-842089563,2,['cache'],['cached-property']
Performance,"er than a hard limit, but it's a good rule of thumb for testing one piece of functionality. [Here's a (slightly out-dated) list of our current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function. The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up. With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead. I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them. Minor things that _may_ speed up - check the profiling!; 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tensor(tensor(els[0], els[1]), els[2]), ...), els[-1])`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213:1156,load,loads,1156,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640127213,2,['load'],['loads']
Performance,"er the hood will not fully understand how this is working. I believe the crux of this implementation is a fast computation of the tensors of `coherent_dm` operators for all the alpha values at (x + iy). Personally, on many occasions, I have looked at qutip implementations of quantum operations just to understand what is happening under the hood and I believe several users have often done this to hack around. If someone were to try and understand Q-function computation from this code, it seems simple enough with the call:. ```; np.abs(np.dot(alphas, (self._g*0.5)*vector))**2; ```. for state vectors, or decomposing a density matrix into state vectors and then running the above call. Or . ```; out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha.conj,; ); ```. But the object `alpha` now constructed with `_qfunc_alpha_matrix` class is a bit difficult to understand. The variable `self.conj = np.empty(x.shape, dtype=np.complex128)` creates a tensor and sets it to a mesh grid (x, -y), but then what does the `__call__()` return? The tensor of `coherent_dm(x+iy)` for each x and y coordinate? But how is it computing it without knowing the Hilbert space dim for the state, which I think is computed on the fly by `ns = np.arange(first, last).reshape(1, 1, -1)`. It seems it caches the `coherent_dm` computed upto `current_size` and then extends it to `size` for new Hilbert space dimensions. . I am sorry if I am being a bit thick here because I understand the overall idea of the code but somehow I am not confident it will be easy for others to understand on first read. Do you think we can make it a bit more transparent how the `_qfunc_alpha_matrix` works and that the crux of the method is computing the operators `coherent_dm` in an efficient way and saving them? If I have understood the code correct, I could try to document it a bit more and simplify it. . Let me know your thoughts and correct me if I misunderstood something @jakelishman @Ericgig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762:1979,cache,caches,1979,https://qutip.org,https://github.com/qutip/qutip/pull/1583#issuecomment-877241762,2,['cache'],['caches']
Performance,"ery test run, and upload all of them to Coveralls at the end, so we get accurate stats on what lines were actually tested. I've also turned pytest's timer, so it reports all tests that took longer than a second to run. This should really help identify where the real problems in our testing are - right now you should see that there's a `correlation` test that takes around 2 minutes to run, which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because I now install _all_ optional dependencies in most runners, so slightly more gets tested than before. Currently there's also a slowdown on several machines because `cvxpy` doesn't build many wheels, and none at all for Linux, on `pip`. I install all our dependencies except BLAS/LAPACK stuff that way, since it's easiest to read out the dependencies like that. We can potentially save some build time (maybe ~3 minutes?) if we install that from conda-forge instead. I also fixed a minor point of how environment variables are read within `setup.py` (in the end I didn't actually use the new behaviour in the action, but I did during testing), and added a warning fi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:1694,concurren,concurrent,1694,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['concurren'],['concurrent']
Performance,"es in each respective case. The reason the tests are a little bit slow compared to, e.g., the tests in `TestMESolveTDDecay` is the computation of the fidelity of the states at all the different times. If you think the tests are too slow, i can change them, and for example only check the fidelity of the final state. As a side note: As I wrote this new functionality, I also ran some simple tests comparing a pure python implementation of the right hand side for `_mesolve_const` to the cython implementation (I did this because I was considering how much cython code I had to write, or if a pure python implementation of the new functionality would suffice). I actually found that a pure python implementation was as fast (or maybe slightly _faster_) than the cython implementation. The pure python implementation of the right hand side is simply (see lines 767-769 of mesolve.py). ``` python; def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); ```. Here is a plot of the performance compare to the standard cython implementation for a very simple test. The benchmark was a damped-cavity JC-model with Hilbert space dimension 4 for the cavity, integrated up to ""integration time"". ""run time"" is the real run time on my laptop. ![benchmark](https://cloud.githubusercontent.com/assets/2354542/11615553/48fe8604-9c32-11e5-83b9-2de366bd3cef.png). Since there is no big difference between the cython implementation and the pure python implementation (if anything, the pure python implementation is slightly faster), maybe it makes sense to replace the call to `cy_ode_rhs` with a call to `_ode_rhs_test` (see lines 744 to 747 in mesolve.py)? This makes the code a tiny bit easier to read. Of course, this was a single, very simplistic test. Sorry about all the merge commits. I'm still learning good workflow for this type of feature branch. Will use rebasing more in the future. Let me know if you have any questions about the implementation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/404:1522,perform,performance,1522,https://qutip.org,https://github.com/qutip/qutip/pull/404,1,['perform'],['performance']
Performance,"es</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/releases"">pillow's releases</a>.</em></p>; <blockquote>; <h2>10.3.0</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/10.3.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/10.3.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>CVE-2024-28219: Use strncpy to avoid buffer overflow <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7928"">#7928</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Use <code>functools.lru_cache</code> for <code>hopper()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7912"">#7912</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Raise ValueError if seeking to greater than offset-sized integer in TIFF <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7883"">#7883</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improve speed of loading QOI images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7925"">#7925</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added RGB to I;16N conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7920"">#7920</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Add --report argument to <strong>main</strong>.py to omit supported formats <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7818"">#7818</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Added RGB to I;16, I;16L and I;16B conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7918"">#7918</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix editable installation with custom build backend and configuration options <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7658"">#7658</a> [<a href=""https://g",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:1125,load,loading,1125,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['load'],['loading']
Performance,"est_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3816,cache,cached,3816,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"est_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2756,cache,cached,2756,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"ete): qutip/essolve.py deleted in HEAD and modified in master. Version master of qutip/essolve.py left in tree.; CONFLICT (modify/delete): qutip/eseries.py deleted in HEAD and modified in master. Version master of qutip/eseries.py left in tree.; CONFLICT (content): Merge conflict in qutip/entropy.py; CONFLICT (modify/delete): qutip/cy/spmatfuncs.pyx deleted in HEAD and modified in master. Version master of qutip/cy/spmatfuncs.pyx left in tree.; CONFLICT (modify/delete): qutip/cy/sparse_routines.pxi deleted in HEAD and modified in master. Version master of qutip/cy/sparse_routines.pxi left in tree.; CONFLICT (modify/delete): qutip/cy/codegen.py deleted in HEAD and modified in master. Version master of qutip/cy/codegen.py left in tree.; CONFLICT (content): Merge conflict in qutip/core/superop_reps.py; CONFLICT (content): Merge conflict in qutip/core/subsystem_apply.py; CONFLICT (content): Merge conflict in qutip/core/states.py; CONFLICT (content): Merge conflict in qutip/core/semidefinite.py; CONFLICT (content): Merge conflict in qutip/core/metrics.py; CONFLICT (content): Merge conflict in qutip/control/pulseoptim.py; CONFLICT (content): Merge conflict in qutip/control/pulsegen.py; CONFLICT (content): Merge conflict in qutip/control/optimizer.py; CONFLICT (content): Merge conflict in qutip/control/dump.py; CONFLICT (content): Merge conflict in qutip/bloch.py; CONFLICT (content): Merge conflict in qutip/_pyxbuilder.py; CONFLICT (content): Merge conflict in qutip/_mkl/utilities.py; CONFLICT (content): Merge conflict in qutip/_mkl/spsolve.py; CONFLICT (content): Merge conflict in qutip/_mkl/spmv.py; CONFLICT (content): Merge conflict in qutip/_mkl/__init__.py; CONFLICT (content): Merge conflict in qutip/__init__.py; CONFLICT (add/add): Merge conflict in VERSION; CONFLICT (content): Merge conflict in MANIFEST.in; CONFLICT (add/add): Merge conflict in .github/workflows/tests.yml; ```. Uh-oh. (This is actually expected: most of these are benign, and I can fix them quickly.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165:4284,optimiz,optimizer,4284,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864984165,1,['optimiz'],['optimizer']
Performance,"ey reduce conceptual clarity. (For example, `temporal_basis_vector` returns a specific vector in the temporal basis; I would expect a function named `temporal_basis` to return an enumeration of all basis vectors.) However, I will try to think of shorter names which don't reduce clarity and will make changes if I come up with any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2798,perform,performance,2798,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['perform'],['performance']
Performance,"for clarity.; <div align=""center"">; <img width=""314"" alt=""image"" src=""https://github.com/user-attachments/assets/e7a6fb3e-c9e8-4cf9-96ba-aefaf7e9a554"">; </div>. To make the problem clearer, I simplified the simulation model. The Hamiltonian used is:. $$ H_{\rm rot} = {\rm Re}[\Omega(t)]\frac{\sigma_x}{2} + {\rm Im}[\Omega(t)]\frac{\sigma_y}{2} $$. where $\Omega(t)$ is a time-dependent coefficient. The tlist and coefficients are both numpy arrays. Providing the entire code that generates these coefficients would be lengthy, so I preselected a few sets of coefficients and tlist where the issue is present. Specifically, the problematic data is from indices 92, 93, and 94, which have been highlighted in the plot. These are stored using np.savetxt. Below is the plot of the coefficients, showing that they are mainly real and differ only slightly. ```; plt.figure(); ax0 = plt.subplot(221); ax1 = plt.subplot(222). for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt(f""{wavedata_name}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt(f""{wavedata_name}_tlist.txt"",dtype=np.float64); ax0.plot(tlist, coef.real, label=f""{wavedata_name}""); ax1.plot(tlist, coef.imag, label=f""{wavedata_name}""); ax0.legend(); ax1.legend(); ; ax0.set_title(r""$\sigma_x$ coefficient""); ax1.set_title(r""$\sigma_y$ coefficient""); ```. <div align=""center"">; <img width=""314"" alt=""image"" src=""https://github.com/user-attachments/assets/b07b3a64-a2d4-458b-a04e-4c83c0c4c093"">; </div>; Despite these small differences, the simulation results show significant and unexpected variations. ; Below is simulation code and results. ```; import qutip; import numpy as np; import matplotlib.pyplot as plt. sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); psi0 = qutip.fock(2,0); psi1 = qutip.fock(2,1). def Hrot(coef,tlist): ; return qutip.QobjEvo([[sx,coef.real/2],[sy,coef.imag/2]],tlist=tlist). Omega0 = 10e6 * 2 * np.pi; for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552:1264,load,loadtxt,1264,https://qutip.org,https://github.com/qutip/qutip/issues/2552,1,['load'],['loadtxt']
Performance,"for review. I have a; > working implementation of the ICM model now and a partial implementation of Pauli; > tracking; > <https://www.date-conference.com/files/proceedings/2014/pdffiles/05.6_7_ip2-19.pdf>; > which pushes all the corrections and measurement to the end of the circuit.; > I have written a quick example which demonstrates the use of this :; >; > https://github.com/sahmed95/notebooks/blob/icm/qutip_icm/; > icm_pauli_tracked.ipynb; > Circuit with a rotation gate (T gate); >; > [image: t_example]; > <https://cloud.githubusercontent.com/assets/6968324/21744332/c723fc5e-d556-11e6-9007-83187de75867.png>; > Pauli tracked ICM representation of circuit; >; > [image: t_pauli_tracked]; > <https://cloud.githubusercontent.com/assets/6968324/21744335/c997f300-d556-11e6-9202-f3ed33955b8a.png>; >; > Thus, we get a quantum circuit with qubit initializations in the begining,; > a mesh of CNOT gates in the middle and measurements in the end. This seems; > to be very useful as the starting point of topological quantum circuit; > optimization.; >; > Future work:; >; > 1.; >; > Represent qubit initializations in some way. Right now I consider; > everything as a gate. (Perhaps make new objects for qubit intializations,; > measurement, correction etc.); > 2.; >; > Better visualization such that all initializations, measurements and; > corrections can be stacked in one line.; > 3.; >; > Representing the information regarding P_dagger, T_dagger, V_dagger; > gate teleportation in some way. The difference is just based on the; > interpretation of the measurement.; > 4.; >; > Complete the Pauli tracking algorithm to get the gate sequence for; > correction based on measurement.; >; > Tests, tests and more tests.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/603#issuecomment-271102783>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AI",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/603#issuecomment-271126423:1396,optimiz,optimization,1396,https://qutip.org,https://github.com/qutip/qutip/pull/603#issuecomment-271126423,1,['optimiz'],['optimization']
Performance,"g()+tm.dag()*c+tm*c.dag()+tm.dag()*d+tm*d.dag()+qm.dag()*d+qm*d.dag()+qm.dag()*a+qm*a.dag(),1j*(sm.dag()*a-sm*a.dag())+1j*(sm.dag()*b-sm*b.dag())+1j*(zm.dag()*b-zm*b.dag())+1j*(zm.dag()*c-zm*c.dag())+1j*(tm.dag()*c-tm*c.dag())+1j*(tm.dag()*d-tm*d.dag())+1j*(qm.dag()*d-qm*d.dag())+1j*(qm.dag()*a-qm*a.dag()),sm+sm.dag()+zm+zm.dag()+tm+tm.dag()+qm+qm.dag(), 1j*(sm-sm.dag())+1j*(zm-zm.dag())+1j*(tm-tm.dag())+1j*(qm-qm.dag())]. # Set optimization parameters; U_0=tensor(qeye(N), qeye(N), qeye(N), qeye(N), qeye(2), qeye(2), qeye(2), qeye(2)) # Initial gate; U_targ=mapped # Target gates. # Run the optimization. result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)). ```; For N=>3, instead of getting a printout of the optimized controls, I receive the following terminal output error:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 59, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 829, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 510, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 970, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 375, in _create_result; re",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:3725,optimiz,optimized,3725,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimized']
Performance,"g. They can transfer a quantum circuit into the corresponding control sequence and simulate the dynamics with QuTiP solvers. Different noise models can be added to `qutip.qip.noise` to simulate noise in a quantum device. . This module is still young and many features can be improved, including new device models, new noise models and integration with the existing general framework for quantum circuits (`qutip.qip.circuit`). There are also possible applications such as error mitigation techniques [1-3]. The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM conference may help you get an overview (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github Project page for a collection of related issues and ongoing Pull Requests. ### Expected outcomes; - More devices defined in the `qutip.qip.device` module. At the moment, we have two models: spin chain and cavity QED. We would like to include some other commonly used planform such as Superconducting system, Ion trap system or silicon system. Each model will need a new set of control hamiltonian and a compiler that find the control pulse of a quantum gate. This part is gonna involve some physics and study of commonly used hardware platforms. The related code can be found in `qutip.qip.device` and `qutip.qip.compiler`; - Refactoring the circuit compiler to allow simple pulse scheduling, e.g. Restriction one pulses that can be turned on at the same time.; - Features to perform error mitigation techniques in QuTiP, such as zero-error extrapolation.; - APIs to allow import quantum circuits from other software packages or commonly used language e.g. through quantum assembly language (qasm); ----------------------------------------------------------------. Also, the last outcomes have some overlap with the last project. Although I also find this circuit importation very important, I guess two projects should not have overlap if they are both selected.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184:2205,perform,perform,2205,https://qutip.org,https://github.com/qutip/qutip/issues/1184,1,['perform'],['perform']
Performance,"gcc 4.4 does not support the `-flto` option for link time optimization. This is still a common compiler because it is the system gcc in centos 6 and redhat enterprise 6. In this pull request I've removed that option. Users who need this could set the CCFLAGS environment variable to customize the compiler flags. Alternatively, we could add options to `setup.py` to enable or disable link time optimization. I've also added additional rows to the travis build matrix to test building with gcc 4.4 and clang. In its current form this adds 4 additional rows to the build matrix (2 additional compilers, each tested with python 2.7 and 3.4). Let me know if you think this is excessive. It's possible to add just one python version for gcc 4.4 and clang.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/318:58,optimiz,optimization,58,https://qutip.org,https://github.com/qutip/qutip/pull/318,2,['optimiz'],['optimization']
Performance,"gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmp8u8pmfcw_in_process.py build_wheel /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmpcrdfx79e; cwd: /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-install-cp5z29tf/numpy_1458b1f38a5449d18aa77b5bb31c63d1; Complete output (881 lines):; Running from numpy source directory.; numpy/random/_bounded_integers.pxd.in has not changed; numpy/random/_philox.pyx has not changed; numpy/random/_bounded_integers.pyx.in has not changed; numpy/random/_sfc64.pyx has not changed; numpy/random/_mt1",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:2038,cache,cached,2038,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"hanged is replacing the Pauli operator to annihilation/creation operator formalism.; However, when comparing with the Lindblad-Master equation based simulation, the outcome is quantitatively quite different. ![Figure 2023-02-18 142921](https://user-images.githubusercontent.com/47425237/219868478-8210e6d6-155a-4587-9afd-0b0ec505fc09.png). It seems that the function ""floquet_master_equation_rates"" might be an issue, but I do not know how to fix this problem. Any help is appreciated!; Thank you very much!!. QuTiP: Quantum Toolbox in Python; ================================; QuTiP Version: 4.7.0; Numpy Version: 1.21.2; Scipy Version: 1.7.1; Cython Version: 0.29.32; Matplotlib Version: 3.5.0; Python Version: 3.9.7; Number of CPUs: 12; BLAS Info: INTEL MKL; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Windows (AMD64). ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; from IPython.display import Image; import math. from scipy.optimize import least_squares; from scipy.optimize import curve_fit. from Ham_tools import Ham_tools; ###--------------------physical constants-----------------------; hbar = 1.055*10**(-28) ##(*[J µs]*); ###-------------------waste mode--------------------------; ww = 2* np.pi* 7.609* 10**3 #(*[MHz] waste mode cavity frequency*); gdw = 2* np.pi* 16.6 #12 #(*[MHz]external decay rate of waste mode*). ###definitions; def J_cb(omega):; """""" Noise spectral density """"""; #print ""evaluate J_cb for omega ="", omega; return 0.5 * gdw /(2*np.pi) # 2*gdw/(np.pi**2). def cos_drv(t, args):; return np.cos(wd*t); ###=========================================================================================================; ###Set the dimensions of the Hilbert space of each participating quantum system; ###=========================================================================================================; ### resonator; d1 = 3; ### create ""annihilation operator; aw = destroy(d1). #%%=====================================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2097:1618,optimiz,optimize,1618,https://qutip.org,https://github.com/qutip/qutip/issues/2097,1,['optimiz'],['optimize']
Performance,"hi,; i think there was a bug in the computation of gradients for unitary problems. im not sure if i tracked them down correctly, but the gradients seem to be more consistent now. this can be checked with the following code after initialization of an Optimizer object `optim`. ``` python; from scipy.optimize import check_grad; func = optim.fid_err_func_wrapper; grad = optim.fid_err_grad_wrapper; x0 = optim.dynamics.ctrl_amps.flatten(); check_grad(func, grad, x0); ```. also, im new to github and im not sure if im doing this correctly.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/325:250,Optimiz,Optimizer,250,https://qutip.org,https://github.com/qutip/qutip/pull/325,2,"['Optimiz', 'optimiz']","['Optimizer', 'optimize']"
Performance,"higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap them or ask users to write more complicated code. It means that all benefits and bug-fixes to qutip are instantly available to users of other packages too that rely on it. And I think that calling a conversion method at the beginning, which most of the time will do nothing will just be a tiny drop in the bucket of the overhead of those `large` functions. However, I don't want to argue that right now. All my proposal was about was having a way to play well with your `Qobj` constructor.; It seems to me you were eventually favourable to this, so I propose we focus the discussion only on this point, and leave aside implicit or explicit conversion discussions. . I'll gladly open another issue to discuss implicit conv",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:2381,perform,performed,2381,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['perform'],['performed']
Performance,"hon3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Boar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5309,cache,cache,5309,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,"https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L125) abstract base class, [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/master/src/krotov/propagators.py#L162) being a particular example. In particular, the interface we define there is strictly for a single time step, makes no reference to `tlist` and we use ``H=[H0, [H1, u]]`` where `u` is a scalar for that particular timestep. However, I can easily write a wrapper around an `mesolve` that would work something along the lines of the pseudo-code from https://github.com/qucontrol/krotov/issues/93#issuecomment-859717563:. ~~~; for (i, state) in enumerate(; mesolve([H0, [H1, ctrl_array]], state0, list); ):; # assuming `state` is at tlist[i]; new_val = calculate_control_value_for_next_step(state); ctrl_array[i] = new_val; ctrl_array[i+1] = new_val # ignoring IndexError; ~~~. So I don't think you'd have to worry about these details: any implementation with low overhead that would allow me to get the states from `mesolve` as well as tweak the control fields for the next time step should be sufficient. In particular, the `.step` that you discuss in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 looks very much like it's going in the right direction! The one option from the earlier https://github.com/qutip/qutip/issues/1571#issue-917391349 that might *not* work very well is callback functions. I *might* be able to work around that, but it wouldn't really fit into the control flow of an optimization. The code. ~~~; solver = MeSolver(H, c_ops, options=opt); solver.start(t0, rho0); for t in [t1,t2, ...]:; rho_t = solver.step(t, args=new_args); ~~~. from https://github.com/qutip/qutip/issues/1571#issuecomment-858740451 on the other hand would definitely fit the bill, assuming that `args=new_args` is the way to modify the control fields. Sorry for the long explanation, but I hope this clarifies the use case. If not, I'll be happy to try to explain better! ;-)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215:5130,optimiz,optimization,5130,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859754215,2,['optimiz'],['optimization']
Performance,"https://github.com/user-attachments/assets/e7a6fb3e-c9e8-4cf9-96ba-aefaf7e9a554"">; </div>. To make the problem clearer, I simplified the simulation model. The Hamiltonian used is:. $$ H_{\rm rot} = {\rm Re}[\Omega(t)]\frac{\sigma_x}{2} + {\rm Im}[\Omega(t)]\frac{\sigma_y}{2} $$. where $\Omega(t)$ is a time-dependent coefficient. The tlist and coefficients are both numpy arrays. Providing the entire code that generates these coefficients would be lengthy, so I preselected a few sets of coefficients and tlist where the issue is present. Specifically, the problematic data is from indices 92, 93, and 94, which have been highlighted in the plot. These are stored using np.savetxt. Below is the plot of the coefficients, showing that they are mainly real and differ only slightly. ```; plt.figure(); ax0 = plt.subplot(221); ax1 = plt.subplot(222). for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt(f""{wavedata_name}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt(f""{wavedata_name}_tlist.txt"",dtype=np.float64); ax0.plot(tlist, coef.real, label=f""{wavedata_name}""); ax1.plot(tlist, coef.imag, label=f""{wavedata_name}""); ax0.legend(); ax1.legend(); ; ax0.set_title(r""$\sigma_x$ coefficient""); ax1.set_title(r""$\sigma_y$ coefficient""); ```. <div align=""center"">; <img width=""314"" alt=""image"" src=""https://github.com/user-attachments/assets/b07b3a64-a2d4-458b-a04e-4c83c0c4c093"">; </div>; Despite these small differences, the simulation results show significant and unexpected variations. ; Below is simulation code and results. ```; import qutip; import numpy as np; import matplotlib.pyplot as plt. sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); psi0 = qutip.fock(2,0); psi1 = qutip.fock(2,1). def Hrot(coef,tlist): ; return qutip.QobjEvo([[sx,coef.real/2],[sy,coef.imag/2]],tlist=tlist). Omega0 = 10e6 * 2 * np.pi; for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt(f""{wavedata_name}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552:1333,load,loadtxt,1333,https://qutip.org,https://github.com/qutip/qutip/issues/2552,1,['load'],['loadtxt']
Performance,"https://redirect.github.com/python-pillow/Pillow/issues/7888"">#7888</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Support FITS images with GZIP_1 compression <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7894"">#7894</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use I;16 mode for 9-bit JPEG 2000 images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7900"">#7900</a> [<a href=""https://github.com/scaramallion""><code>@​scaramallion</code></a>]</li>; <li>Raise ValueError if kmeans is negative <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7891"">#7891</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Remove TIFF tag OSUBFILETYPE when saving using libtiff <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7893"">#7893</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Raise ValueError for negative values when loading P1-P3 PPM images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7882"">#7882</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added reading of JPEG2000 palettes <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7870"">#7870</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added alpha_quality argument when saving WebP images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7872"">#7872</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed joined corners for ImageDraw rounded_rectangle() non-integer dimensions <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7881"">#7881</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed Python and NumPy pinning on Cygwin <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7880"">#7880</a> [<a href=""https://",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:3648,load,loading,3648,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['load'],['loading']
Performance,"ier to separate out different versions, and detect what to register as the conversion function with QuTiP. This is a particular advantage for Python classes compiled as C-extensions (like from C or Cython), which typically don't allow assigning methods dynamically.; - A library could even register multiple versions of the conversion function with us, and let QuTiP handle API versioning centrally, rather than requiring downstream libraries to roll their own checks.; - We're basically already set up to do this in `dev.major` already. We'd have to modify our procedures a little bit (we're mostly concerned with constructing the underlying matrices at the moment), but it's a smaller change in behaviour. Disadvantages that I can think of:; - It's got linear scaling with the number of conversions registered, so it's in theory possible to register ""too many"" and cause a slow down. In reality, this will be a very small effect (`Qobj` construction time will be dominated by copying data into new formats), and I think the benefits of a priority queue of allowed converters outweighs it in convenience for users.; - It involves some global state of the `qutip` library, which _may_ cause problems for multiprocessing if somebody tries to register a `lambda` converter (can't pass through `pickle`, though I'm not 100% on whether module-level stuff needs to), and of course there's the query of what happens when converters are registered in separate processes. We already have this ""problem"" in 5.0 though, because that's how the entire underlying dispatch mechanism is handled; we can just require that converters must be pickle-able.; - If a downstream package wants to lazily `import qutip` (we're a pretty heavy import right now), it's harder in this method; you'd basically have to ask a user to call `otherlibrary.register_qutip()`. For one, I'm going to put some effort into making `import qutip` take much less time for 5.0 (the main problem right now is we essentially eagerly import all ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691:7304,queue,queue,7304,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-830003691,2,['queue'],['queue']
Performance,"igation techniques [1-3].; >; > The tutorial notebooks can be found at; > http://qutip.org/tutorials.html#nisq. A recent presentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; > Expected outcomes; >; > - More devices defined in the qutip.qip.device module. At the moment,; > we have two models: spin chain and cavity QED. We would like to include; > some other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in qutip.qip.device and; > qutip.qip.compiler; > - Refactoring the circuit compiler to allow simple pulse scheduling,; > e.g. Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages; > or commonly used language e.g. through quantum assembly language (qasm); >; > ------------------------------; >; > Also, the last outcomes have some overlap with the last project. Although; > I also find this circuit importation very important, I guess two projects; > should not have overlap if they are both selected.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/issues/1184?email_source=notifications&email_token=ADPF67A5MSYZVSDKCZD73LTREGE2LA5CNFSM4KZUPCQ2YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4IPQGYLA>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADPF67EWECDUIOQMTKK2N2DREGE2LANCNFSM4KZUPCQQ>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313:2731,perform,perform,2731,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590726313,2,['perform'],['perform']
Performance,"illow/issues/7706"">#7706</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use subprocess with CREATE_NO_WINDOW flag in ImageShow WindowsViewer <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7791"">#7791</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>When saving GIF frame that restores to background color, do not fill identical pixels <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7788"">#7788</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed reading PNG iCCP compression method <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7823"">#7823</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow writing IFDRational to UNDEFINED tag <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7840"">#7840</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix logged tag name when loading Exif data <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7842"">#7842</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use maximum frame size in IHDR chunk when saving APNG images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7821"">#7821</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Prevent opening P TGA images without a palette <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7797"">#7797</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use palette when loading ICO images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7798"">#7798</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Use consistent arguments for load_read and load_seek <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7713"">#7713</a> [<a href=""https://github.com/radarhere""><c",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:6222,load,loading,6222,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['load'],['loading']
Performance,"in this release are 3.8-3.10, Python 3.7; has been dropped. Note that 32 bit wheels are only provided for Python; 3.8 and 3.9 on Windows, all other wheels are 64 bits on account of; Ubuntu, Fedora, and other Linux distributions dropping 32 bit support.; All 64 bit wheels are also linked with 64 bit integer OpenBLAS, which should fix; the occasional problems encountered by folks using truly huge arrays.</p>; <h2>Expired deprecations</h2>; <h3>Deprecated numeric style dtype strings have been removed</h3>; <p>Using the strings <code>&quot;Bytes0&quot;</code>, <code>&quot;Datetime64&quot;</code>, <code>&quot;Str0&quot;</code>, <code>&quot;Uint32&quot;</code>,; and <code>&quot;Uint64&quot;</code> as a dtype will now raise a <code>TypeError</code>.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19539"">gh-19539</a>)</p>; <h3>Expired deprecations for <code>loads</code>, <code>ndfromtxt</code>, and <code>mafromtxt</code> in npyio</h3>; <p><code>numpy.loads</code> was deprecated in v1.15, with the recommendation that; users use <code>pickle.loads</code> instead. <code>ndfromtxt</code> and <code>mafromtxt</code> were both; deprecated in v1.17 - users should use <code>numpy.genfromtxt</code> instead with; the appropriate value for the <code>usemask</code> parameter.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19615"">gh-19615</a>)</p>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/numpy/numpy/commit/4adc87dff15a247e417d50f10cc4def8e1c17a03""><code>4adc87d</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/20685"">#20685</a> from charris/prepare-for-1.22.0-release</li>; <li><a href=""https://github.com/numpy/numpy/commit/fd66547557f57c430d41be2fc0764f74a62e8ccf""><code>fd66547</code></a> REL: Prepare for the NumPy 1.22.0 release.</li>; <li><a href=""https://github.com/numpy/nu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:2435,load,loads,2435,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['load'],['loads']
Performance,"ing); > > > /usr/lib/python2.7/dist-packages/scipy/sparse/linalg/dsolve/umfpack/umfpack.py:576: UmfpackWarning: (almost) singular matrix! (estimated cond. number: 1.03e+15); > > > warnings.warn(msg, UmfpackWarning); > > > ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; # ; ## ERROR: Failure: ValueError (invalid literal for int() with base 10: '1post0'). Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/loader.py"", line 411, in loadTestsFromName; addr.filename, addr.module); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 47, in importFromPath; return self.importFromDir(dir_path, fqname); File ""/usr/lib/python2.7/dist-packages/nose/importer.py"", line 94, in importFromDir; mod = load_module(part_fqname, fh, filename, desc); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mcsolve.py"", line 232, in <module>; @unittest.skipIf(version2int(Cython.**version**) < version2int('0.14') or; File ""/usr/local/lib/python2.7/dist-packages/qutip/**init**.py"", line 35, in version2int; return sum([int(d) \* (100 *\* (3 - n)) for n, d in enumerate(str_list[:3])]); ValueError: invalid literal for int() with base 10: '1post0'; # ; ## ERROR: mesolve: simple time-dependence as string list. Traceback (most recent call last):; File ""/usr/lib/python2.7/dist-packages/nose/case.py"", line 197, in runTest; self.test(*self.arg); File ""/usr/local/lib/python2.7/dist-packages/qutip/tests/test_mesolve.py"", line 398, in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126:14452,load,loadTestsFromName,14452,https://qutip.org,https://github.com/qutip/qutip/issues/126,1,['load'],['loadTestsFromName']
Performance,"instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The primary consequence of this is that the cache will simply be a little un",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1372,cache,cache,1372,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,2,['cache'],['cache']
Performance,"ip 24.0 from /home/defreule/.local/lib/python3.8/site-packages/pip (python 3.8); Defaulting to user installation because normal site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1610,cache,cached,1610,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The primary consequence of this is that the cache will simply be a little under-zealous, and sometimes it will calculate the value twice for three similar `Qobj`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1470,cache,cache,1470,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,14,"['cache', 'perform']","['cache', 'cached', 'performance']"
Performance,"ith any. > Moving temporal_scattered_state, scattering_probability, and temporal_basis_vector into a new class. I think this is the only proposed change worth significant amounts of discussion, and it's actually something I had considered before. I'm conflicted about whether this change would be good or not, and I would value input from everyone involved in this review process (@sahmed95 , @kafischer, @nonhermitian, @ajgpitch). I've outlined my thoughts on the pros and cons of this change below. **Pros:**; - Consolidating these functions to class methods would be convenient in terms of reducing verbosity, since you would have to specify fewer arguments when calling these functions; - This would allow for a small performance increase, since maintaining a class-wide Evolver would mean that propagators would be precomputed for later simulations. However, this performance increase would be small and would be nearly un-noticeable for simulating N>3 scattered photons, since N=2 fully computes all propagators U[t1, t2]; - This could allow for additional helper functions to be added without cluttering up the exported top-level functions. Examples could include a `temporal_basis` function which could enumerate all `temporal_basis_vector`s for a given configuration of waveguides and list of times, or a `to_ndarray` function which could create an n-dimensional numpy array containing the projections of the computed scattered state onto appropriate basis vectors. **Cons:**; - Making this a class seems to be at odds with the general style that QuTiP is coded in. In physics-related modules which users regularly interact with, QuTiP seems to reserve classes exclusively for physical things, like states and operators, instead using functions to represent physics calculations which can be done with these objects. (Or, if you like, ""classes are nouns, functions are verbs"".) There are 25 keyword occurrences of ""class"" in the top-level qutip directory and subdirectories thereof:; - 21 are",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384821368:2945,perform,performance,2945,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384821368,1,['perform'],['performance']
Performance,"kum, Franco Nori and Will Zeng.; Original developers: R. J. Johansson & P. D. Nation.; Previous lead developers: Chris Granade & A. Grimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.6.2; Numpy Version: 1.21.0; Scipy Version: 1.7.0; Cython Version: 0.29.23; Matplotlib Version: 3.4.2; Python Version: 3.9.6; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /opt/homebrew/lib/python3.9/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; ```. **Additional context**; No sysctl hw.cpufrequency at all on this machine, so it blows up (some error handling in that function would be good :-). ```$ sysctl hw; hw.ncpu: 8; hw.byteorder: 1234; hw.memsize: 17179869184; hw.activecpu: 8; hw.optional.amx_version: 2; hw.optional.arm64: 1; hw.optional.armv8_1_atomics: 1; hw.optional.armv8_2_fhm: 1; hw.optional.armv8_2_sha3: 1; hw.optional.armv8_2_sha512: 1; hw.optional.armv8_crc32: 1; hw.optional.breakpoint: 6; hw.optional.floatingpoint: 1; hw.optional.neon: 1; hw.optional.neon_fp16: 1; hw.optional.neon_hpfp: 1; hw.optional.ucnormal_mem: 1; hw.optional.watchpoint: 4; hw.cacheconfig: 8 1 1 0 0 0 0 0 0 0; hw.cachelinesize: 128; hw.cachesize: 3616980992 65536 4194304 0 0 0 0 0 0 0; hw.cpu64bit_capable: 1; hw.cpufamily: 458787763; hw.cpusubfamily: 2; hw.cpusubtype: 2; hw.cputype: 16777228; hw.ephemeral_storage: 0; hw.l1dcachesize: 65536; hw.l1icachesize: 131072; hw.l2cachesize: 4194304; hw.logicalcpu: 8; hw.logicalcpu_max: 8; hw.osenvironment: ; hw.packages: 1; hw.pagesize: 16384; hw.pagesize32: 16384; hw.physicalcpu: 8; hw.physicalcpu_max: 8; hw.serialdebugmode: 0; hw.tbfrequency: 24000000; hw.use_kernelmanagerd: 1; hw.use_recovery_securityd: 0; hw.targettype: J293; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1606:3288,cache,cacheconfig,3288,https://qutip.org,https://github.com/qutip/qutip/issues/1606,3,['cache'],"['cacheconfig', 'cachelinesize', 'cachesize']"
Performance,"le^{\otimes&space;4}"" title=""\psi = \left|0\right\rangle^{\otimes 4}"" /></a>; I do that as follow: ; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); ```; and i got the following : . ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1); Traceback (most recent call last):. File ""<ipython-input-160-ae66af2f799c>"", line 1, in <module>; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)) * basis(16,1). File ""/home/user/anaconda2/envs/Quantum/lib/python2.7/site-packages/qutip/qobj.py"", line 515, in __mul__; raise TypeError(""Incompatible Qobj shapes""). TypeError: Incompatible Qobj shap; ```. but when i do each part separately as follow I notice that the shapes are compatible:; ```python; tensor(hadamard_transform(1), hadamard_transform(1), identity(2), identity(2)); Out[161]: ; Quantum object: dims = [[2, 2, 2, 2], [2, 2, 2, 2]], shape = (16, 16), type = oper, isherm = True; ```; ```python; basis(16,1); Out[162]: ; Quantum object: dims = [[16], [1]], shape = (16, 1), type = ket; Qobj data =; ```; The first has shape = (16, 16) and the second has shape = (16, 1), there shouldn't be any problems in performing matrix multiplication.; **Why I got this error and how to solve it.**. My environment is as follow:; ```; ~$ conda info. active environment : Quantum; active env location : /home/user/anaconda2/envs/Quantum; shell level : 1; user config file : /home/user/.condarc; populated config files : /home/user/.condarc; conda version : 4.5.4; conda-build version : 3.10.5; python version : 2.7.15.final.0; base environment : /home/user/anaconda2 (writable); channel URLs : https://repo.anaconda.com/pkgs/main/linux-64; https://repo.anaconda.com/pkgs/main/noarch; https://repo.anaconda.com/pkgs/free/linux-64; https://repo.anaconda.com/pkgs/free/noarch; https://repo.anaconda.com/pkgs/r/linux-64; https://repo.anaconda.com/pkgs/r/noarch; https://repo.anacond",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/888:2669,perform,performing,2669,https://qutip.org,https://github.com/qutip/qutip/issues/888,1,['perform'],['performing']
Performance,"le_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)). ```; For N=>3, instead of getting a printout of the optimized controls, I receive the following terminal output error:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 59, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 829, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 510, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 970, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 375, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 448, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 458, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 474, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1421, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"",",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:4566,optimiz,optimizer,4566,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimizer']
Performance,"les in QuTiP follow the pep8 standard and wrap two newlines for top-level functions. I am in favor of the pep8 standard and have two newlines. @ajgpitch what do you suggest?. Please remove the helper function `count_filled` without the test if it is not required. We aim to test as much as possible and remove redundancy in code. About `__all__`, I will shift all the rest in a new PR and we can keep yours as it is now. Coming to the more important discussion regarding the `class` based implementation, I have started pushing for similar approaches in newer modules such as [qutip.models.piqs](https://github.com/qutip/qutip/blob/master/qutip/models/piqs.py). I am also working on a new non-Markovian method which requires a class. Something of that sort is already used in `qutip.nonmarkov.heom`. I understand that many of qutip's solvers are written to be isolated functions but that should not mean that we should not write code to fully use the object oriented framework Python provides. Moreover, I noticed that you have to rewrite wrappers for the functions anyways to deal with repeatedly calculating things such as `scattering_probability` which clearly can be made much more compact if we use a class based approach. I am not making this suggestion just for the minor performance improvement. It improves the organization of the code, allows greater flexibility in adding new things to an existing class and modifying it easily. In terms of user experience, this means less clutter in the code and verbosity of arguments. You can initialize something once and keep re-calculating things by dynamically changing the parameters and calling the `class` method. If it does not hurt to slowly shift in this direction then I think we should go for it. If there is an alternative reason for not having classes then please let us know as the cons @bencbartlett mentions has more to do with following qutip precedent than some fundamental disadvantage in performance or use. @ajgpitch @nonhermitian",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/848#issuecomment-384860713:1994,perform,performance,1994,https://qutip.org,https://github.com/qutip/qutip/pull/848#issuecomment-384860713,4,['perform'],['performance']
Performance,"ly by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. That's an extremely exciting prospect! I'd love to be able to have internal sparse data for Qobj's that represent Hamiltonians/Liouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with nump",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:3901,optimiz,optimization,3901,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['optimiz'],['optimization']
Performance,"m/qutip for details. QuTiP Version: 4.7.3; Numpy Version: 1.24.2; Scipy Version: 1.10.1; Cython Version: 0.29.36; Matplotlib Version: 3.6.3; Python Version: 3.12.1; Number of CPUs: 8; BLAS Info: OPENBLAS; OPENMP Installed: True; INTEL MKL Ext: False; Platform Info: Linux (x86_64); Installation path: /usr/lib/python3/dist-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ================================================================================================================================== test session starts ===================================================================================================================================; platform linux -- Python 3.12.1, pytest-7.4.4, pluggy-1.3.0 -- /usr/bin/python3.12; cachedir: .pytest_cache; hypothesis profile 'default' -> database=DirectoryBasedExampleDatabase(PosixPath('/home/drew/projects/misc/build/.hypothesis/examples')); rootdir: /home/drew/projects/misc/build/qutip; plugins: remotedata-0.4.1, asyncio-0.20.3, filter-subpackage-0.1.2, doctestplus-1.1.0, flaky-3.7.0, arraydiff-0.6.1, xvfb-3.0.0, astropy-0.11.0, mpi-0.6, astropy-header-0.2.2, cov-4.1.0, mock-3.12.0, openfiles-0.5.0, hypothesis-6.92.2; asyncio: mode=Mode.STRICT; collected 3269 items / 3233 deselected / 36 selected . qutip/tests/test_brmesolve_td.py::test_time_dependent_spline_in_c_ops FAILED [ 2%]; qutip/tests/test_brmesolve_td.py::test_split_operators_maintain_answer[_2_tuple_split] FAILED [ 5%]; qutip/tests/test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[string] FAILED [ 8%]; qutip/tests/test_correlation.py::TestTimeDependence::test_varying_coefficient_hamiltonian_2ls[numpy] FAILED [ 11%]; qutip/tests/test_correlation.py::TestTimeDependence::test_v",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293:4704,cache,cachedir,4704,https://qutip.org,https://github.com/qutip/qutip/issues/2293,1,['cache'],['cachedir']
Performance,"mpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depend",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4081,cache,cached,4081,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"mpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; pandas 2.0.3 requires numpy>=1.20.3; python_version < ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:3021,cache,cached,3021,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"n my points 1 and 2 above, I don't think QuTiP should go this route. You can, however, set these properties to `None` to unconditionally tell Numpy that the object is incompatible with ufuncs. I think this might be a good way for us to go. ## What other libraries do. Provide everything:; - Dask: mostly trying to provide a numpy-like distributed array class. Its arrays mostly support the numpy interface, including how ufuncs should act on them. Providing `__array__` seems odd to me here in the context of other libraries, since that may easily blow out memory.; - PyTorch: CPU/GPU accelerated tensors for ML. This is a bit beyond my experience to comment on why they made the choices they did.; - Xarray: strongly extends the idea of structured arrays; this to me is the best example of how `__array__` was intended to be used.; ; Provide some things:; - Qiskit: (just changed behaviour in Qiskit/qiskit-terra#5402) implements `__array__` (but nothing else) for things that are like our `Qobj`. Discussed more at the top.; - CuPy (CUDA operations on ndarray-likes) explicitly does not allow implicit conversion to `np.ndarray` (see cupy/cupy#3421) for performance reasons, but does implement `__array_ufunc__` and `__array_function__`.; - pydata/sparse (nd-sparse _arrays_ instead of scipy.sparse's sparse _matrices_): always implement `__array_ufunc__` and `__array_function__` because they are trying to be a sparse version of `ndarray`. By default, they do not implement `__array__` for performance/memory reasons, but they do allow turning it on by an environment variable. Do not implement anything:; - JAX (autodiff) tries really hard to replace numpy rather than interoperate with it; - scipy.sparse matrices are intended for use with a _matrix_ interface, not a broadcast-able _array_ interface. They specifically document that they will not provide this interface (see scipy/scipy#12279). Somewhat weirdly, they do have custom methods for some elementwise ufuncs, though (like `np.sin`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902:7126,perform,performance,7126,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-772608902,4,['perform'],['performance']
Performance,"nbasis and back ... ok; > > > Transform 10-level real-values to eigenbasis and back ... ok; > > > Transform 10-level to eigenbasis and back ... ok; > > > Transform 10-level imag to eigenbasis and back ... ok; > > > Check diagonalization via eigenbasis transformation ... ok; > > > brmesolve: harmonic oscillator, finite temperature ... ok; > > > brmesolve: harmonic oscillator, finite temperature, states ... ok; > > > brmesolve: harmonic oscillator, zero temperature ... ok; > > > brmesolve: Jaynes-Cummings model, zero temperature ... ok; > > > brmesolve: qubit ... ok; > > > correlation: comparing me and es for oscillator in coherent initial state ... ok; > > > correlation: comparing me and es for oscillator in steady state ... ok; > > > correlation: compare spectrum from eseries and pseudo-inverse methods ... ok; > > > Diagonalization of random two-level system ... ok; > > > Diagonalization of composite systems ... ok; > > > von-Neumann entropy ... ok; > > > Linear entropy ... ok; > > > Concurrence ... ok; > > > Mutual information ... ok; > > > Conditional entropy ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and density matrix ... ok; > > > expect: operator and ket ... ok; > > > expect: operator list and state ... ok; > > > expect: operator list and state list ... ok; > > > expect: operator and state list ... ok; > > > Read and write complex valued decimal formatted data ... ok; > > > Read and write complex valued default formatted data ... ok; > > > Read and write complex valued exp formatted data ... ok; > > > Read and write real valued decimal formatted data ... ok; > > > Read and write real valued default formatted data ... ok; > > > Read and write real valued exp formatted data ... ok; > > > Read and write with automatic separator detection ... ok; > > > Floquet: test unitary evolution of time-dependent two-level system ... ok; > > > gates: expand 1 to N ... ok; > > > gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:2142,Concurren,Concurrence,2142,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,1,['Concurren'],['Concurrence']
Performance,"ne help me with this issue?. The underlying reason for wanting to have MKL is that it allowed me in the past (on the same machine but with a different conda environment I no longer have access to) to calculate the steady states of much larger Liouvillians than I am now able to. I am unfortunately unable to reproduce this environment. Below you can find the outcomes of various installation processes, each in a new conda environment:. **Attempt 1a:** ; Conda install mkl; conda install numpy; conda install scipy; conda install conda-forge::qutip; **Results:** ; QuTiP Version: 	5.0.3; Numpy Version: 	2.0.0; Scipy Version: 	1.14.0; Cython Version: 	None; Matplotlib Version: 	None; Python Version: 	3.12.4; Number of CPUs: 	12; BLAS Info: 		Generic; INTEL MKL Ext: 	False; Platform Info: 	Windows (AMD64). **Attempt 1b:**; Conda install mkl; conda install scipy ; conda install conda-forge::qutip; **Results:**; QuTiP Version: 	5.0.3; Numpy Version: 	1.26.4; Scipy Version: 	 1.10.1; Cython Version: 	None; Matplotlib Version: 	None; Python Version: 	3.10.14; Number of CPUs: 	12; BLAS Info: 		INTEL MKL; INTEL MKL Ext: 	False; Platform Info: 	Windows (AMD64). **Attempt 1c:**; Conda install mkl; conda install conda-forge::qutip; **Results**; QuTiP Version: 5.0.3; Numpy Version: 2.0.0; Scipy Version: 1.14.0; Cython Version: None; Matplotlib Version: None; Python Version: 3.12.4; Number of CPUs: 12; BLAS Info: Generic; INTEL MKL Ext: False; Platform Info: Windows (AMD64). **Attempt 2:** ; Conda install conda-forge::qutip; **Results**: obtained errors when importing qutip (ImportError: DLL load failed while importing _arpack: The specified module could not be found.). **Attempt 2b:**; Conda install scipy; conda install conda-forge::qutip; **Results:**; QuTiP Version: 5.0.3; Numpy Version: 1.26.4; Scipy Version: 1.10.1; Cython Version: None; Matplotlib Version: None; Python Version: 3.10.14; Number of CPUs: 12; BLAS Info: INTEL MKL; INTEL MKL Ext: False; Platform Info: Windows (AMD64)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2496:2071,load,load,2071,https://qutip.org,https://github.com/qutip/qutip/issues/2496,1,['load'],['load']
Performance,"nly used functions, improvements to F2PY, and better documentation.</p>; <p>The Python versions supported in this release are 3.8-3.10, Python 3.7; has been dropped. Note that 32 bit wheels are only provided for Python; 3.8 and 3.9 on Windows, all other wheels are 64 bits on account of; Ubuntu, Fedora, and other Linux distributions dropping 32 bit support.; All 64 bit wheels are also linked with 64 bit integer OpenBLAS, which should fix; the occasional problems encountered by folks using truly huge arrays.</p>; <h2>Expired deprecations</h2>; <h3>Deprecated numeric style dtype strings have been removed</h3>; <p>Using the strings <code>&quot;Bytes0&quot;</code>, <code>&quot;Datetime64&quot;</code>, <code>&quot;Str0&quot;</code>, <code>&quot;Uint32&quot;</code>,; and <code>&quot;Uint64&quot;</code> as a dtype will now raise a <code>TypeError</code>.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19539"">gh-19539</a>)</p>; <h3>Expired deprecations for <code>loads</code>, <code>ndfromtxt</code>, and <code>mafromtxt</code> in npyio</h3>; <p><code>numpy.loads</code> was deprecated in v1.15, with the recommendation that; users use <code>pickle.loads</code> instead. <code>ndfromtxt</code> and <code>mafromtxt</code> were both; deprecated in v1.17 - users should use <code>numpy.genfromtxt</code> instead with; the appropriate value for the <code>usemask</code> parameter.</p>; <p>(<a href=""https://github-redirect.dependabot.com/numpy/numpy/pull/19615"">gh-19615</a>)</p>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/numpy/numpy/commit/4adc87dff15a247e417d50f10cc4def8e1c17a03""><code>4adc87d</code></a> Merge pull request <a href=""https://github-redirect.dependabot.com/numpy/numpy/issues/20685"">#20685</a> from charris/prepare-for-1.22.0-release</li>; <li><a href=""https://github.com/numpy/numpy/commit/fd66547557f57c430d41be2fc0764f74a62e8ccf""><code>fd6",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1940:2340,load,loads,2340,https://qutip.org,https://github.com/qutip/qutip/pull/1940,1,['load'],['loads']
Performance,numpy as np imported in loadparams,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/321:24,load,loadparams,24,https://qutip.org,https://github.com/qutip/qutip/pull/321,1,['load'],['loadparams']
Performance,"numpy give deprecation warning in some test related to mcsolve:; ```Monte-carlo: Constant H (str format) with no collapse ops (expect) ... /home/ericgig/.local/lib/python3.6/site-packages/qutip-4.4.0.dev0+7af31179-py3.6-linux-x86_64.egg/qutip/mcsolve.py:1152: DeprecationWarning: Calling np.sum(generator) is deprecated, and in the future will give a different result. Use np.sum(np.fromiter(generator)) or the python sum builtin instead.```. I replaced the 2 np.sum causing problem by the python builtin sum. Since we are not doing the sum on a numpy array and it's in the solver setup phase, there is only a negligible effect on performance.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/945:631,perform,performance,631,https://qutip.org,https://github.com/qutip/qutip/pull/945,1,['perform'],['performance']
Performance,"objevo_compiled_coeff_130828459648281117.cp37-win_amd64.exp; Generating code; Finished generating code; cl : Command line warning D9025 : overriding '/W3' with '/w'; cl : Command line warning D9025 : overriding '/Ox' with '/O1'; cqobjevo_compiled_coeff_8398411180025011525.cpp; c:\anaconda\lib\site-packages\numpy\core\include\numpy\npy_1_7_deprecated_api.h(14) : Warning Msg: Using deprecated NumPy API, disable it with #define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION; Creating library C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.lib and object C:\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\Users\Quantro\.pyxbld\temp.win-amd64-3.7\Release\pyrex\cqobjevo_compiled_coeff_8398411180025011525.cp37-win_amd64.exp; Generating code; Finished generating code; Process SpawnPoolWorker-671:; Process SpawnPoolWorker-669:; Traceback (most recent call last):; Traceback (most recent call last):; File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 297, in _bootstrap; self.run(); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\process.py"", line 99, in run; self._target(*self._args, **self._kwargs); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\pool.py"", line 110, in worker; task = get(); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); File ""C:\Anaconda\lib\multiprocessing\queues.py"", line 354, in get; return _ForkingPickler.loads(res); ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'; ModuleNotFoundError: No module named 'cqobjevo_compiled_coeff_130828459648281117'. Note: I have installed qutip using pip installer",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1084:2422,queue,queues,2422,https://qutip.org,https://github.com/qutip/qutip/issues/1084,4,"['load', 'queue']","['loads', 'queues']"
Performance,"ocesses to avoid overwhelming the host system. This approach helps in balancing load and performance. 2. **Error Handling and Robustness**:; - Enhanced the resilience of the parallel computation by encapsulating the worker function’s body in a try-except block, ensuring that failures in one computation do not impact the overall execution.; - Ensured the stability of the test environment by restoring the original function state after the test execution, preventing side effects on subsequent tests. 3. **Testing**:; - **Extended Test Coverage**: Developed new test cases to validate both the parallel and sequential execution paths of the function. Tests ensure that both modes produce equivalent results, thereby confirming that the parallelization did not introduce computational errors.; - **Integration with Existing Tests**: Integrated the new tests into the existing pytest framework used for QuTiP, making use of fixtures and parameterization to test different scenarios and system setups effectively. ### Implementation Details. - **Concurrency**: The parallel execution is managed through a pool of processes, where each process is responsible for a subset of the total computations. This method is particularly effective for operations that can be divided into independent, smaller tasks.; - **Compatibility**: Ensured that the enhancements are backward-compatible with existing code by modifying only the internal execution strategy of the `correlation_2op_1t` function and by maintaining the original API signature.; - **Performance Considerations**: The parallel implementation can significantly reduce computation times, particularly for larger systems or longer `taulist` arrays, by leveraging multiple CPU cores concurrently. ### Conclusion. The enhancements to the `correlation_2op_1t` function in QuTiP are designed to harness the capabilities of modern multi-core processors, thereby improving the efficiency of quantum correlation computations. This is still a WIP enhancement.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2395:2220,Concurren,Concurrency,2220,https://qutip.org,https://github.com/qutip/qutip/pull/2395,3,"['Concurren', 'Perform', 'concurren']","['Concurrency', 'Performance', 'concurrently']"
Performance,"ocessor.py::TestCircuitProcessor::testGetObjevo PASSED [ 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; =============================",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5117,cache,cache,5117,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,optimized bloch_redfield_tensor routine,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/336:0,optimiz,optimized,0,https://qutip.org,https://github.com/qutip/qutip/pull/336,1,['optimiz'],['optimized']
Performance,"or::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, Boxi Li, Jake Lishman and Simon Cross.; Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, Franco",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5379,cache,cache,5379,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,"ouvillians, but dense data for Qobj's that represent Hilbert space states or Density matrices. In fact, it looks like a significant part of the overhead in the [calculation of the Krotov's pulse update](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/optimize.py#L466) is due to the stacking/unstacking, see [`profile.svg`](https://gist.githubusercontent.com/goerz/34af142b78d7e344417d838bbea78aaf/raw/f3f49104083d59b9612f153d2f0ff652ea6a9f01/profile.svg) in the [gist](https://gist.github.com/goerz/34af142b78d7e344417d838bbea78aaf#file-profile-svg). In the benchmarking notebook, for the optimization in `In [34]`, that's the extra 6 seconds per iteration (iterations 1-3 should ideally take exactly twice as long as iteration 0, as iteration 0 is a simple forward propagation and all later iterations are one forward and one backward propagations). That's what we have in our Fortran implementation, too: the runtime of the optimization is basically just the runtime of all the internal propagations; calculating the updates should be completely negligible. There's also [shape conversions](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L254-L260) happening in [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) which would be nice to eliminate. Lastly, having dense internal storage for states might actually give the same speedup as we've demonstrated in https://qucontrol.github.io/krotov/v1.2.1/notebooks/09_example_numpy.html for doing Krotov with numpy arrays instead of Qobj's -- potentially even more speedup, in fact, since with numpy now *everything* is dense (including the Hamiltonian), whereas the best thing to do numerically would be to do sparse-matrix-dense-vector operations (which is what we do in Fortran, incidentally). > In the form I've written it, this loop is thread-safe ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:4238,optimiz,optimization,4238,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['optimiz'],['optimization']
Performance,"p install qutip; ```. ### Code Output. ```shell; Collecting qutip; Using cached qutip-4.6.2.tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmp8u8pmfcw_in_process.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:1560,cache,cached,1560,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"p` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they are not Qobj but support the interface. That is even nicer because we would get to use all of qutip solvers out of the box with our objects.`. ; - So implicitly I do have stated that I'd like to see implicit conversion being performed on high-level methods. I do see benefits for the whole ecosystem if we can start integrating more: qutip already has very advanced and feature-complete solvers, there are large benefits for other packages to exploit them without having to wrap ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1567,perform,perform,1567,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['perform'],['perform']
Performance,"packages/qutip/tests/test_processor.py::TestCircuitProcessor::testGetObjevo PASSED [ 63%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; =",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5089,cache,cache,5089,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cache']
Performance,performance regression in qobj.expm,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/50:0,perform,performance,0,https://qutip.org,https://github.com/qutip/qutip/issues/50,1,['perform'],['performance']
Performance,"plitting the authority component.</li>; </ul>; <p><strong>If you or your organization rely on urllib3 consider supporting us via <a href=""https://github.com/sponsors/urllib3"">GitHub Sponsors</a></strong></p>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/blob/main/CHANGES.rst"">urllib3's changelog</a>.</em></p>; <blockquote>; <h2>1.26.5 (2021-05-26)</h2>; <ul>; <li>Fixed deprecation warnings emitted in Python 3.10.</li>; <li>Updated vendored <code>six</code> library to 1.16.0.</li>; <li>Improved performance of URL parser when splitting; the authority component.</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/urllib3/urllib3/commit/d1616473df94b94f0f5ad19d2a6608cfe93b7cdf""><code>d161647</code></a> Release 1.26.5</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2d4a3fee6de2fa45eb82169361918f759269b4ec""><code>2d4a3fe</code></a> Improve performance of sub-authority splitting in URL</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2698537d52f8ff1f0bbb1d45cf018b118e91f637""><code>2698537</code></a> Update vendored six to 1.16.0</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/07bed791e9c391d8bf12950f76537dc3c6f90550""><code>07bed79</code></a> Fix deprecation warnings for Python 3.10 ssl module</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/d725a9b56bb8baf87c9e6eee0e9edf010034b63b""><code>d725a9b</code></a> Add Python 3.10 to GitHub Actions</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/339ad34c677c98fd9ad008de1d8bbeb9dbf34381""><code>339ad34</code></a> Use pytest==6.2.4 on Python 3.10+</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/f271c9c3149e20d7feffb6429b135bbb6c09ddf4""><code>f271c9c</code></a> Apply latest Black formatting</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/1884878aac87ef0494b282e940c32c24ee917d52""><code>1884878</code>",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1563:1638,perform,performance,1638,https://qutip.org,https://github.com/qutip/qutip/pull/1563,1,['perform'],['performance']
Performance,"produce the Bug. ```shell; python -m pip install -v --upgrade qutip; ```. ### Code Output. ```shell; Using pip 24.0 from /home/defreule/.local/lib/python3.8/site-packages/pip (python 3.8); Defaulting to user installation because normal site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1513,cache,cached,1513,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"ps://github-redirect.dependabot.com/python-pillow/Pillow/issues/5572"">#5572</a> [<a href=""https://github.com/t-vi""><code>@​t-vi</code></a>]</li>; </ul>; <h2>8.3.0</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/8.3.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/8.3.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>Use snprintf instead of sprintf <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5567"">#5567</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit TIFF strip size when saving with LibTIFF <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5514"">#5514</a> [<a href=""https://github.com/kmilos""><code>@​kmilos</code></a>]</li>; <li>Allow ICNS save on all operating systems <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4526"">#4526</a> [<a href=""https://github.com/newpanjing""><code>@​newpanjing</code></a>]</li>; <li>De-zigzag JPEG's DQT when loading; deprecate convert_dict_qtables <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/4989"">#4989</a> [<a href=""https://github.com/gofr""><code>@​gofr</code></a>]</li>; <li>Do not use background or transparency index for new color <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5564"">#5564</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Simplified code <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5315"">#5315</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Replaced xml.etree.ElementTree <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5565"">#5565</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/py",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1654:3255,load,loading,3255,https://qutip.org,https://github.com/qutip/qutip/pull/1654,1,['load'],['loading']
Performance,"py Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</summary>. ```; pip install --verbose qutip; Using pip 24.0 from /tmp/test-venv/lib/python3.8/site-packages/pip (python 3.8); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:2670,cache,cached,2670,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"q__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy transitive equality (i.e. `a == b and b == c` does not imply `a == c`). The pr",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1309,cache,cache,1309,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,2,['cache'],['cache']
Performance,"r current longest tests](https://github.com/qutip/qutip/issues/1217#issuecomment-604116373), bearing in mind that some of those ones actually test many many things in the same test function.; > ; > The test seems structured ok to me. Certainly the testing algorithm isn't the major cause of speed loss. You could try timing some ""real-world"" examples of using your measurements, and try running them in a profiler to see if there are any obvious ways to speed things up.; > ; > With any luck the new data-layer tools and the possibility of using dense `Qobj` storage will give you a fair amount of speed-up once they're complete, since I imagine in your small circuit you're paying quite a lot of sparse matrix overhead.; > ; > I'll prefix this last part with: _you should always profile your code before optimising it_. That said, let me wildly break that rule and guess at where I think you'll find big speed-ups: caching and pre-computation. If you know you're going to run the same thing loads and loads of times, then you shouldn't have to call `self.propagators` each time, or build `measurement_ops` inside `measure_comp_basis`. Do those once at the start of `run_statistics`, and save them.; > ; > Minor things that _may_ speed up - check the profiling!; > ; > 1. ""compress"" the output of `self.propagators`: consecutive propagators with no measurements or classical controls inbetween can be pre-multiplied together at the start to make one matrix. This will save you ~3 matrix multiplications per run in the test.; > 2. use more efficient ways to construct large tensor spaces: `qutip.basis`, `qutip.projection` and `qutip.qeye` can all directly constructor product spaces (e.g. `qutip.basis([2, 2, 2], [0, 1, 0])`). `tensor` is a comparatively expensive operation, and tensoring a list of elements internally is effectively `tensor(...(tensor(tensor(els[0], els[1]), els[2]), ...), els[-1])`. Excellent Suggestions ! I already added some of the speed-ups you suggested, just haven't pushed",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273:1179,load,loads,1179,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640128273,2,['load'],['loads']
Performance,"r to use from a user's perspective, and it's faster than #934 as well. The concept of the precomputed matrix is encapsulated into a class with a cached tensor, so that the same precomputed system can be used for many states of different sizes, and autoexpands (up to the memory limit) to accommodate larger states. This is called `QFunc` as opposed to the standard function interface `qfunc`. It also adds rather more error checking on its inputs, and adds a complete testing suite for the new implementation. Closes #934. ## Examples. Let's say we have some states, and the phase-space coordinates we want to calculate the Husimi Q function at.; ```python; >>> import qutip; >>> states = [qutip.rand_dm(32, density=0.2) for _ in [None]*100]; >>> xs = np.linspace(-2, 2, 401); ```. Now the normal way of calculating the Q distribution for a single state is; ```python; >>> qutip.qfunc(states[0], xs, xs); array( ... ); ```. This already has some speed advantages over the pre-PR version of `qfunc`, because it caches a lot of its intermediary results, to avoid recomputing them. This results in calculating more matrix-vector products than before, but far fewr FLOPS overall. By default, `qfunc` issues a warning if it exceeds a certain amount of memory, and falls back to the low-memory version. You can control this limit with the `precompute_memory` option:; ```python; >>> qutip.qfunc(states[0], xs, xs, precompute_memory=0); qutip/qutip/wigner.py:822: UserWarning: Falling back to iterative algorithm due to lack of memory.; Needed 78.52 MB, but only allowed to use 0.00 MB. Increase `precompute_memory` to raise limit, or; set to `None` to suppress warning.; array( ... ); ```; To suppress the warning, and always use the iterative approach, you can set `precompute_memory=None`. Now, even if you're using the `precompute_memory` option, `qfunc` still can't remember its state between calls. This means it's inefficient. Instead, we can use the `QFunc` class, which adds an extra step (set-up an",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1583:1487,cache,caches,1487,https://qutip.org,https://github.com/qutip/qutip/pull/1583,1,['cache'],['caches']
Performance,"ray. Also make things more efficiently with <code>1 - np.abs(psi_exact.overlap(psi_k))**2</code>. --> **Corrected.**; * [x] More efficiently <code>psi0=qutip.rand_ket(dim)</code>. --> **Corrected.**; * [x] Why compute 3 expectation values if only one is tested?; Also please use the normal <code>assert</code> instead of numpy's <code>assert_</code>. We are slowly removing them since we migrated from unitest to pytest. --> **Now all of them are checked and using <code>asset</code>**. #### <code>krylovsolve.py</code>. * [x] <code>isinstance</code> should be tested first since if it isn't, <code>psi0.isket</code> will raise an error before reaching it. It should raise a <code>TypeError</code>.; * [x] Please raise an error instead of using <code>assert</code>, since it can be suppressed.; * [x] Testing for dims instead of shape would be better. --> **Done.**; * [x] Empty progress bars can be ignored.; * [x] Improve the print at <code>particular_tlist</code> using <code>warnings.warn</code>. Properly describe the warning.; * [x] Swap illinois algorithm with a root finder from scipy. --> **Now using <code>scipy.optimize.root_finder</code>**.; * [x] <code>n_iterations</code> become <code>delta_t</code> when <code>optimizer</code> is called. It does not seems to be an integer so isn't <code>delta_t</code> a better name here? --> **Renamed to <code>delta_t</code>.**; * [x] <code>bound_function</code> seems very generic. Same with <code>optimizer</code>. --> **Renamed to <code>_lanczos_error_equation_to_optimize_delta_t</code> and <code>_optimize_lanczos_timestep_size</code>.**; * [x] numpy's array have a <code>dot</code> method that act the same a sparse array's one. This is not needed.; * [x] The <code>dims</code> of the output are not kept at <code>evolved_states = map(Qobj, evolved_states[1:-1]</code> --> **Separated into two variables. Now dimensions are also be kept.**; * [x] Why make <code>lanczos_algorithm</code> part of the public interface? --> **Mistake; corrected**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233:2105,optimiz,optimize,2105,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1041914233,6,['optimiz'],"['optimize', 'optimizer']"
Performance,"re\include/numpy/__multiarray_api.h:1634:1: warning: '_import_array' defined but not used [-Wunused-function]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c: In function '__pyx_pw_8rhs14883_1cy_td_ode_rhs':; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t_off' may be used uninitialized in this function [-Wmaybe-uninitialized]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_tp' may be used uninitialized in this function [-Wmaybe-uninitialized]; C:\Users\alex.pyxbld\temp.win-amd64-2.7\Release\pyrex\rhs14883.c:2142:11: warning: '__pyx_v_t' may be used uninitialized in this function [-Wmaybe-uninitialized]; ok; correlation: comparing TLS emission correlations (fn-list td format) ... ok; correlation: comparing TLS emission correlations (fn td format) ... ok; Counting statistics: current and current noise in a DQD model ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP and propogator ... ok; Dispersive cQED Setup: compare unitary matrix for ISWAP, SQRTISWAP, ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... C:\Anaconda3\envs\qutip_py2\lib\site-packages\qutip\ptrace.py:111: RuntimeWarning: invalid name encountered in remainder np.fix(counter / np.prod(dims[sel[k + 1:]])), dims[sel[k]]) + 1",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377#issuecomment-148708318:26791,Concurren,Concurrence,26791,https://qutip.org,https://github.com/qutip/qutip/issues/377#issuecomment-148708318,1,['Concurren'],['Concurrence']
Performance,"ream libraries to implement qutip's interface you'd want not to increase their loading times. That would easily be achieved by defining the `__qutip_qobj__` as the entry point of this API. A drawback of this implementation is that it requires the conversion method to be defined on the object itself.; The dispatch-like solution, as was proposed by @hodgestar, is easier to play with, can be defined in a separate file, can be added to a separate package like `netket_qutip_interop` or even using setuptools entry points, though that would add complexity. Again, I'm personally not biased. I would go with option 1 because it's simpler, but I do like the organisational beauty of option 2 (that is used throughout the jax ecosystem). 2. About implicit conversion; - Assume we can distinguish two level of APIs exposed by qutip, similar in spirit to the distinction there is between BLAS and LAPACK. ; - There are low level (BLAS-like) operations on Qobjs such as addition, kron, sum, ecc that are performed repeatedly, can be efficiently implemented only among objects whose data structure is well know. Everything is built on top of those, so they need to be fast with a low overhead. ; - There are higher-level (LAPACK-like) operations on Qobjs, such as `.eigenvalues()` or `eigenstates()`, or `sesolve/mesolve` which are built by combining several low level operations. Their runtime is much higher, and they perform a fair bit of setup/input handling, which comes at the price of some overhead, but which is negligible compared to the runtime cost for most meaningfully large systems. I'd then like to state that; - *I have never suggested to insert a mechanism to insert implicit conversion in the low-level operations.* ; - In this RFC in no way have I proposed to implement implicit conversion anywhere else then were is already done in qutip itself. All I stated was that `I played around with auto-converting input hamiltonians and jump operators in qutip.sesolve and mesolve to Qobj if they ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687:1152,perform,performed,1152,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-913661687,2,['perform'],['performed']
Performance,"reated it --> **Added**; * [x] If tlist is empty, you can just return the empty results. --> **Now it returns an empty <code>Results()</code> instance.**; * [x] Can you use the <code>eigh</code> in <code>qutip.sparse</code> . There is a bug in eigh on mac with openblas. --> **Switched to <code>qutip.sparse.eigh</code>**; * [x] What does this <code>optimizer</code> function optimize? Could you add a simple description. --> **This functions finds the optimal number of Lanczos algorithm iterations inside Krylov, added as small description**; * [x] <code>_estimate_norm</code> is nerver used. --> **Removed**; * [x] Why is tlist here and not in solve? It seems strange that you can reuse one instance for multiple H and psi0, but you cannot change tlist. --> **Removed when deprecating <code>KSolve</code> class**; * [x] Why do you need KSolve? --> **It was a workaround to the cognitive complexity check of github. But we decided to revert back to a non Class solver, as it adds another type of complexity.**; * [x] Increasing pdx here when it is already controlled by enumerate is strange. The best would be to include the first partition here too. Otherwise using update_progress_bar(pdx + 1) is clearer. --> **Changed ""pdx"" into ""idx"". Added the first lazy iteration inside the loop, now it is more clear with <code>update_progress_bar(idx)</code>.**; * [x] There is no work done between update_progress_bar(0) and update_progress_bar(1). Did you start it? --> **Fixed simultaneously by the previous change.**; * [x] Shouldn't this also double the last element? prepare_next_step remove the first and last so the last state is not stored. --> **Good catch, it was a bug. Fixed.**; * [x] <code>_happy_breadkown</code> never used... --> **Should be fixed, performing extra checks**; * [x] evolved states It should keep the input state dims. --> **Checked all situations that came to mind and output dimensions seem to be working properly.**; * [x] Why import <code>mcsolve</code>? --> **Removed**",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650:3547,perform,performing,3547,https://qutip.org,https://github.com/qutip/qutip/pull/1739#issuecomment-1039192650,2,['perform'],['performing']
Performance,"rements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 setuptools-69.5.1 wheel-0.43.0; Installing build dependencies ... done; Running command Getting requirements to build wheel; Compiling qutip/core/data/dia.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/data/tidyup.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/scipy/linalg.pxd.; Compiling qutip/core/cy/qobjevo.pyx because it depends on /tmp/pip-build-env-50cuuv9x/overlay/lib/python3.8/site-packages/Cython/Includes/numpy/__init__.pxd.; Compiling qutip/core/data/mul.pyx because it depends on /tmp/pi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:4248,cache,cached,4248,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"rements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Installing collected packages: wheel, setuptools, packaging, numpy, cython, scipy, oldest-supported-numpy; ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.; launchpadlib 1.10.13 requires testresources, which is not installed.; awkward-cpp 26 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; awkward 2.5.0 requires numpy>=1.18.0, but you have numpy 1.17.3 which is incompatible.; matplotlib 3.7.4 requires numpy<2,>=1.20, but you have numpy 1.17.3 which is incompatible.; pandas 2.0.3 requires numpy>=1.20.3; python_version < ""3.10"", but you have numpy 1.17.3 which is incompatible.; Successfully installed cython-3.0.2 numpy-1.17.3 oldest-supported-numpy-2023.12.21 packaging-24.0 scipy-1.8.1 s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:3188,cache,cached,3188,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"resentation on the FOSDEM; > conference may help you get an overview (; > https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the; > Github Project page for a collection of related issues and ongoing Pull; > Requests.; >; > ### Expected outcomes; > - More devices defined in the `qutip.qip.device` module. At the moment, we; > have two models: spin chain and cavity QED. We would like to include some; > other commonly used planform such as Superconducting system, Ion trap; > system or silicon system. Each model will need a new set of control; > hamiltonian and a compiler that find the control pulse of a quantum gate.; > This part is gonna involve some physics and study of commonly used hardware; > platforms. The related code can be found in `qutip.qip.device` and; > `qutip.qip.compiler`; > - Refactoring the circuit compiler to allow simple pulse scheduling, e.g.; > Restriction one pulses that can be turned on at the same time.; > - Features to perform error mitigation techniques in QuTiP, such as; > zero-error extrapolation.; > - APIs to allow import quantum circuits from other software packages or; > commonly used language e.g. through quantum assembly language (qasm); > ----------------------------------------------------------------; >; > Best; > Boxi; >; > From: Nathan Shammah<mailto:notifications@github.com>; > Sent: Tuesday, February 25, 2020 8:36 AM; > To: qutip/qutip<mailto:qutip@noreply.github.com>; > Cc: Boxi Li<mailto:etamin1201@gmail.com>; Author<mailto:; > author@noreply.github.com>; > Subject: Re: [qutip/qutip] More detailed information for GSoC 2020 project; > (#1184); >; > Hi Boxi,; >; > Can you please modify the projects of the Wiki page as you deem best?; > All: we can also think of changing the order of them. It may be that; > project #3 is deemed the most important.; >; > Best wishes,; >; > Nathan; >; > Dr. Nathan Shammah; > Postdoctoral Research Scientist; > Theoretical Quantum Physics Laboratory; > RIKEN, Wako, Saitama, Japan; > www.n",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553:2893,perform,perform,2893,https://qutip.org,https://github.com/qutip/qutip/issues/1184#issuecomment-590741553,2,['perform'],['perform']
Performance,rhs module load error - testing on Windows,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/728:11,load,load,11,https://qutip.org,https://github.com/qutip/qutip/issues/728,1,['load'],['load']
Performance,"rimsmo.; Currently developed through wide collaboration. See https://github.com/qutip for details. QuTiP Version: 4.7.1; Numpy Version: 1.25.0; Scipy Version: 1.10.1; Cython Version: None; Matplotlib Version: 3.7.1; Python Version: 3.9.6; Number of CPUs: 10; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (arm64); Installation path: /Users/guglielmo2/Library/Python/3.9/lib/python/site-packages/qutip; ================================================================================; Please cite QuTiP in your publication.; ================================================================================; For your convenience a bibtex reference can be easily generated using `qutip.cite()`; ================================================================== test session starts ===================================================================; platform darwin -- Python 3.9.6, pytest-7.3.2, pluggy-1.2.0 -- /Applications/Xcode.app/Contents/Developer/usr/bin/python3; cachedir: .pytest_cache; rootdir: /Users/guglielmo2; collected 2814 items / 30 errors / 51 deselected / 2763 selected . ========================================================================= ERRORS =========================================================================; _________________________________ ERROR collecting Library/Python/3.9/lib/python/site-packages/qutip/tests/test_graph.py _________________________________; ImportError while importing test module '/Users/guglielmo2/Library/Python/3.9/lib/python/site-packages/qutip/tests/test_graph.py'.; Hint: make sure your test modules/packages have valid Python names.; Traceback:; /Applications/Xcode.app/Contents/Developer/Library/Frameworks/Python3.framework/Versions/3.9/lib/python3.9/importlib/__init__.py:127: in import_module; return _bootstrap._gcd_import(name[level:], package, level); Library/Python/3.9/lib/python/site-packages/qutip/tests/test_graph.py:3: in <module>; from numpy.testing import run_module_suite",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2180:1833,cache,cachedir,1833,https://qutip.org,https://github.com/qutip/qutip/issues/2180,1,['cache'],['cachedir']
Performance,"rintout of the optimized controls, I receive the following terminal output error:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 59, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 829, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 510, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 970, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 375, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 448, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 458, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 474, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1421, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 299, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/propcom",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617:4720,optimiz,optimizer,4720,https://qutip.org,https://github.com/qutip/qutip/issues/1617,1,['optimiz'],['optimizer']
Performance,"rix multiplications, taking advantage the new Dense data layer. In particular, for cases where the density matrix/state has few zero's, and we want to multiply a local operator (e.g. one acting on only a small subset of the full system), this routine is expected to be faster. **What is does**; Using some standard tools, such as NumPy's einsum one can compute the local matrix operation directly, i.e. applying a one or two-local gate on a Qobj of many qubits. This is only really useful if one uses the Dense data layer, since otherwise there are conversion overheads which kill any speed-up (at the end of the day, we need NumPy arrays). The code has two 'backends', one using einsum as mentioned, and another using what I call a 'vectorization' approach (where the density matrix or vector is reshaped to a vector over the target qubits). Note: It will work on qudits in general (does not have to be qubits). **Performance**; I find, in systems where the state is dense (few zeros), one can get a speed-up of between 2 and up to around 10x faster (depends on the size and system etc). Of course, sometimes using the standard built in sparse routines are faster, so it really depends what one is doing. Attached is a wall-clock time comparison between the standard sparse way for a 1-local multiplication on a vector (using `gate_expand_1toN`), and the added code (dense local). N being the number of qubits. Here I made things as hard as possible for the sparse routine (all elements non-zero), so this is probably the limit of the speed-up. ![1_local_vector_adaptive_backend](https://user-images.githubusercontent.com/47875526/101932409-91f44900-3b8f-11eb-8b5b-7a00dabec2e4.png). **Other notes**; 1. I am a contractor for NASA, and they required a slight change to the license for the code I added. This is why I made two new files for this work specifically (instead of putting it in e.g. gates.py), which now includes a Copyright NASA sentence. I will talk privately with someone about this. 2",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1405:1152,Perform,Performance,1152,https://qutip.org,https://github.com/qutip/qutip/pull/1405,1,['Perform'],['Performance']
Performance,"ronment, doing `pip install qutip` will cause the error. ```; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. I know this is quite an old OS and Python version, but that's what I have available. Numpy 1.24 should be supported in Python 3.8.10. ### Code to Reproduce the Bug. ```shell; $ python3 -m venv /tmp/test-venv. $ source /tmp/test-venv/bin/activate. $ pip install --upgrade pip; Collecting pip; Using cached pip-24.0-py3-none-any.whl (2.1 MB); Installing collected packages: pip; Attempting uninstall: pip; Found existing installation: pip 20.0.2; Uninstalling pip-20.0.2:; Successfully uninstalled pip-20.0.2; Successfully installed pip-24.0. $ pip list; Package Version; ------------- -------; pip 24.0; pkg_resources 0.0.0; setuptools 44.0.0. $ pip install qutip; Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Installing build dependencies ... done; Getting requirements to build wheel ... done; ERROR: Some build dependencies for qutip from https://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19.; ```. ### Code Output. _No response_. ### Expected Behaviour. Qutip should install normally. ### Your Environment. ```shell; QuTiP Version: 5.0.1; Numpy Version: (1.17.3) (apparently this is the version it's trying to install); Scipy Version: (1.10.1); Cython Version: (3.0.2); Matplotlib Version: -; Python Version: 3.8.10; Number of CPUs: 16; BLAS Info: OPENBLAS; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Linux (x86_64) (Ubuntu 20.04.6 LTS); ```. ### Additional Context. Here's the output of `pip install --verbose qutip`, not sure if it's of any help. <details><summary>Output</s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:1060,cache,cached,1060,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"s://files.pythonhosted.org/packages/43/41/cae32aa94bfe0b22d2aec9392b2676210e5473ce097b10c689297b254a80/qutip-5.0.1.tar.gz conflict with the backend dependencies: numpy==1.17.3 is incompatible with numpy>=1.19` this is due to the fact that on this platform `oldest-supported-numpy` (from `pyproject.toml`) defaults to 1.17.3, but `setup.cfg` requires `numpy>=1.19`. ### Code to Reproduce the Bug. ```shell; python -m pip install -v --upgrade qutip; ```. ### Code Output. ```shell; Using pip 24.0 from /home/defreule/.local/lib/python3.8/site-packages/pip (python 3.8); Defaulting to user installation because normal site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of s",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1133,cache,cached,1133,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"s://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmp8u8pmfcw_in_process.py build_wheel /var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/tmpcrdfx79e; cwd: /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-install-cp5z29tf/numpy_1458b1f38a5449d18aa77b5bb31c63d1; Complete output (881 lines):; Running from numpy source directory.; numpy/random/_bounded_integers.pxd.in has not changed; numpy/random/_philox.pyx has not changed; numpy/random/_bounded_integers.pyx.in has not changed; numpy/random/_sfc64.pyx has not changed; numpy/random/_mt19937.pyx has not changed; numpy/random/bit_generator.pyx has not changed; Processing numpy/random/_bounded_in",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:2145,cache,cached,2145,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"s` format. Operators are used to represent operators and super-operators acting on hilbert spaces. We use a very custom format roughly corresponding to a lazy kronecker product. Those object satisfy the numpy `__array__` interface and can be converted by calling `np.array(netket_operator)` or `np.asarray(netket_operator)`. We can also obtain sparse representations (but there is no nice api to do that, so we simply provide a method `netket_operator.to_sparse()`. Variational states can also be converted to vectors or matrices (kets and density operators) as they also support the `__array__` interface. I would like our users to be able to call `Qobj(netket_operator)` or `Qobj(netket_state)` and obtain the corresponding qutip object. We could, in principle support a `netket_operator.to_qobj()` conversion method, but I am strongly opposed to that as this is an ugly design pattern: a way to construct a `Qobj` already exists, it's `Qobj(...)`, and the simplest-to-use api is, in my opinion, to overload this constructor to perform the conversion.; This is a standard design pattern in Julia, which I believe has the best ecosystem inter-compatibility thanks to a standardisation of this pattern through (multiple)dispatch. Numpy too, does the same, through the `__array__` interface: any object that defines a `__array__(self, dtype=None)->np.ndarray` method will be supported by `np.asarray` and `np.array`. Proposal: I would like QuTiP to support a `__qobj__` interface, meaning that your `Qobj` constructor should check if an object has this method, and if it has, then use it to convert it to a Qobj.; It should be relatively simple and involve adding another else-if in [your constructor](https://github.com/qutip/qutip/blob/624405e7c49f7c25d0623451cff5a5a5d0544559/qutip/qobj.py#L333). ```; if isinstance(inpt, Qobj):; ...; elif inpt is None:; ...; ...; elif hasattr(inpt, ""__qobj__""):; data = input.__qobj(options); self.shape = data.shape; ...; ```; The only thing to do would be discu",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508:1932,perform,perform,1932,https://qutip.org,https://github.com/qutip/qutip/issues/1508,1,['perform'],['perform']
Performance,"setuptools-69.5.1-py3-none-any.whl.metadata (6.2 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-69.5.1-py3-none-any.whl (894 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Instal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2412:3414,cache,cached,3414,https://qutip.org,https://github.com/qutip/qutip/issues/2412,1,['cache'],['cached']
Performance,"setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.3-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Using cached scipy-1.9.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.9.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (2.2 kB); Using cached setuptools-70.0.0-py3-none-any.whl (863 kB); Using cached packaging-24.0-py3-none-any.whl (53 kB); Using cached wheel-0.43.0-py3-none-any.whl (65 kB); Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (3.6 MB); Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl (4.9 kB); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl (20.5 MB); Using cached scipy-1.8.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (41.6 MB); Instal",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:2354,cache,cached,2354,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,"sh function must follow from there are; 1. objects which compare equal with `__eq__` have the same hash; 2. the hash of an object cannot change after instantiation (no mutable types). Unfortunately we fail on both points. `Qobj.__eq__` is a rounding match, because it gives a total `True` or `False` based on a floating point tolerance, not on exact equality. I'm not aware of any hash function which can handle this. Second, the `data` attribute of a `Qobj` is mutable in-place, and so hashing based on the data in the object is not valid. This is the same reason that `list` and `np.ndarray` are also not hashable types. If your cache is just for memoisation over a small number of `Qobj` where you know that floating-point tolerance will never be an issue, you may be able to get away with rolling your own cache decorator which uses linear lookup rather than constant-time. I mean something like; ```python; In [1]: import functools; ...: import qutip; ...:; ...: def linear_cache(f):; ...: cache = []; ...: @functools.wraps(f); ...: def out(*args):; ...: for cached_args, cached_value in cache:; ...: if args == cached_args:; ...: print(""Getting from cache""); ...: return cached_value; ...: print(""Computing new value""); ...: value = f(*args); ...: cache.append((args, value)); ...: return value; ...: return out; ...:; ...: @linear_cache; ...: def negate(x):; ...: return -x; ...:; ...: sx = qutip.sigmax(); ...: sy = qutip.sigmay(); ...: negate(sx); ...: negate(sx); ...: negate(sy); ...: negate(sx); ...: negate(sy); Computing new value; Getting from cache; Computing new value; Getting from cache; Getting from cache; ```; This will lead to degraded performance if you need to do it for a large number of possible inputs, but if you have a relatively small number of inputs and your cached function is computationally expensive, this may be a way to achieve what you want. Also note that this is not infallible: the floating-point tolerance used in `__eq__` means that `Qobj` does not satisfy",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277:1211,cache,cache,1211,https://qutip.org,https://github.com/qutip/qutip/issues/1321#issuecomment-658078277,2,['cache'],['cache']
Performance,"sounds good to me. On 10 Jan 2017 07:30, ""Paul Nation"" <notifications@github.com> wrote:. > A faster isherm function. 3-5x faster if operator is Hermitian, 100x+; > faster if not. Essentially does a modified adjoint calculation. This; > requires having a csr matrix in canonical format, which is not guaranteed; > under sparse multiplication. Since canonical format is important for; > time-dependent dynamics as well, fast_csr_matrix now does the indices and; > data sorting for canonical format after multiplication. This gives a slight; > performance hit, but having all Qobj in canonical format outweighs this.; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/qutip/qutip/pull/629; > Commit Summary; >; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - Merge remote-tracking branch 'qutip/master'; > - ENH: Faster isherm; >; > File Changes; >; > - *M* qutip/cy/spmath.pyx; > <https://github.com/qutip/qutip/pull/629/files#diff-0> (82); >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/629#issuecomment-271928375:542,perform,performance,542,https://qutip.org,https://github.com/qutip/qutip/pull/629#issuecomment-271928375,1,['perform'],['performance']
Performance,"ssues/1268#issue-619006856)), which can get a bit messy, as there's Python's `random`, NumPy's `random` (which also comes in a legacy and a modern flavour, namely `numpy.random.RandomState` and `numpy.random.Generator`). Also, as you've mentioned, there's tight coupling between the implementation logic and the corresponding set of tests, and updates in the former require constant maintenance of the latter.; - As an alternative, I've sometimes resorted to [`mock`](https://docs.python.org/3/library/unittest.mock.html)ing the random-number generation process itself, and - in a way equivalent to using a fixed seed - providing a pre-defined sequence of numbers to the functions which depend on those. It comes with the same disadvantage of relatively tight coupling, but is somehow more flexible and powerful than just setting the seeds.; - I have used Hypothesis in the past (on a relatively small-scale project), and it's indeed a great framework with a lot of interesting and nice functionalities. I like it very much, but one disadvantage I ran into was the increased overall time for completion of a test run. In my case, a viable approach, for instance, was to run my Hypothesis tests (which were a subset of all tests) with a bit larger periodicity (in the CI pipeline) than the regular tests. Another concern that I intuitively have (I may be _wildly_ wrong on this one, though, not having yet properly explored QuTiP's testing landscape) is that - depending on how some Hypothesis tests are set up - there might be a cost incurred in that, eventually, one might have to implement guards against inputs, that would be virtually impossible (or very close to that) to occur in practical scenarios. In any case, I'd strongly recommend performing a time-boxed experiment on a small subset of tests, which are more suited to property-based testing, and examining how that affects the test-run-completion time(s) and whether it introduces more failures than what would be desired/cost-efficient.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707:3063,perform,performing,3063,https://qutip.org,https://github.com/qutip/qutip/issues/1268#issuecomment-1123679707,2,['perform'],['performing']
Performance,"st_processor.py::TestCircuitProcessor::testNoise PASSED [ 72%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testMultiLevelSystem PASSED [ 81%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testDrift PASSED [ 90%]; ../../usr/lib/python3/dist-packages/qutip/tests/test_processor.py::TestCircuitProcessor::testChooseSolver PASSED [100%]. ================================================================================================ warnings summary =================================================================================================; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122; /usr/lib/python3/dist-packages/_pytest/stepwise.py:122: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/stepwise; self.config.cache.set(""cache/stepwise"", []). /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396; /usr/lib/python3/dist-packages/_pytest/cacheprovider.py:396: PytestCacheWarning: could not create cache path /usr/lib/python3/dist-packages/qutip/tests/.pytest_cache/v/cache/nodeids; config.cache.set(""cache/nodeids"", sorted(self.cached_nodeids)). -- Docs: https://docs.pytest.org/en/stable/warnings.html; ========================================================================================= 11 passed, 2 warnings in 0.84s ==========================================================================================; XIO: fatal IO error 0 (Success) on X server "":1029""; after 366 requests (352 known processed) with 19 events remaining.; $ echo $?; 1; ```. **Expected behavior**. The XIO error should not be triggered. Exit value should be 0 not 1. **Your Environment**. Linux (Debian unstable). ```; $ python3 -c ""import qutip; qutip.about()"". QuTiP: Quantum Toolbox in Python; ================================; Copyright (c) QuTiP team 2011 and later.; Current admin team: Alexander Pitchford, Nathan Shammah, Shahnawaz ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639:5250,cache,cacheprovider,5250,https://qutip.org,https://github.com/qutip/qutip/issues/1639,1,['cache'],['cacheprovider']
Performance,"tation</strong></p>; <ul>; <li>Various typo fixes and doc improvements.</li>; </ul>; <p><strong>Packaging</strong></p>; <ul>; <li>Requests has started adopting some modern packaging practices.; The source files for the projects (formerly <code>requests</code>) is now located; in <code>src/requests</code> in the Requests sdist. (<a href=""https://redirect.github.com/psf/requests/issues/6506"">#6506</a>)</li>; <li>Starting in Requests 2.33.0, Requests will migrate to a PEP 517 build system; using <code>hatchling</code>. This should not impact the average user, but extremely old; versions of packaging utilities may have issues with the new packaging format.</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/psf/requests/commit/d6ebc4a2f1f68b7e355fb7e4dd5ffc0845547f9f""><code>d6ebc4a</code></a> v2.32.0</li>; <li><a href=""https://github.com/psf/requests/commit/9a40d1277807f0a4f26c9a37eea8ec90faa8aadc""><code>9a40d12</code></a> Avoid reloading root certificates to improve concurrent performance (<a href=""https://redirect.github.com/psf/requests/issues/6667"">#6667</a>)</li>; <li><a href=""https://github.com/psf/requests/commit/0c030f78d24f29a459dbf39b28b4cc765e2153d7""><code>0c030f7</code></a> Merge pull request <a href=""https://redirect.github.com/psf/requests/issues/6702"">#6702</a> from nateprewitt/no_char_detection</li>; <li><a href=""https://github.com/psf/requests/commit/555b870eb19d497ddb67042645420083ec8efb02""><code>555b870</code></a> Allow character detection dependencies to be optional in post-packaging steps</li>; <li><a href=""https://github.com/psf/requests/commit/d6dded3f00afcf56a7e866cb0732799045301eb0""><code>d6dded3</code></a> Merge pull request <a href=""https://redirect.github.com/psf/requests/issues/6700"">#6700</a> from franekmagiera/update-redirect-to-invalid-uri-test</li>; <li><a href=""https://github.com/psf/requests/commit/bf24b7d8d17da34be720c19e5978b2d3bf94a53b""><code>bf24b7d</code></a> Use an ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:7816,concurren,concurrent,7816,https://qutip.org,https://github.com/qutip/qutip/pull/2434,2,"['concurren', 'perform']","['concurrent', 'performance']"
Performance,"te` has properties `rhs: QobjEvo`, `state: Qobj`, `time: float` (`sesolve_prepare_ode` and `mcsolve_prepare_ode` would presumably return the same object, or a derived object). Then we'd have an `Integrator` class, which encapsulates an integration step using whatever integrator of choice, so there's one that encapsulates the scipy integrator, one which is a Cython-ised RK4 implementation, etc. Then the low-level user would simply write the `for time in times` loop themselves; at this level, there's nothing fancy that QuTiP adds, so we may as well just expose it directly. That sounds like the exact right solution! ;-). > I think this architecture is approximately what Eric had in mind too, though I presumably haven't used the same names. Yeah, I think we're actually all on the same page, irrespective of minor implementation/naming details: Have an object that keeps internal state of `mesolve` and allows to advance step-by-step. Personally, I like the naming of `MeSolver` that @Ericgig wrote out in https://github.com/qutip/qutip/issues/1571#issuecomment-858740451, but `mesolve_prepare_ode`/`OdeState` works too. @Ericgig in https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:. > Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. If you can point me to any thread-safe solver, I'd love to try that out. As already discussed above, if I can replace [`scipy.integrate.ode`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L312) in Krotov's [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) with something that's reentrant so I don't have to [re-initialize the integrator in every time step](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L244) , that might be a significant performance boost already.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:13598,perform,performance,13598,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['perform'],['performance']
Performance,"th numpy>=1.19` this is due to the fact that on this platform `oldest-supported-numpy` (from `pyproject.toml`) defaults to 1.17.3, but `setup.cfg` requires `numpy>=1.19`. ### Code to Reproduce the Bug. ```shell; python -m pip install -v --upgrade qutip; ```. ### Code Output. ```shell; Using pip 24.0 from /home/defreule/.local/lib/python3.8/site-packages/pip (python 3.8); Defaulting to user installation because normal site-packages is not writeable; Requirement already satisfied: qutip in /usr/local/lib/python3.8/dist-packages (4.7.3); Link requires a different Python (3.8.10 not in: '>=3.9'): https://files.pythonhosted.org/packages/73/73/abcc185174ac6dbc7965e5aeb9418c163eafda704008ee795ee9cdc75e4a/qutip-5.0.2.tar.gz (from https://pypi.org/simple/qutip/) (requires-python:>=3.9); Collecting qutip; Using cached qutip-5.0.1.tar.gz (6.4 MB); Running command pip subprocess to install build dependencies; Ignoring cython: markers 'python_version >= ""3.10""' don't match your environment; Collecting setuptools; Using cached setuptools-70.0.0-py3-none-any.whl.metadata (5.9 kB); Collecting packaging; Using cached packaging-24.0-py3-none-any.whl.metadata (3.2 kB); Collecting wheel; Using cached wheel-0.43.0-py3-none-any.whl.metadata (2.2 kB); Collecting cython<3.0.3,>=0.29.20; Using cached Cython-3.0.2-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (3.1 kB); Collecting oldest-supported-numpy; Using cached oldest_supported_numpy-2023.12.21-py3-none-any.whl.metadata (9.8 kB); Collecting scipy>=1.8; Using cached scipy-1.10.1-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (58 kB); Collecting numpy==1.17.3 (from oldest-supported-numpy); Using cached numpy-1.17.3-cp38-cp38-manylinux1_x86_64.whl.metadata (2.0 kB); INFO: pip is looking at multiple versions of scipy to determine which version is compatible with other requirements. This could take a while.; Collecting scipy>=1.8; Using cached scipy-1.10.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x8",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2440:1342,cache,cached,1342,https://qutip.org,https://github.com/qutip/qutip/issues/2440,1,['cache'],['cached']
Performance,tip.tests.test_dimensions.test_deep_remove ... ok; qutip.tests.test_dimensions.test_unflatten ... ok; qutip.tests.test_dimensions.test_dims_idxs_to_tensor_idxs ... ok; qutip.tests.test_dimensions.test_dims_to_tensor_shape ... ok; qutip.tests.test_dimensions.test_type_from_dims ... ok; qutip.tests.test_dimensions.test_collapse ... ok; Diagonalization of random two-level system ... ok; Diagonalization of composite systems ... ok; Excitation-number-restricted state-space: full state space ... ok; Excitation-number-restricted state space: single excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and ket ... ok; expect: operator list and state ... ok; expect: operator list and state list ... ok; expect: operator and state list ... ok; fastsparse: fast_csr_matrix operations ... ok; fastsparse: transpose operations ... ok; fastsparse: adjoint operations ... ok; Read and write complex valued decimal formatted data ... ok; Read and write complex valued default formatted data ... ok; Read and write complex valued exp formatted data ... ok; Read and write real valued decimal formatted data ... ok; Read and write real valued default formatted data ... ok; Read and write real valued exp formatted data ... ok; Read and write with automatic separator detection ... ok; qsave/qload ... ok; Floquet: test unitary evolution of time-dependent two-level system ... o,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:7564,Concurren,Concurrence,7564,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,1,['Concurren'],['Concurrence']
Performance,to reduce load on travis system and shorten test times ?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/289:10,load,load,10,https://qutip.org,https://github.com/qutip/qutip/pull/289,1,['load'],['load']
Performance,"tps://github.com/psf/requests) from 2.31.0 to 2.32.0.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/psf/requests/releases"">requests's releases</a>.</em></p>; <blockquote>; <h2>v2.32.0</h2>; <h2>2.32.0 (2024-05-20)</h2>; <h2>🐍 PYCON US 2024 EDITION 🐍</h2>; <p><strong>Security</strong></p>; <ul>; <li>Fixed an issue where setting <code>verify=False</code> on the first request from a; Session will cause subsequent requests to the <em>same origin</em> to also ignore; cert verification, regardless of the value of <code>verify</code>.; (<a href=""https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56"">https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56</a>)</li>; </ul>; <p><strong>Improvements</strong></p>; <ul>; <li><code>verify=True</code> now reuses a global SSLContext which should improve; request time variance between first and subsequent requests. It should; also minimize certificate load time on Windows systems when using a Python; version built with OpenSSL 3.x. (<a href=""https://redirect.github.com/psf/requests/issues/6667"">#6667</a>)</li>; <li>Requests now supports optional use of character detection; (<code>chardet</code> or <code>charset_normalizer</code>) when repackaged or vendored.; This enables <code>pip</code> and other projects to minimize their vendoring; surface area. The <code>Response.text()</code> and <code>apparent_encoding</code> APIs; will default to <code>utf-8</code> if neither library is present. (<a href=""https://redirect.github.com/psf/requests/issues/6702"">#6702</a>)</li>; </ul>; <p><strong>Bugfixes</strong></p>; <ul>; <li>Fixed bug in length detection where emoji length was incorrectly; calculated in the request content-length. (<a href=""https://redirect.github.com/psf/requests/issues/6589"">#6589</a>)</li>; <li>Fixed deserialization bug in JSONDecodeError. (<a href=""https://redirect.github.com/psf/requests/issues/6629"">#6629</a>)</li>; <li>Fixed bug where an ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:999,load,load,999,https://qutip.org,https://github.com/qutip/qutip/pull/2434,1,['load'],['load']
Performance,"turn same result, ... ok; > > > Non-composite system, operator on Hilbert space. ... ok; > > > Non-composite system, operator on Liouville space. ... ok; > > > Superoperator: Converting superoperator to Choi matrix and back. ... ok; > > > Superoperator: Test that to_choi(q) returns q if q is already Choi. ... ok; > > > Superoperator: Test that converting a two-qubit superoperator through ... /usr/local/lib/python2.7/dist-packages/qutip/qobj.py:412: UserWarning: Multiplying superoperators with different representations; > > > warnings.warn(msg); > > > ok; > > > Superoperator: Converting superoperator to Choi matrix and back. ... ok; > > > Superoperator: Test that to_super(q) returns q if q is already a ... ok; > > > Superoperator: Checks that the trace of matrices returned by to_choi ... ok; > > > Superoperator: Checks that iscp, istp and iscptp work in a few different ... ok; > > > Superoperator: Checks that randomly generated superoperators are ... ok; > > > Superoperator: Randomized comparison of standard and optimized ... ok; > > > Superoperator: Conversion matrix to vector to matrix ... ok; > > > Superoperator: Test unitary transformation with operators and superoperators. ... ok; > > > Superoperator: Test compability between matrix/vector conversion and ... ok; > > > Superoperator: Conversion between matrix and vector indices ... ok; > > > Superoperator: Conversion vector to matrix to vector ... ok; > > > qutip.tests.test_superoperator.TestMatrixVector.test_reshuffle ... ok; > > > utilities: energy unit conversions ... ok; > > > wigner: test wigner function calculation for coherent states ... ok; > > > wigner: test wigner function calculation for Fock states ... ok; > > > wigner: compare wigner methods for random density matrices ... ok; > > > wigner: compare wigner methods for random state vectors ... ok; > > > Wigner: Compare Wigner fft and iterative for rand. ket ... ok; > > > Wigner: Compare Wigner fft and iterative for rand. dm ... ok. # . ## ERROR: Qobj ad",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/126#issuecomment-42855884:11083,optimiz,optimized,11083,https://qutip.org,https://github.com/qutip/qutip/issues/126#issuecomment-42855884,2,['optimiz'],['optimized']
Performance,"uilds correctly (then I get same problem as Issue #1606 when importing, but that's another story). ### Code to Reproduce the Bug. ```shell; conda create -n qutip_test; pip install qutip; ```. ### Code Output. ```shell; Collecting qutip; Using cached qutip-4.6.2.tar.gz (3.4 MB); Installing build dependencies ... error; ERROR: Command errored out with exit status 1:; command: /opt/homebrew/Caskroom/miniforge/base/envs/qutip_test/bin/python3.9 /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-standalone-pip-g3h2vfu_/__env_pip__.zip/pip install --ignore-installed --no-user --prefix /private/var/folders/kj/vdvd_3693992wc4c9gm79hdr0000gn/T/pip-build-env-m9x0lkny/overlay --no-warn-script-location --no-binary :none: --only-binary :none: -i https://pypi.org/simple -- setuptools packaging wheel 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'; cwd: None; Complete output (912 lines):; Collecting setuptools; Using cached setuptools-59.5.0-py3-none-any.whl (952 kB); Collecting packaging; Using cached packaging-21.3-py3-none-any.whl (40 kB); Collecting wheel; Using cached wheel-0.37.0-py2.py3-none-any.whl (35 kB); Collecting cython>=0.29.20; Using cached Cython-0.29.25-py2.py3-none-any.whl (983 kB); Collecting numpy<1.20,>=1.16.6; Using cached numpy-1.19.5.zip (7.3 MB); Installing build dependencies: started; Installing build dependencies: finished with status 'done'; Getting requirements to build wheel: started; Getting requirements to build wheel: finished with status 'done'; Preparing metadata (pyproject.toml): started; Preparing metadata (pyproject.toml): finished with status 'done'; Collecting scipy>=1.0; Using cached scipy-1.7.3-1-cp39-cp39-macosx_12_0_arm64.whl (27.0 MB); Collecting pyparsing!=3.0.5,>=2.0.2; Using cached pyparsing-3.0.6-py3-none-any.whl (97 kB); Building wheels for collected packages: numpy; Building wheel for numpy (pyproject.toml): started; Building wheel for numpy (pyproject.toml): finished with status 'error'; ERROR: Command errored out ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1740:1404,cache,cached,1404,https://qutip.org,https://github.com/qutip/qutip/issues/1740,1,['cache'],['cached']
Performance,"uot; was not working.</li>; <li>Fix typing error for codec encoding</li>; <li>&quot;setup.cfg&quot; has been added for this release due to some downstream; lack of adherence to PEP 517. Should be removed in a future release; so please prepare accordingly.</li>; <li>Removed reliance on a symlink for the &quot;idna-data&quot; tool to comport; with PEP 517 and the Python Packaging User Guide for sdist archives.</li>; <li>Added security reporting protocol for project</li>; </ul>; <p>Thanks Jon Ribbens, Diogo Teles Sant'Anna, Wu Tingfeng for contributions; to this release.</p>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/kjd/idna/commit/1d365e17e10d72d0b7876316fc7b9ca0eebdd38d""><code>1d365e1</code></a> Release v3.7</li>; <li><a href=""https://github.com/kjd/idna/commit/c1b3154939907fab67c5754346afaebe165ce8e6""><code>c1b3154</code></a> Merge pull request <a href=""https://redirect.github.com/kjd/idna/issues/172"">#172</a> from kjd/optimize-contextj</li>; <li><a href=""https://github.com/kjd/idna/commit/0394ec76ff022813e770ba1fd89658790ea35623""><code>0394ec7</code></a> Merge branch 'master' into optimize-contextj</li>; <li><a href=""https://github.com/kjd/idna/commit/cd58a23173d2b0a40b95ee680baf3e59e8d33966""><code>cd58a23</code></a> Merge pull request <a href=""https://redirect.github.com/kjd/idna/issues/152"">#152</a> from elliotwutingfeng/dev</li>; <li><a href=""https://github.com/kjd/idna/commit/5beb28b9dd77912c0dd656d8b0fdba3eb80222e7""><code>5beb28b</code></a> More efficient resolution of joiner contexts</li>; <li><a href=""https://github.com/kjd/idna/commit/1b121483ed04d9576a1291758f537e1318cddc8b""><code>1b12148</code></a> Update ossf/scorecard-action to v2.3.1</li>; <li><a href=""https://github.com/kjd/idna/commit/d516b874c3388047934938a500c7488d52c4e067""><code>d516b87</code></a> Update Github actions/checkout to v4</li>; <li><a href=""https://github.com/kjd/idna/commit/c095c75943413c75ebf8ac74179757031b7f80b7""><code>c0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2392:2356,optimiz,optimize-contextj,2356,https://qutip.org,https://github.com/qutip/qutip/pull/2392,1,['optimiz'],['optimize-contextj']
Performance,"uote>; <h2>1.26.5</h2>; <p>:warning: <strong>IMPORTANT: urllib3 v2.0 will drop support for Python 2</strong>: <a href=""https://urllib3.readthedocs.io/en/latest/v2-roadmap.html"">Read more in the v2.0 Roadmap</a></p>; <ul>; <li>Fixed deprecation warnings emitted in Python 3.10.</li>; <li>Updated vendored <code>six</code> library to 1.16.0.</li>; <li>Improved performance of URL parser when splitting the authority component.</li>; </ul>; <p><strong>If you or your organization rely on urllib3 consider supporting us via <a href=""https://github.com/sponsors/urllib3"">GitHub Sponsors</a></strong></p>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/blob/main/CHANGES.rst"">urllib3's changelog</a>.</em></p>; <blockquote>; <h2>1.26.5 (2021-05-26)</h2>; <ul>; <li>Fixed deprecation warnings emitted in Python 3.10.</li>; <li>Updated vendored <code>six</code> library to 1.16.0.</li>; <li>Improved performance of URL parser when splitting; the authority component.</li>; </ul>; </blockquote>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/urllib3/urllib3/commit/d1616473df94b94f0f5ad19d2a6608cfe93b7cdf""><code>d161647</code></a> Release 1.26.5</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2d4a3fee6de2fa45eb82169361918f759269b4ec""><code>2d4a3fe</code></a> Improve performance of sub-authority splitting in URL</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/2698537d52f8ff1f0bbb1d45cf018b118e91f637""><code>2698537</code></a> Update vendored six to 1.16.0</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/07bed791e9c391d8bf12950f76537dc3c6f90550""><code>07bed79</code></a> Fix deprecation warnings for Python 3.10 ssl module</li>; <li><a href=""https://github.com/urllib3/urllib3/commit/d725a9b56bb8baf87c9e6eee0e9edf010034b63b""><code>d725a9b</code></a> Add Python 3.10 to GitHub Actions</li>; <li><a href=""https://github.com/urllib3/urllib",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1563:1213,perform,performance,1213,https://qutip.org,https://github.com/qutip/qutip/pull/1563,1,['perform'],['performance']
Performance,utip/qip/algorithms/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/qip/algorithms; creating build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/fidcomp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/optimresult.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/pulseoptim.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/io.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/dump.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/optimconfig.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/symplectic.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/stats.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/termcond.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/optimizer.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/errors.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/propcomp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/grape.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/pulsegen.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/tslotcomp.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/loadparams.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; copying qutip/control/dynamics.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/control; creating build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/memorycascade.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/transfertensor.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/nonmarkov; copying qutip/nonmarkov/__init__.py -> build/lib.macosx-10.9-x86_64-3.7/qutip/non,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1404:9614,optimiz,optimizer,9614,https://qutip.org,https://github.com/qutip/qutip/issues/1404,1,['optimiz'],['optimizer']
Performance,"which module we need to modify to get array of fidelities at the end of each optimization loop, I want to modify code to get fidelity vs. iterations plot.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/840:77,optimiz,optimization,77,https://qutip.org,https://github.com/qutip/qutip/issues/840,1,['optimiz'],['optimization']
Performance,"y install, and I get the following error for the minimal example:; ```; Traceback (most recent call last):; File ""MinimalErrorExample.py"", line 62, in <module>; result = cpo.optimize_pulse_unitary(drift, ctrls, U_0, U_targ, n_ts, evo_time, fid_err_targ=fid_err_targ, min_grad=min_grad, max_iter=max_iter, max_wall_time=max_wall_time, out_file_ext=f_ext, init_pulse_type=p_type, log_level=log_level,gen_stats=True,dyn_params=dict(oper_dtype=Qobj,sparse_eigen_decomp=True)); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 757, in optimize_pulse_unitary; gen_stats=gen_stats); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/pulseoptim.py"", line 459, in optimize_pulse; result = optim.run_optimization(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 957, in run_optimization; result = self._create_result(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/optimizer.py"", line 362, in _create_result; result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 412, in get_fid_err; return np.abs(1 - self.get_fidelity()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 422, in get_fidelity; self.fid_norm_func(self.get_fidelity_prenorm()); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/fidcomp.py"", line 438, in get_fidelity_prenorm; dyn.compute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/dynamics.py"", line 1394, in compute_evolution; self.tslot_computer.recompute_evolution(); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/tslotcomp.py"", line 265, in recompute_evolution; prop_comp._compute_prop_grad(k, j); File ""/Users/msoley/opt/anaconda3/lib/python3.7/site-packages/qutip/control/propcom",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212:1085,optimiz,optimizer,1085,https://qutip.org,https://github.com/qutip/qutip/issues/1617#issuecomment-886098212,1,['optimiz'],['optimizer']
Performance,"}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt(f""{wavedata_name}_tlist.txt"",dtype=np.float64); ax0.plot(tlist, coef.real, label=f""{wavedata_name}""); ax1.plot(tlist, coef.imag, label=f""{wavedata_name}""); ax0.legend(); ax1.legend(); ; ax0.set_title(r""$\sigma_x$ coefficient""); ax1.set_title(r""$\sigma_y$ coefficient""); ```. <div align=""center"">; <img width=""314"" alt=""image"" src=""https://github.com/user-attachments/assets/b07b3a64-a2d4-458b-a04e-4c83c0c4c093"">; </div>; Despite these small differences, the simulation results show significant and unexpected variations. ; Below is simulation code and results. ```; import qutip; import numpy as np; import matplotlib.pyplot as plt. sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); psi0 = qutip.fock(2,0); psi1 = qutip.fock(2,1). def Hrot(coef,tlist): ; return qutip.QobjEvo([[sx,coef.real/2],[sy,coef.imag/2]],tlist=tlist). Omega0 = 10e6 * 2 * np.pi; for wavedata_name in [""index92"",""index93"",""index94""]:; coef = np.loadtxt(f""{wavedata_name}_coef.txt"",dtype=np.complex128); tlist = np.loadtxt(f""{wavedata_name}_tlist.txt"",dtype=np.float64); H = Hrot(coef=coef*Omega0,tlist=tlist); result = qutip.mesolve(H,psi0,tlist=tlist); print(f""{wavedata_name}"",np.abs(psi0.dag()@result.final_state)**2); ```. ```; index92 1.9513183436107076e-10; index93 0.49999366030208936; index94 1.0264492246902099e-13; ```. I would appreciate any insights into the potential causes of these errors and guidance on how to prevent such issues in future simulations. Additional Information:; scipy version: 1.13.0; python version: 3.12.2; qutip version: 5.0.1; numpy version: 1.26.4; Operating system: macOS 15.1. The files with the preselected coefficients and tlist are provided for reproducibility.; [index92_coef.txt](https://github.com/user-attachments/files/17613505/index92_coef.txt); [index92_tlist.txt](https://github.com/user-attachments/files/17613506/index92_tlist.txt); [index93_coef.txt](https://github.com/user-attachments/files/17613507/index",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552:2273,load,loadtxt,2273,https://qutip.org,https://github.com/qutip/qutip/issues/2552,1,['load'],['loadtxt']
Safety," (3,); >>> arr[0]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. This change purely affects `np.array` and similar constructors when passed sequences of objects that all implement `__array__`. It is still possible to make a Numpy array of `Qobj` even with `Qobj.__array__` defined in Numpy 1.20, but you have to be rather more indirect about it:. ```python; >>> arr = np.empty((3,), dtype=object); >>> arr[:] = [qutip.qeye(2), qutip.qeye(2), qutip.qeye(2)]; >>> arr.shape; (3,); >>> arr[0]; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]; ```. The reason numpy does this now is because (my understanding is that) defining `__array__` was meant to be a much stronger guarantee than just ""it's convenient to let `np.array` know about this object"". It was meant to be an indication that your class can be safely coerced into `ndarray` (and potentially coerced back afterwards), and that mathematical operations will satisfy the normal ufunc broadcasting rules, which isn't true of `Qobj`. That means that arrays of things implementing `__array__` should be safely representable as `ndarray`, which clearly isn't true for us. Similarly, ever since `Qobj.__array__` was first defined you could use Numpy ufuncs on `Qobj`, which would get implicitly converted to `ndarray` and then return complete nonsense, rather than throwing an error like ""what you're doing is silly"":; ```python; >>> np.sin(qutip.basis(2, 1)); array([[0. ],; [0.84147098]]); ```; (imo that should really be a `TypeError` if done without an explicit conversion into Numpy semantics). There is a way around that latter point in modern Numpy - defining `Qobj.__array_ufunc__ = Qobj.__array_function__ = None` - but it does raise the question of whether we _should_ define `Qobj.__array__`; we have no intention of implying that `Qobj` satisfies the general Numpy ufunc interface, and it isn't any sort ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094:2129,safe,safely,2129,https://qutip.org,https://github.com/qutip/qutip/issues/1433#issuecomment-773992094,2,['safe'],['safely']
Safety," I want to evolve on this dynamics, shape( 6,69,2,2) . Note that I am only taking the 0th element on the axis with lenght of 69. predictions=[mesolve(H,; Qobj(estados_val[i][0]),; time,list_Jump_op,options=Options(nsteps=10000000000000000)) for i in range(len(estados_val))]. The terminal out put is; /home/andrius/anaconda3/lib/python3.8/site-packages/scipy/integrate/_ode.py:1013: UserWarning: zvode: Excess accuracy requested. (Tolerances too small.); warnings.warn('{:s}: {:s}'.format(self.__class__.__name__,; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-11-0bc27bfd6f01> in <module>; 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. <ipython-input-11-0bc27bfd6f01> in <listcomp>(.0); 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class. **Expected behavior**; The time evolution of the 0th states. This is it. Am I doing something wro",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605:1614,predict,predictions,1614,https://qutip.org,https://github.com/qutip/qutip/issues/1605,1,['predict'],['predictions']
Safety," Turn it into a Liouvillian once, so we don't repeat the cost; base = qutip.liouvillian(base_hamiltonian, collapse_operators); state = ...; options = qutip.Options(store_states=False, store_final_state=True); for prev, time in zip(times[:-1], times[1:]):; controls = krotov.get_next_controls(time, state, ...); current_liouvillian = base.copy(); for control, operator in zip(controls, control_liouvillians):; current_liouvillian += control * operator; # ^^^^^^^^^^^^^^^^^^; # each of these terms is a single time-independent Qobj,; # and the sum is a single QobjEvo with all the uncontrolled; # time dependence already handled.; state = qutip.mesolve(current_liouvillian, state, [prev, time], options=options).final_state; ```. By giving `mesolve` the Liouvillian instead of the Hamiltonian and collapse operators separately, you've already done most of its setup, so the time penalties should be much less than the current system (i.e. you avoid several Kronecker products and safety checks on the time-dependence terms because you've done them once at the start). In theory, that should already work from at least 4.5 onwards, and likely most of it will work from 4.4. In the 5.x series, almost all the intermediary operations should get a speed up as well (`Qobj.__init__` is getting its time slashed, and the line `current_liouvillian += control * operator` may be able to be replaced with one that applies the same in-place calculation optimisations that `mesolve` does internally). One thing you pay a nasty penalty for right now if that internally we'd keep column-stacking/unstacking the state, but in the 5.x branch it'll stop being represented internally by a sparse matrix, and instead it'll be a Fortran-ordered dense matrix, for which the stack/unstack is a free operation. In the form I've written it, this loop is thread-safe already. As it stands in the 4.x series, `mesolve` is re-entrant (I'm fairly sure), but note that it does generally mutate its arguments, especially if you pass",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615:2166,avoid,avoid,2166,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859873615,4,"['avoid', 'safe']","['avoid', 'safety']"
Safety," [<a href=""https://github.com/evanmiller""><code>@​evanmiller</code></a>]</li>; <li>Fixed reading FLI/FLC images with a prefix chunk <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7804"">#7804</a> [<a href=""https://github.com/twolife""><code>@​twolife</code></a>]</li>; <li>Updated package name for Tidelift <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7810"">#7810</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed unused code <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7744"">#7744</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>10.3.0 (2024-04-01)</h2>; <ul>; <li>; <p>CVE-2024-28219: Use <code>strncpy</code> to avoid buffer overflow <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7928"">#7928</a>; [radarhere, hugovk]</p>; </li>; <li>; <p>Deprecate <code>eval()</code>, replacing it with <code>lambda_eval()</code> and <code>unsafe_eval()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7927"">#7927</a>; [radarhere, hugovk]</p>; </li>; <li>; <p>Raise <code>ValueError</code> if seeking to greater than offset-sized integer in TIFF <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7883"">#7883</a>; [radarhere]</p>; </li>; <li>; <p>Add <code>--report</code> argument to <code>__main__.py</code> to omit supported formats <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7818"">#7818</a>; [nulano, radarhere, hugovk]</p>; </li>; <li>; <p>Added RGB to I;16, I;16L, I;16B and I;16N conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7918"">#7918</a>, <a href=""https://redirect.github.com/python-pillow/Pi",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:10201,avoid,avoid,10201,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['avoid'],['avoid']
Safety," `adams`, `bdf`, `dop853`, `lsoda`, `vern7`, `vern9`, `diag`. The 4 first are from `scipy.integrate.ode`, the 3 last are ours. `vern7` and `vern9` are runge-kutta methods of 7th and 9th order using [verner's most efficient coefficient](http://people.math.sfu.ca/~jverner/) with dense output. `diag` diagonalize a constant system and solve the ODE in that basis.; The minimum that must be given for a new evolver are the `prepare`, `set_state`, `get_state` and `step` methods. `evolver_collection` work as a dispatcher over evolvers. Solvers obtain their evolver instance using `evolver_collection[method, rhs]` with both `method` and `rhs` taken from the options. `evolver_collection` keep a list of description, used options and capacities for each member. It can list the available method matching desired condition. The `rhs` options is not used yet in this PR, it is for future Adaptative Hilbert Space and other modification to the ODE that affect the matrix-state product. #### Other utilities and code added in this PR:. ##### `SolverQEvo`, `Feedback`:; Wrapper around `QobjEvo` that handle feedback arguments and provide `ndarray` interface. ##### qutip/solver/ode/...; Code qutip's evolver, mostly for Verner's method. . ##### progress_bar:; Added a progress bar passed on `tqdm`. `update` no longer need the iteration number. ##### parallel map:; - Added a `loky` based parallel map, hopefully will help windows users.; - Added a `reduce_func` input. Presently the map function is saving all results and the average, std, etc. are only computed at the end. There was no real advantage in saving only average values since all trajectories were in memory at the end of the map. But users expected lower memory usage when asking for only the results average.; - Added `timeout` options to the map, when passed, no error is raised but obtained results are returned. This allow to ask for 30s worth of trajectories instead of fixing a number. **Related issues or PRs**; Build on top of the #1407",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1409:3002,timeout,timeout,3002,https://qutip.org,https://github.com/qutip/qutip/pull/1409,1,['timeout'],['timeout']
Safety," callable(base):; 173 op = FunctionCoefficient(base, args.copy(), style=function_style). File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:388, in coeff_from_str(base, args, args_ctypes, compile_opt, **_); 385 code = make_cy_code(parsed, variables, constants,; 386 raw, compile_opt); 387 try:; --> 388 coeff = compile_code(code, file_name, parsed, compile_opt); 389 except PermissionError:; 390 pass. File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:528, in compile_code(code, file_name, parsed, c_opt); 524 os.chdir(qset.coeffroot); 525 # Files with the same name, but differents extension than the pyx file, are; 526 # erased during cythonization process, breaking filelock.; 527 # Adding a prefix make them safe to use.; --> 528 lock = filelock.FileLock(""compile_lock_"" + file_name + "".lock""); 529 try:; 530 lock.acquire(timeout=0). NameError: name 'filelock' is not defined; ```. However, I would expect it to be rare that users call `qutip.coefficient` directly including compilation options. The only indication that something might be wrong then comes from two failing tests, but it is very hard to deduce the actual problem from the pytest output:. ```shell; $ pytest --disable-pytest-warnings --pyargs qutip.tests.core -k test_coefficient; ========================================================================= test session starts =========================================================================; platform linux -- Python 3.11.3, pytest-7.1.2, pluggy-1.0.0; rootdir: /home/paul; collected 5917 items / 5700 deselected / 217 selected. miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/tests/core/test_coefficient.py .................. [ 8%]; ........................................................................................................",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2162:2934,timeout,timeout,2934,https://qutip.org,https://github.com/qutip/qutip/issues/2162,1,['timeout'],['timeout']
Safety," data layer later); - all functions in `correlation` and `qobj` which were marked ""deprecated"" are now actually removed; - `vec2mat` and `mat2vec` have been renamed to `vector_to_operator` and `operator_to_vector`; - all ""legacy"" files have been completely removed; - all previous scipy-CSR-like Cython code is completely gone (replaced by the data layer); - `Qobj` no longer defines `__array__`, and so will not automatically turn itself into one. Having this produced very inconsistent behaviour when multiplying by numpy arrays, or otherwise dealing with numpy functions. If you _need_ `Qobj` to be array, be explicit and call `Qobj.full()`. Notable changes in `Qobj`:; - matrix multiplication now contracts to a scalar if doing `bra @ ket`; - matrix multiplication no longer contracts 1D subspaces, but the new `Qobj.contract()` will do this; - arithmetic operations are much more strict about enforcing `Qobj.type`-safety; - `Qobj` understands the `@` operator to mean matrix multiplication, but also maintains the same behaviour of treating `Qobj * Qobj` as matrix multiplication. Package organisation:; - the solvers are now physically contained in `qutip.solve`, but are still logically available in the `qutip` namespace. This means that direct imports (like `from qutip.mesolve import mesolve`) will fail (it becomes `from qutip.solve.mesolve import mesolve`), but the ""proper"" unqualified access `from qutip import mesolve` remains unchanged. This is for internal code organisation purposes. The integral type used as the indices in the `CSR` type is now done by simple typedef in the files `qutip/core/data/base.{pyx,pxd}`, so changes it in those two files at compile-time will allow you to switch between 32-bit and 64-bit. The C++ backing source file `zspmv.cpp` and its associated header are renamed to `matmul_csr_vector` to match the new data-layer naming conventions, but more importantly, the functions are now templated over integral types so they will ""magically"" work at either ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1332:1548,safe,safety,1548,https://qutip.org,https://github.com/qutip/qutip/pull/1332,1,['safe'],['safety']
Safety," excitations ... ok; Excitation-number-restricted state space: two excitations ... ok; Excitation-number-restricted state space: fock states ... ok; Excitation-number-restricted state space: identity operator ... ok; Excitation-number-restricted state space: thermal density operator (I) ... ok; Excitation-number-restricted state space: thermal density operator (II) ... ok; Entropy: von-Neumann entropy ... ok; Entropy: Linear entropy ... ok; Entropy: Concurrence ... ok; Entropy: Mutual information ... ok; Entropy: Conditional entropy ... ok; Entropy: Entangling power ... ok; expect: operator list and state list ... ok; expect: operator and density matrix ... ok; expect: operator and ket ... ok; expect: operator list and state ... ok; expect: operator list and state list ... ok; expect: operator and state list ... ok; fastsparse: fast_csr_matrix operations ... ok; fastsparse: transpose operations ... ok; fastsparse: adjoint operations ... ok; Read and write complex valued decimal formatted data ... ok; Read and write complex valued default formatted data ... ok; Read and write complex valued exp formatted data ... ok; Read and write real valued decimal formatted data ... ok; Read and write real valued default formatted data ... ok; Read and write real valued exp formatted data ... ok; Read and write with automatic separator detection ... ok; qsave/qload ... ok; Floquet: test unitary evolution of time-dependent two-level system ... ok; gates: expand 1 to N ... ok; gates: expand 2 to N (using cnot, iswap, sqrtswap) ... ok; gates: expand 2 to N (using swap) ... ok; gates: expand 3 to N (using toffoli, fredkin, and random 3 qubit gate) ... ok; gates: expand 3 to 3 with permuTation (using toffoli) ... ok; gates: swap gate ... ok; qutip.tests.test_gates.TestGates.test_are_cliffords ... ok; qutip.tests.test_gates.TestGates.test_clifford_group_len ... ok; Graph: Graph Degree ... ok; Graph: Breadth-First Search ... ok; Graph: Reverse Cuthill-McKee Ordering (simple) ... ok; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/858#issuecomment-387626958:8454,detect,detection,8454,https://qutip.org,https://github.com/qutip/qutip/issues/858#issuecomment-387626958,2,['detect'],['detection']
Safety," in coefficient_builders:; 169 if isinstance(base, type_):; --> 170 return coefficient_builders[type_](base, **kwargs); 172 if callable(base):; 173 op = FunctionCoefficient(base, args.copy(), style=function_style). File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:388, in coeff_from_str(base, args, args_ctypes, compile_opt, **_); 385 code = make_cy_code(parsed, variables, constants,; 386 raw, compile_opt); 387 try:; --> 388 coeff = compile_code(code, file_name, parsed, compile_opt); 389 except PermissionError:; 390 pass. File ~/miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/core/coefficient.py:528, in compile_code(code, file_name, parsed, c_opt); 524 os.chdir(qset.coeffroot); 525 # Files with the same name, but differents extension than the pyx file, are; 526 # erased during cythonization process, breaking filelock.; 527 # Adding a prefix make them safe to use.; --> 528 lock = filelock.FileLock(""compile_lock_"" + file_name + "".lock""); 529 try:; 530 lock.acquire(timeout=0). NameError: name 'filelock' is not defined; ```. However, I would expect it to be rare that users call `qutip.coefficient` directly including compilation options. The only indication that something might be wrong then comes from two failing tests, but it is very hard to deduce the actual problem from the pytest output:. ```shell; $ pytest --disable-pytest-warnings --pyargs qutip.tests.core -k test_coefficient; ========================================================================= test session starts =========================================================================; platform linux -- Python 3.11.3, pytest-7.1.2, pluggy-1.0.0; rootdir: /home/paul; collected 5917 items / 5700 deselected / 217 selected. miniconda3/envs/qutip-tmp/lib/python3.11/site-packages/qutip-5.0.0.dev0+7892453-py3.11-linux-x86_64.egg/qutip/tests/core/test_coefficient.py ...",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2162:2820,safe,safe,2820,https://qutip.org,https://github.com/qutip/qutip/issues/2162,1,['safe'],['safe']
Safety," install qutip from pip with the latest python 3.9 fails. When we run the installations from a fresh conda env (conda 4.8.5) using pip as. ```; pip install qutip; ```; or with conda (using both). ```; conda install -c conda-forge qutip; conda install qutip; ```. we get different errors. The errors do not occur if we use python3.8 while creating the conda environment as. ```; conda create -n py38 python==3.8; ```. Looking at the error it seems there is specification that prohibits python 3.9. @jakelishman @Ericgig any idea about this?. # Steps to reproduce (with conda 4.8.5). ```; conda create -n qutip-test python=3.9; conda activate qutip-test; conda install -c conda-forge qutip; ```. ### Error; ```; Collecting package metadata (current_repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: failed with repodata from current_repodata.json, will retry with next repodata source.; Collecting package metadata (repodata.json): done; Solving environment: failed with initial frozen solve. Retrying with flexible solve.; Solving environment: \; Found conflicts! Looking for incompatible packages.; This can take several minutes. Press CTRL-C to abort.; failed. UnsatisfiableError: The following specifications were found; to be incompatible with the existing python installation in your environment:. Specifications:. - qutip -> python[version='2.7.*|3.5.*|3.6.*|>=2.7,<2.8.0a0|>=3.6,<3.7.0a0|>=3.7,<3.8.0a0|>=3.8,<3.9.0a0|>=3.5,<3.6.0a0|3.4.*']. Your python: python=3.9. If python is on the left-most side of the chain, that's the version you've asked for.; When python appears to the right, that indicates that the thing on the left is somehow; not available for the python version you are constrained to. Note that conda will not; change your python version to a different minor version unless you explicitly specify; that. Note that strict channel priority may have removed packages required for satisfiability.; ```",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1371:1260,abort,abort,1260,https://qutip.org,https://github.com/qutip/qutip/issues/1371,1,['abort'],['abort']
Safety," it is not clear which is the best one:. 1. Ensure all eigen values and eigen vectors are computed.; 1.1 This could be done by finding an alternative to scipy to solve for sparse matrix decomposition, but it would add extra requirement and it must be easy to install with pip.; 1.2 Use a third call to `scipy.sparse.linalg.eigs`/ `scipy.sparse.linalg.eigsh` using `sigma` to find all the pseudo degenerate values. It need to be done while being careful about special cases. This would make the sparse eigen solver even slower than it already is.; 2. Allow to sort by other orders, such as the complex value or magnitude. This would not solve the issue, but give some options to go around it. However the dense eigen solver would be expected to behave the same and the dense eigen solver does not have this options, so we need to implement it ourselves. This sorting option would also be required for any other data type we want to support. To go around that, the `Qobj` methods could be responsible for the sorting, the `sort` argument would only be passed to the dispatched function when `sparse=True`.; 3. Refuse to use the sparse solver for the full decomposition as scipy does. The sparse eigensolver is both slow and hard to use in this case. Also the eigen vectors computed by the sparse solver are stored in a dense array, so it is not that useful to save memory...; 4. Implement our own sparse eigen decomposition...; 5. Only document the issue without fixing. The default is the dense solver, which is both faster and safer in almost all cases.; 6. Something else...; ; I would personally go for either 1.2 of 3. ; Adding different sorting options in `Qobj` methods (2) and removing them from the dispatched functions, could be nice, but it's not a fix. The place to start would be to debate on the solution. If you have some opinion on the matter, please let us know.; Once we've made up our mind, you can implement it, but only 5 would be an easy fix in line with other _good first issue_.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161:1613,safe,safer,1613,https://qutip.org,https://github.com/qutip/qutip/issues/1998#issuecomment-1472150161,2,['safe'],['safer']
Safety," n = dg.data.nnz; @@ -1177,9 +1177,9 @@ class Dynamics(object):; dg = self._drift_dyn_gen; for j in range(self._num_ctrls):; if self.time_depend_ctrl_dyn_gen:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[k, j]; else:; - dg = dg + self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; + dg += self.ctrl_amps[k, j]*self._ctrl_dyn_gen[j]; ; self._dyn_gen[k] = dg; if self.cache_phased_dyn_gen:; diff --git a/qutip/control/fidcomp.py b/qutip/control/fidcomp.py; index bb7a67ef..afa898ad 100644; --- a/qutip/control/fidcomp.py; +++ b/qutip/control/fidcomp.py; @@ -729,7 +729,7 @@ class FidCompTraceDiffApprox(FidCompTraceDiff):; if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; - evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; + evo_final_eps *=dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; diff --git a/qutip/control/pulsegen.py b/qutip/control/pulsegen.py; index ec5ac177..418da1ff 100644; --- a/qutip/control/pulsegen.py; +++ b/qutip/control/pulsegen.py; @@ -283,7 +283,7 @@ class PulseGen(object):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; - pulse = pulse*ramping_pulse; + pulse *= ramping_pulse; ; return pulse; ; @@ -379,7 +379,7 @@ class PulseGenRndFourier(PulseGen):; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); - wavelen = wavelen/2.0; + wavelen /= 2.0; ; num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); @@ -650,7 +650,7 @@ class PulseGenLinear(PulseGen):; for k in range(self.num_tslots):; y = self.gradient*t + self.start_val; pulse[k] = self.scaling*y; - t = t + self.tau[k]; + t += self.tau[k]; ; return self._apply_bounds_and_offset(pulse); ; @@ -745,7 +745,7 @@ class PulseGenSine(PulseGenPeriodic):; for k in range(self.num_tslots):; phase = 2*np.pi*self.freq*t +",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872:2942,avoid,avoids,2942,https://qutip.org,https://github.com/qutip/qutip/issues/1714#issuecomment-974625872,1,['avoid'],['avoids']
Safety," number. The dimensions types should be available for advanced users (to allow them to access the full parsing speed-ups), but should not be presented as the standard choice. I propose we place the types inside a nested namespace, such as `qutip.dims` (logically - physically it would be `qutip/core/dims.py`), to allow the form `from qutip.dims import *` where appropriate without forcing the user to do the modern bad practice left over from our MATLAB past `from qutip import *`. ## User impact. In principle, nothing will change for the normal QuTiP user compared to the 4.x branch. You will still be able to supply the `dims` argument to the `Qobj` constructor as lists in the exact same format, and they will be parsed in the same way. Users _do not_ need to type out the new computer-friendly dimensions objects, but they will be available for advanced users who frequently make `Qobj` using the raw constructor with funny dimensions. We will publicly provide `qutip.dims.parse` to turn a list into the new form, so even advanced users do not need to type out all the nonsense. `Qobj` factory functions that take a `dims` parameter should now also accept the new form. Since almost all of them just pass this directly to the `dims` argument in the `Qobj` constructor, this likely won't involve any developer effort. `Qobj` construction overhead should be reduced to near-zero when passed a new dimensions object, which we will always do within the library. Compared to the 4.x branch, the overhead of `Qobj` will shrink from ~100µs to ~1µs in library code, even for functions where the `Qobj` type cannot be cleanly inferred from the input types. ## Particular points worth commenting on. 1. Are there currently valid `Qobj` that cannot be represented with this system?; 2. Should we push to implement basis-safety for QuTiP 5.x?; 3. Do you agree we should keep track of ""missing"" tensor product spaces?; 4. Should we change the pretty-printed format of `dims` and `type` in `Qobj.__repr__()`?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421:11135,safe,safety,11135,https://qutip.org,https://github.com/qutip/qutip/issues/1421,1,['safe'],['safety']
Safety," only _detected_ at garbage collection. Here is the output of a Python 3.8 crash on the `Malloc.py` file with some additional debugging enabled. This is with Python 3.8.8, Numpy 1.19.2, Scipy 1.6.2 and MKL:; ```; jake@tauros$ PYTHONMALLOC=pymalloc_debug python -Xfaulthandler Malloc.py; 500; Debug memory block at address p=0x7fa2e02de610: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7fa2e02ed64f are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p: dd dd dd dd dd dd dd dd ... 00 00 00 00 00 00 00 00. Enable tracemalloc to get the memory block allocation traceback. Fatal Python error: bad trailing pad byte; Python runtime state: finalizing (tstate=0x7fa2ddc04270). Current thread 0x00000001123d55c0 (most recent call first):; <no Python frame>; Abort trap: 6; ```. ## Relation to `to_kraus`. The above `Malloc.py` file uses `scipy.linalg.eig` via use of an `eseries` version of `correlation`. The current test of superoperator representations uses `choi_to_kraus` which also calls `scipy.linalg.eig`. Here is a file `kraus.py` that can reproduce these segfaults semi-reliably (may need to run it a few times to get it to trigger):. ```python; import qutip. s = qutip.rand_super(); c = qutip.to_choi(s); k = qutip.to_kraus(c); ```. For example, here's a similar command on this file:. ```; Debug memory block at address p=0x7f98cc467db0: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7f98cc476def are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OU",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:3580,Abort,Abort,3580,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety," special about the value 1e-12 for Qobjs. Multiplying a Qobj with a float<1e-12 makes all entries 0.0. This can be worked-around as follows:; > ; > import qutip as qt; > ; > print ""Multiplying states by small numbers""; > state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1476,detect,detector,1476,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety," to palette with duplicate entries <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6548"">#6548</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Allow remap_palette() to return an image with less than 256 palette entries <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6543"">#6543</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Corrected BMP and TGA palette size when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6500"">#6500</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; </ul>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/blob/main/CHANGES.rst"">pillow's changelog</a>.</em></p>; <blockquote>; <h2>9.3.0 (2022-10-29)</h2>; <ul>; <li>; <p>Limit SAMPLESPERPIXEL to avoid runtime DOS <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6700"">#6700</a>; [wiredfool]</p>; </li>; <li>; <p>Initialize libtiff buffer when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6699"">#6699</a>; [radarhere]</p>; </li>; <li>; <p>Inline fname2char to fix memory leak <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6329"">#6329</a>; [nulano]</p>; </li>; <li>; <p>Fix memory leaks related to text features <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6330"">#6330</a>; [nulano]</p>; </li>; <li>; <p>Use double quotes for version check on old CPython on Windows <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6695"">#6695</a>; [hugovk]</p>; </li>; <li>; <p>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a>; [cgohlke]</p>; </li>; <l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:10333,avoid,avoid,10333,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['avoid'],['avoid']
Safety,"# Broad strokes. `Qobj` instantiation and mathematical operations have a large overhead, mostly because of handling the `dims` parameter in tensor-product spaces. I'm proposing one possible way to speed this up, while also gaining some additional safety and knowledge about mathematical operations on tensor-product spaces. The steps:; 1. rigourously define the ""grammar"" of `dims`, and allow all of `dimensions.py` to assume that this grammar is followed to speed up parsing; 2. maintain a private data structure type `dimensions._Parsed` inside `Qobj` which is constructed once, and keeps all details of the parsing so they need not be repeated. Determine `Qobj.type` from this data structure; 3. maintain knowledge of the individual `type` of every subspace in the full Hilbert space (e.g. with a list). There is still a ""global"" `Qobj.type`, but this can now be one in the set `{'bra', 'ket', 'oper', 'scalar', 'super', 'other'}`. `'other'` is for when the individual elements do not all match each other. Individual elements cannot be `'other'`. `'scalar'` is added to operations can keep track of tensor elements which have been contracted, say by a `bra-ket` product - operations will then broadcast scalar up to the correct dimensions on certain operations.; 4. dimension parsing is now sped up by using the operation-specific type knowledge. For example, `bra + bra -> bra`, and `ket.dag() -> bra`. Step 3 is necessary to allow matrix multiplication to work. These lookups could be done with enum values instead of string hashing. # Technical details. As of QuTiP 4.5 (and all previous versions), `Qobj` instantiation is slow and this permeates through to all operations on `Qobj`. Matrix multiplication, scalar multiplication, addition and so forth all need to instantiate new `Qobj` instances, and the time penalty for this is on the order of ~50µs per object. This results in more and more code than needs to bypass `Qobj` for speed, and in some cases (e.g. `qutip.control`) makes the use ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320:247,safe,safety,247,https://qutip.org,https://github.com/qutip/qutip/issues/1320,1,['safe'],['safety']
Safety,"### Bug Description. SciPy 1.8 deprecated importing functions from many submodules of scipy.sparse. For example, `scipy.sparse.sputils`. QuTiP fastsparse implementation accessing many of these functions because it extends scipy's sparse matrix support. It would be good to avoid as many of these deprecated imports as we can. Note that SciPy 1.8 is the first SciPy to support Python 3.10. ### Code to Reproduce the Bug. ```shell; python -X dev -c ""import qutip""; ```. ### Code Output. ```shell; <frozen importlib._bootstrap>:914: ImportWarning: PyxImporter.find_spec() not found; falling back to find_module(); /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `upcast` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `upcast_char` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `to_native` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `isdense` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastsparse.py:5: DeprecationWarning: Please use `isshape` from the `scipy.sparse` namespace, the `scipy.sparse.sputils` namespace is deprecated.; from scipy.sparse.sputils import (upcast, upcast_char, to_native, isdense, isshape,; /home/simon/repos/github/qutip/qutip/fastspar",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1823:273,avoid,avoid,273,https://qutip.org,https://github.com/qutip/qutip/issues/1823,1,['avoid'],['avoid']
Safety,"### Bug Description. qutip has functions to detect the available of BLAS libraries. For instance on my system (debian unstable), `python3 -c ""import qutip; qutip.about()""` reports; ```; BLAS Info: OPENBLAS; ```. However, I think the logic behind BLAS Info is not robust. For context, debian builds packages against generic libblas.so (libblas-dev package). The various optimised BLAS implementations are supposed to be binary compatible, such that the system administrator can install the preferred implementation for use at runtime (the identity of libblas.so is controlled using debian's alternatives mechanism). On my system, OpenBLAS is indeed installed. But taking a closer look, I'm not sure it was detected for the right reason.; The blas configuration is identified by the `_blas_info()` function in qutip/utilities.py. It uses the local numpy configuration (`np.__config`), testing the availability of various attributes in the numpy config, in the form of ; ```; if hasattr(config,'mkl_info') ...; elif hasattr(config,'openblas_info'); ```. MKL was not used to build debian's numpy package, and I don't have it installed. So mkl_info is not detected. OpenBLAS was not used to to build numpy either, but it is installed, so I want look closer at the logic. config (i.e. `np.__config__`) does indeed have an openblas_info. But it is empty (`{}`). Nevertheless `hasattr(config,'openblas_info')`returns True, since the empty dict is there. As far as MKL goes, mkl_info is indeed not there, so qutip does not detect MKL BLAS. But there is a `blas_mkl_info` attribute, and `hasattr(config,'blas_mkl_info')` returns True, same as with openblas_info. numpy provides a summary of its configuration in `np.show_config()`:; ```; numpy.show_config(); blas_armpl_info:; NOT AVAILABLE; blas_mkl_info:; NOT AVAILABLE; blis_info:; NOT AVAILABLE; openblas_info:; NOT AVAILABLE; accelerate_info:; NOT AVAILABLE; atlas_3_10_blas_threads_info:; NOT AVAILABLE; atlas_3_10_blas_info:; NOT AVAILABLE; atlas_blas_th",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2053:44,detect,detect,44,https://qutip.org,https://github.com/qutip/qutip/issues/2053,2,['detect'],"['detect', 'detected']"
Safety,"### Describe the Issue!. Most of the functions in `random_objects.py` take an `N` input and an optional `dims`. Those input are redundant as the size (`N`) can be obtained from the `dims`. However the way they handle this inconsistent:; - Many functions, such as `rand_super`, `rand_dm`, check that the dims matches the size and raise an error if it doesn't.; - `rand_dm_ginibre`, `rand_super_bcsz` just pass the `dims` to `Qobj` without any checks.; - `rand_ket` has a default `N=0` and obtain the size from `dims` when `N` is `0`, but it raise a division per zero error when neither `N` nor `dims` is passed.; - `rand_ket_haar` also tries to obtain the size from `dims` when `N` is `0`, but the default value of `N` is `2`, thus one need to pass `N=0` to use it. `N=0` would fail almost everywhere else. Also some function have a default size, other not: `rand_unitary(N, ...)`, `rand_unitary_haar(N=2, ...)`. The interface of these functions need to be unified. Some options:; - `N` is always needed and `dims` are checked to match.; - A default of `None` is used for `N` and either `N` or `dims` is needed. If both are given, we check that they are compatible. If none are passed, we raise an appropriate error.; - (For `dev.major`) Remove the `dims` parameter and replace `N` with `dimensions`, which act as `N` if an integer is given and `dims` is a list is. This is already the behavior of `qeye` and `qzero`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1838:128,redund,redundant,128,https://qutip.org,https://github.com/qutip/qutip/issues/1838,1,['redund'],['redundant']
Safety,"### Problem Description. Now that qutip-qip has moved to another package, gates are not available in the main repo. This is inconvenient for examples such as the control optimization ones, where one would need to install the qutip-qip package just to access say the Hadamard or CNOT for instance. ### Proposed Solution. The easiest solution would be just to copy the `gates.py` file from the QIP package into the main repo. Perhaps might confuse imports in qip? Also, I think that file has func defs that refer to 'controls' that might not make sense in this repo. ### Alternate Solutions. Have a file called `operations.py`. Just have a subset of the gates (operations), the most typical named unitaries - sounds less QIP like and would avoid import confusion. I think also `hadamard_transform` could be shortened to `hadamard`, but also include the original name. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2389:738,avoid,avoid,738,https://qutip.org,https://github.com/qutip/qutip/issues/2389,1,['avoid'],['avoid']
Safety,"'; ```; and a lot of functionality will break - anything that requires `Qobj.eigenstates()` for example. This is because `Qobj` defines `__array__`, one of numpy's ""array interface"" functions, intended for classes that can be safely converted _implicitly_ into an `ndarray`. This isn't really the case for `Qobj` - it loses all sorts of information when you do that, which is why we've maintained the separate `Qobj.full()` for explicitly getting the dense matrix representation of a `Qobj`. This is not to mention that numpy ufuncs probably should not be able to implicitly convert `Qobj` - I'd strongly argue that `np.sin(qutip.basis(2, 1))` should be `TypeError`, _not_ `array([[0. +0.j], [0.84147098+0.j]])` (like it is right now). We actually already removed this ""functionality"" in `dev.major`. The most pressing incompatibility is that a few points in QuTiP put a few `Qobj` into a `np.array(dtype=object)`. In numpy 1.20, this no longer produces a 1D array of `Qobj`, but a 3D array of complex. This breaks `Qobj.eigenstates`, and prevents test collection due to it being present in `states.py::qutrit_basis()`, which is called during parametrisation. There are a two possible ways to solve this, and we ought to release a fix with one of them in a patch ASAP:; 1. remove `Qobj.__array__`; 2. remove all use of `Qobj` in `np.array`. I'm personally in favour of ""explicit is better than implicit"" in this case, i.e. removing `Qobj.__array__` and relying on `Qobj.full()`. As another example along this vein, note `scipy.sparse` matrices don't implement this either, and they're arguably closer to being safely coerced to `ndarray` than we are. ### Related issues. #938: feature request for implementing `__array__`. This only asks for `np.array(qobj)` as a convenience, acknowledging the availability of `Qobj.full()`.; #1017: includes a comment on buggy behaviour caused by `__array__`. Note that the solution given there (`np.asarray(..., dtype=object)`) will no longer work with numpy 1.20.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433:1779,safe,safely,1779,https://qutip.org,https://github.com/qutip/qutip/issues/1433,1,['safe'],['safely']
Safety,"'t access global state as far as I recall. Just to be clear: there's two interconnected issues here: One is just being ""reentrant"" in the sense that I can safely have multiple `mesolve`'s run in parallel. This doesn't seem to be a problem for `mesolve` as a whole (propagating over the entire time grid). The other issue, at a lower level is whether I can keep the internal state of the integrator (`scipy.integrate.ode` or whatever else `mesolve` might be using) when propagating a single time step (and whether I can have multiple integrators to run in parallel that each safely keep track of their own state). That comes down to the integrator itself being ""reentrant"", of course. Certainly, calling `mesolve` in a loop (`In [19]`) doesn't keep the internal state of the integrator, hence the overhead between `In [21]` compared to `In [18]`. I wouldn't expect it to, of course, but the question is whether a refactoring of `mesolves` internals into an object that keeps state in a thread-safe way and allows doing time steps would alleviate this overhead (like the `mesolve_prepare_ode(H, state, c_ops) -> OdeState` that you propose in https://github.com/qutip/qutip/issues/1571#issuecomment-859917462). On the other hand, looping over the full `mesolve` as in `In [19]` obviously has no problems with parallelization. I wasn't sure if that's what you meant by ""`mesolve` is re-entrant"" or whether recent changes in QuTiP now use a re-entrant internal integrator, i.e. not `scipy.integrate.ode`. At the time I implemented the [`DensityMatrixODEPropagator`](https://github.com/qucontrol/krotov/blob/cfe6b108708cdfd29ab7eee24f2112977b951ed2/src/krotov/propagators.py#L162) by looking at what `mesolve` was doing at a low level for the specific case of density matrices, `scipy.integrate.ode` was definitely being used, and that couldn't handle propagating in parallel (and by ""parallel"" I include alternating propagation steps from two different propagations). I'm also not sure what using `QobjEvo",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243:6577,safe,safe,6577,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-860254243,2,['safe'],['safe']
Safety,* imports should be avoided internally to try and make single qutip module imports more lightweight,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580:20,avoid,avoided,20,https://qutip.org,https://github.com/qutip/qutip/issues/580,1,['avoid'],['avoided']
Safety,"**Background**. Since I am planning to add an mpi_parallel_map to the parallel module, I had a detailed look at the current implementations of parallel_map and loky_pmap. In the case of timeouts, errors or interrupts, I found surprising behavior. I will first summarize the current behavior in these situations, and then the behavior if my changes are included. It seems difficult to write better unit tests for such timing-sensitive behavior, but I have tested in detail on both Linux (WSL) and Windows. **Current behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | If `fail_fast`, behaves similarly to `parallel_map`. <br> Otherwise, completes all tasks but only returns <br> results of those that were started before the timeout.; CTRL+C | First CTRL+C interrupts all tasks, but program <br> enters deadlock requiring second CTRL+C | Interrupts currently running tasks, but then still <br> executes the rest before raising `KeyboardInterrupt`.; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes all tasks, then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Ignored | Always completes all tasks anyway, see below. **New behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | Aborts currently running tasks, <br> then returns results of all finished tasks.; CTRL+C | First CTRL+C raises `KeyboardInterrupt` | First CTRL+C raises `KeyboardInterrupt`; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes tasks earlier in the list, then <br> aborts remaining ones and raises exception. <br> `!fail_fast`: rais",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2280:186,timeout,timeouts,186,https://qutip.org,https://github.com/qutip/qutip/pull/2280,3,"['Timeout', 'timeout']","['Timeout', 'timeout', 'timeouts']"
Safety,"**Checklist**; This rewrite the stochastic solver to use the class interface. - `smesolve`, `ssesolve` have been rewritten to match other solver with matching class interface `SMESolver`, `SSESolver`. The main change is that the options used to be passed as keywords (`**kwargs`) and are now passed as an options dict.; - `m_ops` and `dW_factors` are properties of the classes, but not available to overwrite through the function interface. ; - The multiples end condition (`target_tol`, `timeout`) are added.; - The `solver` keyword is now `method` options, as it is in other solver.; - The method that was referring the homodyne or heterodyne detection is now the `heterodyne` keyword. ie before `method=""heterodyne""` now `heterodyne=True`.; - The default integration method is now `rouchon`, instead of `taylor1.5`. ie the method coming from a physic paper and not a mathematics textbook. . - The stochastic integration methods have been spitted in smaller chunk instead of the huge classes in _stochastic.pyx. I kept most methods, only skipping the taylor order 2.0 method. The python interface is kept very similar to the `Integrator` as `SIntegrator`, the main difference being that `set_state` and `get_state` use an extra random number generator with the time and state. The integration methods are usually 5%~10% slower than they where for medium size problems (shape ~100). Most method are computed the same way as before, but the rouchon method no longer use super operator, but keep the density matrix as a matrix and not an oper-ket. - The derivative computation for used by the integration method has also been split into multiple functions and made only available for `smesolve`. For there methods to be valid, the each diffusion contribution must commute. For `smesolve`, this means that each `sc_ops` must commute, as documented. For `ssesolve`, each `sc_ops` must not only commute, but also commute with other `sc_ops`'s adjoint, this last part being missing from v4's documentation.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2131:489,timeout,timeout,489,https://qutip.org,https://github.com/qutip/qutip/pull/2131,2,"['detect', 'timeout']","['detection', 'timeout']"
Safety,"**Describe the issue**. The ""Stochastic Solver"" page on the users guide currently have typos on equations and the text. Additionally, I believe the page could be improved by: ; - adding an example for qutip.smesolve;; - adding references for the equations discussed on the page (Chapter 4, Quantum Measurement and Control, from Wiseman and Milburn, for example);; - add links on the page for [this](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/smesolve-heterodyne.ipynb) and [this](https://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/smesolve-inefficient-detection.ipynb) tutorials. I would like to volunteer to make these changes.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1706:616,detect,detection,616,https://qutip.org,https://github.com/qutip/qutip/issues/1706,1,['detect'],['detection']
Safety,"**Description**; A lot of the code in `propagators.py` is quite old and manipulates `Qobj` shapes directly and unnecessarily converts backwards and forward between numpy arrays and `Qobj`s. This PR attempts to address two important bugs in dimension checking -- the one reported in #1585 (when calculating propagators for collapse operators) and another I found while reading the nearby code. A more thorough rework of the code should probably happen on `dev.major` for QuTiP version 5. The `propagator` method could do with more input sanity checking for QuTiP version 5, e.g.; * rename `c_op_list` to `c_ops` for consistency with the solver; * complain if `c_ops` are supplied along with a superoperator (?); * perhaps remove the `single` or `batch` unitary_mode option, or at least complain if the parameters supplied don't make sense. **Related issues or PRs**; * #1585. **Changelog**; - Fixed support for calculating the ``propagator`` of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (#1459), but the propagator function's calls to ``mesolve`` violated these checks by supplying initial states with the dimensions incorrectly set. ``propagator`` now calls ``mesolve`` with the correct dimensions set on the initial state. Fixes #1585.; - Fixed support for calculating the ``propagator`` for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1588:536,sanity check,sanity checking,536,https://qutip.org,https://github.com/qutip/qutip/pull/1588,2,['sanity check'],"['sanity checking', 'sanity checks']"
Safety,**Description**; Activate remaining tests on Windows now that pytest-timeout has been removed. **Related issues or PRs**; - Continues on from #1853. **Changelog**; Activate remaining tests on Windows.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1854:69,timeout,timeout,69,https://qutip.org,https://github.com/qutip/qutip/pull/1854,1,['timeout'],['timeout']
Safety,"**Description**; Add a lock for creating string coefficient. This allow to use the coefficient inside a parallel loop without issues.; The lock use `filelock` which works across processes, so it's safe to use with parallel coming from outside python.; The lock is per file, so different coefficient can compile in parallel. If there is a conflict, the first process will create and compile the coefficient and the other will use it (raising a hash collision error if not actually the same string.). `filelock` is a new requirement for runtime compilation. **Related issues or PRs**; #1963",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1968:197,safe,safe,197,https://qutip.org,https://github.com/qutip/qutip/pull/1968,1,['safe'],['safe']
Safety,"**Description**; Add some `skipif` to bypass tests that were failing (segmentation faults) during the local testing of `qutip.testing.run()` that was failing in the zip version of #1241. I am on Mac with generic BLAS and no MKL. ; I have been installing it on a fresh conda environment with; ```; pip install -e .[development]; ```; which I think is better than ; ```; python setup.py develop; ```; and by the way maybe this is something that can be updated in the readme and docs.; ; My qutip.about reads:; ```; QuTiP Version: 4.5.1; Numpy Version: 1.15.4; Scipy Version: 1.4.1; Cython Version: 0.29.8; Matplotlib Version: 3.1.2; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: Generic; OPENMP Installed: False; INTEL MKL Ext: False; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/github/qutip-4.5.1/qutip; ```; This PR could be included in the 4.5.1 version @Ericgig. . **Related issues or PRs**; This PR is related to #1241. **Changelog**; Add `skipif`in `pytest` on Mac with generic BLAS, avoiding segmentation fault during `qutip.testing.run()`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1255:1023,avoid,avoiding,1023,https://qutip.org,https://github.com/qutip/qutip/pull/1255,2,['avoid'],['avoiding']
Safety,"**Description**; As presented in #1722, the docstring of the states and operators functions are not consistent. This change the docstring so that _Number of basis states in Hilbert space_ is used everywhere, instead of _fock states_ or _vector states_. This set the variable names as:; - Single Hilbert space function : `N`; - Multiple Hilbert space function: `dimensions`; - Number of qubits: `N_qubit`. Added support for `dimensions` input to take `Space` object.; Added sanity check in dimensions object.; Added `scalar_like` method to dimensions object. In transform any dims `[[2, 3], [2, 3]]` to it's scalar with same structure `[[1, 1], [1, 1]]`.; Added another input parameter to qzero to create rectangular operator `qzero([2],[3]).dims == [[2], [3]]`. **Related issues or PRs**; fix #1184, replace #2075",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2289:473,sanity check,sanity check,473,https://qutip.org,https://github.com/qutip/qutip/pull/2289,1,['sanity check'],['sanity check']
Safety,**Description**; Avoid int overflow in Qobj dims check . **Related issues or PRs**; fix #2249,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2252:17,Avoid,Avoid,17,https://qutip.org,https://github.com/qutip/qutip/pull/2252,1,['Avoid'],['Avoid']
Safety,"**Description**; Dimension checks was not done for `e_ops` for most solvers, which could result in segfault, (#1776).; Add checks and tests for these checks for `sesolve`, `mesolve`, `mcsolve`, stochastic solvers. ; `brmesolve` and `floquet` are safe. **Related issues or PRs**; fixes #1776. **Changelog**; Add dims check for e_ops in main solvers",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1778:246,safe,safe,246,https://qutip.org,https://github.com/qutip/qutip/pull/1778,1,['safe'],['safe']
Safety,**Description**; Fix the bug in correlation where it would not properly detect that the system were time-dependent when only the c_ops were. **Related issues or PRs**; fix #1808; replace #1929,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1979:72,detect,detect,72,https://qutip.org,https://github.com/qutip/qutip/pull/1979,1,['detect'],['detect']
Safety,"**Description**; Hinton plots accept a `title` argument, but the code does not actually set the plot's title. Along with this fix, I also removed unused imports and fixed the other function's titles to avoid verbose such as. ```python; if title:; ax.set_title(title); ```; where the simple `ax.set_title(title)` does nothing when `title` is `None`. **Related issues or PRs**; No related issues or PRs. **Changelog**; Display a title for hinton and matrix_histogram plots when a title is given.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1707:202,avoid,avoid,202,https://qutip.org,https://github.com/qutip/qutip/pull/1707,1,['avoid'],['avoid']
Safety,"**Description**; In #2120, `countstat` was updated to use `data.solve`.; `countstat` would sometime try to solve a system with singular matrix and has a fallback for it using `try: ... except:`; However, while numpy raises an error when the matrix is singular, `scipy.sparse` raises a warnings, thus the tests only pass because we use the warnings as error flags... Without it, the singular matrix would not be caught and the solution from `countstat` would contain a `NaN` and the tests would fail... - Redirect the warning from scipy sparse and numpy's `LinAlgError` to a `ValueError`to allow easy catching of these case.; - Add the small `1e-15` in `countstat` with `auto_tidyup` turned off.; - Add support for the method `lstsq` and `solve` for `data.solve_csr`. These methods are supported by numpy, jax, tensorflow, scipy.sparse is the exception which use `spsolve` and `lsqr` instead, probably to avoid name collision the the dense version they also have.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2144:904,avoid,avoid,904,https://qutip.org,https://github.com/qutip/qutip/pull/2144,1,['avoid'],['avoid']
Safety,"**Description**; In a few places, we remove the imaginary part for hermitian matrices.; It's nice for the user, but it breaks a few cases: `isherm` check breaks `jax.jit` and tensorflows does not support casting for auto-differentiation. The solution we had when tensorflow was added was to detect it (no `real` method). But this did not fix `jit` as seen in qutip/qutip-jax#34. This add a setting that is checked first, so after `qutip.settings.core[""auto_real_casting""] =False` all these checks are removed and `jit` works.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2329:291,detect,detect,291,https://qutip.org,https://github.com/qutip/qutip/pull/2329,1,['detect'],['detect']
Safety,"**Description**; Make our integrator re-entrant. Scipy'ode is can only have one active instance active for some of the methods. This cuased no issue when the whole integration is done at once as when used in `mesolve`. But with solver as class, this mean using them will have side effect on other solver instances. This PR make the check for concurrent integrator usage before scipy does and force a reset if needed. Switching between system will be inefficient, but will return the expected results. In lsoda's integrator's `_backstep` we are catching a warning before acting on it, but catching the warnings still printed them at the end of tests, bloating the output. In this PR, I also do the check before scipy does so the warning is never raised. **Related issues or PRs**; Point raised in discussion with @hodgestar and @AGaliciaMartinez on #1710 . **Changelog**; Front run some safety check in scipy.ode",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1734:886,safe,safety,886,https://qutip.org,https://github.com/qutip/qutip/pull/1734,1,['safe'],['safety']
Safety,"**Description**; On mac, with OpenBlas, `eigh` can cause segmentation fault, see #1197. For 4.5.1, we simply skipped the tests causing problems ( #1257). This replace the calls of `numpy.linalg.eigh` to `numpy.linalg.eig`, and lapack calls of `ZHEEVR` to `ZGEEV` when at risk of segfault. This will result in slower `Qobj.eigenstates` and `brmesolve`. . Tests where adapted, the issues were the phase of the eigenvectors and the lower numerical precision of `eig`. While the flag to use `eig` instead of `eigh` is `qutip.settings.eigh_unsafe`, it must be set before importing `qutip.sparse` to have any effect. Thus it is not a true settings, (like `has_openmp`). **Changelog**; Replace calls of `eigh` to `eig` when at risk of segfault.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1288:271,risk,risk,271,https://qutip.org,https://github.com/qutip/qutip/pull/1288,2,['risk'],['risk']
Safety,"**Description**; Remove Bloch 3D, it's redundant to Bloch but without new features added in recent years.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2306:39,redund,redundant,39,https://qutip.org,https://github.com/qutip/qutip/pull/2306,1,['redund'],['redundant']
Safety,"**Description**; Rewrite `mcsolve` as a class for dev.major. Main addition:; - `MultitrajSolver` class as a base class for solver computing trajectory from a seed: it uses custom ; - It uses custom integrator using a generator which `MultitrajSolver` provide. ; - Stepping run one trajectory at a time.; - Use numpy.random new interface with `SeedSequence` and `Generator`.; - `run` can end on number of trajectories reached, timeout reached, or error bars on expectation values under a certain tolerance.; - `McSolver` class for mcsolve class interface.; - Support closed and open system. For open systems. `H` must be a Liouvillian. The `c_ops` are computed stochasticly and are used for collapse. Dissipation terms to be used in a deterministic way can be added as Lindblad dissipators to the liouvillian.; - McSolver's results include the photocurrent.; - McSolver need a layer between the solver interface and the integrator. In #1710, this was a trajectory solver, but here I use a pseudo integrator. This makes `MultitrajSolver` easier to use with stochastic which need custom integrator and thus a trajectory solver did very little. Other fixes:; - `MultiTrajResult` keep the `dtype` of expect.; - `MultiTrajResult` can merge instance with no states stored. **Related issues or PRs**; Replace #1710",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1972:426,timeout,timeout,426,https://qutip.org,https://github.com/qutip/qutip/pull/1972,1,['timeout'],['timeout']
Safety,"**Description**; Rewrite `mcsolve` using class as was done for `sesolve` and `mesolve` in #1700. This add new capacities to `mcsolve`:; - `measurement` and `photocurrent` are added to result making the `photocurrent_..solve` function redundant.; - The `H` input can be a super operator, allowing to do evolution with some collapse operator being treated democratically and some with discrete jumps (as was done in `photocurrent_mesolve`.; - Result are compiled at the end of each trajectories. Previously the result of each trajectories would be stored until the end of the map function, even if only the average are desired, making it quite memory inefficient, see #1667.; - New end condition are added. `mcsolve` can run for a desired number of trajectories, a desired time or the expectation values have converged within a desired tolerance (computed using jackknife re-sampling). ; - Stepping capacities have been added. However, collapse are not available this way, so it's still open to improvement. Other changes include reworking `MultitrajResults`, it was added in a previous PR but was not used. Also the 2 versions: trajectories stored or averaged are merged. **Related issues or PRs**; Follow up to #1700 . **Changelog**; Rewrite mcsolve with a class approach.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1710:234,redund,redundant,234,https://qutip.org,https://github.com/qutip/qutip/pull/1710,1,['redund'],['redundant']
Safety,**Description**; Setting eigh_unsafe on sipy<1.5 and MKL. **Related issues or PRs**; #1495. **Changelog**; - Changed init to set eigh not safe in case scipy<1.5 and mkl backend; - Added the correct pytest breaking test from issue #1491 to check the solution,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1498:138,safe,safe,138,https://qutip.org,https://github.com/qutip/qutip/pull/1498,1,['safe'],['safe']
Safety,"**Description**; Since yesterday, our tests hangs for both `master` and `dev.major` and never finish. It seen only a few tests are affected.; I am adding a timeout so the tests that hangs result in a localized error.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787:156,timeout,timeout,156,https://qutip.org,https://github.com/qutip/qutip/pull/1787,1,['timeout'],['timeout']
Safety,"**Description**; The error for too large minimum step was not raised.; The error therefore came later in scipy code and was hard to understand. ; Found from https://groups.google.com/g/qutip/c/NUcKnAwpx30/m/7IKDqbNOAgA; Fix the error and add a test for it. Also added some sanity check on `min_step` and `max_step`, which could create infinite loop if `min_step = 0` or `min_step > max_step`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2402:273,sanity check,sanity check,273,https://qutip.org,https://github.com/qutip/qutip/pull/2402,1,['sanity check'],['sanity check']
Safety,**Description**; There was an error in line 613 of qutip/stochastic.py as the measurement operators for heterodyne detection in the implemented stochastic master equation should be `c + c.dag()` and `1j (c - c.dag())` as explicitely presented in equation (5.64) and the following 2 paragraphs in https://arxiv.org/abs/1710.09523. The same measurement operators can also be drawn from equation (4.108) of Milburn & Wiseman _Quantum Measurement and Control_. **Changelog**; Fixed error in m_ops definition for heterodyne detection in smesolve.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1237:115,detect,detection,115,https://qutip.org,https://github.com/qutip/qutip/pull/1237,2,['detect'],['detection']
Safety,"**Description**; This adds a few more tests to the specialisations. I also found a Bug in expm and changed `TypeError` to `ValueError`. - Expm: ; - Added tests for its specialisations.; - There was a _bug_ in expm where if the matrix was csr and diagonal, zero values where not being exponentiated as they did not appear in scipy's data attribute. This case is now handled properly with the same scaling in resources (O(N) where N is the non-cero diagonal elements in the matrix).; - Incorrect shape now raises ValueError.; ; - UnaryOpMixin: ; - It did not check for bad shapes. It now does have a function that checks for them (this avoids code duplication in `trace`, `expm` and some others). ; - As a result of this change a hidden bug emerged: even though `TestProject` had a non-empty `bad_shapes` attribute, it was not doing anything as `UnaryOpMixin` did not generate tests for bad shapes. It now does. - Project:; - Changed `TypeError` to `ValueError`.; - Removed redundant `TestProject`. - Pow:; - Added the case where `n=0` as it is a special case. **Changelog**; `project` specialisations now return `ValueError` when matrix has not valid shapes.; Removed redundant `TestProject`.; Added special test case for Pow (n=0).; `UnaryOpMixin` now has test_incorrect_shapes (by default it does not have any bad shapes); Added tests for `expm` specialisations.; Fixed bug where diagonal `CSR` matrix was not exponentiating zero values in the diagonal.; `expm` specialisations now raises `ValueError` when matrix is not square. _Edit: Added ""Removed redundant `TestProject`""_; _Edit2: Added changelog_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1630:634,avoid,avoids,634,https://qutip.org,https://github.com/qutip/qutip/pull/1630,4,"['avoid', 'redund']","['avoids', 'redundant']"
Safety,"**Description**; Update tests in `test_steadystate` to use pytest.; Improve coverage by adding tests for previously untested method and options and tests for raised errors. It will not reach full coverage: no tests use `debug=True`, `pinv2` is deprecated on `scipy` side, some checks are redundant, etc. Some work on `steadystate.py` will be needed, but this is for another time, possibly for dev.major. **Changelog**; Update steadystates tests to pytest for better coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1679:288,redund,redundant,288,https://qutip.org,https://github.com/qutip/qutip/pull/1679,1,['redund'],['redundant']
Safety,"**Description**; Upgrade from 4.5.1 to 4.5.2.; Include cherry picked commit from the following PR:. #1307 Fix zcsr_proj for bras with unsorted indices; #1306 Fix quadratic complexity in zcsr_inner; #1302 Enforce a CI test with scipy<1.5; #1301 Fix brtools zheevr test; #1298 Support scipy >= 1.5 in fast_csr_matrix matmul and legacy.ptrace; #1283 Milstein's heterodyne index fix; #1271 Remove duplicate line in setup.py; #1264 Remove incorrect use of 'is' in comparisons. Code from #1288 was added manually to evade conflict and related test were reinstalled. (removed in 4.5.1, not in master). #1269 and #1242 are not included since they depend on #1209 which is more that a bugfix and is not in 4.5.0. **Changelog**; Bug Fixes; -------; - `zcsr_proj` does not fail with unsorted indices (by **Jake Lishman**); - Fixed Milstein's heterodyne errors (by **Eric Giguère**); - Removed risky code (by **Jake Lishman**); <!-- - Fix `add_circuit` and `remove_gate` (by **Canoming**) -->. Improvements; -------; - Faster `zcsr_inner` (by **Jake Lishman**); - Support for Scipy 1.5 (by **Jake Lishman**)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1310:882,risk,risky,882,https://qutip.org,https://github.com/qutip/qutip/pull/1310,1,['risk'],['risky']
Safety,"**Description**; When a `Qobj` is present in the output of a Jupyter cell, e.g. when running:; ```python; import qutip as qt; qt.fock(2, 0); ```; the output, which contains LaTeX code, is displayed in Markdown. The aim of this PR is to display the LaTeX output correctly. Replacing the `equation` environment in the LaTeX code with `$$...$$` and changing the `array` environment alignment from `*{11}c` to `cc` causes the vectors and matrices to display in the expected mathematical typeface. A test has not yet been provided, because the change was to a stored raw string; if a test is needed then the presence of this syntax in the string could be detected. **Related issues or PRs**; Fixes #2172",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2272:650,detect,detected,650,https://qutip.org,https://github.com/qutip/qutip/pull/2272,1,['detect'],['detected']
Safety,"**Description**; With new version of os, it sometime break our hardware_info function, as with the new apple M1 with #1754.; Instead of fixing it each time, I propose removing the function:; - Qutip only use the number of cpu from that function, we never uses the cpu frequency or any other info obtained.; - There are cross platform modules for that (`psutil`), if we need that information, we should use them instead. In this PR, I removed `hardware_info`, created a new function `available_cpu_count` which is placed it in `utilities.py` since `blas_info` is also there. This function is set to detect the number of cpus _available_, not total number, so that when used on a cluster, it return the number of cpus assigned to the job. I tested it on slurm. **Changelog**; Remove hardware info",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1758:598,detect,detect,598,https://qutip.org,https://github.com/qutip/qutip/pull/1758,1,['detect'],['detect']
Safety,"**Description**; With the update of correlation to v5 in #1997, the need for `shift` in `QobjEvo` and `Coefficient` disappeared.; `ShiftCoefficient`, `QobjEvo._insert_time_shift` and related tests are removed. I also restored the correlation tests on windows hoping they are now fast enough to not timeout. **Related issues or PRs**; #1997",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2016:298,timeout,timeout,298,https://qutip.org,https://github.com/qutip/qutip/pull/2016,1,['timeout'],['timeout']
Safety,"**Description**; `IntergratorScipylsoda.mcstep` read the integration range from the scipy solver's `rwork`. However `rwork` is initialized to 0 when initializing the state and only take the expected value when the first step in done. Therefore it would fail when starting from time other than `0`. `IntergratorScipyZvode` also used `rwork` in an unsafe way. Fix that and add a test. . **Related issues or PRs**; Similar improvement where first made in https://github.com/qutip/qutip/pull/1710, splitting it to made that PR simpler. **Changelog**; `IntergratorScipylsoda` safe for starting at any time.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1880:346,unsafe,unsafe,346,https://qutip.org,https://github.com/qutip/qutip/pull/1880,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"**Is your feature request related to a problem? Please describe.**; Traditionally in Hinton diagrams, any positive number is represented by a fully white square, while any negative number is represented by a fully black square. In the current implementation of `qutip.visualization.hinton`, however, each square is shaded such that numbers close to zero are represented by colors close to gray. While it is nice to be able to use shaded colormaps of this form, traditional Hinton diagrams (that is, thresholded at zero) can be easier to read when some elements that are close to zero can still have significant impact. **Describe the solution you'd like**; A `config` option or keyword argument that would allow using a threshold at zero. **Additional context**; Current Hinton diagram implementation (with colorblind safe mode turned off):. ![image](https://user-images.githubusercontent.com/31516/124228221-bb8ba800-dac0-11eb-8fc4-047ed79ecb1d.png). Current Hinton diagram implementation (with colorblind safe mode turned on):. ![image](https://user-images.githubusercontent.com/31516/124228374-fa216280-dac0-11eb-9e5c-095c1fd10373.png). Examples with thresholded colors (https://arxiv.org/pdf/1509.03770.pdf):. ![image](https://user-images.githubusercontent.com/31516/124228283-dcec9400-dac0-11eb-9067-7870f3dddf95.png); ![image](https://user-images.githubusercontent.com/31516/124228321-e970ec80-dac0-11eb-9006-c535f21c6f9b.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1595:818,safe,safe,818,https://qutip.org,https://github.com/qutip/qutip/issues/1595,2,['safe'],['safe']
Safety,"**Testing fails on several platforms**; In QuTiP 4.5.1, several `skipif`have been introduced to avoid build fail on Mac. Similarly, there are other issues related to robust random objects testing. . **Describe the solution you'd like**; An option could be using [`xdist`](https://docs.pytest.org/en/3.0.1/xdist.html) to allow specifics of certain tests, as it seems to have, beyond parallelization, some potentially interesting multi-platform coverage.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1267:96,avoid,avoid,96,https://qutip.org,https://github.com/qutip/qutip/issues/1267,1,['avoid'],['avoid']
Safety,"**Update - Ignore this. This problem was because I called the file ""pyqtgraph"" which conflicted with the library name.**. > As I understand it, the new Mac M1 chips have an ARM-based architecture so there shouldn't be any compatible binary releases on conda yet for macos - I'm surprised conda even claimed to have solved the system. Maybe they've not updated to take the new chips into account either.; > ; > If you can, you might want to try building from source - you'll also need the Python package Cython, but this way should build all the binary components for your architecture. We know (#1395) that there's a minor problem with some hardware detection on the M1 macs at the moment, but you can comment out lines 48 and 49 of `qutip/hardware_info.py` to work around it.; > ; > None of us have one of the new macs, and I think we'll need a new release to get conda-forge updated. It might be a little while before we get that done, sorry. I have the same error on an Intel Mac (11.2.1) having installed pyqtgraph within PyCharm. ```; Connected to pydev debugger (build 203.7148.72); Traceback (most recent call last):; File ""<frozen importlib._bootstrap>"", line 991, in _find_and_load; File ""<frozen importlib._bootstrap>"", line 975, in _find_and_load_unlocked; File ""<frozen importlib._bootstrap>"", line 671, in _load_unlocked; File ""<frozen importlib._bootstrap_external>"", line 783, in exec_module; File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed; File ""/Users/ben/Library/Application Support/JetBrains/PyCharm2020.3/scratches/pyqtgraph.py"", line 3, in <module>; pg.mkQApp(); AttributeError: partially initialized module 'pyqtgraph' has no attribute 'mkQApp' (most likely due to a circular import). ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-776702708:650,detect,detection,650,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-776702708,1,['detect'],['detection']
Safety,", qeye(2)) + tensor(qeye(2), sigmaz()); 5 H = H0; ----> 6 prop = propagator(H, 1.0, c_ops). /opt/anaconda3/envs/scqubits_v2/lib/python3.7/site-packages/qutip/propagator.py in propagator(H, t, c_op_list, args, options, unitary_mode, parallel, progress_bar, _safe_mode, **kwargs); 240 shape=(N, N), dtype=complex)); 241 output = mesolve(H, rho0, tlist, c_op_list, [], args, options,; --> 242 _safe_mode=False); 243 for k, t in enumerate(tlist):; 244 u[:, n, k] = mat2vec(output.states[k].full()).T. /opt/anaconda3/envs/scqubits_v2/lib/python3.7/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 263 raise Exception(""Invalid H type""); 264 ; --> 265 func, ode_args = ss.makefunc(ss, rho0, args, e_ops, options); 266 ; 267 if _safe_mode:. /opt/anaconda3/envs/scqubits_v2/lib/python3.7/site-packages/qutip/mesolve.py in _qobjevo_set(HS, rho0, args, e_ops, opt); 349 # Should be caught earlier in mesolve.; 350 raise ValueError(""rho0 must be a ket, density matrix or superoperator""); --> 351 _test_liouvillian_dimensions(H_td.cte.dims, rho0.dims); 352 return func, (); 353 . /opt/anaconda3/envs/scqubits_v2/lib/python3.7/site-packages/qutip/mesolve.py in _test_liouvillian_dimensions(L_dims, rho_dims); 332 raise ValueError("""".join([; 333 ""incompatible Liouvillian and state dimensions: "",; --> 334 str(L_dims), "" and "", str(rho_dims),; 335 ])); 336 . ValueError: incompatible Liouvillian and state dimensions: [[[2, 2], [2, 2]], [[2, 2], [2, 2]]] and [[4], [4]]; ```. ### Expected Behaviour. In my given input, vectorization of `rho` is not taken into account. However the documentation could use clarification how input must be provided to avoid this error. ### Your Environment. ```shell; QuTiP Version: 4.6.2; Numpy Version: 1.21.2; Scipy Version: 1.7.3; Cython Version: 0.29.25; Matplotlib Version: 3.5.0; Python Version: 3.7.11; Number of CPUs: 6; BLAS Info: INTEL MKL; OPENMP Installed: False; ```. ### Additional Context. _No response_",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1899:2456,avoid,avoid,2456,https://qutip.org,https://github.com/qutip/qutip/issues/1899,1,['avoid'],['avoid']
Safety,", which is a very sizable chunk of the entire test suite. We can concentrate on rewriting the longest tests to make sure we're still testing all the behaviour, without excessively long runtimes. I've been fairly conservative with the number of tests I set in motion. On the free GitHub plan we can have 20 concurrent VMs running across the whole QuTiP organisation, which I think spreads across all repositories and all test runs. With no Windows tests currently active this is 6 test runs plus the documentation build. If we want more, we could consider spending some money ($4/user/month) to convert into a Teams account which gets us 60 concurrent VMs, but I don't see any need to do this right now. All the test runners now start up almost instantly, which really solves a lot of the slowdown we were getting on Travis. The actual speeds of the Linux VMs seem to be similar to what we had on Travis - the walltimes are slightly longer because I now install _all_ optional dependencies in most runners, so slightly more gets tested than before. Currently there's also a slowdown on several machines because `cvxpy` doesn't build many wheels, and none at all for Linux, on `pip`. I install all our dependencies except BLAS/LAPACK stuff that way, since it's easiest to read out the dependencies like that. We can potentially save some build time (maybe ~3 minutes?) if we install that from conda-forge instead. I also fixed a minor point of how environment variables are read within `setup.py` (in the end I didn't actually use the new behaviour in the action, but I did during testing), and added a warning filter on dnorm tests to account for a deprecated Numpy alias being used within `cvxpy` code. Also of note: this [should allow us to have commits that skip the testing stages](https://github.blog/changelog/2021-02-08-github-actions-skip-pull-request-and-push-workflows-with-skip-ci/) (though possibly not codeclimate). You should be able to put `[skip ci]` in the commit message to avoid it.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1551:3045,avoid,avoid,3045,https://qutip.org,https://github.com/qutip/qutip/pull/1551,1,['avoid'],['avoid']
Safety,- Favor sparse matrix BR tensor for non-secular evolution. - Build diagonal Hamiltonian directly from evals to avoid small; off-diagonal nonzeros that popup when doing a basis transformation.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/789:111,avoid,avoid,111,https://qutip.org,https://github.com/qutip/qutip/pull/789,1,['avoid'],['avoid']
Safety,- Fixed num_cpus not properly set for multiprocessing.; - Fixed compiler args not recognized by clang.; - Avoid data copy in cy_expect_psi_csr.; - Add ability to reuse seeds [Options(seeds=xxx)].; - Clean up numpy imports.; - Fast reset of scipy zvode integrator and change stepping mode.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/264:106,Avoid,Avoid,106,https://qutip.org,https://github.com/qutip/qutip/pull/264,1,['Avoid'],['Avoid']
Safety,- Just a simple reorder of the e_ops to list and the safety checks.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/631:53,safe,safety,53,https://qutip.org,https://github.com/qutip/qutip/pull/631,1,['safe'],['safety']
Safety,- Restructure code to avoid multiple copies of code snippets.; - Optionally return dict with details on solution and solver details.; - Allow for building preconditioner separately so that different; iterative methods can be applied.; - Calculates inf-norm of residual at output.; - Returns number of iterations performed.; - Allow for inputing initial guess vector.; - Calculate a lower bound on the condition number of a preconditioner.; - Residual norm is given when iterative method fails to converge.; - Removed bicg method since it is not compatible.; - General docstring edits.; - Add tests for bicgstab method.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221:22,avoid,avoid,22,https://qutip.org,https://github.com/qutip/qutip/pull/221,1,['avoid'],['avoid']
Safety,- This is Py3 as to not avoid conflicts with the built in Python.; - Installs master branch of qutip.; - Shamelessly adapted from the SciPy Superpack.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/279:24,avoid,avoid,24,https://qutip.org,https://github.com/qutip/qutip/pull/279,1,['avoid'],['avoid']
Safety,- hardware_info now detects # of physical cpus under Win.; - about() and version_table() now display BLAS type.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/421:20,detect,detects,20,https://qutip.org,https://github.com/qutip/qutip/pull/421,1,['detect'],['detects']
Safety,". This transpired to be because `coverage.py` wasn't able to find our `.coveragerc` file correctly when `pytest` was called in the manner it is on Travis. This PR then does a couple of things:; 1. correctly locates the `.coveragerc` file; 2. excludes the Cython bootstrapping code from being part of the coverage; 3. correctly locates the pytest configuration file `pytest.ini` (although now we have a `pyproject.toml`, we could move that configuration there); 4. completely reorganises `.travis.yml` to remove dead configs, properly share common setups, and generally make it a bit easier to read and see what's going on; 5. fixes file reporting in Coveralls (look at the ""tree"" tab in the Coveralls web report compared to the current `master`); you can now click on the files and get proper line-by-line detail on what was covered and what wasn't, e.g. [here's the report for `mcsolve.py`](https://coveralls.io/builds/32982136/source?filename=qutip/mcsolve.py). We _don't_ enable Cython line-tracing and coverage analysis. This is actually [quite easily possible](https://cython.readthedocs.io/en/latest/src/tutorial/profiling_tutorial.html#enabling-coverage-analysis), but enabling full tracing including on `nogil` functions absolutely tanks performance to the degree where the coverage Travis run would take well in excess of two hours to complete (I think Travis actually just kills things that run longer than 2 hours). I might return to the Cython elements to see how much of them when _can_ reasonably do coverage analysis on. My prediction about actual test coverage dropping once the test files are correctly omitted, which I mentioned in #1339, came true though not _quite_ as cataclysmically (`coverage.py` uses statements, not SLOC as its metric); coverage drops from ~71% to ~63%. Technically the true percentage is higher because the Cython code is generally very well covered, but arguing between 63% and 71% when we should be aiming to get to >95% is missing the point. Fixes #1339.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1347:1662,predict,prediction,1662,https://qutip.org,https://github.com/qutip/qutip/pull/1347,1,['predict'],['prediction']
Safety,".</em></p>; <blockquote>; <h2>v2.32.0</h2>; <h2>2.32.0 (2024-05-20)</h2>; <h2>🐍 PYCON US 2024 EDITION 🐍</h2>; <p><strong>Security</strong></p>; <ul>; <li>Fixed an issue where setting <code>verify=False</code> on the first request from a; Session will cause subsequent requests to the <em>same origin</em> to also ignore; cert verification, regardless of the value of <code>verify</code>.; (<a href=""https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56"">https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56</a>)</li>; </ul>; <p><strong>Improvements</strong></p>; <ul>; <li><code>verify=True</code> now reuses a global SSLContext which should improve; request time variance between first and subsequent requests. It should; also minimize certificate load time on Windows systems when using a Python; version built with OpenSSL 3.x. (<a href=""https://redirect.github.com/psf/requests/issues/6667"">#6667</a>)</li>; <li>Requests now supports optional use of character detection; (<code>chardet</code> or <code>charset_normalizer</code>) when repackaged or vendored.; This enables <code>pip</code> and other projects to minimize their vendoring; surface area. The <code>Response.text()</code> and <code>apparent_encoding</code> APIs; will default to <code>utf-8</code> if neither library is present. (<a href=""https://redirect.github.com/psf/requests/issues/6702"">#6702</a>)</li>; </ul>; <p><strong>Bugfixes</strong></p>; <ul>; <li>Fixed bug in length detection where emoji length was incorrectly; calculated in the request content-length. (<a href=""https://redirect.github.com/psf/requests/issues/6589"">#6589</a>)</li>; <li>Fixed deserialization bug in JSONDecodeError. (<a href=""https://redirect.github.com/psf/requests/issues/6629"">#6629</a>)</li>; <li>Fixed bug where an extra leading <code>/</code> (path separator) could lead; urllib3 to unnecessarily reparse the request URI. (<a href=""https://redirect.github.com/psf/requests/issues/6644"">#6644</a>)</li>; </ul",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:1214,detect,detection,1214,https://qutip.org,https://github.com/qutip/qutip/pull/2434,1,['detect'],['detection']
Safety,".array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Opti",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1185,predict,predictions,1185,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"0: API 'r'; 61503 bytes originally requested; The 7 pad bytes at p-7 are FORBIDDENBYTE, as expected.; The 8 pad bytes at tail=0x7f98cc476def are not all FORBIDDENBYTE (0xfd):; at tail+0: 0x00 *** OUCH; at tail+1: 0x00 *** OUCH; at tail+2: 0x00 *** OUCH; at tail+3: 0x00 *** OUCH; at tail+4: 0x00 *** OUCH; at tail+5: 0x00 *** OUCH; at tail+6: 0x00 *** OUCH; at tail+7: 0x00 *** OUCH; Data at p: dd dd dd dd dd dd dd dd ... 00 00 00 00 00 00 00 00. Enable tracemalloc to get the memory block allocation traceback. Fatal Python error: bad trailing pad byte; Python runtime state: finalizing (tstate=0x7f98c9d018e0). Current thread 0x0000000109fe85c0 (most recent call first):; <no Python frame>; Abort trap: 6; ```. So these both use `scipy.linalg.eig`, which is suspicious. ## Valgrind checks. To see if I could track it down, I had a go with valgrind. This isn't guaranteed to find everything, because I'm not using a debug build of Python, and Python also typically optimises small allocations by using a custom allocator into some pre-allocated space it manages itself - invalid writes that still fall within this may not get detected by valgrind. Here is the output of `valgrind` running on the `kraus.py` file I wrote in the previous section: [kraus_valgrind.txt](https://github.com/qutip/qutip/files/6370180/kraus_valgrind.txt) (note I filtered out like 30,000 errors that stem from Python's internal memory management - they're nothing to worry about, they're just what happens when you have your own allocator). The important part is. ```; ==54133== Invalid write of size 8; ==54133== at 0x10AFAFA8A: ??? (in /Users/jake/.anaconda3/envs/py38/lib/libmkl_intel_thread.dylib); ==54133== by 0xFFFFFFFF: ???; ==54133== by 0x1162E4DEF: ???; ==54133== by 0x1162E3A5F: ???; ==54133== by 0x10550EB3F: ???; ==54133== by 0x3FEFFFFFFFFFFFFF: ???; ```. Obviously I don't have the debugging symbols for MKL, so it's pretty hard to say where exactly it's coming from, but it is at least clearly inside that l",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:5297,detect,detected,5297,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,2,['detect'],['detected']
Safety,"1. _Non-compound Hilbert spaces_: For state `A` on a simple non-compound Hilbert space, we should have `A.ptrace(0) == A` always. This has appeared as something useful in a few users' scripts (see #1239, #1413). This patch fixes the underlying bug in `_ptrace_dense` which caused this to fail (even though the logic should have supported it), and adds fast-paths to the dense and sparse partial trace functions to avoid doing work if all subspaces are being kept. Fix #1239; Fix #1413. 2. _Unsorted selections_: the tracing logic already ignores the order of the selection terms, this just fixes sparse ptrace's `dims` output. Fix #1325",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1414:414,avoid,avoid,414,https://qutip.org,https://github.com/qutip/qutip/pull/1414,1,['avoid'],['avoid']
Safety,"14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, opt, progress_bar, dims); 515 ; 516 if not r.successful():; --> 517 raise Exception(""ODE integration error: Try to increase ""; 518 ""the allowed number of substeps by increasing ""; 519 ""the nsteps parameter in the Options class.""). Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class.`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:1443,predict,predictions,1443,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub, or mute",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1608,detect,detector,1608,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"56"">https://github.com/psf/requests/security/advisories/GHSA-9wx4-h78v-vm56</a>)</li>; </ul>; <p><strong>Improvements</strong></p>; <ul>; <li><code>verify=True</code> now reuses a global SSLContext which should improve; request time variance between first and subsequent requests. It should; also minimize certificate load time on Windows systems when using a Python; version built with OpenSSL 3.x. (<a href=""https://redirect.github.com/psf/requests/issues/6667"">#6667</a>)</li>; <li>Requests now supports optional use of character detection; (<code>chardet</code> or <code>charset_normalizer</code>) when repackaged or vendored.; This enables <code>pip</code> and other projects to minimize their vendoring; surface area. The <code>Response.text()</code> and <code>apparent_encoding</code> APIs; will default to <code>utf-8</code> if neither library is present. (<a href=""https://redirect.github.com/psf/requests/issues/6702"">#6702</a>)</li>; </ul>; <p><strong>Bugfixes</strong></p>; <ul>; <li>Fixed bug in length detection where emoji length was incorrectly; calculated in the request content-length. (<a href=""https://redirect.github.com/psf/requests/issues/6589"">#6589</a>)</li>; <li>Fixed deserialization bug in JSONDecodeError. (<a href=""https://redirect.github.com/psf/requests/issues/6629"">#6629</a>)</li>; <li>Fixed bug where an extra leading <code>/</code> (path separator) could lead; urllib3 to unnecessarily reparse the request URI. (<a href=""https://redirect.github.com/psf/requests/issues/6644"">#6644</a>)</li>; </ul>; <p><strong>Deprecations</strong></p>; <ul>; <li>Requests has officially added support for CPython 3.12 (<a href=""https://redirect.github.com/psf/requests/issues/6503"">#6503</a>)</li>; <li>Requests has officially added support for PyPy 3.9 and 3.10 (<a href=""https://redirect.github.com/psf/requests/issues/6641"">#6641</a>)</li>; <li>Requests has officially dropped support for CPython 3.7 (<a href=""https://redirect.github.com/psf/requests/issues/6642"">#6642</a>)</l",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2434:1697,detect,detection,1697,https://qutip.org,https://github.com/qutip/qutip/pull/2434,2,['detect'],['detection']
Safety,"; > ; > print ""Multiplying states by small numbers""; > state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1553,detect,detector,1553,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,"; ```; Map(Space(Map(Space, Space)), Space(Map(Space, Space))); ```; to; ```; Super(Space(Map(Space, Space)), Space(Map(Space, Space)), rep='super'); ```; and I definitely like having the superop rep included in it. The user is never ever meant to write any of this themselves, so the literal length shouldn't be too much of a problem. You'd still specify dimensions using the exact same list syntax that we currently use, it's just we'd immediately parse it into this internal representation and internally operate on this, because it's much faster. Essentially what I'm describing here is an abstract syntax tree for relevant linear algebra structures. We _could_ even have the tensor index dimensions stored within the `Compound` objects, to help with `ptrace`, `permute`, the future `local_multiply` algorithms and so on. I wouldn't want to add that immediately, though - no need to complicate things. #### Point 2. Basis safety wouldn't have any performance cost here - `Space(2, basis='x')` and `Space(2, basis='y')` would referentially be unequal, so the test would be free. It's basically the same thing as checking superoperator representations. I would worry about user ergonomics for creating these though. I'd propose that all QuTiP functions maintain their current behaviour of creating everything in the number basis (`sigmaz()`, `num()` and so on all imply a particular basis). Beyond that, the ENR functions would attach some basis information onto their outputs to make them safe, and functions like `Qobj.transform` could take a required argument to name the new basis. . I'm certainly not considering this a priority, just a possible solution to the ENR problem and a couple of people had expressed interest in basis safety in the google group. We can always tack it on in a later release if it ever seems like a good idea in the future. #### Point 3. Yeah, this is absolutely all intended to be internal only. We wouldn't even print out this form in `Qobj.__repr__`, to my mind. Y",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661:1455,safe,safety,1455,https://qutip.org,https://github.com/qutip/qutip/issues/1421#issuecomment-764870661,2,['safe'],['safety']
Safety,"<!--; **Checklist**; Thank you for contributing to QuTiP! Please make sure you have finished the following tasks before opening the PR. - [ ] Please read [Contributing to QuTiP Development](https://github.com/qutip/qutip-doc/blob/master/CONTRIBUTING.md); - [ ] Contributions to qutip should follow the [pep8 style](https://www.python.org/dev/peps/pep-0008/).; You can use [pycodestyle](http://pycodestyle.pycqa.org/en/latest/index.html) to check your code automatically; - [ ] Please add tests to cover your changes if applicable.; - [ ] If the behavior of the code has changed or new feature has been added, please also update the [documentation](https://github.com/qutip/qutip-doc) and the [notebook](https://github.com/qutip/qutip-notebooks). Feel free to ask if you are not sure. Delete this checklist after you have completed all the tasks. If you have not finished them all, you can also open a [Draft Pull Request](https://github.blog/2019-02-14-introducing-draft-pull-requests/) to let the others know this on-going work and keep this checklist in the PR description.; -->. **Description**; Index error in stochastic `smesolve` made `milstein` solver with `heterodyne` method converge only O(0.5) instead of the O(1) expected. This fix it. **Changelog**; Fixed typo in stochastic code affecting `heterodyne` detection efficiency.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1283:1316,detect,detection,1316,https://qutip.org,https://github.com/qutip/qutip/pull/1283,1,['detect'],['detection']
Safety,"<br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes all tasks, then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Ignored | Always completes all tasks anyway, see below. **New behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | Aborts currently running tasks, <br> then returns results of all finished tasks.; CTRL+C | First CTRL+C raises `KeyboardInterrupt` | First CTRL+C raises `KeyboardInterrupt`; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes tasks earlier in the list, then <br> aborts remaining ones and raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Removed from documentation | Removed from documentation. **Job timeout**. Currently, the job timeout parameter is ignored by parallel_map. In loky_pmap, it is not the maximum allowed time for one job, but the maximum time between two job finishes (possibly in different processes). If this time is exceeded, all tasks will still be executed until the end; only the results of the tasks that finished too slowly will be discarded. I do not think that this was the intention of the job timeout parameter?. Unfortunately, both `ProcessPoolExecutor` (which parallel_map is based on) and its loky version do not support timeouts for single tasks, nor do they support aborting single tasks manually. (The loky one supports killing *all* worker processes at once.) If we wanted to have a job timeout parameter, we would need to either use non-public API to obtain references to the worker processes and interrupt them manually, or to completely rewrite parallel_map and base it on e.g. `multiprocessing.pool.Pool`. Maybe better",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2280:2037,timeout,timeout,2037,https://qutip.org,https://github.com/qutip/qutip/pull/2280,1,['timeout'],['timeout']
Safety,"> ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. @AGaliciaMartinez Hey Asier, issue #1616 refers to a similar problem. Following it, I tried `plt.show()` and it works. But `b.show()` doesn't work. So, please suggest what to do? Now that `plt.show()` works, I can remove my minor addition in the `show()`, but still I would like to have `b.show()` working. Looking forward to your response.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059:227,avoid,avoid,227,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945618059,1,['avoid'],['avoid']
Safety,"> > I am not sure why it is only failing in the Python 3.8 case.; > ; > Well, it's a statistical average, so it can deviate. I don't think it has anything to do with Python 3.8. But probably it can be avoided? I guess its the same question as #1268; > ; > I'm thinking, what about adding a `targets` parameters to `QubitCircuit.run_statistics`. Usually, people don't interested in the full output state of the circuit because many of them are ancillary qubits. They can use `targets` to specify what is the qubits they want to look at. In the function, we can use `ptrace(state, targets)` to trace out the ancilla. Seems like a good idea, maybe we can add it as optional parameter to both `QubitCircuit.run_statistics` and `QubitCircuit.run`. Also, regarding Python 3.8, I was saying because both times it only failed in that test run, also never failed in any of my runs. Should I make tolerance higher ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594:201,avoid,avoided,201,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640006594,1,['avoid'],['avoided']
Safety,"> > _**Other minor changes**_; > > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > > ```; > > if self.fig:; > > plt.show(self.fig); > > ```; > ; > This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again. So, I found that the value of `self._shown` is false when it tries to execute `show()', and therefore, the Bloch sphere is not displayed. ; I use the following code to play around with the Bloch sphere, please let me know if I need to add something:; ```; b= Bloch(fig=None); b.xlabel = ['$\\left|+\\right>$',' ']; b.ylabel = ['$\\left|+i \\right> (r_8)$',' ']; b.xlpos = [1.1,-1.1]; b.zlabel = [' $\\left|0\\right> (r_7)$','$\\left|1\\right> $']; b.zlpos = [1.075,-1.08]. <b.add_other_stuff>. b.view=[-20,20,0]; b.show(); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485:474,avoid,avoid,474,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945609485,1,['avoid'],['avoid']
Safety,"> As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one.; > ; > I don't think there's a problem distributing files as part of the tests. You can add a line which says; > ; > ```; > recursive-include qutip/tests/qasm_files *.qasm; > ```; > ; > to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest.; > ; > Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see.; > ; > Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us. Thanks for this information, it seems to work ! I was wondering if the following statement is still needed (at all) in `PACKAGE_DATA` in setup.py? ; `'qutip/tests/qasm_files': ['*.qasm'],`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639:38,avoid,avoid,38,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656450639,1,['avoid'],['avoid']
Safety,"> Does anyone know how we would give some kind of deprecation warning when `from qutip import *` is made to say that only core functions will be imported from v5 onwards?. @ajgpitch . I know I'm resurrecting a dead thread, but I have a way of detecting star imports if you can cope with a fairly gross hack. The only internal difference in `from qutip import *` (that I know about) from `import qutip` is that in the former, the import system access the `qutip.__all__` list to see which names it should import. This is intended to be a list of names, so the star import doesn't _have_ to import every single name, i.e. so you can manually set what's public to a module; the star import is designed for use within packages, and the user importing a package like that is strongly recommended against (though in scientific code, I'm 100% sure that's a losing battle). So, what if we make `__all__` _look_ like a list, but a list that injects a warning whenever anyone tries to see what items it has? An example:; ```python; import warnings as _warnings. x = 2. class _all_wrapper(list):; def __iter__(self, *args, **kwargs):; _warnings.warn(""You star-imported!""); return super().__iter__(*args, **kwargs). __all__ = _all_wrapper(['x']); ```; I put that in a package called ""test"".; ```python; >>> from test import x; >>> x; 2; ```; or; ```python; >>> from test import *; /Users/jake/code/tmp/test/__init__.py:7: UserWarning: You star-imported!; _warnings.warn(""You star-imported!""); >>> x; 2; ```. I won't complain if you want to scream after that...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925:243,detect,detecting,243,https://qutip.org,https://github.com/qutip/qutip/issues/1071#issuecomment-605502925,1,['detect'],['detecting']
Safety,"> I addressed all your comments in my new commit, but when I try to run the tests with pytest I get a strange error:. This is likely because qutip is not correctly installed. Could you try uninstalling qutip and reinstalling again?. > Also, to avoid the circular import problem with tensor, would it be better if I created a new py file (qutip.core.fermionic_operators.py) for these new operators? . A new file for this seems too much for me... I think `operators.py` is the best choice but it includes indeed mostly basic operators not using `tensor`. Maybe there is a better place for this @Ericgig ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451:244,avoid,avoid,244,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565683451,1,['avoid'],['avoid']
Safety,"> I am not sure why it is only failing in the Python 3.8 case. Well, it's a statistical average, so it can deviate. I don't think it has anything to do with Python 3.8. But probably it can be avoided? I guess its the same question as #1268 . I'm thinking, what about adding a `targets` parameters to `QubitCircuit.run_statistics`. Usually, people don't interested in the full output state of the circuit because many of them are ancillary qubits. They can use `targets` to specify what is the qubits they want to look at. In the function, we can use `ptrace(state, targets)` to trace out the ancilla.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-640005926:192,avoid,avoided,192,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-640005926,1,['avoid'],['avoided']
Safety,"> I think the `.integrate(t, step=....)` interface is currently way too complex, as evidenced by the difficulty of implementing it and the hard to resolve issues.; > ; > SciPy has a much simpler ODE interface -- see https://github.com/scipy/scipy/blob/v1.7.1/scipy/integrate/_ivp/base.py#L25-L214. Essentially a single `.step()` function.; > ; > Is there a reason we could not implement something similar here, and just have one `.step()` method and then implement `.integrate()` on top of that?. The `.step()` is essentially `.integrate(self.t)`, sot there would be no need for both.; If you mean having `step()` always advance one internal integrator step, we don't always have that possibility, `dop853` cannot advance only one step. And it would require to safe `self.back` each time even when not needed.; If you want a method to just advance to the time `t`, what ever it is as `scipy` seems to do, it will crush `mcsolve` speed. `mcsolve` has a root finding step that require a some back and forth and ode schemes all have their quirks when doing this. For actual use `integrate`, `step` and `backstep` can be 3 methods. I had this in the evolver PR but was told to merge them... The complexity could be split: have `integrate` for normal evolution (`sesovle`, `mesolve`), and `step` or `mcstep` for `mcsolve`.; This would also make it easier to create new Integrator for special use, it is easier to choose not to support `mcsolve` if the logic is split.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667:761,safe,safe,761,https://qutip.org,https://github.com/qutip/qutip/pull/1643#issuecomment-925988667,2,['safe'],['safe']
Safety,"> I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine. Where were you running your example? Python console, IPython console, Jupyter notebook? I'm guessing the IPython console because of the reference to `display`, but I wanted to double check.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216:165,redund,redundant,165,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988089216,1,['redund'],['redundant']
Safety,"> It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?. I was thinking that we're removing functions that users might be using in their own code. On the other hand it is functionality that is untested and breaks on many modern machines, so I am not completely against adding this to 4.6.3.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699:113,safe,safer,113,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015547699,1,['safe'],['safer']
Safety,"> It would be good if our naming can help avoid confusion between the concept of a `dtype` (which is the type of elements within an array) and our `data backend type` (which is how the array itself is represented). I'm not sure what a good convention is, but ensuring the docstrings for the backend type have specific examples of valid inputs would definitely help (e.g. `dense` or `csr`). We actually deliberately called this `dtype` to make it familiar to Numpy syntax. The concept of the Numpy `dtype` is mostly irrelevant when using QuTiP, because all data is invariably `double complex`, and this `dtype` is the larger data type of `Qobj`. I suppose it could be `fmt` instead (as a common abbreviation of `format`)? Or even the full word `format` I suppose. Agree on the docstrings - we should have an alias like Numpy's `array_like` that we define clearly in documentation in one place.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809213365:42,avoid,avoid,42,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809213365,2,['avoid'],['avoid']
Safety,"> Overall, it look good as a way to make HEOM solvers work on v5. Woot. > But the use of data layer seems not ideal, why is the rhs fixed to `csr`. With it's size, it's probably not ideal as a Dense, but I don't think we should raise an error for other type... It doesn't actually restrict the RHS to CSR -- it only *constructs* the RHS as a CSR initially. The base solver will convert the RHS to the correct format for the integrator if needed. It might be possible one day to avoid constructing the RHS as a CSR but it might be tricky to make it not horribly slow, so I'd like to leave this as potential enhancement rather than work on it right now. > There is no `heomsolve` to go with `HEOMSolver`. I've added `heomsolve`. It has more parameters than `sesolve` or `mesolve`, which is not great, but I'm not sure how to avoid it. The bath and the max_depth are not really optional for the HEOM, and there aren't reasonably default values. > With other solvers, they accept `H` as a `Qobj` or `QobjEvo` only, list format is accepted by the __solve function. I changed HEOMSolver to only support `Qobj` or `QobjEvo`. I allowed `HSolverDL` to continue to support other objects since `HSolverDL` exists only for backwards compatibility. Perhaps we should remove it at some point, but the amount of code in it is also tiny. > `bofin_*.py` does not have a `__all__`, even if they are not supposed to be imported directly, it would be better if they had. I've added `__all__`.; ; > The test coverage does not include time-dependent Hamiltonian. Are those too slow to include in automated tests?. The tests don't include a truly time-dependent case because it's hard to solve one analytically. Previously I tested the time-dependent logic by supplying `[H]` as the system (i.e. fooling the code into using the time-dependent path) but that broke when I switched to using `QobjEvo.isconstant`. I fixed it by using `[H, lambda t: 1.0]` instead, which would be very hard to determine as constant. Thank for pi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845:478,avoid,avoid,478,https://qutip.org,https://github.com/qutip/qutip/pull/1869#issuecomment-1165701845,2,['avoid'],['avoid']
Safety,"> Overly specific build-system.requires can also cause failures with conda-forges build system. Conda-forge does not and cannot use `build-system.requires`; those are PyPI packages and they might not even have the same name in Conda. Conda always sets PIP_NO_BUILD_ISOLATION to avoid this. This (the linked log) is tripping up on setup_requires, which is deprecated and I don't think you have it set up correctly anyway; if you ask for `Cython` but don't `install_requires` Cython, Cython will not be installed before running the setup.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502:278,avoid,avoid,278,https://qutip.org,https://github.com/qutip/qutip/pull/1735#issuecomment-989955502,1,['avoid'],['avoid']
Safety,"> The bug in the 3.9 tests seems a real bug with the new tests, it should be fixed. If it's numpy version specific, we can officially drop that version. (1.20). Yes, I need to fix that. > I see no mention of tidyup, some of the tested operation use it, should it not be turned off for these tests? Otherwise it will cause random fails eventually. Disabling tidyup during the tests is a good idea. > What is the plan for other functions? Most of the common function are tested, but some often used are missing (`kron`, `l2`, `isherm`, `expect`). For this PR I just covered all the functions that are methods of the `Data` class. Some of these call out to dispatch functions, but I included those anyway since they're part of the `Data` class API. > I am also curious about some of the more complex functions (`inv`, `expm`, `pow`) would fare, but I don't expect them to play nice with this kind of test. I suspect those will be a bit tricky, but I think we can still find a way to assert that they give the right answer even if it requires restricting a bit what examples hypothesis generates. > I disagree with making our code worst for common use case just to handle junk the same way others do. I don't think I did this anywhere now? In some cases what QuTiP was doing was just wrong. E.g. `inf * CSR-zeros` is just `NaNs` everywhere. The previous QuTiP answer was wrong. We also don't have to handle junk the same way, but we do have to handle junk in a way that is sensible and avoids silently propagating or swallowing errors. People are going to make mistakes, that set of people includes us as core QuTiP developers.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695:1482,avoid,avoids,1482,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1507141695,1,['avoid'],['avoids']
Safety,"> This is the same as #1247; > ; > QuTiP uses sparse matrices, so a matrix element smaller than a certain threshold (by default 1e-7) will be discarded. This can be changed in the settings.; > ; > Consider changing your unit to avoid very small values, for instance, by writing the formula with h=1` and in nanosecond time unit. Sorry which formula are you referring to when you say h=1'?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1466#issuecomment-804906162:228,avoid,avoid,228,https://qutip.org,https://github.com/qutip/qutip/issues/1466#issuecomment-804906162,1,['avoid'],['avoid']
Safety,"> What's the preferred method to link functions that are not public APIs?. I don't think we should link to non-public API in the doc. Non-public API should not (at least no encouraged) be used outside of QuTiP because we may change it without issuing a deprecation warning. Besides, [`check_unitary`](http://qutip.org/docs/latest/apidoc/classes.html?highlight=check_isunitary#qutip.Qobj.check_isunitary) is a public API, it is a class method under `Qobj`, rather than a function, see bellow. > Qobj vs qobj link. `qutip.qobj.isoperbra` and `qutip.Qobj.isoperbra` are different. The lower case `qobj` is a submodule in QuTiP (qobj.py) while `Qobj` is a class. `isoperbra` is not a class method under `Qobj`. It is a function defined under the submodule `qobj`. So only `qutip.qobj.isoperbra` is the correct path. To make the life simpler, I would recommend to use the shortcut ``:func:`.isoperbra` `` for functions and ``:meth:`.Qobj.class_method` ``. Or even simpler: ``:obj:`.isoperbra` ``. Sphinx will automatically look for the correct match. As long as there are no two functions with the same name, we are safe. This isalso because `qutip.qobj.isoperbra` will be a wrong path in qutip 5.0. The file is moved.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1499#issuecomment-824624079:1111,safe,safe,1111,https://qutip.org,https://github.com/qutip/qutip/pull/1499#issuecomment-824624079,2,['safe'],['safe']
Safety,"> Would it be okay to use `_path_from_env(""XDG_CONFIG_HOME"", ` / "".config"")`. That would probably be fine. `XDG_CONFIG_HOME` is not normally set as an environment variable, but you're suggesting the same code that the xdg package itself uses, so the result will be the same, using ~/.config. . xdg seems to be pure Python, indifferent to operating system. So it would just use whatever `Path.home()` returns on Windows. Some frameworks take it a step further and use an Organization/Application subdir underneath ~/.config. That's what Qt does with [`QStandardPaths::ConfigLocation`](https://doc.qt.io/qt-6/qstandardpaths.html#StandardLocation-enum). So Qt would use these XDG paths where supported (Linux systems, maybe MacOS) and assign equivalent paths in the case of Windows. No point overengineering it though (unless you want to switch to QtPy6 as a framework!), so using `_path_from_env` will get the job done if you're trying to avoid the extra xdg dependency.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649:937,avoid,avoid,937,https://qutip.org,https://github.com/qutip/qutip/issues/1876#issuecomment-1219870649,1,['avoid'],['avoid']
Safety,"> You see, the gate Gate(RY, targets=[0, 1], controls=None) is clearly wrong because RY acts only on one qubits. Yep ! That's what I thought as well..for all the single qubit gate outputs with two targets. I knew I was getting an error but was not sure why it was not the same error as both of you. It was because I was using the released version (like you predicted). . I was trying to put off installing from source for as long as I could because I would have to install conda and other dependencies manually. Now, I did get `ValuError`. Thanks !",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1330#issuecomment-810592555:357,predict,predicted,357,https://qutip.org,https://github.com/qutip/qutip/issues/1330#issuecomment-810592555,2,['predict'],['predicted']
Safety,"> _**Other minor changes**_; > ; > In `def show(self)`, the plot was not being displayed using the previous lines of code in the function, so I have commented them out and changed it to; > ; > ```; > if self.fig:; > plt.show(self.fig); > ```; This is something I have not being able to reproduce. It works fine for me with the unmodified lines of code in `show()`. Could you provide an example of when it stops working? In this way, we can include it in a test to avoid the issue happening again.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935:464,avoid,avoid,464,https://qutip.org,https://github.com/qutip/qutip/pull/1690#issuecomment-945596935,1,['avoid'],['avoid']
Safety,"> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes all tasks, then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Ignored | Always completes all tasks anyway, see below. **New behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | Aborts currently running tasks, <br> then returns results of all finished tasks.; CTRL+C | First CTRL+C raises `KeyboardInterrupt` | First CTRL+C raises `KeyboardInterrupt`; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes tasks earlier in the list, then <br> aborts remaining ones and raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Removed from documentation | Removed from documentation. **Job timeout**. Currently, the job timeout parameter is ignored by parallel_map. In loky_pmap, it is not the maximum allowed time for one job, but the maximum time between two job finishes (possibly in different processes). If this time is exceeded, all tasks will still be executed until the end; only the results of the tasks that finished too slowly will be discarded. I do not think that this was the intention of the job timeout parameter?. Unfortunately, both `ProcessPoolExecutor` (which parallel_map is based on) and its loky version do not support timeouts for single tasks, nor do they support aborting single tasks manually. (The loky one supports killing *all* worker processes at once.) If we wanted to have a job timeout parameter, we would need to either use non-public API to obtain references to the worker processes and interrupt them manually, or to completely rewrite parallel_map and base it on e.g. `multiprocessing.pool.Pool`. Maybe better to just remove the job_timeout parameter? If you agree with that, I will then also re",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2280:2140,timeout,timeout,2140,https://qutip.org,https://github.com/qutip/qutip/pull/2280,1,['timeout'],['timeout']
Safety,"> state3 = qt.ket([0])_1e-12; > state2 = qt.ket([0])_9.999e-13; > state1 = qt.ket([0]); > state1 = qt.Qobj(state1.data*9.999e-13); > print 'Desired:', state3; > print 'Undesired:', state2; > print 'Desired, via workaround:', state1; > Multiplying states by small numbers; > Normal behaviour: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 1.00000000e-12]; > [ 0.00000000e+00]]; > Undesired: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 0.]; > [ 0.]]; > Desired, via workaround: Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; > Qobj data =; > [[ 9.99900000e-13]; > [ 0.00000000e+00]]; > But the real issue is this 1e-12 bound also occurs for expect() with tensored operators and states even if the individual operators's values are all >1e-12:; > ; > print ""Expectation values with small operators""; > detector = qt.Qobj([[1e-12, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-12:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-6, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-6:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > detector = qt.Qobj([[1e-14, 0], [0, 0]]); > print 'Expectation value for one detector, 1e-14:', qt.expect(detector, qt.ket([0])); > detector = qt.Qobj([[1e-7, 0], [0, 0]]); > print 'Expectation value for two detectors, 1e-7:', qt.expect(qt.tensor(detector, detector), qt.tensor(qt.ket([0]), qt.ket([0]))); > Expectation values with small operators; > Expectation value for one detector, 1e-12: 1e-12; > Expectation value for two detectors, 1e-6: 1e-12; > Expectation value for one detector, 1e-14: 1e-14; > Expectation value for two detectors, 1e-7: 0.0; > It is important for me to get the real nonzero value in the last case, but I cannot see a way to do it with the current behaviour.; > ; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, vi",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/521#issuecomment-242049107:1582,detect,detector,1582,https://qutip.org,https://github.com/qutip/qutip/issues/521#issuecomment-242049107,1,['detect'],['detector']
Safety,">https://pillow.readthedocs.io/en/stable/releasenotes/9.0.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>Restrict builtins for ImageMath.eval() <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5923"">#5923</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Ensure JpegImagePlugin stops at the end of a truncated file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5921"">#5921</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fixed ImagePath.Path array handling <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5920"">#5920</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Remove consecutive duplicate tiles that only differ by their offset <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5919"">#5919</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Removed redundant part of condition <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5915"">#5915</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Explicitly enable strip chopping for large uncompressed TIFFs <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5517"">#5517</a> [<a href=""https://github.com/kmilos""><code>@​kmilos</code></a>]</li>; <li>Use the Windows method to get TCL functions on Cygwin <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5807"">#5807</a> [<a href=""https://github.com/DWesl""><code>@​DWesl</code></a>]</li>; <li>Changed error type to allow for incremental WebP parsing <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5404"">#5404</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improved I;16 operations on big endian <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/5901"">#59",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1760:1342,redund,redundant,1342,https://qutip.org,https://github.com/qutip/qutip/pull/1760,1,['redund'],['redundant']
Safety,"@AGaliciaMartinez @RobHam99 I will put in a small vote that we leave sorting this out for QuTiP 5 (i.e. the dev.major) branch, where I suspect it has been sorted out already. The only QuTiP release it could go into before 5 would be 4.7 and I'd like to avoid doing too many minor clean-ups in 4.7 because I want 4.7 to just work nicely for existing users before the big just to 5. Happy to consider exceptions to that policy on a case by case basis though.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454:253,avoid,avoid,253,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-974502454,1,['avoid'],['avoid']
Safety,"@AGaliciaMartinez Perhaps it would be better to check for whether `other` is complex directly using `isinstance(other, numbers.Number)`. This is the canonical approach for detecting scalar numbers and avoids raising and catching an exception and allows objects that support just `__complex__` to still be dispatched for special handling.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257:172,detect,detecting,172,https://qutip.org,https://github.com/qutip/qutip/pull/1620#issuecomment-885075257,2,"['avoid', 'detect']","['avoids', 'detecting']"
Safety,"@AGaliciaMartinez The `.elements` are intentionally only accessible from Cython (it's not safe to modify the list from Python because the QobjEvo element lists are meant to be immutable). If you have an idea for a cleaner implementation of this though, maybe just write the idea here and then we can all look at it?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808:90,safe,safe,90,https://qutip.org,https://github.com/qutip/qutip/pull/2000#issuecomment-1257255808,1,['safe'],['safe']
Safety,"@AGaliciaMartinez This doesn't look terrible to me, but we've avoided silencing warnings like this in qutip so far and it would be nice to keep it that way. Some questions:. * Do you know why qutip's own tests are not affected?; * Which qutip-tensorflow tests are affected? All of them?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142:62,avoid,avoided,62,https://qutip.org,https://github.com/qutip/qutip/pull/1582#issuecomment-864882142,1,['avoid'],['avoided']
Safety,"@BoxiLi thank you so much for the comments! . I addressed all your comments in my new commit, but when I try to run the tests with `pytest` I get a strange error:. <img width=""570"" alt=""Screen Shot 2023-05-27 at 1 01 17 PM"" src=""https://github.com/qutip/qutip/assets/74874354/1b34ab67-a5c0-4223-863d-d7b64109f153"">. This seems to be an issue with a circular import in `qutip.core.data.__init__.py` file, but I haven't touched anything in that file, or for that matter, any file besides `qutip.core.operators.py` and `qutip.tests.core.test_operators.py`. I wanted to reach out and ask if this problem has been resolved somewhere else. Also, to avoid the circular import problem with `tensor`, would it be better if I created a new py file (`qutip.core.fermionic_operators.py`) for these new operators? happy to do this if it would be helpful. Thank you so much, and please let me know if you have any insight on the `pytest` error :)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898:643,avoid,avoid,643,https://qutip.org,https://github.com/qutip/qutip/pull/2166#issuecomment-1565664898,1,['avoid'],['avoid']
Safety,"@Ericgig Approved, because faster tests are good, but I am wondering if the krylovsolve tests are much slower on v5 because tests didn't seem to timeout on v4?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801:145,timeout,timeout,145,https://qutip.org,https://github.com/qutip/qutip/pull/1861#issuecomment-1098919801,1,['timeout'],['timeout']
Safety,"@Ericgig I implemented a version of your suggestion. Let's see how it goes on this test run. Other notes:; - I switched the fork method to `forkserver` for Linux, as that should play better with threads.; - I left the correlation tests in for now, but will remove them again if they still timeout. Perhaps we should set some timeouts in the correlation function tests as a way to prevent the whole test run from dying.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877:289,timeout,timeout,289,https://qutip.org,https://github.com/qutip/qutip/pull/1948#issuecomment-1171510877,2,['timeout'],"['timeout', 'timeouts']"
Safety,"@Ericgig I re-factor the result class a fair bit to make it possible to re-use more of it for the HEOMSolver. Let me know if you like the general approach. I would like to remove the additional parameters to `_post_init(...)` and supply everything either directly via the result options (since that would avoid the HEOMResult class receiving parameters it doesn't use like ``rhs_is_super``). I'm happy to implement that here if you have an idea, but I'm also happy to leave it for a future PR (maybe post #1889).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450:305,avoid,avoid,305,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1139694450,1,['avoid'],['avoid']
Safety,"@Ericgig Ready for review again. I haven't implemented anything for detecting whether an .e_op returns a number that can be averaged, and I'd like to leave that for a later PR because it's really about a better implementation of the MultiTrajResult and MultiTrajResultAveraged classes and that feels quite separate (even if it tweaks the Result class a bit more). In the `HEOMResult` class in #1869 I override `_store_state`, `_store_final_state`, `_pre_copy` and `_e_op_func` which gives quite a lot of flexibility and might be sufficient to implement `MultiTrajResult` as a sub-class of `Result`. There is also a question of whether there should be a way to supply processors directly -- either in e_ops or a separate lists. Processors are almost identical to e_ops except their values are not stored in `.expect` or `.e_data` and they don't appear in `.e_ops`. I'd like to leave that for a later (maybe never) PR too -- currently I don't have an immediate use case for it, and I don't want to expose the extra feature directly until we do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664:68,detect,detecting,68,https://qutip.org,https://github.com/qutip/qutip/pull/1907#issuecomment-1144867664,1,['detect'],['detecting']
Safety,"@Ericgig Thanks for finding this. I don't think we should add a setting for this though -- it's too obscure. The point of returning `None` when `p == 0` seems to be to avoid division by zero, not to round down small probabilities. I think we should either 1) update the test or 2) if we lots some precision in a recent change, try to get that precision back. Do you know which change caused the loss of precision?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156:168,avoid,avoid,168,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917036156,1,['avoid'],['avoid']
Safety,"@Ericgig That is true. Possibly a check in `Qobj` constructor, would be the best to avoid mismatched `Qobj`s to be created in the first place. A rudimentary fix might be something like:. ```diff; diff --git a/qutip/qobj.py b/qutip/qobj.py; index bf82a4a6..6c7c630d 100644; --- a/qutip/qobj.py; +++ b/qutip/qobj.py; @@ -310,6 +310,11 @@ class Qobj(object):; ); self.dims = [[int(inpt.shape[0])], [int(inpt.shape[1])]]; ; + if self._data.shape[0] != np.prod(self.dims[0]) or \; + self._data.shape[1] != np.prod(self.dims[1]):; + raise ValueError(f""Qobj has mismatched dims {self.dims} "" +\; + f""and shape {self._data.shape}""); +; if type == 'super':; # Type is not super, i.e. dims not explicitly passed, but oper-like; # shape.; ```; If you think this would be a good fix I can open a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683:84,avoid,avoid,84,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021447683,1,['avoid'],['avoid']
Safety,"@Ericgig When I read the description of this PR I thought you might have implemented something that might be even faster. Instead of having the numpy proxy have dynamic access via `__getattr__` we could do either of the following:. * When the numpy backend is set, actually copy the attributes across to the proxy objects so that they are looked up in `__dict__` in the ordinary way without having to fall back to `__getattr__`.; * Do the same as the above but define the attributes as slots so that the `__dict__` lookup is avoided.; * Or implement `__getattribute__` so that the original `__dict__` lookup is never checked.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618:525,avoid,avoided,525,https://qutip.org,https://github.com/qutip/qutip/pull/2509#issuecomment-2294432618,1,['avoid'],['avoided']
Safety,"@Ericgig yes, I like the args idea. Let's go with that. And you are of course right about the use of `dense2D_to_fastcsr_fmode`. Should definitely be avoided in users code",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/947#issuecomment-462900455:150,avoid,avoided,150,https://qutip.org,https://github.com/qutip/qutip/issues/947#issuecomment-462900455,1,['avoid'],['avoided']
Safety,@Zac-HD Would you mind doing a quick sanity check of my `MatrixShapesStrategy` class (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L15-L62)? Mostly I want to know whether I should have been able to do this with `mutually_broadcastable_shapes`. I also wouldn't mind a quick check of `qobj_shared_shapes` (https://github.com/qutip/qutip/blob/2aee70cb3981e60e236de831c56505a7caabd0aa/qutip/tests/strategies.py#L113-L131). Is this a good thing to be doing with shared strategies?,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602:37,sanity check,sanity check,37,https://qutip.org,https://github.com/qutip/qutip/pull/1957#issuecomment-1207406602,1,['sanity check'],['sanity check']
Safety,"@ajgpitch I am trying to fix this will Pull #660. I do not see this on any other compiler, so it is hard to peg down. Hopefully, switching to a vector from a pointer does the trick. The strange thing is that Apple's own clang compiler does not abort with this error, but somehow XCODE does.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/649#issuecomment-286179882:244,abort,abort,244,https://qutip.org,https://github.com/qutip/qutip/issues/649#issuecomment-286179882,1,['abort'],['abort']
Safety,"@arnelg and @cgranade, you are both raising good points here. I'm not exactly sure what the best solution for this particular issue is, but do tend to agree with @arnelg that we do not want functions that perform unexpected actions, if possible, and that explicit is better than implicit. However, ultimately, it has to be the docstrings that should resolve any ambiguities, because not all functions can be intuitive to everyone, since we all have different backgrounds and expectations. So if the current behaviour is clearly described in the docstring, it should also be an acceptable solution I think. But one important thing that @arnelg also alluded to is that if at some point we expect that we might want to use `composite(S, O)` to mean something different than `composite(S, to_super(O))`, then we should better not implement the operator-to-superoperator promotion implicitly in `composite` now. Since the `composite` function is brand new it might be a good idea at this point to avoid doing these implicit assumptions on how it will be used until various use-cases has been explored in more details. I absolutely agree that it is great to have discussions about these kind of design issues, and it's great that you both have taken an interest in this particular issue. I also agree that Qobj.dims is a bit obscure and not that flexible, and maybe insufficient for complex cases with mixes of operators, kets, superoperators along different subsystems. This would not be an easy thing to change, but having a discussion about the short-comings and possible solutions would be great. I've created a new page on the wiki for listing various issues and design short-comings in qutip:. https://github.com/qutip/qutip/wiki/Future-Design-Changes. Feel free to add to this page and edit what's already on it (and of course, propose solutions!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/241#issuecomment-58190164:992,avoid,avoid,992,https://qutip.org,https://github.com/qutip/qutip/pull/241#issuecomment-58190164,2,['avoid'],['avoid']
Safety,"@asma2farhat; If you don't use `countstat`, you can safely ignore this.; Otherwise it should be fixed in the `qutip-4.7.X` branch with #2323, (not released yet, coming in 4.7.6):; `pip install git+https://github.com/qutip/qutip@qutip-4.7.X`; It should also be fixed in v5 that is in beta `pip install qutip --pre`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977:52,safe,safely,52,https://qutip.org,https://github.com/qutip/qutip/issues/1755#issuecomment-1994342977,1,['safe'],['safely']
Safety,@cgranade did you test your PR #362 against dick-t example? If so what were the results?; It would seem that dick-t is comparing a method that works with states in general (mixed or pure) with one that assumes states are pure. Do we have some method in qutip that gives the fidelity when states are assumed pure? It would seem more efficient (and less numerical error risk) to compute the fidelity without the sqrtm (as dick-t did in the comparison) if we knew the states were pure.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/361#issuecomment-134927300:368,risk,risk,368,https://qutip.org,https://github.com/qutip/qutip/issues/361#issuecomment-134927300,1,['risk'],['risk']
Safety,"@drew-parsons I imagine `MPLBACKEND=agg` avoids the issue by not using X at all. I have used it in the past for matplotlib tests, and it's not a bad idea perhaps to switch the QuTiP visualization tests to the `agg` backend, but it's not something I'm going to tackle right now I don't think (too many other big QuTiP changes up in the air at the moment).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571:41,avoid,avoids,41,https://qutip.org,https://github.com/qutip/qutip/issues/1639#issuecomment-912397571,1,['avoid'],['avoids']
Safety,"@goerz I think one of Mølmer's papers (maybe the one I have pointed out) addressed the equivalence of the two methods. Sorry, I don't have a definite paper to point out at this moment. I was actually organizing the Julia community to work on this direction (see [JuliaQuantum](http://juliaquantum.github.io)) from scratch, and hence didn't follow up the efforts in the measurement simulation within QuTiP. . When I was writing my paper on continuous measurement ([PRA, 93.023817](http://journals.aps.org/pra/abstract/10.1103/PhysRevA.93.023817)), I came up the argument that the former method may be more appropriate for measurement models. This is because measurements have to happen in evenly spaced time steps determined by the detector's integrating time, so it is intuitive to use a random number to judge if on each measurement step the quantum jump will happen. There may be a way to use the second method to implement the same measurement simulation model, but I didn't think too much on it. In reality, I developed another more efficient method without actually evolving the density operator in my paper to simulate continuous measurement using a set of stochastic equations for squeezing thousands of atoms' state which has not been included in QuTiP yet. Sorry I don't have more useful reference that explains this point in more details at this moment. Good luck!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/111#issuecomment-220744432:731,detect,detector,731,https://qutip.org,https://github.com/qutip/qutip/issues/111#issuecomment-220744432,2,['detect'],['detector']
Safety,"@hodgestar Thanks for doing it!; The custom `m_ops`, as far as I understand, would be of a form `[np.sqrt(coef)*(a+a.dag()), -1i*np.sqrt(coef)*(a - a.dag())]` where `a` would be an annihilation operator for a photon in a mode that is detected, and `coef` represents whatever happens between the emission and the detection (cavity-guide coupling, detection efficiency etc). In the current implementation it would be subset of default `m_ops`, that are formed as; ```python; for c in sso.sc_ops:; m_ops += [c + c.dag(), -1j * (c - c.dag())]; ```. As for the tests, I can think of something like this; ```python; def test_heterodyne_mesolve():; b = 1 # drive amplitude; gamma = 1 # spont. emission rate; eta = 0.3 # coupling efficiency; n_steps = 1000; n_traj = 50; ; H = np.sqrt(eta*gamma) * b * sigmay(); c_ops = [np.sqrt(gamma)*sigmam()]; psi0 = basis(2); times = np.linspace(0, np.pi*2, n_steps). n_tr = 3. sme_het = smesolve(; H,; psi0,; times,; [],; c_ops,; e_ops=[sigmax(), sigmay(), sigmaz()],; store_measurement = True,; dW_factors=[1e-5, 1e-5], # to make tests simpler; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay()],; ntraj=n_traj,; noise=123, # random seed; ); ; assert np.array(sme_het.measurement).shape == (n_traj, n_steps, 1, 2); assert all(np.isclose(np.array(sme_het.measurement).mean(axis=0)[:,0,0].T, np.sqrt(eta)*sme_het.expect[0], atol=2e-2)); ; def test_incorrect_m_ops_heterodyne_mesolve():; ; with pytest.raises(ValueError, match=""The measured operators for the heterodyne method supposed to be pairs of quadratures: m_ops should have even length.""):; sme_het_bad_mops = smesolve(; sigmax(),; basis(2),; np.linspace(0,1,10),; [],; [sigmam()],; e_ops=[],; store_measurement = True,; method=""heterodyne"",; m_ops=[np.sqrt(eta)*sigmax(), np.sqrt(eta)*sigmay(), np.sqrt(eta)*sigmaz()], # three operators; ntraj=10,; ); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548:234,detect,detected,234,https://qutip.org,https://github.com/qutip/qutip/pull/2081#issuecomment-1424737548,6,['detect'],"['detected', 'detection']"
Safety,@jakelishman Leaving it as is sounds fine to me. Deprecation warnings are filtered out by default when running Python scripts these days (unless one runs with `-X dev`) so that and the notebook filtering probably avoids the majority of cases where someone will be annoyed or confused by the warnings.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1480#issuecomment-815581980:213,avoid,avoids,213,https://qutip.org,https://github.com/qutip/qutip/pull/1480#issuecomment-815581980,1,['avoid'],['avoids']
Safety,"@nonhermitian Hi Paul, I don't think it's super important to necessarily have the most efficient algorithm for allowing non-linear tlists, but I do think it's good to have to avoid tripping up more advanced users. Could you merge this solution and we can always re-visit later?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-245201155:175,avoid,avoid,175,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-245201155,1,['avoid'],['avoid']
Safety,"@pmenczel I've worked on this quite a bit, mostly focusing on putting initial tests in place, supporting the full set of coefficient functions supported by the other solvers for the rates, shifting the martingale calculations into the integrator and moving the rate shift calculations to Cython to avoid the overhead of Python function calls and loops. @Ericgig I ended up doing some odd things because QobjEvo doesn't seem like natural fit for these rate functions and coefficients are a bit awkward to use directly inside solvers. @pmenczel & @Ericgig Could you take a look at everything again and let me know what you think?. Some of the bigger todo items I have in mind at the moment:. - How do we tell that the negative rate case is really working correctly? I added a test but it doesn't match mesolve well and I'm unhappy with that.; - Can we strengthen any of the existing tests with more assertions?; - Now that the discrete and continuous martingale calculations are mostly handled when collapses happen, we could expose them on the result along with `col_which` and `col_time`. Should we?; - Are the new martingale and rate shift calculations correct?; - The way the shared coefficients are used inside `RateSet` and exposed to `MCSolve` required a lot of careful thinking, did I get the design of that right?; - How do we test whether this works when using `parallel_map`? Being able to run in parallel is a key strength of the Monte Carlo method, so it would be good to have tests that show that that works.; - Can we drop the number of trajectories in the docs to make the doc build faster?; - Using the SciPy integrator is a bit awkward. Is there anything we can replace it with? If not, should we expose more of its options? I exposed the `limit` option because I kept having the integration fail during testing.; - Add tests for the `nm_mcsolve` Cython classes. There is also a bunch of general cleaning up still to do, but lets try get the big picture happy first.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354:298,avoid,avoid,298,https://qutip.org,https://github.com/qutip/qutip/pull/2070#issuecomment-1493417354,1,['avoid'],['avoid']
Safety,@sahmed95 shouldn't the merge automatically take care of that without bothering to rebase? . I'd like to avoid wasting time on a rebase if there's no tangible benefit,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398031660:105,avoid,avoid,105,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398031660,1,['avoid'],['avoid']
Safety,"@victor-onofre Thank you for looking at this! I think it's important to address @nwlambert's concerns once @Ericgig has had a look. Note: Issue #1808 isn't part of the current Unitaryhack, so I am removing the ""[unitaryhack]"" from the issue title to avoid confusion.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/pull/1929#issuecomment-1153723802,1,['avoid'],['avoid']
Safety,@wrzadkow thank you. It sounds good to me. Could [detect](https://stackoverflow.com/questions/5376837/how-can-i-do-an-if-run-from-ipython-test-in-python) whether the environment is `IPython`. ; If you can write a test too for it to avoid environment-dependent errors that would be great.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/989#issuecomment-493725091:50,detect,detect,50,https://qutip.org,https://github.com/qutip/qutip/issues/989#issuecomment-493725091,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"@ziofil, I just checked that updating the colab notebook to have the line; ```; !pip install scipy==1.2.1; !pip install qutip; ```; works for me, as @quantshah mentioned. ; QuTiP will find already the SciPy 1.2.1 requirement and will avoid keeping 1.3.; It is an issue with `IndexMixin` relocation in SciPy 1.3 (released this May 17), which has been changed from `scipy.sparse.sputils` to `scipy.sparse._index`.; I tested this also in My Binder and this works too, by setting in the `environment.yml` file, ; [in line 9,](https://github.com/nathanshammah/interactive-notebooks/blob/master/environment.yml#L9); from; ```; - scipy; ```; to ; ```; - scipy==1.2.1; ```; I will open a PR with this patch for `qutip-notebooks` for the time being. Once the next official version of QuTiP is released, this problem will not arise, as this issue has been taken care of by @Ericgig in PR #999 by updating scipy `IndexMixin`, now under private use, with scipy `get_index_dtype`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616:234,avoid,avoid,234,https://qutip.org,https://github.com/qutip/qutip/issues/1008#issuecomment-499038616,1,['avoid'],['avoid']
Safety,A faster displacement operator avoiding matrix exponentiation,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1293:31,avoid,avoiding,31,https://qutip.org,https://github.com/qutip/qutip/issues/1293,1,['avoid'],['avoiding']
Safety,"A lot of the cost of the Husimi Q function does not depend on the state. If it is called many times (e.g. for a density matrix or when doing multiple states), this can be used for a speedup. I wrote a function to precompute everything that does not depend on the state and store it as a 3d array. The Q function itself is then a dot product between the last axis of the precomputed array and a pure state. Performance: Everything tested by computing Q of a coherent state with N dimensions, evaluated at 401 points in x and y, respectively.; Speedup is 3x for N=10, 4x for N=20, 7x for N=50. ; For density matrices, precomputing is already paid for by the first call. . Possible further changes:; Because precomputing is always worth it if the state is a density matrix, one could do that automatically. Because the memory cost can be large (len(xvec) * len(yvec) * N * 128 bit) , I still leave the decision to the user. The third if statement in _qfunc_pure can be avoided at a small performance cost in either the polyval or np.dot variant. This seemed the best compromise between performance and nice code.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/934:966,avoid,avoided,966,https://qutip.org,https://github.com/qutip/qutip/pull/934,1,['avoid'],['avoided']
Safety,A number of posts have appeared recently on the Google group reporting problems with installing QuTiP on MS Windows 8 or 10 64 bit editions. I have also experienced problems when trying to install on a colleagues laptop. Mainly these seem to be compilation related issues. Is there anything we can do to the code or the instructions to help avoid these issues?. Is there any value in creating an Anaconda install package?,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/377:341,avoid,avoid,341,https://qutip.org,https://github.com/qutip/qutip/issues/377,1,['avoid'],['avoid']
Safety,"About pickling. `QobjEvo` doesn't contain any cython only data and cython autopickling is working fine.; There is a test for it. (But not for windows, there is still a risk there).; But function used in `linear_map` or in coefficient etc. may cause problem.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272:168,risk,risk,168,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-815141272,1,['risk'],['risk']
Safety,"Adds custom `csr.diags` and swaps `qdiags` over to use it to avoid using the `scipy` version with its large overhead. Constructing a tridiagonal matrix of dimension 100 gets approximately a 7x speed up (320µs to 45µs on my machine) and it's better for small dimensions - the `scipy` overhead has a constant component something around 280µs compared to a constant ~20µs in the new `csr` one. Not a big deal since it's hardly ever going to be a bottleneck, but it's just part of my work speeding up general QuTiP operations.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1419:61,avoid,avoid,61,https://qutip.org,https://github.com/qutip/qutip/pull/1419,1,['avoid'],['avoid']
Safety,"After a second look, I realize that small numbers might not be the problem here. I was thinking that the `coeffs` you computed is too small so that it gets discarded. It turned out that your `Delta` is around 10^6, which is not small at all. Apologies for the rush. ; Still, I would suggest changing the unit so that `Delta` is close to 1 to avoid this kind of pitfalls. Then, there could be the following reasons:; - In the example you give, `w-w0` is actually 0, if you then choose phi=0, the `coeffs` is always 0. But this maybe just a mistake from extracting this example.; - A more likely problem is that `pulse` function, `t` is not used at all. I guess you probably mean that the pulse is turned on at `t=t0`, which should be:; ```; def pulse(t0,t):; return np.heaviside(t - t0, 2e-9); ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1466#issuecomment-805120396:342,avoid,avoid,342,https://qutip.org,https://github.com/qutip/qutip/issues/1466#issuecomment-805120396,1,['avoid'],['avoid']
Safety,"After installing qutip via conda (conda install qutip) on Mac 10.15.1 High Sierra, I ran the testing script using:. >> import qutip.testing as qt ; >> qt.run(). I am getting the following error: . Qobj subtraction ... python(4259,0x119a26dc0) malloc: Incorrect checksum for freed object 0x7fdbb05c5910: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(4259,0x119a26dc0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6. Does anyone know what is causing this, how to fix it, or what kinds of problems it might cause later? Thank you!. Sacha",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1120:462,Abort,Abort,462,https://qutip.org,https://github.com/qutip/qutip/issues/1120,1,['Abort'],['Abort']
Safety,"After you created a fork to work on #1242, a different PR (#1226) was merged into `master`. It so happens that #1242 and #1226 don't conflict so that merge succeeded, but the new changes you're now trying to make do. This is fundamentally a true merge conflict and so unfortunately there's no fancy way around it, though it could have been avoided if you'd matched the state of our `master` before beginning work here, and it would be a bit easier for you for future PRs to branch off before starting work (GitHub has [some nice material about this workflow](https://guides.github.com/introduction/flow/)). I've rebased your PR onto our `master` and fixed the resulting merge conflict for you. You should _immediately, without doing anything else_ reset your branch state to match mine, and then force-push your changes to GitHub to update the PR. To do this, do; ```bash; git remote add jakelishman https://www.github.com/jakelishman/qutip.git; git fetch jakelishman; git checkout master; git reset --hard jakelishman/Canoming-circuit-patch; git push --force; git remote remove jakelishman; ```; This will destroy anything on `master` that you may have but haven't yet pushed. You should do it anyway, because a lot of the underlying structure has changed from underneath you, and your changes aren't consistent with the current state of `circuit.py`. Please also note that the tests are failing after your modifications in (the current) 10e457e.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121:340,avoid,avoided,340,https://qutip.org,https://github.com/qutip/qutip/pull/1269#issuecomment-630932121,2,['avoid'],['avoided']
Safety,"Agreed, safer to make it explicit. I'll prepare a PR.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1451#issuecomment-784354122:8,safe,safer,8,https://qutip.org,https://github.com/qutip/qutip/issues/1451#issuecomment-784354122,1,['safe'],['safer']
Safety,"Ah ok, that makes it easier to understand what happened - the `MANIFEST.in` file got added at some point before the 4.5.2 release, but its mere presence overrides the content of `setuptools`' `package_data` option, in which we _do_ add the requisite files. If it's not desperately urgent, are you able to build from the `git` branch at 4.5.3 instead temporarily? I can merge this PR, but we're hoping to put out 4.6.0 in about two weeks' time (which I'll make sure has this patch), and our release process is still very manual - I'd rather not have to repeat it another time if I can avoid it!. Sorry this file got lost when `MANIFEST.in` turned up.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1449#issuecomment-782615652:584,avoid,avoid,584,https://qutip.org,https://github.com/qutip/qutip/pull/1449#issuecomment-782615652,1,['avoid'],['avoid']
Safety,"Ah, nice catch thanks, and thanks for the super clear repro. We're overhauling the solvers for QuTiP 5.0, which will include a lot more rigorous input checking on entry, but also it uses far safer low-level datatypes that would catch this shape mismatch in the C layer (even though the `dims` _should_ have been checked by `mesolve`). I'll check the other solvers and patch in a sanity test - probably after these lines: https://github.com/qutip/qutip/blob/d5e305513d9186df74beee4fd8da680e89f29d15/qutip/mesolve.py#L259-L261; we can just insert a test; ```python; if rho0.dims[0] != rho0.dims[1]:; raise ValueError(; ""input state must be a pure state or square density matrix""; ); ```. There may also be other segfaults lurking if you use a Python function to generate a time-dependent `Qobj` value in the Liouvillian or the expectation operators, but right now you're unlikely to use that form (because it's slow as anything). The bug slips through because we unsafely pass off a matrix down to C code (where we currently don't have sanity checks) without first verifying that it is a valid shape in Python space - the C code is working as designed, so there shouldn't be problems with correct inputs. Removing `c_ops` causes `mesolve` to delegate to `sesolve` which presumably is better at its type-checking, and I expect that a small dimension size working is likely just `malloc` having slack in the memory it gives us for small sizes or small requests being allocated into the special pre-allocated store.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169:191,safe,safer,191,https://qutip.org,https://github.com/qutip/qutip/issues/1456#issuecomment-791925169,6,"['safe', 'sanity check', 'unsafe']","['safer', 'sanity checks', 'unsafely']"
Safety,"Ahh, it is because I forgot to add the safety check to the propagator function.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/761#issuecomment-336207115:39,safe,safety,39,https://qutip.org,https://github.com/qutip/qutip/issues/761#issuecomment-336207115,1,['safe'],['safety']
Safety,"An alternative solution if one does not wish to use Anaconda can be to change the Python version in use to a user installed one instead of the default version supplied by macOS. I have discussed it in #348 . It is perhaps because the default Python version does not detect the local python packages (numpy/scipy). After this fix, I was able to do a `sudo -H python setup.py install` and everything worked fine for me.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/382#issuecomment-263751111:266,detect,detect,266,https://qutip.org,https://github.com/qutip/qutip/issues/382#issuecomment-263751111,1,['detect'],['detect']
Safety,"Any news on this? I would personnally find it particularly useful to have `cosm` and `sinm` methods on `Qobj` class. I can submit a PR with it if you want. If such methods are not to be added, I think this issue can be safely closed.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/427#issuecomment-203561277:219,safe,safely,219,https://qutip.org,https://github.com/qutip/qutip/issues/427#issuecomment-203561277,1,['safe'],['safely']
Safety,"As I understand it, the new Mac M1 chips have an ARM-based architecture so there shouldn't be any compatible binary releases on conda yet for macos - I'm surprised conda even claimed to have solved the system. Maybe they've not updated to take the new chips into account either. If you can, you might want to try building from source - you'll also need the Python package Cython, but this way should build all the binary components for your architecture. We know (#1395) that there's a minor problem with some hardware detection on the M1 macs at the moment, but you can comment out lines 48 and 49 of `qutip/hardware_info.py` to work around it. None of us have one of the new macs, and I think we'll need a new release to get conda-forge updated. It might be a little while before we get that done, sorry.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-736516068:519,detect,detection,519,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-736516068,1,['detect'],['detection']
Safety,"As I understand it, the only way to avoid needing to touch `MANIFEST.in` is to not have files distributed with the test suite (or to have the temporary files by `*.py`, since `setup.py` automatically recognises them). That's not really a pytest thing, it's a `setuptools` one. I don't think there's a problem distributing files as part of the tests. You can add a line which says; ```; recursive-include qutip/tests/qasm_files *.qasm; ```; to `MANIFEST.in`, and that should hopefully fix the problem. You won't have the problem locally, because you'll be running `./setup.py develop`, which ""installs"" in-place, so you don't notice the fact that you've missed files from the manifest. In the tests, it runs `./setup.py install`, which does the copy, missing files which aren't in the manifest. Boxi: I'm not certain what more you'd like to do with fixtures here. Fixtures are good for setup and tear down, parametrisation and sharing resources (like network connections), but I'm not certain what further benefit you get for a test function which is testing whether it can open a known file, read it, and construct the expected output. I think Sidhant is already doing some nice parametrisation of his tests, from what I see. Sidhant: I added a comment on the exception test, since pytest gives us an easier-to-read context manager you can use. It's also typically better practice to handle file paths like I did in that (using the overloaded `/` operator with `pathlib.Path`, or `os.path.join`) rather than manually putting in slashes. Windows _usually_ will do the right thing now with slashes, but it's better to let Python handle it for us.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156:36,avoid,avoid,36,https://qutip.org,https://github.com/qutip/qutip/pull/1291#issuecomment-656255156,1,['avoid'],['avoid']
Safety,"At least in Sublime Text 3's case, it doesn't claim to be a TTY, such that checking `sys.stdout.isatty()` returns False. It's possible that this could be used to detect which bar to use. Since IPython QtConsole and Notebook also return `False` for `isatty()`, a combination of checking `qutip.settings.ipython` and `isatty()` may help eliminate edge cases.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63328522:162,detect,detect,162,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63328522,1,['detect'],['detect']
Safety,Avoid global imports in jit cython code,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/155:0,Avoid,Avoid,0,https://qutip.org,https://github.com/qutip/qutip/issues/155,1,['Avoid'],['Avoid']
Safety,Avoid int overflow in Qobj dims check,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2252:0,Avoid,Avoid,0,https://qutip.org,https://github.com/qutip/qutip/pull/2252,1,['Avoid'],['Avoid']
Safety,Avoid matrix tidyup in trace norm,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1479:0,Avoid,Avoid,0,https://qutip.org,https://github.com/qutip/qutip/pull/1479,1,['Avoid'],['Avoid']
Safety,BUG: Fix for safety check,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/687:13,safe,safety,13,https://qutip.org,https://github.com/qutip/qutip/pull/687,1,['safe'],['safety']
Safety,"Because things worked a bit differently 10 years ago. However, psutil does do everything QuTiP needs these days. They can also come up with a smarter M1 detection method.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736677888:153,detect,detection,153,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736677888,1,['detect'],['detection']
Safety,"Bumps [pillow](https://github.com/python-pillow/Pillow) from 10.2.0 to 10.3.0.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/releases"">pillow's releases</a>.</em></p>; <blockquote>; <h2>10.3.0</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/10.3.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/10.3.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>CVE-2024-28219: Use strncpy to avoid buffer overflow <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7928"">#7928</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Use <code>functools.lru_cache</code> for <code>hopper()</code> <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7912"">#7912</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>Raise ValueError if seeking to greater than offset-sized integer in TIFF <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7883"">#7883</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Improve speed of loading QOI images <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7925"">#7925</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Added RGB to I;16N conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7920"">#7920</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Add --report argument to <strong>main</strong>.py to omit supported formats <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7818"">#7818</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Added RGB to I;16, I;16L and I;16B conversion <a href=""https://redirect.github.com/python-pillow/Pillow/issues/7918"">#7918</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Fix editable installation with custom build backend and configurati",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2381:479,avoid,avoid,479,https://qutip.org,https://github.com/qutip/qutip/pull/2381,1,['avoid'],['avoid']
Safety,"Bumps [pillow](https://github.com/python-pillow/Pillow) from 9.0.1 to 9.3.0.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/python-pillow/Pillow/releases"">pillow's releases</a>.</em></p>; <blockquote>; <h2>9.3.0</h2>; <p><a href=""https://pillow.readthedocs.io/en/stable/releasenotes/9.3.0.html"">https://pillow.readthedocs.io/en/stable/releasenotes/9.3.0.html</a></p>; <h2>Changes</h2>; <ul>; <li>Initialize libtiff buffer when saving <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6699"">#6699</a> [<a href=""https://github.com/radarhere""><code>@​radarhere</code></a>]</li>; <li>Limit SAMPLESPERPIXEL to avoid runtime DOS <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6700"">#6700</a> [<a href=""https://github.com/wiredfool""><code>@​wiredfool</code></a>]</li>; <li>Inline fname2char to fix memory leak <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6329"">#6329</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Fix memory leaks related to text features <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6330"">#6330</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Use double quotes for version check on old CPython on Windows <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6695"">#6695</a> [<a href=""https://github.com/hugovk""><code>@​hugovk</code></a>]</li>; <li>GHA: replace deprecated set-output command with GITHUB_OUTPUT file <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6697"">#6697</a> [<a href=""https://github.com/nulano""><code>@​nulano</code></a>]</li>; <li>Remove backup implementation of Round for Windows platforms <a href=""https://github-redirect.dependabot.com/python-pillow/Pillow/issues/6693"">#6693</a> [<a href=""https://github.com/cgohlke""><code>@​cgohlke</code></a>]</li>; <li>Upload fribidi.dll to GitHub Acti",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2023:678,avoid,avoid,678,https://qutip.org,https://github.com/qutip/qutip/pull/2023,1,['avoid'],['avoid']
Safety,"Bumps [urllib3](https://github.com/urllib3/urllib3) from 1.26.14 to 1.26.17.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/releases"">urllib3's releases</a>.</em></p>; <blockquote>; <h2>1.26.17</h2>; <ul>; <li>Added the <code>Cookie</code> header to the list of headers to strip from requests when redirecting to a different host. As before, different headers can be set via <code>Retry.remove_headers_on_redirect</code>. (GHSA-v845-jxx5-vc9f)</li>; </ul>; <h2>1.26.16</h2>; <ul>; <li>Fixed thread-safety issue where accessing a <code>PoolManager</code> with many distinct origins would cause connection pools to be closed while requests are in progress (<a href=""https://redirect.github.com/urllib3/urllib3/issues/2954"">#2954</a>)</li>; </ul>; <h2>1.26.15</h2>; <ul>; <li>Fix socket timeout value when HTTPConnection is reused (<a href=""https://redirect.github.com/urllib3/urllib3/issues/2645"">urllib3/urllib3#2645</a>)</li>; <li>Remove &quot;!&quot; character from the unreserved characters in IPv6 Zone ID parsing (<a href=""https://redirect.github.com/urllib3/urllib3/issues/2899"">urllib3/urllib3#2899</a>)</li>; <li>Fix IDNA handling of 'x80' byte (<a href=""https://redirect.github.com/urllib3/urllib3/issues/2901"">urllib3/urllib3#2901</a>)</li>; </ul>; </blockquote>; </details>; <details>; <summary>Changelog</summary>; <p><em>Sourced from <a href=""https://github.com/urllib3/urllib3/blob/main/CHANGES.rst"">urllib3's changelog</a>.</em></p>; <blockquote>; <h1>1.26.17 (2023-10-02)</h1>; <ul>; <li>Added the <code>Cookie</code> header to the list of headers to strip from requests when redirecting to a different host. As before, different headers can be set via <code>Retry.remove_headers_on_redirect</code>. (<code>[#3139](https://github.com/urllib3/urllib3/issues/3139) &lt;https://github.com/urllib3/urllib3/pull/3139&gt;</code>_)</li>; </ul>; <h1>1.26.16 (2023-05-23)</h1>; <ul>; <li>Fixed thread-safety issue where accessing a ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2236:561,safe,safety,561,https://qutip.org,https://github.com/qutip/qutip/pull/2236,2,"['safe', 'timeout']","['safety', 'timeout']"
Safety,"But how would you know which ones are safe to remove? The fact that we can have many python interpreters running qutip at the same time makes this complicated. I'm not sure what would be the best solution, but I guess that in principle one could imagine an atexit handler that does the cleanup of files corresponding to the current PID. https://docs.python.org/3/library/atexit.html. But taking us down a path of complicated and and hard to maintain code...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/291#issuecomment-66948492:38,safe,safe,38,https://qutip.org,https://github.com/qutip/qutip/pull/291#issuecomment-66948492,1,['safe'],['safe']
Safety,"But it seems to me that it would be best to avoid this type of issue when possible. For example, the squeezing operator is called squeez just to get around a namespace conflict. Otherwise people are bound to get errors that don't make any sense just because of the import order and then they will be emailing us. Of course we can not avoid all conflicts, but since loading scipy is so fundamental to what we do, having no conflicts with this package seems to be reasonable, at least to me. . On Wednesday, June 5, 2013 at 11:12 AM, Robert Johansson wrote:. > Yes, this can happen.. But I dont think this is a bug or error, although it can be confusing. There is always a risk of namespace collisions when importing different packages into the global namespace. For example, many conflicts of this kind occur between the math and numpy packages.. The only way to get around it safely is to import packages in different namespaces.; > ; > —; > Reply to this email directly or view it on GitHub (https://github.com/qutip/qutip/issues/25#issuecomment-18951570).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/25#issuecomment-18951920:44,avoid,avoid,44,https://qutip.org,https://github.com/qutip/qutip/issues/25#issuecomment-18951920,4,"['avoid', 'risk', 'safe']","['avoid', 'risk', 'safely']"
Safety,"Can this be done legally?; Is it acceptable to remove the copyright in the files?; We would be changing the owner of the code. In #1405, it has to have the Nasa copyright by agency policy:; ```; Copyright 2020 United States Government as represented by the Administrator; of the National Aeronautics and Space Administration. All Rights Reserved; ```; I think we could have legal issues if we removed this without their permission. While I agree with removing the ~30 lines header with the license in each file, we should keep the copyright lines unless we can confirm it safe to do so. Luckily, it is mostly Paul, Robert and Alex that have specified it and if they agree then I guess it fine. But if any other contributor added their copyright, we should keep it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-864019462:572,safe,safe,572,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-864019462,1,['safe'],['safe']
Safety,"Certainly the `zheevr` segfaults on my machine with scipy < 1.5 and _doesn't_ with scipy 1.5, but that's hardly a perfect test - segfaults are pretty intermittent at the best of times. It's easy to test that all eigenvectors are mathematically actually eigenvectors with the correct eigenvalue, but the harder bit is ensuring that we've actually found _all_ the eigenvectors, especially when we're dealing with a lot of eigenvalues that look like `(0, 0, 0, 1e-17, -1.1e-17, ...)`. Degeneracy is a more annoying to check that we've got the full spanning set of the degenerate basis, and it's even harder when we've got eigenvalues like `1e-17` which is almost certainly actually degenerate with 0, but hasn't been detected as such. This is roughly what I was trying to get at with method 2.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934:714,detect,detected,714,https://qutip.org,https://github.com/qutip/qutip/issues/1299#issuecomment-649525934,1,['detect'],['detected']
Safety,"Closing for now as the fix is not something QuTiP can detect - we need to have `max_step` to a suitable value to know how stiff the input is. If there's further discussion we need to have, let's talk about it more in other issues / the Google groups discussion boards.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1265#issuecomment-809335608:54,detect,detect,54,https://qutip.org,https://github.com/qutip/qutip/issues/1265#issuecomment-809335608,1,['detect'],['detect']
Safety,"Closing now due to lack of activity. The problem is likely caused by `from math import *` shadowing many functions that should be called from `numpy`, as noted above. (I take this opportunity to evangelise the belief that star-imports are evil and should be avoided in almost all situations.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1111#issuecomment-809411375:258,avoid,avoided,258,https://qutip.org,https://github.com/qutip/qutip/issues/1111#issuecomment-809411375,1,['avoid'],['avoided']
Safety,"Codeclimte detects the same code in matrix_histogram and matrix_histogram_complex, but matrix_histogram_complex will be deleted after matrix_histogram takes over it and the problem will be solved",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527:11,detect,detects,11,https://qutip.org,https://github.com/qutip/qutip/pull/2193#issuecomment-1628641527,1,['detect'],['detects']
Safety,"Currently QuTiP solvers are pure batch jobs. One calls a function, e.g. `mesolve`, which then runs until the state has been propagated to all requested time steps and then the function returns the result. There are a variety of use cases where having access to results as they are calculated can be useful:. * Implementing a progress bar; * Limiting how long a solver runs for; * Stopping a solver early if a steady state or other desired or undesired state is detected.; * Implementing adaptive solvers where parameters are changed depending on the current state. We're currently refactoring the QuTiP solvers for QuTiP v5, so perhaps now is a good time to consider whether this feature will see enough use to be worth the effort. Implementation options:. * The solver could call a `callback function` each time a new result becomes available.; * The solver could `yield` each time a new result becomes available.; * The solver could do something asynchronous (I think this is not worth supporting natively in QuTiP -- either of the others would allow something asynchronous to be implemented by a QuTiP users themselves if they wanted). Probably these are not mutually exclusive. To make porting easier, it should still be possible to call some solve function without a callback or yielding as one can do now. Related issues:. * qucontrol/krotov#93",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571:461,detect,detected,461,https://qutip.org,https://github.com/qutip/qutip/issues/1571,1,['detect'],['detected']
Safety,"Currently, the method to add a new gate to a quantum circuit is the following:; ```; import numpy as np; from qutip import QubitCircuit; from qutip.qip.circuit import Gate. qcircuit = QubitCircuit(4); qcircuit.add_gate(""CNOT"", targets=[2], controls=[0]). # This is a valid gate addition.; qcircuit.add_gate(""test_gate"", targets=[0], controls=[1], arg_label=r""\pi/12"",; 	 arg_value=""np.pi/12""); for gate in qcircuit.gates:; 	print(gate). ```. There is no way to add a gate directly. For instance:. ```; test_gate = Gate(""test_gate"", targets=[0], controls=[1], arg_label=r""\pi/12"",; 	 arg_value=""np.pi/12""); # This leads to an invalid gate addition.; qcircuit.add_gate(test_gate); ```; which leads to . ```; Gate(Gate(test_gate, targets=[0], controls=[1]), targets=None, controls=None); ```. Can we add a check to see if the input to `add_gate` is a Gate object and unpack it to add a new gate ? Or, have some kind of a sanity check if the given input is in a correct gate input format. (name, targets, controls).",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/610:918,sanity check,sanity check,918,https://qutip.org,https://github.com/qutip/qutip/issues/610,1,['sanity check'],['sanity check']
Safety,"Deleting everything that starts with 'tdname' sounds sub-optimal, but also not too risky.; I have not looked into it myself, and with this pull we are definitely better off than without.; I will merge now, as I am about to make the 4.1 release",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/655#issuecomment-285674287:83,risk,risky,83,https://qutip.org,https://github.com/qutip/qutip/pull/655#issuecomment-285674287,1,['risk'],['risky']
Safety,"Diffrax and I suspect some other ODE solves have direct support for coupled ODEs -- https://docs.kidger.site/diffrax/examples/coupled_odes/. It looks like diffrax supports these directly. The QuTiP equivalent would appear to be something like a QobjEvo which has a list of terms for each element of the direct product in the output space and, in addition, knows which subspace in the input space each term acts on. The HEOM is very sparse (tri-block diagonal) and just constructing the RHS is slow, so I suspect it will be hard to make any implementation faster than what we have now without a means to avoid constructing the RHS entirely. It would be interesting to try the current HEOM with the diffrax coupled-ODE support and see how big the gain is (if any) before putting a lot of effort into making something similar ourselves. @Ericgig Any thought on how crazy / difficult it would be to make something like an coupled-ODE PyTree / QobjEvo in QuTiP?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982:603,avoid,avoid,603,https://qutip.org,https://github.com/qutip/qutip/issues/2384#issuecomment-2307877982,1,['avoid'],['avoid']
Safety,"Doing #1646, I saw that we use operator between data object in code where types are not strictly checked. We may have other test working only because we do test mostly in `CSR`... . This PR add operators support between data-layer. This will help clean the code:; `_data.matmul(_data.matmul(A, B), C)` vs `A @ B @ C`.; and it will reduce the risk of them being used in functions where we expect, but don't check, that all data object are of the same type. . It is added in `base.Data` so any new data-layer will have operators working without having to create them. It use the dispatched function of `add`, `sub`, `matmul`, `mul`, `imul`, and `neg`. But it has the side effect that operators can change the type if the specialization does not exist. @jakelishman, is this something you though of but choose not to do?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1647:342,risk,risk,342,https://qutip.org,https://github.com/qutip/qutip/pull/1647,1,['risk'],['risk']
Safety,ENH: Fix OPENMP threshold detection exception,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/711:26,detect,detection,26,https://qutip.org,https://github.com/qutip/qutip/pull/711,1,['detect'],['detection']
Safety,ENH: Safety check for solver inputs,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/537:5,Safe,Safety,5,https://qutip.org,https://github.com/qutip/qutip/pull/537,1,['Safe'],['Safety']
Safety,"Example implementation of `Qobj(thing)` with caveat noted below:; ```python; # qq.py; """""" A quick experiment with a Qobj creation API. """""". import qutip; import qutip.core.data. class NetketThing:; """""" An object with a __qutip_qobj__ method. """"""; def __init__(self, stuff):; self._stuff = stuff. def __qutip_qobj__(self, copy=True):; return qutip.Qobj(self._stuff, copy=copy). def _has_qutip_qobj_method(arg):; return getattr(arg, ""__qutip_qobj__"", None) is not None. def _call_qutip_qobj(arg, shape, copy=True):; # Note 1: shape argument intentionally ignored here -- arg should already; # know its dims and shape (possible a sanity check would be good); # Note 2: unfortunately, the .data object does not know the dims of; # of the Qobj, so the dims are lost. :/; return arg.__qutip_qobj__(copy=True).data. qutip.core.data.create.add_creators([; (_has_qutip_qobj_method, _call_qutip_qobj, 10),; ]); ```; Example usage:; ```python; # try_qq.py; """""" Trying out the experiment. """""". import qutip; import qq. nk = qq.NetketThing([0, 2]); q = qutip.Qobj(nk); qn = q.norm(); print(q); print(qn); ```; Explanation:; * `qutip.core.data.create` is the new Qobj data layer creation dispatcher. It's already called by `Qobj.__init__` after a few hardwired cases.; * We register a creator (i.e. a pair of functions) with priority 10. The first function checks whether `__qutip_qobj__` exists and the second function calls it if it does. Caveat:; * The creator provides no way to retrieve the `dims` from `arg` if the `arg` already knows what the `dims` should be. I can see a lot of uses for this so I propose we fix this part now regardless. Bonus:; * Adding this as a default creator gives us a good way to keep the creator list short while still supporting simple conversion of many objects to Qobjs in a flexible way. Thoughts?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732:627,sanity check,sanity check,627,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908336732,2,['sanity check'],['sanity check']
Safety,"Except for setting the type of the `Qobj` (which is deleted at the end of `Qobj.__init__`), there's no need for the 'mc' or 'mc-dm' fast-paths to exist in `Qobj.__init__` at all, even in `master`. If we were to fix the handling of a passed `type` - nothing else is overwritten if passed explicitly - you could achieve all the same effects at approximately the same speed with correct application of the kwargs, such as; ```python; Qobj(data, dims=dims, copy=False, type='oper', isherm=...); ```; providing `data` is actually of a valid (`fast_csr_matrix`) format. Technically the `Qobj.data` attribute will be a new object that wraps the same numpy arrays as was passed, rather than the same `fast_csr_matrix`. In various forms, `expect` already does check the Hermicity, that's why `mc-dm` is careful to set it to avoid recalculating it. The expect functions in `qutip.expect` do this directly, and aren't aware of column-stacked density matrices - they'll just raise a TypeError. `mesolve` and `mcsolve` now bypass the `Qobj` stage and go direct to Cython - in 5.0 it might not be a terrible idea to route everything back through the `Qobj` form, since the performance issues there are solved (a column-stacked dense matrix can be directly wrapped by an f-ordered `Dense` type), and it's the natural central point of the code (and those parts are called from Python-space anyway, so no C concerns). Here though, the problem is actually that the expectation generator in `mesolve` correctly calculates the dtype of the output expectation array using both the state and the expectation operator, but then it does it incorrectly in the loop, and passes the hermicity down to Cython using only the expectation operator, which promptly throws out the complex part. So setting `fast='mc-dm'` in `Qobj` is a symptom of the same root cause as the problem here, rather than the cause itself. At the start of `mesolve` we don't assume that the state is Hermitian, but then inside the integration loop we do. W",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048:815,avoid,avoid,815,https://qutip.org,https://github.com/qutip/qutip/issues/1460#issuecomment-796835048,1,['avoid'],['avoid']
Safety,"Extra safety check have been added to prevent this kind of errors. #1783, #1784, #1778",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1374#issuecomment-1074188292:6,safe,safety,6,https://qutip.org,https://github.com/qutip/qutip/issues/1374#issuecomment-1074188292,1,['safe'],['safety']
Safety,"Finishes currently running tasks, <br> then returns results of all finished tasks. | If `fail_fast`, behaves similarly to `parallel_map`. <br> Otherwise, completes all tasks but only returns <br> results of those that were started before the timeout.; CTRL+C | First CTRL+C interrupts all tasks, but program <br> enters deadlock requiring second CTRL+C | Interrupts currently running tasks, but then still <br> executes the rest before raising `KeyboardInterrupt`.; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes all tasks, then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Ignored | Always completes all tasks anyway, see below. **New behavior**. &nbsp; | `parallel_map` | `loky_pmap`; ---|---|---; Timeout | Finishes currently running tasks, <br> then returns results of all finished tasks. | Aborts currently running tasks, <br> then returns results of all finished tasks.; CTRL+C | First CTRL+C raises `KeyboardInterrupt` | First CTRL+C raises `KeyboardInterrupt`; Task raises <br> exception | `fail_fast`: finishes running tasks, <br> then raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end. | `fail_fast`: finishes tasks earlier in the list, then <br> aborts remaining ones and raises exception. <br> `!fail_fast`: raises `MapExceptions` at the end.; Job timeout | Removed from documentation | Removed from documentation. **Job timeout**. Currently, the job timeout parameter is ignored by parallel_map. In loky_pmap, it is not the maximum allowed time for one job, but the maximum time between two job finishes (possibly in different processes). If this time is exceeded, all tasks will still be executed until the end; only the results of the tasks that finished too slowly will be discarded. I do not think that this was the intention of the job timeout parameter?. Unfortunately, both `ProcessPoolExecuto",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2280:1551,Abort,Aborts,1551,https://qutip.org,https://github.com/qutip/qutip/pull/2280,1,['Abort'],['Aborts']
Safety,"First remove the completely unnecessary triplicated calls to `_Indexer.single()` by caching the results. An otherwise sensible use of the sparse code would get ruined by vastly over-using the call, which is exactly what the special-case is trying to avoid. Second, fix a buggy line: in `_dimensions_csr_sparse` there used to be the lines (229--230) that's hard to spot in the diff because of the release of the GIL in this commit:; ```python; if n:; out.row_index[index.single(row) + 1] = len; ```; where the assignment should have been `n`, not `len`. `len` is the longest row seen before now, so the first row seen would also be zeroed out by this function. Also, a matrix with some rows having more elements in that others would set the wrong values in later short rows, probably causing a segfault. Release the GIL when we don't need it for iteration - that's often a free speedup in Cython code. Fixes #1382.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1384:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/pull/1384,1,['avoid'],['avoid']
Safety,"Fix #1433, see further discussion of points there. - sets `Qobj.__array_ufunc__ = None` to prevent implicit usage with ufuncs; - change use of `np.array(dtype=object)` with `Qobj` into either raw Python lists (when only used internally), or sets `out = np.empty(shape, dtype=object); out[:] = ...` to force object-array creation; - fix version of numpy build version to `1.16.6 <= x < 1.20` to prevent cross-version ABI incompatibility (see also comments in #1429); - change default of `dims` and `shape` in `Qobj` constructor to `None`, rather than dangerous lists (also helps avoid numpy calls on ragged sequences)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1440:578,avoid,avoid,578,https://qutip.org,https://github.com/qutip/qutip/pull/1440,1,['avoid'],['avoid']
Safety,Fix `brmsolve` time-dependent a_ops detection,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2541:36,detect,detection,36,https://qutip.org,https://github.com/qutip/qutip/pull/2541,1,['detect'],['detection']
Safety,Fix `isherm_csr` wrongly detecting structure,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1866:25,detect,detecting,25,https://qutip.org,https://github.com/qutip/qutip/pull/1866,1,['detect'],['detecting']
Safety,Fix error in definition of m_ops for heterodyne detection in smesolve(),MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1237:48,detect,detection,48,https://qutip.org,https://github.com/qutip/qutip/pull/1237,1,['detect'],['detection']
Safety,Fix redundancy and sign error in jmat.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/565:4,redund,redundancy,4,https://qutip.org,https://github.com/qutip/qutip/pull/565,1,['redund'],['redundancy']
Safety,"Good catch, this seems to be a problem with how the arguments are structured in the function signature for brme_solve. For the tensor formation, . `def bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=[], use_secular=True, sec_cutoff=0.1):`. In this case, the spectra_cb is given the [ohmic_spectrum] argument, which is the correct argument. However, for the brme_solve, the signature is . ```; def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],. args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; ```. If you run the same code with . `output = brmesolve(H, psi0, tlist, [sigmax()], e_ops, spectra_cb = [ohmic_spectrum]); `. the code will run perfectly. However, this is an issue we should fix since spectra_cb is a depreciated argument and technically the c_ops list should accommodate arbitrary noise power spectrum functions that spectra_cb handled before. The error seems to be originating because ohmic_spectrum is of type function but the safety checker expects either a Qobj or a tuple. Also, once we fix the documentation/code on how to use c_ops, we also need to add depreciate warning to bloch_redfield_tensor to maintain uniformity.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1223#issuecomment-605703993:1056,safe,safety,1056,https://qutip.org,https://github.com/qutip/qutip/issues/1223#issuecomment-605703993,1,['safe'],['safety']
Safety,Having a warning that appears every time qutip is imported should be avoided. That is unless we want a ton of questions on the google help group.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/465:69,avoid,avoided,69,https://qutip.org,https://github.com/qutip/qutip/pull/465,1,['avoid'],['avoided']
Safety,"Having looked around a bit, it seems that the inverse should be avoided in general. The output is always dense, even for a sparse input. Perhaps there is a better way of calculating. https://github.com/jrjohansson/qutip/blob/counting-statistics/qutip/countstat.py#L150. that avoids finding the inverse?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/272#issuecomment-67448877:64,avoid,avoided,64,https://qutip.org,https://github.com/qutip/qutip/pull/272#issuecomment-67448877,2,['avoid'],"['avoided', 'avoids']"
Safety,Here are the associated notebook PR:; https://github.com/qutip/qutip-notebooks/pull/55 (QobjEvo). - development/development-qobjevo.ipynb; - development/development-qobjevo-adv.ipynb. https://github.com/qutip/qutip-notebooks/pull/56 (Stochastic); For general usage:. - examples/smesolve-heterodyne.ipynb; - examples/smesolve-inefficient-detection.ipynb; - examples/smesolve-jc-photocurrent.ipynb. Too see the convergence of each solvers:. - development/development-smesolver-new-methods.ipynb; - development/development-ssesolver-new-methods.ipynb,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/815#issuecomment-458813149:337,detect,detection,337,https://qutip.org,https://github.com/qutip/qutip/pull/815#issuecomment-458813149,1,['detect'],['detection']
Safety,"Hey @RobHam99. I have talked today with @hodgestar and we agreed that, since `**kwargs` is only used to pass the argument `num_cpus`, we think it is best to raise an _error_ (`TypeError`) when kwargs contains a key that is not `num_cpus`. This should hopefully avoid the same confusion to happen again with propagator, but we should definitely try to get the naming consistent for the new QuTiP version that is under active development. @RobHam99, are you still interested in opening a Pull Request for this issue?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1716#issuecomment-981512742:261,avoid,avoid,261,https://qutip.org,https://github.com/qutip/qutip/issues/1716#issuecomment-981512742,1,['avoid'],['avoid']
Safety,"Hey Eric,. I've been working on improving the underlying structure of FLiMESolve and; making it more efficient. I haven't done another review request yet because; I want to try to address as many things as I can at once. I've been delayed; heavily by a system I'm trying to solve for my paper about this solver, on; which Simon has offered to help such that I'll hopefully be moving forward; again soon. Additionally, there are some changes I want to make that I'm; not sure how to do which I'm going to try to address with Simon when we are; able to meet next. Most of those are in regards to structural things, e.g.; how to filter input ""args"" arguments to pull out the frequency of the; Hamiltonian in the same manner as other solvers in QuTiP are able to filter; arguments. I've been trying to avoid submitting review requests/questions; in the PR comments too much so as not to be a bother. I have definitely not; abandoned this PR, and plan on seeing it through fully, although I; apologize for my relative lack of communication the last few weeks. Thanks!. On Mon, Aug 21, 2023, 11:29 AM Eric Giguère ***@***.***>; wrote:. > @magnamancer <https://github.com/magnamancer> are you waiting for review,; > still working on the PR or abandoned it?; >; > There are still issues I raised here and in magnamancer#4; > <https://github.com/magnamancer/qutip/pull/4>, that you have not been; > addressed and I am waiting for them before the next round of review.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/2186#issuecomment-1686550860>, or; > unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AV5WL5GN3R6GPKYKYNOWSGDXWN5GDANCNFSM6AAAAAAZWI6GRQ>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935:798,avoid,avoid,798,https://qutip.org,https://github.com/qutip/qutip/pull/2186#issuecomment-1686607935,1,['avoid'],['avoid']
Safety,"Hi @Chasmiccoder, indeed the qutip source code is not yet fully pep8 compatible, although we are pushing towards it. In general, we try to avoid large-scale PR that only fix style issues like running `pycodestyle`, because it may introduce lots of conflicts if someone else is also working on the same code. That said, refactoring code for better maintainability is of course helpful in the long run. It would be good to check the development version. I believe we are doing a better job there. The newest version of `qutip` can be found on the `dev.major` branch of qutip https://github.com/qutip/qutip/tree/dev.major. And the master branch of `qutip-qip` https://github.com/qutip/qutip-qip. The package `qutip-qip` is a separate repository that serves as a replacement of the module `qutip.qip`, because the module will be removed in qutip-v5 (`dev.major`). The duplication you mentioned should already be fixed there. But of course there are still other imperfections if you are interested.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393:139,avoid,avoid,139,https://qutip.org,https://github.com/qutip/qutip/issues/1729#issuecomment-982408393,1,['avoid'],['avoid']
Safety,"Hi @Ericgig ; Thanks for investigating this so thoroughly. ; I guess it makes sense that unpacking a dict at each call is inefficient, so I think we should drop this idea. As you have suggested previously, users can always use module variables if they wish to avoid passing vars in `args`. So I think we should aim to keep it simple. I think adding `f(t)` as a signature option will be sufficient for what @goerz wanted and would be sufficient for using a Numba jit. So, my suggestion for the next major release (v5) would be that we have only two call sigs:; - `f(t, args)` (default); - `f(t)`. For now we will have to have the three (although I don't think the `rhs_with_state` is not widely used, if at all).; - `f(t, args)` (default); - `f(t)`; - `f(t, state, args)`; The default needs to remain as it is, because it is widely used. I think it makes sense to use introspection to decide which has been specified by the user, as the sig is clearly distinguishable by the number of args. So effectively we can ignore the `rhs_with_state` option, but I think we should give a deprecation warning that the `f(t, state, args)` signature will be removed in the next version. So, I think this means we can keep the new method of passing the state in the args dict. I would suggest we make it a bit more simple though. I notice that the processing of the option is a bit involved. So I suggest that any element of the `args` dict where the key is of the form `name:special_value_kind` be considered some kind of special value. If `special_value_kind` is not recognised then it should throw a `ValueError`. For now we will have the `special_value_kind` of:; - `state`: Qobj of the state at time `t`, with the correct dimensions; - `state_vec`: ndarray of state as a vector; - `expect`: I can't remember exactly what you did here. The `state_vec` will clearly be much more efficient, as this is what the ODE solver maintains. However, for completeness I think we should have the `state` option. The initial ",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162:260,avoid,avoid,260,https://qutip.org,https://github.com/qutip/qutip/issues/1136#issuecomment-562523162,2,['avoid'],['avoid']
Safety,"Hi @nonhermitian, I spent some time struggling with this as I recently shifted to macOS. This problem affects other Python installations too. I found a solution to this and if you could update it in the docs instead of the default macOS installation script, then it would be very helpful for new users. I will post the solution first and explain it below. . 1. Install a manual Python version which overrides the default Python supplied by Apple in the `usr/bin/python` path. You can check this using ```which python```. Installing using brew - . ```brew install python```. 2. Change the default Python interpreter from the one supplied by macOS in `usr/bin/python` to the user installed version in `/usr/local/bin/python`. This is explained in this [post](http://blog.manbolo.com/2014/09/27/use-python-effectively-on-os-x#p1). Edit the file `/etc/paths` using ```sudo vi etc/paths``` and move the line `/usr/local/bin` to the top. This makes the user installed Python default and the packages installed by pip or brew are imported instead of the ones supplied by apple. Restart the terminal. You may need to update numpy and scipy using ```pip install numpy``` or ```pip install numpy -U```. 3. Install qutip using ```python setup.py install```. Apple has its own Python version and a few modules such as numpy and scipy come along with it which are at `/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/include/python2.7`. These modules are difficult to manage and update due to issues with permission. Hence, even if you update numpy or scipy using `pip` or `brew`, it is not detected by Python. ~~This also raises an issue later `error: could not create 'build/src.macosx-10.12-x86_64-2.7': Permission denied`~~. This solution seems better since it does not mess with the system default. Edit 1 : sudo -H is needed to install using ```sudo -H python setup.py install```. The -H tag sets the home directory as the default for installing configuration files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/348#issuecomment-263745214:1602,detect,detected,1602,https://qutip.org,https://github.com/qutip/qutip/issues/348#issuecomment-263745214,1,['detect'],['detected']
Safety,"Hi @sarsid! I'd like to recommend that we land #1090 separately. It's a stand alone piece of work and coupling PRs together into big PRs where it can be avoided generally makes things harder to review and land. I can show you how to merge that branch into this one if you need to it make progress before #1090 lands. I would also recommend making the formatting changes you have made (I assume using black or your editor?) in a separate PR to this one. Lumping them into one PR also makes reviewing harder since one doesn't know which changes are intentional or meaningful. I'm also happy to help with this if you need!. I've started work on the docs for #1090, so hopefully it can land this week.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691:153,avoid,avoided,153,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633747691,1,['avoid'],['avoided']
Safety,"Hi @sarsid, there are still some tests failing. When you think the PR is really, just make it a ready-for-review PR and request a review. Besides, it would be great to address some of the style issues in code climate like ""Continuation line under-indented for visual indent"". Not all of them must be fixed though, it's more like a guide. The `pycodestyle` package can help you detect them locally if you would like to use it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967:377,detect,detect,377,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-646002967,2,['detect'],['detect']
Safety,"Hi Ben. Thanks a lot for your contribution. It's looking great!. A couple of small things:; - We try to make qutip python3 compatible, so please use python3 compatible print(...) function calls instead of print ... statements.; - Functions super_to_choi and choi_to_super seems to do the same thing, while the function names suggest complementary conversion. Is this intentional?; - I think it would be better if you move the test code from within the if **name** == '**main**' to a separate file in the examples directory, or even better as unit tests in qutip/tests/; - Avoid global import of qutip ""from qutip import *"" by only selectively importing the functions that you need (we try to do this internally in qutip to avoid circular module dependencies).; - Make relative import of qutip functions (for example from qutip.super_to_choi import super_to_choi). This is also required for python3 compatibility.; - Add an import of the main functions (for example subsystem_apply) to qutip/**init**.py ; - I would probably prefer the super_to_choi.py module be called something more general, like choi_decomposition,py (or something like that), which would reflect that it does not only contain the super_to_choi function but other related functions as well.; - Avoid printouts in choi_to_kraus function. If you want to enable debugging or diagnostic info, consider adding an optional function argument debug=False or verbose=False and print the vals and vecs variables only if the user explicitly asks for it. Otherwise, one could get an excessive amount of printouts if your code is used in a loop.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/22#issuecomment-18592742:572,Avoid,Avoid,572,https://qutip.org,https://github.com/qutip/qutip/pull/22#issuecomment-18592742,3,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"Hi Emily,. The photocurrent is the number of detector clicks (i.e., jumps) per unit time, averaged over all trajectories. For sufficiently many trajectories, it will approximate $tr[C_n \rho(t) C_n^\dagger]$. If I'm not mistaken, you should find that; ```math; x = \frac{1}{\Delta t} \frac{1}{N_t}; ```; where $\Delta t$ is the spacing in your `tlist` and $N_t$ the number of trajectories. The integer (photocurrent/x) is simply the number of clicks in that time interval in all trajectories; we multiply with x for the ""per unit time, averaged over all trajectories"" that I wrote above. Paul. (PS. I only noticed your username now - is it possible we had a chat at QTD in August? Hope you are doing well!)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615:45,detect,detector,45,https://qutip.org,https://github.com/qutip/qutip/issues/2539#issuecomment-2403687615,2,['detect'],['detector']
Safety,"Hi Louis,. There is work in development that will allow `QobjEvo` to be build from callback also, not just list. This will make callback work anywhere easily. . I was in the impression that H callback worked already for mcsolve. I rewrote part of mcsolve and broke it. Looking at your commit, I inverted `_funcrhs_with_state` and `_funcrhs`...; Sorry to have you take time to correct it. The 20x is big, but the list format allows for optimizations that are hard to do with a callback. A big one is that you don't need to create a new matrix/Qobj when calling `mul_vec`, just use it. With this code, I see a 20x between `mul_vec` and creating a Qobj a python function. . ```; import numpy as np; import qutip as qt. qoe = qt.QobjEvo([qt.qeye(3),[qt.destroy(3), lambda t,_:np.sin(t)]]); qoe.compile(). o1 = qt.qeye(3); o2 = qt.destroy(3) ; def H(t):; return o1 + o2 * np.sin(t). v = np.ones(3)+0j; %timeit qoe(0); %timeit qoe.mul_vec(0, v); %timeit H(0); %timeit H(0).data * v; ```. One optimization you could do is having the callback return a `np.array` instead of a Qobj. In `mcsolve`, this would probably be simple to implement and I expect some speed gain. But it can't really be officially supported in Qutip, for now. . ps. All those 'redundant' argument setting are for reusing the system (`ss`) in multiple call of `mcsolve` with different args, used in `correlation`. Using string coefficient, the compilation step can take a few second, so it is set to be able to reuse a compiled system, changing the `psi0`, `args`, `e_ops`, etc. This will become a less obscure feature in v5 when solver object are available.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634:1241,redund,redundant,1241,https://qutip.org,https://github.com/qutip/qutip/issues/1260#issuecomment-629231634,2,['redund'],['redundant']
Safety,"Hi Robert,. I was thinking about heterodyne and homodyne detection unification. It seems to me that the way how the heterodyne is done now in QuTip is a bit overcomplicated. Why don't we just produce two jump operators $s/sqrt2$ and $-is/sqrt2$ out of one heterodyne $s$ and run the homodyne scheme with these two operators. The Milstein will work automatically. Do I miss something?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22238086:57,detect,detection,57,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22238086,1,['detect'],['detection']
Safety,"Hi Vutshi. Yes, it is perfectly possible to implement the heterodyne detection using two homodyne detections with 50% efficiency, like you suggest. For the Milstein solver it might be the best, or at least the quickest, way to implement heterodyne, but I don't really agree that the current method is overcomplicated. It is in fact basically the same as the method you suggest, so I don't see that either would be more complicated or simpler than the other. The only issue is whether the two stochastic increments are divided up in several stochastic collapse operators or if the d2 function internally takes care of the both stochastic increments for a given stochastic collapse operator. The complexity is just shifted from the d2 function to somewhere else, which in general doesn't simplify anything. However, since the milstein solver you submitted is written so that it only support one increment per collapse operators, then there might be a real advantage of splitting the heterodyne process into two homodyne processes. . I've tried to make the qutip stochastic solver API as general as I could (and it is still a work in process), so that it will be as flexible as possible for implementing custom types of SMEs. Having support for multiple stochastic increments per collapse operators seems to be useful in certain applications. Although such SMEs could probably always be rewritten as multiple collapse operators with single stochastic increments, it might not always be the most natural way to define the SME. The heterodyne detection is one example of this, and it can be formulated in both ways, but I want the qutip SME API to work with both methods (at least with the basic euler solver, not necessarily with every solver we implement). However, that doesn't mean that the implementation of heterodyne for a particular solver has to use one way or the other. We should just document which solvers support multiple increments per operators and which solvers don't. So if it is easier t",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22543416:69,detect,detection,69,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22543416,4,['detect'],"['detection', 'detections']"
Safety,"Hi all,. I'm not sure how to do pull request in this case so let it be a new Issue. I have implemented Milstein method for solving SME for homodyne detection scheme. For my problems it works much better than the simple Euler-Maruyama method. In case of a single Wiener increment all what is required is the new rhs function (see notebook attached). For multiple Wiener increments the provided infrastructure of QuTiP is not enough. One needs to provide all of the A_ops to the rhs. The modified stochastic.py file is also attached (from qutip.stochastic import smesolve_mil). The attached Notebook contains an example of SME with an analytical solution. Which allows to test smesolver for a single quantum trajectory. The notebook and the modified stochastic.py is here:; http://db.tt/dJNjGo3g. P.S. Due to nonlinearity in the stochastic term of quantum SME the simple Euler-Maruyama scheme doesn't work properly sometimes. Even Milstein struggles. From my experience semi implicit methods help. But in order to implement it in a convenient way one needs to modify QuTiP approach to the problem. Maybe instead of rhs function it would be better to have a function which returns \rho_{n+1} instead of d\rho. It could be more flexible.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35:148,detect,detection,148,https://qutip.org,https://github.com/qutip/qutip/issues/35,1,['detect'],['detection']
Safety,"Hi and thanks for the PR. This seems like reasonable functionality, however time dependence using arrays is already supported if you use scipy.interp to create a function for the array. I have used that method myself (see PR #109 for an example), and at that time decided that it was not necessary with a new time-dependence format in qutip for that functionality. But there could be performance advantages with your method. I will test and compare the two methods and get back to you. . Regarding the implementation: I would preferably avoid using global variables. Can you not use the args argument to store the values instead of using globals() ?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/141#issuecomment-44495147:537,avoid,avoid,537,https://qutip.org,https://github.com/qutip/qutip/pull/141#issuecomment-44495147,1,['avoid'],['avoid']
Safety,"Hi taw181,. Thank you for reporting the bug.; The patch will probably take some time to make and publish. ; A work around for now would be to use string based coefficient. Use `(t)` instead of t in the string, there is another bug in the string shifting code. -------------------------------------------------------------------------------------------; Self notes. The function _transform_L_t_shift of correlation.py has at least 2 bugs:; - lambda have side-effect when defined in loop:; ```; H = [0,1,2]; H_shift = []; for i in range(len(H)):; fn = lambda _: H[i]; H_shift.append(fn); ; for f in H_shift:; print(f(0)); ```; Using class is safer and can be used safely in parallel. - The shift is not applied properly to string when ""t"" is the first or last character of the string coefficient. Could/should this shift capacity be made part of QobjEvo?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1048#issuecomment-515517733:640,safe,safer,640,https://qutip.org,https://github.com/qutip/qutip/issues/1048#issuecomment-515517733,2,['safe'],"['safely', 'safer']"
Safety,"Hi, @Ericgig! I would like to work on this issue. We cannot adopt the 3rd option in the master branch due to backwards compatibility, right? I'd rather avoid any single character variable wherever possible. That said, I believe the second option you gave is the best one to adopt in the master branch. Once I finish, I can work on dev.major implementing the third option.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087:152,avoid,avoid,152,https://qutip.org,https://github.com/qutip/qutip/issues/1838#issuecomment-1075142087,1,['avoid'],['avoid']
Safety,"Hi, I'm wondering if it's possible to control the precision of 'predictor-corrector' solver of the photocurrent_mesolve? Seems like the 'tol' has no effect on the 'predictor-corrector' solver. Here's my code. I was trying to use stochastic master equation to generate the outcome photon sequence from a CPT set up, but I got a diverged outcome sometimes. ```; from qutip import *; import matplotlib.pyplot as plt; import numpy as np; import matplotlib as mpl. params = {; 	'axes.labelsize': 12,; 	'legend.fontsize': 10,; 	'xtick.labelsize': 10,; 	'ytick.labelsize': 10,; 	'figure.figsize': [3*1.4/1.2, 2.8/1.2],#2.3; 	'lines.linewidth' : 1,; 	'axes.linewidth':0.9,; 	'figure.subplot.left':0,; 	'figure.subplot.right':1,; 	'figure.subplot.bottom':0,; 	'figure.subplot.top':1,; 	'grid.linestyle':'--',; 	'axes.grid':False,; 	""font.family"":""serif"",; 	""xtick.direction"":""in"",; 	""ytick.direction"":""in"",. 	}; mpl.rcParams.update(params). T = 100; N = 100000; Gamma = 2*np.pi*13; Omega = 2*np.pi*2. times = np.linspace(0,T,N); ge = fock(3, 0) * fock(3, 1).dag(); se = fock(3, 2) * fock(3, 1).dag(); ss = fock(3, 2) * fock(3, 2).dag(); ee = fock(3, 1) * fock(3, 1).dag(); dark = (fock(3, 2) - fock(3, 0)).unit(); dd = dark*dark.dag(). bias = 2*np.pi*0.1. psi0 = dark. H = Omega * (ge + ge.dag() + se + se.dag()) + bias*ss. result_sme = photocurrent_mesolve(H, psi0, times, c_ops = [],sc_ops = [np.sqrt(Gamma/2)*ge + np.sqrt(Gamma/2)*se]\; 	, e_ops = [dd, ee], store_measurement=True, options=Options(store_states=True), nsubsteps=100, \; 	solver='predictor-corrector'). hermitian = [(result_sme.states[0][i]).isherm for i in range(N)]. plt.plot(times, result_sme.expect[0], color = 'orange', label='dark'); plt.plot(times, result_sme.expect[1], color = 'black', label='e'); plt.plot(times, hermitian, color = 'blue'); plt.xlim(0,100); plt.xlabel('Time'); plt.ylabel('Population'); plt.savefig('sme.pdf',bbox_inches='tight',pad_inches=0); plt.close(). ```; And the result,; [sme.pdf](https://github.com/qutip/q",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1357:64,predict,predictor-corrector,64,https://qutip.org,https://github.com/qutip/qutip/issues/1357,2,['predict'],['predictor-corrector']
Safety,"Hi, is the first time that I use sphinx and I am having trouble generating the apidoc. I understand that I have to run sphinx-apidoc to generate the .rst files from /qutip but I don't know where to put them, so they can be detected by autodoc. I tried but every time I run ""make html"" I get ""autodoc: failed to import module"".",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337:223,detect,detected,223,https://qutip.org,https://github.com/qutip/qutip/pull/2441#issuecomment-2144146337,1,['detect'],['detected']
Safety,"Hi, the cropping issue was there before. Even I had faced it when; visualizing circuits. I used to just add a redundant qubit to the circuit; to get that extra padding. I ll look into the cropping and resize it to; make the visualization better. Could you please open a new issue for that?. I opened a new issue to discuss that in #680 . On 05-Apr-2017 9:37 PM, ""Morten Kjaergaard"" <notifications@github.com>; wrote:. > Hi again @ajgpitch <https://github.com/ajgpitch> and @sahmed95; > <https://github.com/sahmed95>.; >; > I had a chance to work a little with the "".add_state"" feature this; > morning, and wanted to raise an issue in terms of the visualization. The; > problems are shown in the figure below:; > [image: image]; > <https://cloud.githubusercontent.com/assets/7925874/24715124/6f96cf7a-19f8-11e7-8ecd-76c937805bc5.png>; > (NB: this could just be due to jupyter notebook? In any case, I see the; > problem is also reproduced in @sahmed95 <https://github.com/sahmed95>'s; > post here: #679 (comment); > <https://github.com/qutip/qutip/pull/679#issuecomment-291652067>); >; > Two things:; >; > 1. The cropping seems to go bonkers if you use anything else than one; > symbol in the ket-state; > 2. It's not possible to use \textrm{xxx} in the ket-names.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/qutip/qutip/pull/679#issuecomment-291911527>, or mute; > the thread; > <https://github.com/notifications/unsubscribe-auth/AGpUBBFZyzHSm5vJxrIdu33IDkreVAMnks5rs7xQgaJpZM4MyxeC>; > .; >",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/679#issuecomment-291957664:110,redund,redundant,110,https://qutip.org,https://github.com/qutip/qutip/pull/679#issuecomment-291957664,1,['redund'],['redundant']
Safety,"Hi,. I think your new implementation of API should be flexible enough to incorporate any explicit scheme. The reason I think it is useful to calculate \rho_{n+1} is to apply a semi implicit method. This is what is done by Lsparse. I tried two ways of doing it. First, one can calculate (1 - (L+d1)_dt)^(-1) and apply it to to the stochastic part of the equation. Another way is to calculate the deterministic evolution expm[(L+d1)_dt] and also apply it to the stochastic part. Both of these methods work for linear deterministic part like in the homodyne detection. I've got good results with these semi-implicit methods on a problem with a few qubits. Due to a big nonlinearity for some parameters regime it really helps to apply the true deterministic evolution (or its approximation). For another regime it is better to use explicit method. In principle it should be good to adjust degree of implicitness. Anyway I'm still looking into the problem and comparing different possibilities. I hope to produce a new notebook with tests soon. This Milstein realisation is compatible in principle with the heterodyne detection. I'm not sure it is possible to express everything in terms of d1 and d2 only. The point is that I need to use derivatives of d2. I don't really see a problem to have separate RHSs for homodyne, heterodyne and photocurrent detections. I'll think a bit more about unification of homodyne and heterodyne and then I'll submit a pull request. Regarding expm for large systems. We need to calculate it only once, it works for small systems so I think it is a good option to have.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/35#issuecomment-22116628:555,detect,detection,555,https://qutip.org,https://github.com/qutip/qutip/issues/35#issuecomment-22116628,3,['detect'],"['detection', 'detections']"
Safety,"Hi,; In the source code of `mesolve`, the derivative are defined via `L * rho` where L is Liouvillian. But when the size is too large, `L` is of huge dimension. I have two questions:; 1. What tricks have you made so that the derivative is still defined via `L` instead of collapse operators, which is relatively smaller in dimension? Sparse in scipy was used. But if `L` is not sparse at all, how can we avoid memory problem?; 2. What is the general advantage of using Liouvillian `L` to define derivative instead of `C` the collapse operators? It seems that using `L` requires only 1 multiplication, but when I tested and try to define in `C`, it seems that it is still faster for relatively small hilbert space dimension. Is speed the main reason?",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/531:404,avoid,avoid,404,https://qutip.org,https://github.com/qutip/qutip/issues/531,1,['avoid'],['avoid']
Safety,"Hmm, I think that should still work. I think numpy is imported locally in `__init__.py` and if it is deleted before the init file ends, it will not overwrite existing symbols form where `from qutip import *` was called.. If this is not how it works we should do something like `import numpy as _numpy` .... `del _numpy` to avoid breaking code with the import pattern in your example.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/233#issuecomment-56173332:323,avoid,avoid,323,https://qutip.org,https://github.com/qutip/qutip/pull/233#issuecomment-56173332,1,['avoid'],['avoid']
Safety,"Hmm, it still seems to use the old travis ci configuration, where I tried to install numpy/scipy with pip without wheels. But took too long to install the dependencies that way, and the tests will probably timeout and get cancelled. In the current travis ci configuration uses pip with wheels to install numpy/scipy much faster.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/76#issuecomment-36083480:206,timeout,timeout,206,https://qutip.org,https://github.com/qutip/qutip/pull/76#issuecomment-36083480,1,['timeout'],['timeout']
Safety,"Hmm. I think let's leave it out. We can reply to the issue with ""it's implemented in v5 and here is how you do it in v4"". That avoids adding a new feature in a point release (and potentially confusing users) while still solving everyone's immediate problems and making the future better.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205:127,avoid,avoids,127,https://qutip.org,https://github.com/qutip/qutip/pull/1992#issuecomment-1248109205,1,['avoid'],['avoids']
Safety,"How about I just directly upload the files and we close the commit?. On Aug 29, 2014, at 2:20 PM, Robert Johansson notifications@github.com wrote:. > Now in order to avoid a +/- 7000 line diff effecting 148 files, a these commits should be squashed with a rebase.; > ; > —; > Reply to this email directly or view it on GitHub.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221#issuecomment-53839695:166,avoid,avoid,166,https://qutip.org,https://github.com/qutip/qutip/pull/221#issuecomment-53839695,1,['avoid'],['avoid']
Safety,"I agree that this might seem a bit inconsistent. However, a quantum system with only 1 quantum state is not that meaningful since it does not have any degrees of freedom, and in some places in QuTiP, such as in the multiplication of two Qobj instances (like in your total_eye*total_eye example) we treat subsystems with only one quantum state as a subsystem that has been ""projected out"", and therefore we remove that subsystem. This is the reason for why you would get (total_eye*total_eye).dims as [[8], [8]] instead of [[1,8], [1,8]]. Perhaps tensor should also make this check (and drop subsystems with only 1 quantum state)... but on the other hand it is reasonable to avoid calling tensor on subsystems with only 1 quantum states, since it is not a very meaningful thing to do.. Is there any case when this causes a problem for you?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/222#issuecomment-53888260:674,avoid,avoid,674,https://qutip.org,https://github.com/qutip/qutip/issues/222#issuecomment-53888260,1,['avoid'],['avoid']
Safety,I also added a few more safety checks. These may be helpful for anyone trying to convert some old example to v4.4 compatible.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1115#issuecomment-546760124:24,safe,safety,24,https://qutip.org,https://github.com/qutip/qutip/pull/1115#issuecomment-546760124,1,['safe'],['safety']
Safety,"I am closing this: change to the documentation are redundant to previous PRs. The `requirements.txt` file refers to the packages needed to use qutip, which we keep to a minimum. Modules required to build the documentation are in `doc/requirements.txt`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988:51,redund,redundant,51,https://qutip.org,https://github.com/qutip/qutip/pull/1764#issuecomment-1014778988,1,['redund'],['redundant']
Safety,"I am having some trouble with the function mesolve. The situation is the following: I have a collection of Hamiltonians and Jump Operators which includes 69 timesteps each, and I want to evolve a initial state to each of this timesteps. However, Qutip is returning ""Exception: ODE integration error: Try to increase the allowed number of substeps by increasing the nsteps parameter in the Options class."". I tryied to change nsteps parameter but it just doesnt work for any value of it, no matter how big the number is. H= Hamiltonian, shape: 69,2,2; list_Jump-op= Jump operators, shape:69,2,2; time= timesteps, shape (69,); estados_val= the different states that I want to evolve on this dynamics, shape( 6,69,2,2) . Note that I am only taking the 0th element on the axis with lenght of 69. predictions=[mesolve(H,; Qobj(estados_val[i][0]),; time,list_Jump_op,options=Options(nsteps=10000000000000000)) for i in range(len(estados_val))]. The terminal out put is; /home/andrius/anaconda3/lib/python3.8/site-packages/scipy/integrate/_ode.py:1013: UserWarning: zvode: Excess accuracy requested. (Tolerances too small.); warnings.warn('{:s}: {:s}'.format(self.__class__.__name__,; ---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-11-0bc27bfd6f01> in <module>; 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. <ipython-input-11-0bc27bfd6f01> in <listcomp>(.0); 40 ; 41 la=10000000000000000; ---> 42 predictions=[mesolve(H,; 43 Qobj(estados_val[i][0]),; 44 time[1:],list_Jump_op,options=Options(nsteps=la)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605:792,predict,predictions,792,https://qutip.org,https://github.com/qutip/qutip/issues/1605,1,['predict'],['predictions']
Safety,"I am not sure what your example of 'n' photons represents. However, if ; you mean what is the probability of a single-photon in the state, as ; measured by calculating the expectation value,the answer converges to ; 0.272 at about 14 states to one-part in a thousand. > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 18:08; >; > OK, if it's intended then there's nothing to change in the code. But I ; > think it would be helpful to document this in a clearer way: there's a ; > big risk of misinterpreting the operator.; >; > —; > You are receiving this because you modified the open/close state.; > Reply to this email directly, view it on GitHub ; > <https://github.com/qutip/qutip/issues/661#issuecomment-286282270>, or ; > mute the thread ; > <https://github.com/notifications/unsubscribe-auth/ABMPqSiIdpvqRZIZO2kklDrotB4b-6b0ks5rldpigaJpZM4MbmLX>.; >; > ziofil <mailto:notifications@github.com>; > March 13, 2017 at 11:48; >; > When I tried to use the |qutip.squeeze| function for my simulations I ; > noticed that something was off. Upon further investigation I found out ; > that the output is not a truncated version of the single-mode ; > squeezing unitary, but rather the matrix exponential of the truncated ; > generator. These are /very/ different things!; >; > Am I right in assuming that the most useful matrix would be the ; > truncated unitary? If that's the case, the current method to compute ; > it is wrong. To compute the right matrix one can use the disentangling ; > formula for SU(1,1) (formula (31) here ; > <http://aip.scitation.org/doi/pdf/10.1063/1.3413923>):; >; > def squeeze(n,z):; > s0 = np.exp(1j*np.angle(z))*np.tanh(abs(z)); > s1 = -2*np.log(np.cosh(abs(z))); > s2 = -np.exp(-1j*np.angle(z))*np.tanh(abs(z)); >; > L = s0*0.5*(qt.create(n)*qt.create(n)); > K = s1*(0.5*qt.num(n)+0.25*qt.identity(n)); > R = s2*0.5*(qt.destroy(n)*qt.destroy(n)); >; > return (L.expm())*(K.expm())*(R.expm()); >; > As you can see, this definition does /not/ depend on th",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286284316:498,risk,risk,498,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286284316,2,['risk'],['risk']
Safety,"I am on the side on having 2 `default_dtype` options for the `Qobj` creation functions. I have some question as to how/where to make `default_dtype` more consistent. Applying the default at Qobj creation feels risky to me. In the solver it will end up converting the states before computing the expectation value. It could create strange interactions with operators and unitary transformations (`Qobj[Dense].dag() -> Qobj[CSR]`). `Qobj(scipy_csr)` could be converted to something else... However if `default_dtype` can be seen as _running in that mode_, it certainly could cause confusion.; It's not clear how it is understood in some places. In `eigenstates`, if we run in `CSR` mode, then does that mean that we use the sparse eigen solver? It's a lot worst than the dense one. Or should only the returned ket be in CSR format? . In my tries, the dense steadystate was faster that the sparse one. Could it be an issue that some matrices where too big to fit in RAM forcing to use swap space? We could have a warning when matrices over a certain size are allocated. ps. Should `eigenstates` return the states in one operator instead of a list of kets? I guess the states were used to create the operators fed to `steadystate`, so operator output would be more practical.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861:210,risk,risky,210,https://qutip.org,https://github.com/qutip/qutip/issues/2328#issuecomment-1952655861,2,['risk'],['risky']
Safety,I believe I have fixed all the conflicts. Will definitely try to avoid that situation again!,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/294#issuecomment-67658347:65,avoid,avoid,65,https://qutip.org,https://github.com/qutip/qutip/pull/294#issuecomment-67658347,1,['avoid'],['avoid']
Safety,"I did some tests and ; 1 - Cause by fortran zheer (lapack eigenvalue solver for complex hermitian matrices) (c's version Ok); 2 - It happen when installing the scipy stack with pip but not when installing it with conda.; 3 - It depend on the problem size, 64 seems particularly bad, usually it fails on the second call.; 4 - I only got it in zheevr which is only used in `brmesolve`. But Nathan got it in other tests which use scipy's `eigh`.; 4 - It happen in scipy in the fortan version of lapack:. ```; import numpy as np; from scipy.linalg import eigh; H = random_hermitian(64); eigh(H) # Work fine; eigh(np.asfortranarray(H)) # segfault after a few try, may need to change H; ```. Possible solutions (for zheevr):. - Installing scipy with conda, the easiest solution, but not in our control.; - Finding a way to link clapack from cython. Linking scipy's one would require good knowledge of scipy internals since only one cython interface is provided. Linking to another installation of lapack, but it would require the user to install lapack or install it with qutip. Both seems wrong to me.; - For mac user, call scipy's eigh from cython i zheevr, slower but better than risking segfault.; - Have the code directly in qutip. We can adapt it from OpenBlas: https://github.com/xianyi/OpenBLAS/blob/master/lapack-netlib/LAPACKE/src/lapacke_zheevr.c",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492:1177,risk,risking,1177,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-628259492,1,['risk'],['risking']
Safety,"I did this work some time ago, and so I did a git rebase in order to try and avoid any conflicts; I was advised this is the thing to do in such circumstances.; It seemed to go okay, some feedback on whether I did the right thing and did it correctly would be welcome",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/350#issuecomment-113537434:77,avoid,avoid,77,https://qutip.org,https://github.com/qutip/qutip/pull/350#issuecomment-113537434,2,['avoid'],['avoid']
Safety,I didn't realise that was causing a problem too. Seems like a good idea generally to try and avoid conflicts with built in names where possible.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/379#issuecomment-147354304:93,avoid,avoid,93,https://qutip.org,https://github.com/qutip/qutip/pull/379#issuecomment-147354304,1,['avoid'],['avoid']
Safety,"I disabled cython support on python 3.12 with [this patch](https://salsa.debian.org/science-team/qutip/-/blob/master/debian/patches/python3.12_no_cython_support.patch?ref_type=heads):; ```; Index: qutip/qutip/__init__.py; ===================================================================; --- qutip.orig/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; +++ qutip/qutip/__init__.py	2024-01-16 03:52:59.780085342 +0100; @@ -53,25 +53,31 @@; except ImportError:; pass; else:; - from qutip.utilities import _version2int; - _cy_require = ""0.29.20""; - _cy_unsupported = ""3.0.0""; - if _version2int(_Cython.__version__) < _version2int(_cy_require):; - warnings.warn(; - ""Old version of Cython detected: needed {}, got {}.""; - .format(_cy_require, _Cython.__version__); - ); - if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; - warnings.warn(; - ""The new version of Cython, (>= 3.0.0) is not supported.""; - .format(_Cython.__version__); - ); + from sys import version_info as sys_pyver; + if sys_pyver.major == 3 and sys_pyver.minor >= 12:; + # cython3 not supported on python 3.12; + # see https://github.com/qutip/qutip/issues/2293; + print(f""qutip does not support Cython on Python 3.{sys_pyver.minor} (Issue#2293)""); else:; - # Setup pyximport; - import qutip.cy.pyxbuilder as _pyxbuilder; - _pyxbuilder.install(); - del _pyxbuilder, _Cython, _version2int; - qutip.settings.has_cython = True; + from qutip.utilities import _version2int; + _cy_require = ""0.29.20""; + _cy_unsupported = ""3.0.0""; + if _version2int(_Cython.__version__) < _version2int(_cy_require):; + warnings.warn(; + ""Old version of Cython detected: needed {}, got {}.""; + .format(_cy_require, _Cython.__version__); + ); + if _version2int(_Cython.__version__) >= _version2int(_cy_unsupported):; + warnings.warn(; + ""The new version of Cython, (>= 3.0.0) is not supported.""; + .format(_Cython.__version__); + ); + else:; + # Setup pyximport; + import qutip.cy.pyxbuilder as _pyxbuilder; + _pyxbuilder.install();",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543:693,detect,detected,693,https://qutip.org,https://github.com/qutip/qutip/issues/2293#issuecomment-1893522543,1,['detect'],['detected']
Safety,"I don't think either ""missing"" or ""full"" should be used much with pure qutip. Only with plugins like qutip-jax it makes any sense to me. With ""missing"", you could set it so it will end up all in jax format and not have too much issues. . ""full"" will probably break HEOM, some steadystate feature, slow down scipy integrators, etc. ""missing? should be safe. Ok for `default_dtype_scope`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422:351,safe,safe,351,https://qutip.org,https://github.com/qutip/qutip/pull/2519#issuecomment-2407529422,1,['safe'],['safe']
Safety,"I don't think this is the right way to solve your problem, but we probably should be consistent. `Qobj` is not a container for arbitrary data, and a 1x1 `Qobj` basically should never exist. If I remember correctly, the auto-promotion to `Qobj` is to avoid breaking backwards compatibility, because 4.x doesn't use the `@` syntax at all. We almost certainly should be moving to remove that ""feature"", not add to it - it should never work with compound Hilbert spaces (we should be safe-by-default), and trying to detect special behaviour on 1x1 inputs just leads to weird edge cases and breakages all over the place. You probably want some sort of different mechanism for deciding what types a `Qobj.data` instance can accept in `mul`. At the moment, the test is `isinstance(other, numbers.Number)`, but you want to accept `tensorflow.Variable` if the backing data is TF-like. I think the right solution would be based on having some way for downstream classes to expose what types they can accept, perhaps by a well-defined try/except pattern?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515:250,avoid,avoid,250,https://qutip.org,https://github.com/qutip/qutip/pull/1611#issuecomment-880664515,3,"['avoid', 'detect', 'safe']","['avoid', 'detect', 'safe-by-default']"
Safety,"I don't want the way to catch error depend on the map, `serial_map` and `loky_map` both return the error of the first failing iteration and stop there. Having `parallel_map` failing differently will mean that every time we want to catch an error in `mcsolve`, etc. we will have to catch both the expected error and the custom `ParallelMapException`. It also hide the kind of error and prevent us to act on it. I still think that stopping the map and returning the first error is the best options. It will ensure that all map functions fail the same way. In our case, the raised exceptions should be consistent so we should not need run all iteration to see every ways it can fail. And we don't waste computing time to compute result that will not be returned. Another options would to not raise any error and return the finished iteration. For mcsolve, we could have a result returning 99% of the asked trajectories with the note that 1% failed because of overwork from the solver. Trowing away all the work done for one error feels bad. However I can see this not being safe, so it would be a solver options for the user to set.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180:1071,safe,safe,1071,https://qutip.org,https://github.com/qutip/qutip/pull/1969#issuecomment-1209406180,1,['safe'],['safe']
Safety,"I had a bit more success by switching as much as possible in the setup of the testing environment to pip:; ~~~; conda create -q -n qutip_testing_env -y python=3.7; conda install -n qutip_testing_env -y numpy scipy cython; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install -e .; /Users/goerz/.pyenv/versions/miniconda3-latest/envs/qutip_testing_env/bin/python -m pip install nose ipython; ~~~; I also added a `unittest.skipIf` decorator to `qutip/tests/test_stochastic_se.py:test_smesolve_homodyne_methods`, which is the only test that consistently fails on `master`. With this, the test suite runs through about 50% of the time. The other 50% it crashes with the following:; ~~~; ...; PIQS: Test the warning for diagonal Hamiltonians to use internal solver. ... ok; Propagator: HO ('single mode') ... ok; Propagator: HO ('batch mode') ... ok; Propagator: HO parallel ... ok; Propagator: str td format ... ok; Propagator: func td format ... ok; Propagator: steady state ... python(52709,0x10fc1f5c0) malloc: Incorrect checksum for freed object 0x7fcbf338af10: probably modified after being freed.; Corrupt value: 0x3ff0000000000000; python(52709,0x10fc1f5c0) malloc: *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ~~~",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378:1265,Abort,Abort,1265,https://qutip.org,https://github.com/qutip/qutip/issues/1093#issuecomment-540141378,1,['Abort'],['Abort']
Safety,"I had some more thoughts about this while responding in the Google group (see: [this post and associated email chain](https://groups.google.com/g/qutip/c/NAGU4iKZNBY/m/3i-oLXAzAgAJ)). I think perhaps a good solution is to move away from keeping track of the ""dimensions"" of each space, to keeping track of what ""basis"" each space is represented by. This actually allows more safety, and I think is probably a more natural way of thinking about the underlying physics for most people.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-667164574:375,safe,safety,375,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-667164574,1,['safe'],['safety']
Safety,"I have a trouble in solving a time dependent Bloch-Redfield master equation with arguments.; Let me use an example discussed in [here](https://github.com/qutip/qutip/issues/966); The schedule functions of the time dependent Hamiltonian are defined by using some parameters which are passed to mesolve as args.; This method works well for sesolve and mesolve.; However, if I try to use the same method in brmesolve, it returns error in compiling Cython. I attached a python code which demonstrates the above observation. . I also noticed that in bloch_redfield.py it says; args : dict ; Placeholder for future implementation, kept for API consistency. Would it be possible to use arguments in brmesolve? If not, how could I use parametrically defined schedule functions while avoiding the issue raised in [here](https://github.com/qutip/qutip/issues/966)?. I need this for my research and I would appreciate your help very much. [Qutip Redfield master issue.py.zip](https://github.com/qutip/qutip/files/4028211/Qutip.Redfield.master.issue.py.zip)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1150:775,avoid,avoiding,775,https://qutip.org,https://github.com/qutip/qutip/issues/1150,1,['avoid'],['avoiding']
Safety,"I haven't checked, but I'd bet it's because we construct a new Liouvillian `QobjEvo` on entry to `mesolve` with collapse operators. If so, this is definitely a bug - we should have detected that the collapse operators have no time-dependence, so don't need to overwrite the `tlist`. As a temporary work-around, you can construct the Liouvillian directly and pass it to `mesolve`:; ```python; liouvillian = qutip.liouvillian(ham, collapse); qutip.mesolve(liouvillian, rho, eval_times); ```; which should work fine for now.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641:181,detect,detected,181,https://qutip.org,https://github.com/qutip/qutip/issues/1560#issuecomment-849604641,1,['detect'],['detected']
Safety,"I just did a fresh instlal of qutip today and ran the tests. mcsolve (and mcsolve_f90) tests involving collapse operators fail. Probably this is due to a recent change in the code where averaging of states is turned off by default for the solver:. > commit fb40b4675bb454089a08087c64a07f83be44cd99; > Author: Robert Johansson jrjohansson@gmail.com; > Date: Mon Aug 5 11:24:26 2013 +0900; > ; > do not average states by default. I think this change in general involves a risk of not being backwards compatible with a lot of old code. What do you think?. Cheers, Arne",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/37:470,risk,risk,470,https://qutip.org,https://github.com/qutip/qutip/issues/37,1,['risk'],['risk']
Safety,"I made a snipped with dummy arrays that reproduce the error. Is it enough?; ````; H=[]. timelist_Jump_op=[]; time=[]; for i in range(t):; H.append(Qobj(np.ones((2,2)))); list_Jump_op.append(Qobj(np.ones((2,2)))); time.append(0.5). estados_val=np.array([; [[ 0.4952317 +0.j , 0.35307695-0.22776115j],; [ 0.35307695+0.22776115j, 0.5047683 +0.j ]],. [[ 0.80942518+0.j , 0.14798043+0.36381018j],; [ 0.14798043-0.36381018j, 0.19057482+0.j ]],. [[ 0.74030166+0.j , -0.42252924+0.11715014j],; [-0.42252924-0.11715014j, 0.25969834+0.j ]],; [[ 0.76627252+0.j , 0.14479804+0.39765874j],; [ 0.14479804-0.39765874j, 0.23372748+0.j ]],; [[ 0.69965345+0.j , 0.4260361 -0.16920917j],; [ 0.4260361 +0.16920917j, 0.30034655+0.j ]],; [[ 0.80355468+0.j , 0.36706718-0.15204028j],; [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) . predictions=[mesolve(H,; Qobj(estados_val[i]),; time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]`. ```; `---------------------------------------------------------------------------; Exception Traceback (most recent call last); <ipython-input-26-ef5799d8412d> in <module>; 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. <ipython-input-26-ef5799d8412d> in <listcomp>(.0); 26 [ 0.36706718+0.15204028j, 0.19644532+0.j ]]]) ; 27 ; ---> 28 predictions=[mesolve(H,; 29 Qobj(estados_val[i]),; 30 time,list_Jump_op,options=Options(nsteps=1000000000)) for i in range(len(estados_val))]. ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in mesolve(H, rho0, tlist, c_ops, e_ops, args, options, progress_bar, _safe_mode); 270 func(0., v, *ode_args) + v; 271 ; --> 272 res = _generic_ode_solve(func, ode_args, rho0, tlist, e_ops, options,; 273 progress_bar, dims=rho0.dims); 274 res.num_collapse = len(c_ops). ~/anaconda3/lib/python3.8/site-packages/qutip/mesolve.py in _generic_ode_solve(func, ode",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553:810,predict,predictions,810,https://qutip.org,https://github.com/qutip/qutip/issues/1605#issuecomment-879127553,1,['predict'],['predictions']
Safety,"I made some tests with this PR and ran into one problem: the iscptp is very computationally demanding for large system, so it cannot be used in the `__str__` and `_latex_repr_`, because it prevents large systems from being displayed. Also, whether a super operator is CPTP is not always relevant so it does not need to be shown in every printed Qobj. Also, superrep should probably only be displayed if it is not 'super' (to avoid both type and superrep duplicating the same information),",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/90#issuecomment-37786513:425,avoid,avoid,425,https://qutip.org,https://github.com/qutip/qutip/pull/90#issuecomment-37786513,1,['avoid'],['avoid']
Safety,"I made the change for immutable `Coefficient` and `_Elements`. ; `replace` is about 200ns slower than the previous inplace `arguments`.; With `_Elements` 'immutable', `QobjEvo.copy`'s default is to do a shallow copy of the `elements` list. ; The `_BaseElement._call` is not returning the (data, coeff) pair, but stores it to save on time to create of a python object.; This it may not safe with threading: if 2 copies of a `QobjEvo` are called at the same time with different `t`, both could return the same result. I am not sure how good is the GIL in this case.; I don't expect it to be an issue, in the rare case threading would be used, a deepcopy is available with `QobjEvo.copy(deepcopy=True)`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-817018631:385,safe,safe,385,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-817018631,1,['safe'],['safe']
Safety,"I mean the motivation behind the np array format itself. And indeed, the spline assumes equidistant points. > On Aug 24, 2016, at 12:04, kafischer notifications@github.com wrote:; > ; > I'm a bit confused by your comment: Are asking about the purpose of the np array format itself or did you mean why it should accept non-linear tlists?; > ; > The reason it should accept non-linear tlists is because such a thing is good to have when you simulate rapid dynamics followed by slow dynamics. This currently works for all other types of time-dependent formats, so it should also work for this one to avoid confusion. The cubic spline would indeed be nicer here, except it seems to me like it assumes the x values are linear?; > ; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub https://github.com/qutip/qutip/pull/520#issuecomment-242156352, or mute the thread https://github.com/notifications/unsubscribe-auth/ABMPqQvb7gOJPOTVk9VN5KseYyslkRUTks5qjIe8gaJpZM4JpQHD.; > ; > Untracked with Trackbuster https://trackbuster.com/?sig",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-242156997:597,avoid,avoid,597,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-242156997,1,['avoid'],['avoid']
Safety,"I moved the Coefficient changes to #1507, all should be thead-safe and _[...]Element are better documented.; #1507 should be merged before this.; The commit history somewhat a mess... I suggest squash and merge.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-825047432:62,safe,safe,62,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-825047432,1,['safe'],['safe']
Safety,"I realised I never replied to this. I suggested `2*rtol` in this case because the error propagation in this case would guarantee that this is always sufficient. For other tests, we can always design the test so that it's calculable what the error term should be. I'd say it's generally a good idea to have the tests be as tight as we can possibly make them without risking false-negatives on the results, because otherwise we're not properly testing that the parameters do what they say. Regardless, that test failure isn't due to any of my PRs - it's a pre-existing problem that we happened to get unlucky on this time round. It'll get fixed when I modify `test_mesolve.py`. Can we review this PR to get the ball rolling on getting all of the test refactoring considered?. Possible reviewers: @Ericgig, @BoxiLi, @nathanshammah",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133:365,risk,risking,365,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-628265133,1,['risk'],['risking']
Safety,"I rechecked the equations:; The stochastic integration has the general form:; ![image](https://user-images.githubusercontent.com/17770236/140782543-9d8ff092-b9cb-4b17-98e8-85ab0254b425.png); For `ssesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140783379-72e48698-4f2d-4ebc-bfac-95630e8724b1.png). And for `smesolve`:; ![image](https://user-images.githubusercontent.com/17770236/140784174-e9fdb33b-2fee-4795-a93d-e7d1abe32ddd.png). The liouvillian use both the `sc_ops` and `c_ops` for collapse, but the `d_2` part only use `sc_ops`. In heterodyne detection, each `sc_ops` is split into 2 parts computed individually: ; ![image](https://user-images.githubusercontent.com/17770236/140784227-39e67d38-33bf-47c8-ab57-afd41c23afa6.png). `m_ops` for homodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784715-a7861965-6b30-4a47-a7a6-e19d4dd8b430.png). `m_ops` for heterodyne:; ![image](https://user-images.githubusercontent.com/17770236/140784760-5adb2535-ff63-4b2d-bba8-b10b6422b5db.png). In both case the `dW`'s default is `1`. In the heterodyne case, the `sqrt(2)` is expected to be included inside `dW_factor` when it's length is the same as `m_ops`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778:571,detect,detection,571,https://qutip.org,https://github.com/qutip/qutip/issues/1706#issuecomment-963395778,1,['detect'],['detection']
Safety,"I report local tests failing on my MacOS 10.13.6 by running qutip.testing.run(). Tests fail for python 3.7 and 3.6 environments, if QuTiP 4.4. is installed in develop mode (openmp = True). ; Tests fail also for QuTiP 4.3.1 installed with conda. . ### py36; Broken test for python 3.6 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1: ; Error Message below: ; ``` ; Metrics: Trace dist. & Fidelity mixed/pure inequality ... ok ; Metrics: Check avg gate fidelities for random ... ; python(35852,0x7fff9757f380) malloc: *** error for object 0x7fe189168a10: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ---------------------------------------------- ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py36 ; source activate qutip-dev-44-py36 ; conda install python=3.6 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp; ``` . ### py37; Broken test for python 3.7 with: (1) QuTiP 4.4-dev, with openmp =True and (2) conda install qutip, QuTiP 4.3.1. Error Message below: ; ``` ; qutip.tests.test_qobj.test_expect_exception ... ok Qobj data ... ok Qobj type ... ok Qobj Hermicity ... ok ; Qobj unitarity ... ok ; Qobj shape ... ok ; Qobj: multiplication w/ non-square qobj.dims ... ok ; Qobj addition ... ok ; Qobj subtraction ... ok ; Qobj multiplication ... ok ; Qobj division ... ok ; Qobj power ... ; python(35379,0x7fff9757f380) malloc: *** error for object 0x7fbf1089fa90: incorrect checksum for freed object - object was probably modified after being freed. *** ; set a breakpoint in malloc_error_break to debug ; Abort trap: 6 ; ``` . Building the dev environment: ; ``` conda create --name qutip-dev-44-py37 ; source activate qutip-dev-44-py37 ; conda install python=3.7 cython numpy scipy nose jupyter matplotlib; python setup.py develop --with-openmp```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-473772867:731,Abort,Abort,731,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-473772867,2,['Abort'],['Abort']
Safety,"I see it as `v4` being wrong instead of `dev.major`. It should not truncate small values with an hidden tolerance.; Here it's the sparse matrix operations which drop small values to stay sparse that cause the change. In v5, these operations are done using dense matrices. However this should have been the case for a long time... The test `p != 0` is always risky with floating number, we should use `p >= tol` with a documented tolerance instead. The `atol` from core options would work here, but we could also have the tolerance as an optional input to measurement functions.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866:358,risk,risky,358,https://qutip.org,https://github.com/qutip/qutip/issues/2029#issuecomment-1336417866,1,['risk'],['risky']
Safety,"I think I agree that the two PRs should be kept separate. Initially, I wanted to make them the same since I was trying to use the code in #1090 but right now the two don't interact much. . Wrt the formatting changes, they were put inadvertently and I'll make sure to revert them but thanks for pointing them out. Let me know what you think of the code in this PR and if you think there's some redundancy between the two (I think there should be but I can't quite put a finger on it).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1274#issuecomment-633964657:393,redund,redundancy,393,https://qutip.org,https://github.com/qutip/qutip/pull/1274#issuecomment-633964657,1,['redund'],['redundancy']
Safety,"I think it's quite important to understand why this happened. Previously we reliably had an exactly correct result, and now we don't. This particular check for `p != 0` of a float is I think okay because it's there specially to avoid division by exactly zero. I can think of at least two plausible scenarios:. 1. The issue was caused by the removal of auto_tidyup, in which case I think either a setting like this with an explicit check in either the measurement functions or the simulator are good solutions (although it should be possible to override the setting on a per-call basis, just like with atol). 2. The issue was caused by the removal of the data layer mathematical operations, and in particular, by the replacement of `data / value` by `data.mul(data, 1 / value)`, in which case I think the solution is to add a `div` operation to the data classes so that we don't lose this accuracy.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773:228,avoid,avoid,228,https://qutip.org,https://github.com/qutip/qutip/pull/1656#issuecomment-917229773,1,['avoid'],['avoid']
Safety,"I think that `qutip.testing` and the tests in CI are different. The former are in that file, the latter look at the instructions from [`.travis.yml`](https://github.com/qutip/qutip/blob/master/.travis.yml), which basically call `python setup.py install` (or `test`). Also looking at the Travis CI reports, it seems that they work fine. Locally, I'm getting tests to fail on my machine, with malloc or abort trap 6 errors every other time, although some time they pass (hence I opened #1160). It may be that they fail on my machine due to some mess with the gcc compiler.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1158#issuecomment-576002319:401,abort,abort,401,https://qutip.org,https://github.com/qutip/qutip/issues/1158#issuecomment-576002319,1,['abort'],['abort']
Safety,"I think that this is the correct solution though, so big bonus points for hunting this down! At work, we have no use for OSX, and would love py3 on win, so I can fiddle around to get something working. Having two separate sources may be the route we need to go. It wouldn't be the end of the world, but should be avoided unless absolutely necessary.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/647#issuecomment-279727419:313,avoid,avoided,313,https://qutip.org,https://github.com/qutip/qutip/issues/647#issuecomment-279727419,1,['avoid'],['avoided']
Safety,"I think the bug is bigger than that. `Qobj` never ensure that the shape and dims match but in many places, solver check only the dims and not the shape. Here `rho` is shaped as an `operator-ket` but with `oper` dims, so it slip through the dims check. I wouldn't be surprised that we can cause other segfault with `Qobj` where the shape and dims don't match. . It would be safer to add a check when entering cython code.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103:373,safe,safer,373,https://qutip.org,https://github.com/qutip/qutip/issues/1782#issuecomment-1021398103,1,['safe'],['safer']
Safety,"I think the module should really be `qutip.testing` (or `qutip.test` if the name's already taken), not `qutip.core.data.testing`, if you're going to add one. It's very likely to be the case in the future (if it isn't already) that you'll need additional dependencies to define the tests, and you don't want to force _all_ runtime users to have them to install QuTiP. If you put the package in a separate top-level module, it's _far_ easier to separate out all the code, and have `qutip/__init__.py` not import `qutip.testing`, so things won't break. Also, tests generally need to work with a fully imported version of the module. If we start putting testing infrastructure in the core, we're going to encode a whole lot of cyclical dependencies right away, or end up with `testing` modules scattered all across the codebase, for no real gain. For discovery: that would only happen during test generation, which comes after importing the modules and defining the classes, so you'd still be able to define tolerances and influence how the tests ran. The problem with _not_ having discovery is that it becomes very easy to forget to test a function, and with so much of the machinery automated, it's also easy to forget it when reviewing a PR. That's particularly true once you have external contributors writing these sorts of things - we have it in Qiskit, where people add things to our ""standard equivalence library"", and new contributors and new reviewers don't know where all the different tests are, so our discovery tests have helped catch bugs. That happens even with super experienced team members. I'd argue that code coverage metrics are possibly a better way of detecting missing tests - that fails safe if you add broken code and forget to test it, whereas having to specify the tests explicitly means you can accidentally add broken code to a dispatcher and not know, if you forgot to add the test.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735:1672,detect,detecting,1672,https://qutip.org,https://github.com/qutip/qutip/pull/1723#issuecomment-981562735,2,"['detect', 'safe']","['detecting', 'safe']"
Safety,"I think there are two separate issues here. . As for the fortran module, it's true that the it adds a lot of build complexity, but most users do not need it and can easily install qutip without it. There is a case for removing it from qutip and put it in a separate module, but think this should be low priority, since it would require non-negligible amount work, would break backwards compatibility (it should bump next release to 4.0), and does not really provide any new features (other than a less complex code base). There might users who rely on it and for them it might be annoying if we remove it. So I would vote for postponing it until there are very strong arguments for removing it. As for the topic of this issue, I think that qutip should follow the lead of NumPy, even if it breaks backwards compatibility in the configuration methods, so that users that are familiar with NumPy and related projects does not have any surprises when using qutip. Also, if I understand correctly, this would mostly change how one configure and build against blas libraries such as openblas? Then I guess it would not effect the typical user that just download and install the package with standard configuration (no site.cfg file), and it should be safe the follow the advice of the OP.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155058653:1246,safe,safe,1246,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155058653,1,['safe'],['safe']
Safety,"I think this is still relevant and could be a topic of work for future google SoC students or other students. . Recently I met Johannes Bausch who at Caltech used the algorithm toolbox for some fun example (predict the winner of the [world cup](https://quantumfrontiers.com/2018/07/02/the-world-cup-from-a-quantum-perspective/)), but this points to the fact that the QIP suite is still used. . Also, there might be room for basic I/O functionality to QiSKit and Rigetti. This quantum compiler integrability would further drive interest from the educational point of view. QuTiP is the best playground to learn realistic quantum mechanics and the notion of a compiler back-end could prove enticing.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/441#issuecomment-464298751:207,predict,predict,207,https://qutip.org,https://github.com/qutip/qutip/issues/441#issuecomment-464298751,2,['predict'],['predict']
Safety,"I thought we had resolved the installation issues with the Fortran side by making the MC solver a optional (default to False).; I am not that I have fully digested everything in this thread, but @zerothi seems confident that there is just some small change that we need to improve integration with the latest Numpy. Its not clear to me what are the risks or other downsides.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/392#issuecomment-155040632:349,risk,risks,349,https://qutip.org,https://github.com/qutip/qutip/issues/392#issuecomment-155040632,2,['risk'],['risks']
Safety,"I tried it locally and `show` print the figure twice, whether you provide a figure or not. `render` itself print the picture so having it in `show` make `display` redundant. Otherwise, it work fine.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295:163,redund,redundant,163,https://qutip.org,https://github.com/qutip/qutip/pull/1619#issuecomment-988068295,1,['redund'],['redundant']
Safety,"I tried running the same test with pytest and it fails.; ```; ============================= test session starts ==============================; platform darwin -- Python 3.7.1, pytest-4.0.2, py-1.7.0, pluggy-0.8.0; rootdir: /Users/shahnawaz/Dropbox/dev/qutip, inifile:; plugins: remotedata-0.3.1, openfiles-0.3.1, doctestplus-0.2.0, arraydiff-0.3; collected 13 items. test_superop_reps.py ..Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/944#issuecomment-458572211:391,Abort,Abort,391,https://qutip.org,https://github.com/qutip/qutip/issues/944#issuecomment-458572211,1,['Abort'],['Abort']
Safety,"I vote for setting the dtype. This is probably safer since there are some; parts of the code that expect arrays.; On Sep 10, 2014 11:36 PM, ""Robert Johansson"" notifications@github.com; wrote:. > Thanks for reporting this problem! It seems to be related to the recent; > numpy 1.9 (works fine with older numpy releases). We should either add; > dtype=object in the call to np.array or use list, as you suggests.; > ; > —; > Reply to this email directly or view it on GitHub; > https://github.com/qutip/qutip/issues/228#issuecomment-55124130.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/228#issuecomment-55211686:47,safe,safer,47,https://qutip.org,https://github.com/qutip/qutip/issues/228#issuecomment-55211686,1,['safe'],['safer']
Safety,I will add tests. I changed the status to draft to avoid merging.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158:51,avoid,avoid,51,https://qutip.org,https://github.com/qutip/qutip/pull/1636#issuecomment-929639158,1,['avoid'],['avoid']
Safety,"I'm a bit confused by your comment: Are asking about the purpose of the np array format itself or did you mean why it should accept non-linear tlists?. The reason it should accept non-linear tlists is because such a thing is good to have when you simulate rapid dynamics followed by slow dynamics. This currently works for all other types of time-dependent formats, so it should also work for this one to avoid confusion. The cubic spline would indeed be nicer here, except it seems to me like it assumes the x values are linear?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/520#issuecomment-242156352:405,avoid,avoid,405,https://qutip.org,https://github.com/qutip/qutip/pull/520#issuecomment-242156352,1,['avoid'],['avoid']
Safety,"I'm also using Anaconda on Macbook M1 and ran into 2 errors today when importing qutip. . 1. With the M1 chip, qutip had a problem with hardware detection and as @jakelishman said, commenting lines 48 and 49 on `qutip/hardware_info.py` fixed this error. 2. Then I got the same error message with ""IPYTHON not defined"" and ""'qutip' has no attribute 'settings'."" I thought my conda environment must have been missing the ipython package somehow(?) so I tried `conda install ipython` and importing qutip again and it worked! (I then ran qutip.testing.run() to test out all functions and everything worked perfectly).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1396#issuecomment-759733240:145,detect,detection,145,https://qutip.org,https://github.com/qutip/qutip/issues/1396#issuecomment-759733240,1,['detect'],['detection']
Safety,"I'm not sure about any of these options:; 1. this absolutely should not happen. Trying to detect ""magic"" behaviour based on size is counterintuitive, and breaks other behaviour; it makes it impossible for `Qobj` to correctly handle 1x1 Hilbert spaces. While very infrequently used in practice, trying to backdoor different behaviour through something because it's already there is a nightmare to maintain, and prevents any other use. We've had large problems with 1x1 Hilbert spaces in the past, and 5.x is very strict about handling them safely now.; 2. `mul` should not be defined between two instances of `Data`, because `Data` represents a matrix, and `mul` is between a scalar and a matrix. Still, this seems closest to the correct solution to me, but instead, perhaps the `mul` dispatcher might take an arbitrary Python object as the scalar, and the inner function is responsible for returning `NotImplemented` if it can't handle it? This would require a couple of wrappers around the existing `csr` and `dense` methods, but that's not a huge deal, since the dispatchers are meant to be called from Python space anyway.; 3. same argument as the start of 2: `mul` is already defined as ""scalar \* matrix"", and there's no need for ""matched-shape elementwise multiplication"" to be a defined operation.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863:90,detect,detect,90,https://qutip.org,https://github.com/qutip/qutip/issues/1607#issuecomment-880740863,2,"['detect', 'safe']","['detect', 'safely']"
Safety,"I'm sorry I don't have a huge amount of time at the moment, but just to add an extra point (that it looks like I didn't think about before): if we _do_ add this, then any method that requires an unconditional `import qutip` in downstream packages probably isn't a suitable solution - `import qutip` already takes far too long (though a lot of this is importing various parts of `scipy`, which another library might do on our behalf), and it means that they'd have to do their own import checking to handle optional dependencies. In that sense, (ab)using Python's duck-typing with a magic method might be the best way to break the dependency/import problem. I'm definitely still against implicit conversion to `Qobj` in pretty much any situation - I can imagine we could define a safe, fairly forward-compatible interface for letting people do `qutip.Qobj(x)`, but as it stands, that's the limit that I'd want the interface to be used for. I particularly am really against the idea of implicit conversion. I don't see an advantage to allowing QuTiP functions to act implicitly on other objects; it means our own functions are slower (because we have to explicitly test inputs on _everything_), and it restricts us more from improving `Qobj`'s internals, because we have to maintain compatibility with the interface. We'd never really be able to output anything _other_ than a `Qobj` without this, so there's no reason not to just have the user convert the inputs to `Qobj` explicitly themselves - that isolates the efficiency penalty so you only pay it if you need it, and it'll likely be clearer in the end anyway, because explicit is better for following the logic than implicit.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301:779,safe,safe,779,https://qutip.org,https://github.com/qutip/qutip/issues/1508#issuecomment-908380301,2,['safe'],['safe']
Safety,"I'm trying it now on a Windows without ImageMagick installed. However, it finds a wrong executable `convert`, which is a default command on Windows...... Is there a way to identify if the `convert` is the one we want? Otherwise, we can also just catch the CalledProcessError at line 148 and add an instruction. ```; 147 in_file = file_stem + "".pdf""; 148 out_file = file_stem + ""."" + configuration.file_type; --> 149 _run_command((which, *configuration.arguments, in_file, out_file)); 150 with open(out_file, mode) as file:; 151 return file.read(). ~\Miniconda3\envs\qutip-dev-py3\lib\subprocess.py in run(input, capture_output, timeout, check, *popenargs, **kwargs); 485 if check and retcode:; 486 raise CalledProcessError(retcode, process.args,; --> 487 output=stdout, stderr=stderr); 488 return CompletedProcess(process.args, retcode, stdout, stderr); 489 . CalledProcessError: Command '('convert', '-density', '100', 'qcirc.pdf', 'qcirc.png')' returned non-zero exit status 4.; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125:628,timeout,timeout,628,https://qutip.org,https://github.com/qutip/qutip/pull/1194#issuecomment-605443125,1,['timeout'],['timeout']
Safety,"I'm wondering, maybe for the colour-blind-safe mode, the traditional black-or-white colour is a better choice? The colour blind cmap goes from dark to bright. If one has a large number of entries, it is inevitable that some of them will be close to the threshold and become hard to distinguish from the background, regardless of the threshold. An alternative could be using a white edge for each blob, distinguish it from the background, e.g.:; ![image](https://user-images.githubusercontent.com/12125783/124672592-967ba880-deb7-11eb-90cb-91c78690a633.png)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1595#issuecomment-875116010:42,safe,safe,42,https://qutip.org,https://github.com/qutip/qutip/issues/1595#issuecomment-875116010,1,['safe'],['safe']
Safety,"I've lost the plot a bit with a whole load of changes to `Coefficient` now merged into this PR. Is there a chance we can split that out into its own PR?. I would expect `QobjEvo.__call__` to be thread-safe/re-entrant. The fact that coefficients seemingly don't support this immediately is worrying to me. A simple call like that changing ""global"" state of the object is dangerous; it has a habit of leaking out even in single-threaded applications, just like the bug I described previously with a call to `mesolve` modifying an existing `QobjEvo` in place. In this case I don't see an immediate bug, but it's very non-obvious behaviour and it would be easy to accidentally introduce one in it in the future (or maybe I just can't think of one now). Having `_BaseElement` be mutable makes all time-dependent operations of `QobjEvo` unresolvably thread-unsafe without copying on every operation. That said, looking again, I'm not sure I understand `_BaseElement`: it seems like `_EvoElement` and `_FuncElement` do entirely different things on `call`? What's the purpose of it, and if we put all speed considerations aside what would the signature and behaviour of `_BaseElement._call` be?. Could you write some docstrings on all the elements to explain their use-cases as well, so we've got it all stored for the future?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122:201,safe,safe,201,https://qutip.org,https://github.com/qutip/qutip/pull/1481#issuecomment-822817122,4,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"If those editors claim to provide terminal emulation it should be reported as bugs to them. However, even if it is fixed there it will take a long time before such a fix would reach end-users. I think in the interest of avoiding regressions I think we should restore the previous TextProgressBar and rename the current one to EnhancedTextProgressBar or something like that. Then this new progress bar would not disrupt peoples workflow and users who wants to use it can do so by creating an instance of it and pass it to progress-bar enabled functions using the progress_bar keyword argument.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-63267628:220,avoid,avoiding,220,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-63267628,2,['avoid'],['avoiding']
Safety,"If you're concerned about the solvers, a) they skip tidyup til the end anyway and b) _technically_ the computational complexity of CSR * dense vector is identical to tidyup (though tidyup is a little more cache efficient), but really it's the constant factors that could kill you for small systems. For example, the ""naive"" way of implementing a relative tolerance would take the absolute value of a complex number, but that involves a floating-point square root, which is a very slow operation. That's likely partly why the current version compares real and imaginary components separately, even though the sparsity structure is only improved if _both_ go to zero. In a two-pass operation you'd sqrt twice for every entry (naively - all the square roots are very avoidable), and I'd start to worry that that really _could_ dominate small system operations. Or maybe you should just ignore me when assigning ""good first issues"" - I'm probably too opinionated about performance characteristics without enough experience at managing other people's code!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141:764,avoid,avoidable,764,https://qutip.org,https://github.com/qutip/qutip/issues/1349#issuecomment-793991141,1,['avoid'],['avoidable']
Safety,"In `smesolve` if heterodyne detection is chosen and custom measurement operators are provided, the variable `m_ops` is used before being declared [here](https://github.com/qutip/qutip/blob/1253740be0600315286438d1a64f172920b0dadc/qutip/solve/stochastic.py#L604). A quick fix would be changing this line to; ```python; if sso.m_ops is None:; sso.m_ops = m_ops; ```; But probably adding some checks (correct shape, and whether the measured ops look like quadratures) would be nice. Thank you for the tremendous work, by the way!",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2078:28,detect,detection,28,https://qutip.org,https://github.com/qutip/qutip/issues/2078,1,['detect'],['detection']
Safety,"In `test_interpolate`, `qzero` was used as `mcsolve`'s collapse operator. Due to numerical error in the interpolation method, `mcsolve` can detect a collapse, but a collapse for a null operator cause a a division by zero. This sometime made our tests fails. By changing the collapse operator to `qeye`, the evolution, thus the test is unaffected, but it no longer randomly fail.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1645:140,detect,detect,140,https://qutip.org,https://github.com/qutip/qutip/pull/1645,1,['detect'],['detect']
Safety,"In certain cases in matrices containing values smaller than the tolerance for Hermicity, a matrix can be considered Hermitian even if its transpose does not have the same sparsity pattern as itself. The previous version of this function would give false negatives in these circumstances, whereas now we fall back on the more computationally and memory intensive version of constructing the transpose completely, and comparing element-wise. We offset some of this slowdown by optimising the floating-point comparisons to avoid calls to `sqrt` (via `abs`), and by removing a redundant test of the sparsity pattern in the inner loop. Fixes #1350 for the `master` branch, but still to do for `dev.major`.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1352:520,avoid,avoid,520,https://qutip.org,https://github.com/qutip/qutip/pull/1352,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"In development version 4.4: . - For Python 3.6, when running `qutip.testing.run()`. ```; uTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.6.8; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); ```; I obtain an error at ; ```; Propagator: steady state ... Segmentation fault: 11; ```. - For Python 3.7 with ; ```; QuTiP Version: 4.4.0.dev0+0bf3e05e; Numpy Version: 1.16.2; Scipy Version: 1.2.1; Cython Version: 0.29.6; Matplotlib Version: 3.0.3; Python Version: 3.7.3; Number of CPUs: 2; BLAS Info: INTEL MKL; OPENMP Installed: True; INTEL MKL Ext: True; Platform Info: Darwin (x86_64); Installation path: /Users/nathanshammah/miniconda3/envs/py37/lib/python3.7/site-packages/qutip-4.4.0.dev0+0bf3e05e-py3.7-macosx-10.7-x86_64.egg/qutip; ```; the error occurs at . ```; Metrics: Check avg gate fidelities for random ... python(42424,0x7fffa34a8380) malloc: *** error for object 0x7fc74f258880: incorrect checksum for freed object - object was probably modified after being freed.; *** set a breakpoint in malloc_error_break to debug; Abort trap: 6; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/963#issuecomment-482116179:1201,Abort,Abort,1201,https://qutip.org,https://github.com/qutip/qutip/issues/963#issuecomment-482116179,1,['Abort'],['Abort']
Safety,"In my earlier PR, I had forgotten to add a check for trace preservation in the `iscptp` property. This has now been added, along with test cases for the new `istp` and `iscp` properties. I'm not entirely satisfied with importing within the property bodies, but I'm not sure how else to avoid circular dependencies.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/94:286,avoid,avoid,286,https://qutip.org,https://github.com/qutip/qutip/pull/94,1,['avoid'],['avoid']
Safety,"In the release version `qutip-4.7.X`, it is set in `qutip/__init__.py`. On master it is at https://github.com/qutip/qutip/blob/253d91c2776fef5cc0025e3c537d046f6e9c97a1/qutip/settings.py#L159; It's a property and can't be changed, but we can change that if useful.; The condition is the same. Qutip's sparse `eig` is not safe for matrices with degenerate real part of the eigen value (#1998), but I have not seen issues with the dense one (calling lapack through numpy).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751:320,safe,safe,320,https://qutip.org,https://github.com/qutip/qutip/issues/2273#issuecomment-1832717751,1,['safe'],['safe']
Safety,"Instead of calculating the alpha**n/sqrt(n!) for every entry, calculate; it recursively by x_{n+1} = x_{n}*alpha/sqrt(n), thereby avoiding the; explicit calculation of the factorial. This way it works also for; dimensions>400 where it would fail before. This comes with a speed improvement:; ![benchmark_coherentstate](https://cloud.githubusercontent.com/assets/102507/24836249/399a4fba-1d17-11e7-9387-dd6ab9da1172.png)",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/683:130,avoid,avoiding,130,https://qutip.org,https://github.com/qutip/qutip/pull/683,1,['avoid'],['avoiding']
Safety,"Introduce a common ODE integrator interface for qutip's solver. Presently qutip's solver use `scipy.integratre.ode`'s zvode ODE solver, which support `adams` and `bdf` methods.; These are great method in most case, but not always optimal.; This PR introduce, a common interface to allow other ODE method to be used by solvers.; It also add 2 new scipy ODE solvers: `lsoda` and `dop853`.; `lsoda` detect if the system is stiff and switch between `adams` and `bdf`.; `dop853` is a 8th order Runge-Kutta method. The `Integrator` use `Data` as state and return the state as a pair `(t, state)`.; Often solver's run only compute the expectation values, so there is no need to create a `Qobj`.; Returning the time with the state is for `mcsolve` which have the integration advancing with one internal step and the run loop is cleaner in solver. . I did some benchmark and `adams` method is often the best scipy method.; Sparse system: loglog plot of time in function of system size.; ![image](https://user-images.githubusercontent.com/17770236/131005186-aa51aa86-8ecf-4c03-8ba4-eeddcd65af30.png). Dense time-dependent system.; ![image](https://user-images.githubusercontent.com/17770236/131005465-5c0a9e8e-9ec7-4409-8cda-70aab5129e1f.png). *`vern7`, `vern9`, and `diag` method will be introduced in another PR.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1643:396,detect,detect,396,https://qutip.org,https://github.com/qutip/qutip/pull/1643,1,['detect'],['detect']
Safety,"Is multiprocessing used by default in some functions ? Can we do away with that in the __init__.py file and add it where it is used ? . Why do we need to check for numpy and scipy versions at each import ? Is it not enough to check it when installing qutip ?. What do you mean by ""avoiding internal imports"" ? Do you mean to say that we should remove all * imports ? . ```; from qutip.tomography import *; ```",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/580#issuecomment-269518208:281,avoid,avoiding,281,https://qutip.org,https://github.com/qutip/qutip/issues/580#issuecomment-269518208,1,['avoid'],['avoiding']
Safety,"Is there any possibility to make the JAX data layer `_data.isherm` JIT / autograd safe? If not, do we perhaps need a general way for the data layer to allow something like `_data.isherm(..., ensure_jit_safe=True)`? The syntax of my suggestion doesn't look great to me, but you understand the question.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027:82,safe,safe,82,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-2152637027,1,['safe'],['safe']
Safety,Issue with me/mcsolve safety checkes,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/630:22,safe,safety,22,https://qutip.org,https://github.com/qutip/qutip/issues/630,1,['safe'],['safety']
Safety,It aborted at the 12nd loop which consist of 200 sub-loop.; see:; ![fig](https://cloud.githubusercontent.com/assets/16291224/26436825/f53e0a06-414b-11e7-8e71-e9df9fa107f4.PNG),MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/697#issuecomment-303924473:3,abort,aborted,3,https://qutip.org,https://github.com/qutip/qutip/issues/697#issuecomment-303924473,1,['abort'],['aborted']
Safety,"It could be that a pulse is too thin and missed.; When working with pulse, it's safer to always set [max_step](https://qutip.readthedocs.io/en/latest/guide/dynamics/dynamics-time.html#working-with-pulses).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658:80,safe,safer,80,https://qutip.org,https://github.com/qutip/qutip/issues/2552#issuecomment-2455520658,2,['safe'],['safer']
Safety,"It feels more 4.6.3 since it's not a new feature but removing unused code in `__init__`, making qutip's import safer. So it looks more like a bug fix to me. Is there any specific reason to wait for 4.7?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419:111,safe,safer,111,https://qutip.org,https://github.com/qutip/qutip/pull/1758#issuecomment-1015544419,1,['safe'],['safer']
Safety,"It is already in the latest dev version on github. . > On Mar 30, 2016, at 12:13, Lucas Verney notifications@github.com wrote:; > ; > Any news on this? I would personnally find it particularly useful to have cosm and sinm methods on Qobj class. I can submit a PR with it if you want.; > ; > If such methods are not to be added, I think this issue can be safely closed.; > ; > —; > You are receiving this because you were mentioned.; > Reply to this email directly or view it on GitHub; > ; > Untracked with Trackbuster",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/427#issuecomment-203563729:354,safe,safely,354,https://qutip.org,https://github.com/qutip/qutip/issues/427#issuecomment-203563729,1,['safe'],['safely']
Safety,It is not so much the safety checks as the order in which a simple single operator is converted internally to a list vs. when the safety checks are run. This is fixed in #631.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/630#issuecomment-272360048:22,safe,safety,22,https://qutip.org,https://github.com/qutip/qutip/issues/630#issuecomment-272360048,4,['safe'],['safety']
Safety,"It looks to me like the old-style format requires args not have mixed type so [args, 0] actually doesn't work. But I tried to make it safer - on that note I think it seems cleaner to just leave the old-style form only implemented for dictionary inputs. I also changed the function list format to have args in a dictionary format. This way any internal code will always reference args[""_t0""] regardless of the format used.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/206#issuecomment-52397664:134,safe,safer,134,https://qutip.org,https://github.com/qutip/qutip/pull/206#issuecomment-52397664,1,['safe'],['safer']
Safety,"It refers to the system's Liouvillian, I'd say. I think all the `C_n` there are stochastic jumps, `sc_ops `, while the system Liouvillian is the constant part, `c_ops`. But I am not 100% sure. . The user guide is partly out of date there, @Ericgig and others have considerably extended the functionalities of the stochastic solvers. Looking at the [API documentation](http://qutip.org/docs/latest/apidoc/functions.html#module-qutip.stochastic) is safer, and the [source code](http://qutip.org/docs/latest/modules/qutip/stochastic.html) is even more complete. . Meanwhile, you can also have a look at these development notebooks [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-milstein-speed-test.ipynb), [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolve-tests.ipynb), and [here](https://nbviewer.jupyter.org/github/qutip/qutip-notebooks/blob/master/development/development-smesolver-new-methods.ipynb) with regards to the new methods (you can find them all, a bit hidden, at the bottom of the http://qutip.org/tutorials.html list). Technically this issue could be transferred under [`qutip/qutip-doc`](https://github.com/qutip/qutip-doc).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702:447,safe,safer,447,https://qutip.org,https://github.com/qutip/qutip/issues/1163#issuecomment-576462702,2,['safe'],['safer']
Safety,"It seems the entire idea of printing from different threads in python is deeply troublesome. https://stackoverflow.com/questions/3029816/how-do-i-get-a-thread-safe-print-in-python-2-6. My guess is that the appropriate solution is to move all the printing to a single thread and use `Queue`, but I am not quite certain of that. I will see what I can do.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42067292:159,safe,safe-print-in-python-,159,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42067292,1,['safe'],['safe-print-in-python-']
Safety,"It would be good if our naming can help avoid confusion between the concept of a `dtype` (which is the type of elements within an array) and our `data backend type` (which is how the array itself is represented). I'm not sure what a good convention is, but ensuring the docstrings for the backend type have specific examples of valid inputs would definitely help (e.g. `dense` or `csr`).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1420#issuecomment-809209356:40,avoid,avoid,40,https://qutip.org,https://github.com/qutip/qutip/pull/1420#issuecomment-809209356,1,['avoid'],['avoid']
Safety,"It would be nice to avoid a proliferation of settings if we can. Could we perhaps add a casting function to the data layer somewhere? For example:; ```; if oper.isherm and ...:; out = oper.data.cast_to_real(out); ```; where for the JAX backend `cast_to_real` is something like `jax.numpy,real`. This is a little bit awkward if `oper.data` and `state.data` are different dtypes, because there are two possible functions to choose from, but perhaps that's okay?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505:20,avoid,avoid,20,https://qutip.org,https://github.com/qutip/qutip/pull/2329#issuecomment-1953218505,1,['avoid'],['avoid']
Safety,"It would maybe be good to keep everything in one PR that can be squashed into a single commit at the end - this is only a single ""logical"" change at the end of the day. Nice to get these things tidied up. You probably need to run all the tests locally before just pushing to check if everything works; QuTiP has quite a few code generation steps and indirect evaluation that can't be detected with static analysis, which is why you're seeing a lot of test failures (though that's _mostly_ `.pyx` files). Something seems wrong with the static analyser if it's not spotting that `Qobj` is used _everywhere_, though, and I notice in several commits it has a lot of false positives for removal. I can't imagine any situation where a static analyser should remove an in-library import from an `__init__.py` file, but it's done that in a couple of places. Similarly, in `cy/pyxbuilder.py` I can see that it's removed a line `import pyximport`, but I can see that that import _is_ used - it's so close it's even within the minimal diff!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1394#issuecomment-735738116:384,detect,detected,384,https://qutip.org,https://github.com/qutip/qutip/pull/1394#issuecomment-735738116,1,['detect'],['detected']
Safety,"It's not completely contradictory: if you provide an instance of `BaseProgressBar`, it'll work. And the argument is optional. Just that on top of that, you can just say `True` to avoid instanciating yourself the progress object, and this is not documented.; Anyway, I'm just noticing, I don't know the code neither. ;)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/444#issuecomment-190621256:179,avoid,avoid,179,https://qutip.org,https://github.com/qutip/qutip/issues/444#issuecomment-190621256,1,['avoid'],['avoid']
Safety,"Just that we also have '_noise_direct()' which does a bit of linear algebra to avoid using the pseudo-inverse. i think it can be a bit more numerically efficient than mucking around with the inverse itself. Maybe doing the pseudo-inverse tends to involve a big large dense matrix, and this avoids it?. iirc, the logic of noise_direct is, since we write the pseudo-inverse like $R=QL^{-1}Q$, the annoying term we have to evaluate in the noise expression is something like:. $$y = I QL^{-1} Q I \rho. $$. so we substitute, for the last few terms. $$x = L^{-1} QI\rho $$. we multiply from the left by L, to get. $$L x = Q I \rho$$. and we can find x using a scipy's solve or something equivalent, and then find y with. $$y = IQ x$$. In the skewness you have this new term,. $$y =I R R I P I \rho$$. which is a bit clunky to manipulate.; maybe we can write something like. $$x = L^{-1}QIPI \rho$$. and again, multiplying by L. $$Lx = QIPI \rho$$. to get x, then the original expression is now. $$y = IQL^{-1}QQx$$. defining a new variable. $$t = L^{-1}QQx$$. we can again, multiply by L. $$Lt = QQx$$,. solve for t, then we get . $$y= IQ t$$. ? i probably made a mistake, so take with a grain of salt!",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230:79,avoid,avoid,79,https://qutip.org,https://github.com/qutip/qutip/pull/2435#issuecomment-2138882230,2,['avoid'],"['avoid', 'avoids']"
Safety,"Knowing the number of CPUs in the system may help in the future in debugging OpenMP code and setting sensible OpenMP thread counts - we may want to keep that part of the detection. I don't see any need for CPU frequency or memory size, though. That said, we should probably switch to using a library (like [`psutil`](https://github.com/giampaolo/psutil)) if we're going to keep it - it'll be a lot more reliable. For example, I've no idea why the current mac hardware detection in QuTiP ignores the `hw.ncpu` entry in `sysctl`, but the FreeBSD version explicitly uses it...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1395#issuecomment-736675351:170,detect,detection,170,https://qutip.org,https://github.com/qutip/qutip/issues/1395#issuecomment-736675351,2,['detect'],['detection']
Safety,"Looking at the Travis CI, it looks as if the Python 3 renaming of `__builtin__` to `builtins` is confusing the IPython detection in my changes to `qutip.settings`. Do you have any suggestions as to how would be best to handle that?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/248#issuecomment-61394654:119,detect,detection,119,https://qutip.org,https://github.com/qutip/qutip/pull/248#issuecomment-61394654,1,['detect'],['detection']
Safety,"Looks like there were breaking changes introduced in CVXPY 1.1 that changed some sort of matrix handling? I think the entirely of the `dnorm` function was written by Chris Granade about 5 years ago, and they're off at Microsoft now. As an immediate workaround, you can pin the version of CVXPY in conda to 1.0 (`conda install 'cvxpy=1.0'`) to fix it. Otherwise, probably there's a solution in swapping over a load of `*` to `@` in `qutip/semidefinite.py` and `qutip/metrics.py`, but that might be a bit nontrivial to solve. If you succeed, please do make a pull request. The reason that the ""simple"" cases work is that QuTiP detects them as known results and has fast paths avoiding `cvxpy`.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713:625,detect,detects,625,https://qutip.org,https://github.com/qutip/qutip/issues/1422#issuecomment-764772713,4,"['avoid', 'detect']","['avoiding', 'detects']"
Safety,"Looks like you two could have a productive conversation. It'd be good to avoid duplication and make the best use of everyone's time, even for the computer ;). Sorry, I accidentally clicked close...",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1320#issuecomment-657778570:73,avoid,avoid,73,https://qutip.org,https://github.com/qutip/qutip/issues/1320#issuecomment-657778570,1,['avoid'],['avoid']
Safety,Maybe macos needs a slightly longer timeout? It is a bit slow.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140:36,timeout,timeout,36,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1028431140,1,['timeout'],['timeout']
Safety,"Most of scipy's solver are not ""thread-safe"", but we will be able to use other solvers in the new version. We will be sure to add at least one which is thread safe. The `args=new_args` refer to the `args` in `[H0, [H1, f(t, args)]]`, in your case, you could use something like:; ```; def f(t, args):; return args['u'] ; ```; We don't have step interpolation with changing coefficient array. It could be added, but we will have to think about it. Using a mutable, as in your example, would create error with most ODE solver with variable step, so I would not recommend it.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561:39,safe,safe,39,https://qutip.org,https://github.com/qutip/qutip/issues/1571#issuecomment-859791561,2,['safe'],['safe']
Safety,New methods for single stochastic jump operator are implemented:; - 1/2 order predictor-corrector euler-maruyama; - 1 order semi-implicit Milstein; - 3/2 order explicit and semi-implicit Taylor 1.5. Tests for all the new (and old) methods are added. There is a corresponding notebook which shows that the solvers achieve (or exceed) their order of convergence.; https://github.com/qutip/qutip-notebooks/pull/37; Here is the scaling of solver error as a function of stepsize:; ![error_scaling_y_an](https://cloud.githubusercontent.com/assets/4971779/18120795/128dcbe6-6f6a-11e6-8b36-8b16fb73f35a.png). Bug: fast-milstein modifies input noise - fixed. The explicit Taylor 1.5 method and most of the coding is done by **Manuel Grimm** under supervision of **Niels Lörch** at University of Basel.,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/529:78,predict,predictor-corrector,78,https://qutip.org,https://github.com/qutip/qutip/pull/529,1,['predict'],['predictor-corrector']
Safety,"No, `dtype` should always be respected, even for jax.; So the default need to be changed.; One options would be to set `dtype=None` for the default and then if it's `None` and sparse, then use dense. (+ update the docstring and tests.); Another options would be to remove the `dtype` parameter and replace it with `sparse` like `eigenenergies`. But I would like to keep support for both for a while has we should no introduce breaking change outside of major release which won't come anytime soon (detect if the user input a dtype and warn it in that case, but still give him his intended behaviour.)",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388:498,detect,detect,498,https://qutip.org,https://github.com/qutip/qutip/pull/2484#issuecomment-2231753388,1,['detect'],['detect']
Safety,"Not a complete switch-over to `CSR` from `fast_csr_matrix`, but this goes a really long way to achieving that. `Qobj` is done completely, but `QobjEvo` is pretty difficult to disentangle, and that really slowed me down a lot, and I'm not at all sure I've got it right there yet. OpenMP is ignored for now as low-priority. We'll need to get it working before a QuTiP 5.0 release, but I'm not working on it at the moment. `CQobjEvo` has been absolutely stripped bare. All its variants are gone, since the data layer types will handle this instead. `QobjEvo` is basically managed by shim at the moment, and needs a huge tidy up to bring it up to speed with the new data layer, and keep it maintainable. The data layer types have been taught to pickle themselves safely and automatically, and so consequently `QobjEvo` is magically pickle-able (aside from the OpenMP types). This PR includes all the commits from #1296 as well, but it's still a pretty giant PR as it stands right now. The tests won't pass yet, because I haven't finished converting everything.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1328:759,safe,safely,759,https://qutip.org,https://github.com/qutip/qutip/pull/1328,1,['safe'],['safely']
Safety,"Note that we don't use threads but the multiprocessing library, which uses processes. So print not being thread safe is not an issue, but there might be other difficulties.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/121#issuecomment-42090970:112,safe,safe,112,https://qutip.org,https://github.com/qutip/qutip/pull/121#issuecomment-42090970,1,['safe'],['safe']
Safety,"Note: it _did_ cause additional CodeClimate failures. I manually approved the run from within CodeClimate (you can see that in the output of the checks). Unfortunately the duplication checker still errors out on a lot of files, because it seems to choke on complex numbers, so we actually don't get detection on loads of our files (not to mention all our Cython files).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861:299,detect,detection,299,https://qutip.org,https://github.com/qutip/qutip/pull/1577#issuecomment-862377861,1,['detect'],['detection']
Safety,"Note: the reported changes (other than the deletion of the licence from each source file) are all whitespace-only, or simply a reflow of the hard-wrapped text in `LICENSE.txt`. I didn't change the licence at all, other than the holder. I've also checked this with the same tool that GitHub uses, and it will definitely recognise the licence correctly after this. The whitespace-only changes in other files weren't actually 100% intended, but it was a function of how I did the licence detection - I normalised the whitespace at the ends of lines first. Looking through, I guess I only did that when changing the `doc` folder, not the main source code (I had to handle those two cases separately).",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684:485,detect,detection,485,https://qutip.org,https://github.com/qutip/qutip/pull/1579#issuecomment-863997684,2,['detect'],['detection']
Safety,"Notionally fixes #1179, #1185. Converts the `os.system` calls to `subprocess.run` because they're now the recommended way of doing things. I check for existence of the dependencies at import time, and emit a warning (`ImportWarning`) if they don't exist. This is ignored by the typical warning filters, so it won't actually show up for most users. If a dependency doesn't exist, then we don't define the relevant methods on the `QubitCircuit` class to avoid IPython introspecting the class object and thinking that it can make a PNG/SVG. This may not be the best way of doing things, but in this delocalised setting I think it's easier to talk/discuss around a problem with an example in front of us. In particular, I think raising `NotImplementedError` on failing to find `pdflatex` might not be the right call: if it doesn't exist, then the PNG and SVG methods of `QubitCircuit` are currently still created, and then IPython would try to call them and produce an error that isn't the fault of the user. Also, maybe there's a nicer way to make sure that the user sees the ""not found"" warnings the first time that they do something which involves a conversion? At the moment, the class just doesn't get the methods defined.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1194:452,avoid,avoid,452,https://qutip.org,https://github.com/qutip/qutip/pull/1194,1,['avoid'],['avoid']
Safety,"Now in order to avoid a +/- 7000 line diff effecting 148 files, a these commits should be squashed with a rebase.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/221#issuecomment-53838419:16,avoid,avoid,16,https://qutip.org,https://github.com/qutip/qutip/pull/221#issuecomment-53838419,1,['avoid'],['avoid']
Safety,"Numpy 1.20 officially deprecated use of `np.int` and other things like `np.complex`. These were just thin aliases to Python types anyway, so that replacement is safe. Swap `float` and `complex` to `np.float64` and `np.complex128`; these still match Python precision (and standard double-precision floats), but more importantly we assume at all points in Cython code that we're dealing with double-precision arithmetic. Anything else would be a larger problem for us. In cases where `np.int` was used as a type check, we actually care more about checking for Integral typing, rather than specifically the int class; super weird constructs like; ```python; isinstance(np.int64(1), int) == False; ```; so taking indices out of an ndarry may lead to incorrect results when this sort of test is used. Better to use the abstract; ```python; isinstance(..., numbers.Integral); ```. See: https://numpy.org/doc/stable/release/1.20.0-notes.html#using-the-aliases-of-builtin-types-like-np-int-is-deprecated",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1432:161,safe,safe,161,https://qutip.org,https://github.com/qutip/qutip/pull/1432,1,['safe'],['safe']
Safety,"OK, if it's intended then there's nothing to change in the code. But I think it would be helpful to document this in a clearer way: there's a big risk of misinterpreting the operator.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286282270:146,risk,risk,146,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286282270,2,['risk'],['risk']
Safety,"Oh, yes, I increase the sampling rate. Indeed the correct result is recovered. Great thanks",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479:68,recover,recovered,68,https://qutip.org,https://github.com/qutip/qutip/issues/2253#issuecomment-1781240479,1,['recover'],['recovered']
Safety,"Ok, I think I may have some more information. I am fairly sure that this is the same bug as #1120, #963 and #944 (which I believe was not actually ever fixed). I'm going to put the information here. My working theory is currently that this is a MKL bug on Mac. For posterity, let me just dump out some information. ## Things you should know if you've not worked with segfaults before. - `Abort trap 6`, `Segmentation fault` and a few other points can all be from the same cause; - Segmentation faults are typically caused by reading or writing to memory that isn't owned by our process. These often occur by reading/writing too much data to an allocated pointer, or trying to read/write a memory location where the location was read from uninitialised memory.; - Segfaults will not always reliably occur. It's _very_ difficult to prove that swapping tools ""fixes"" a segfault; it can often just move around enough allocations to mask the problem, not fix it.; - Python stack traces are likely to be almost entirely unreliable in these cases, because the segfault may often occur while the garbage collector is running, and that will happen at seemingly non-deterministic times.; - Running files in a slightly different interpreter, running within a test runner with differing numbers of files, doing different work before and after will all cause the segfault to change, and may mask it.; - As annoying as they are, segfaults are actually the _good_ case of the bug - the worst is when we have invalid memory writes but _no_ segfault, because then we have memory corruption that's gone undetected. ## Thoughts about #1120. This issue is still present using Andrew's `Malloc.py` file as of the current master branch (commit 624405e7), and is in QuTiP 4.6.0 and most previous versions. I have been able to reproduce the segfaults with Python 3.7, but not Python 3.8, and I can reproduce it with all allowable values of `PYTHONMALLOC`. The most telling is `pymalloc_debug`, where the entire operation comp",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807:388,Abort,Abort,388,https://qutip.org,https://github.com/qutip/qutip/issues/1160#issuecomment-826124807,1,['Abort'],['Abort']
Safety,"Ok, yeah, I definitely see the use-case here. I'll leave it removed from `matmul` for the time being because I hadn't really organised that code to allow safe calling of the function with an `out` parameter, but I'll look to re-instate it, similarly with `add`. For `add`: I envisage a nice possibility for `QobjEvo` using `CSR` backing along the vein of `CQobjEvoTdMatched`: on instantiation we add together all the matrices, then we `memset` all zeroes along the `data` array and store it as `self._structure`. Then each time we `__call__` the object, we simply do `out = self._structure.copy()`, and use that as the output matrix, because we guarantee we'll always have enough space and the correct structure. There's a couple of minor kinks in the logic of `add_csr` that we might have to iron out in order to avoid an additional matrix addition, but the savings in memory allocation could be good. You're absolutely right about the `pxd` files - I haven't taken enough care to make sure they've got all the definitions in yet. Basically everything that isn't prefixed with an underscore in the `.pyx` files _should_ be in the `.pxd` files. I'll add them in tomorrow.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1296#issuecomment-648371869:154,safe,safe,154,https://qutip.org,https://github.com/qutip/qutip/pull/1296#issuecomment-648371869,4,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"On my Mac (Mojave 10.14.5) the latest development version of qutip tests can fail at different points. . First, I run into an abort trap at ptrace. . Then, upon another run, I bumped into this other abort trap error ; ```; tests/test_superop_reps.py::TestSuperopReps::test_ChoiKrausChoi Fatal Python error: Aborted. Current thread 0x000000010b9155c0 (most recent call first):; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/superop_reps.py"", line 547 in to_kraus; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/qutip-4.5.0.dev0+d13f5435-py3.7-macosx-10.9-x86_64.egg/qutip/tests/test_superop_reps.py"", line 106 in test_ChoiKrausChoi; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 166 in pytest_pyfunc_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/python.py"", line 1435 in runtest; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 131 in pytest_runtest_call; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/callers.py"", line 187 in _multicall; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 87 in <lambda>; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/manager.py"", line 93 in _hookexec; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/pluggy/hooks.py"", line 286 in __call__; File ""/miniconda3/envs/qutipdev45/lib/python3.7/site-packages/_pytest/runner.py"", line 207 in <lambda>; File ""/min",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1160:126,abort,abort,126,https://qutip.org,https://github.com/qutip/qutip/issues/1160,3,"['Abort', 'abort']","['Aborted', 'abort']"
Safety,On the other hand I'm not completely against just having this as a safety net for wonky tests anyway.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098:67,safe,safety,67,https://qutip.org,https://github.com/qutip/qutip/pull/1787#issuecomment-1023383098,1,['safe'],['safety']
Safety,Optimization flags in setup.py should be completely avoided,MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/920:52,avoid,avoided,52,https://qutip.org,https://github.com/qutip/qutip/issues/920,1,['avoid'],['avoided']
Safety,"Perhaps an example will help:. Say that I want to squeeze the vacuum with z=1. What I should do is compute the vector S(z)|0> for z=1. What I would expect is that the amplitudes of the result shouldn't depend on whether I decide to truncate at dimension 10 or 20 or 30, but with the current implementation of `qutip.squeeze` it does:; ```python; (qt.squeeze(5,1)*qt.basis(5,0)); ```; tells me that (for instance) the 5-photon state has amplitude 0.453, while according to ; ```python; (qt.squeeze(10,1)*qt.basis(10,0)); ```; the same state has amplitude 0.310. This is a physically relevant difference, so how do I answer the question: what's the probability of detecting n photons in the S(z)-squeezed vacuum? With the current implementation of `qutip.squeeze` I cannot. Do you see the problem?",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/661#issuecomment-286262389:662,detect,detecting,662,https://qutip.org,https://github.com/qutip/qutip/issues/661#issuecomment-286262389,1,['detect'],['detecting']
Safety,"Photocurrent did not handle having 2 or more collapses in the same time step properly and the state became unnormalized in those case. This PR limit the number of collapse to 1 per time step.; It does it in a rough way and still have an avoidable `O(dt**2)` error, but it does not force to throw away the trajectory.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1010:237,avoid,avoidable,237,https://qutip.org,https://github.com/qutip/qutip/pull/1010,1,['avoid'],['avoidable']
Safety,Please consider changing your unit to avoid small terms like `e-6` and `hbar`. QuTiP uses sparse matrix and removes very small (~<e-7) matrix entries. Possible improvement was discussed in https://github.com/qutip/qutip/issues/1349.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1402#issuecomment-739775446:38,avoid,avoid,38,https://qutip.org,https://github.com/qutip/qutip/issues/1402#issuecomment-739775446,1,['avoid'],['avoid']
Safety,"Please merge with master and resolve conflicts and push the updates. In general, to avoid conflicts, you should do 'git pull upsteam master' into your master before creating a new branch.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/294#issuecomment-67649107:84,avoid,avoid,84,https://qutip.org,https://github.com/qutip/qutip/pull/294#issuecomment-67649107,1,['avoid'],['avoid']
Safety,Please rebase this against the current master @IIAOPSW . There are some changes in the travis.yml file put in by @ajgpitch which selectively avoids some py2.7 tests. There were many new additions to tackle some Python 2 issues too.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/883#issuecomment-398000185:141,avoid,avoids,141,https://qutip.org,https://github.com/qutip/qutip/pull/883#issuecomment-398000185,1,['avoid'],['avoids']
Safety,"Probably the safest solution for us right now is to completely elide this run-time check, and have `setup.py` hard-code the value of `settings.has_openmp` at compile time. Does that sound reasonable to you (since you wrote most of the original OpenMP stuff [and most of the current QuTiP code...])? Also checking with @Ericgig, since I know you're a heavy user of it too. Edit: I forgot, I actually already fixed the possibility of this happening in `dev.major` - it uses a much more rigorous `importlib` import to ensure that we're attempting the OpenMP bit with the natural import system, and so it doesn't conflict with relative imports elsewhere in `qutip`:. https://github.com/qutip/qutip/blob/3f5c2980cff42067c0f93b226d3f07be9ef9022a/qutip/__init__.py#L107-L117",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1334#issuecomment-670170527:13,safe,safest,13,https://qutip.org,https://github.com/qutip/qutip/issues/1334#issuecomment-670170527,1,['safe'],['safest']
Safety,"Qobj.expm() is currently not working properly for diagonal states which have a zero in the diagonal (these zeros don't become ones). An example:. ``` python; >>> foo = qutip.Qobj([[1.,0.],[0.,0.]]); >>> foo.expm(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 0. ]]; ```. While the correct result should have been (notice the element in second row, second column):. ``` python; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 2.71828183 0. ]; [ 0. 1. ]]; ```. On analysing the source code I found the the function `sp_expm` in `sparse.py` is responsible for this computation. The particular code is reproduced below:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A.data = np.exp(A.data); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. Since `A.data` is stored in sparse matrix format, only non-zero elements are exponentiated. A way to avoid this problem would be to either completely remove the case of optimizing for diagonal states or modifying the appropriate code as:. ``` python; def sp_expm(A, sparse=False):; """"""; Sparse matrix exponential. ; """"""; if _isdiag(A.indices, A.indptr, A.shape[0]):; A = sp.diags(np.exp(A.diagonal()),format='csr'); return A; if sparse:; E = spla.expm(A.tocsc()); else:; E = spla.expm(A.toarray()); return sp.csr_matrix(E); ```. I am running qutip 3.2.0.dev-cb698ef; Python 3.5.1, numpy 1.10.4, scipy 0.17.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/493:1104,avoid,avoid,1104,https://qutip.org,https://github.com/qutip/qutip/issues/493,1,['avoid'],['avoid']
Safety,"QuTiP currently uses QCircuit 2 (version of 2011) to generate LaTeX circuits that are printed to screen or saved to file. A newer version of QCircuit is available, 2.6.0 (2018) https://www.ctan.org/pkg/qcircuit. * `qcircuit` could be updated to the latest version . * Also, the use of this open source package could be highlighted more evidently in the documentation. * Another package has been recently released, https://arxiv.org/abs/1809.03842, Quantikz, which has some features related to noise that could be useful especially with regard to PR #1065, Google Summer of Code project by @BoxiLi on noise modeling in QIP. As this other package is very young, maybe an option to draw the circuit with this package, instead of qcircuit, could be given, also to avoid issues.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1096:760,avoid,avoid,760,https://qutip.org,https://github.com/qutip/qutip/issues/1096,1,['avoid'],['avoid']
Safety,"QuTiP is currently incompatible with numpy 1.20. Tests will fail to even collect with an error such as; ```; AttributeError: 'numpy.ndarray' object has no attribute 'dag'; ```; and a lot of functionality will break - anything that requires `Qobj.eigenstates()` for example. This is because `Qobj` defines `__array__`, one of numpy's ""array interface"" functions, intended for classes that can be safely converted _implicitly_ into an `ndarray`. This isn't really the case for `Qobj` - it loses all sorts of information when you do that, which is why we've maintained the separate `Qobj.full()` for explicitly getting the dense matrix representation of a `Qobj`. This is not to mention that numpy ufuncs probably should not be able to implicitly convert `Qobj` - I'd strongly argue that `np.sin(qutip.basis(2, 1))` should be `TypeError`, _not_ `array([[0. +0.j], [0.84147098+0.j]])` (like it is right now). We actually already removed this ""functionality"" in `dev.major`. The most pressing incompatibility is that a few points in QuTiP put a few `Qobj` into a `np.array(dtype=object)`. In numpy 1.20, this no longer produces a 1D array of `Qobj`, but a 3D array of complex. This breaks `Qobj.eigenstates`, and prevents test collection due to it being present in `states.py::qutrit_basis()`, which is called during parametrisation. There are a two possible ways to solve this, and we ought to release a fix with one of them in a patch ASAP:; 1. remove `Qobj.__array__`; 2. remove all use of `Qobj` in `np.array`. I'm personally in favour of ""explicit is better than implicit"" in this case, i.e. removing `Qobj.__array__` and relying on `Qobj.full()`. As another example along this vein, note `scipy.sparse` matrices don't implement this either, and they're arguably closer to being safely coerced to `ndarray` than we are. ### Related issues. #938: feature request for implementing `__array__`. This only asks for `np.array(qobj)` as a convenience, acknowledging the availability of `Qobj.full()`.; #1017",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1433:395,safe,safely,395,https://qutip.org,https://github.com/qutip/qutip/issues/1433,1,['safe'],['safely']
Safety,"QuTiP is hosted on Anaconda's conda-forge channel and on PyPI. I would like to showcase downloads on the [website](https://github.com/qutip/qutip.github.io) and possibly have a development notebook (or in a personal repository) showing them updated, for QuTiP presentations. . * **conda install qutip**: For conda-forge, it is possible to use the `anaconda-package-data` with `dask` and `intake`, ; https://github.com/ContinuumIO/anaconda-package-data. * **pip install qutip**: For PyPI, it is possible to use, `pypinfo` ; https://github.com/ofek/pypinfo; Note that with`pypinfo` Google's Big Data queries are not free, but new accounts come with some budget credited. Some data: . *`pip install qutip` data starts in 2016. In 2018, 8000 downloads are reported. For 2019, well over 10,000 downloads are predicted. *`conda install qutip` data starts in March 2017. For 2018, 30,000 downloads have been performed. This data is useful to gauge the effective popularity of the two package managers and distribution platforms and can help in setting priorities for relative support and bug fixing. . ## Anaconda downloads; <img width=""441"" alt=""qutip-conda-forge-downloads"" src=""https://user-images.githubusercontent.com/14573436/57989417-45d94380-7ad5-11e9-9694-623fec86865b.png"">. ## PyPI downloads; ![pip-install-qutip-png](https://user-images.githubusercontent.com/14573436/57979590-df174400-7a5a-11e9-807e-c2f46bbb830e.png). With `pypinfo` we can also easily extract other information on users' machines details, such as python usage, which can provide guidance on aspects: . ### Python version; #### 2018; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 3.6 | 47.33% | 4,079 |; | 2.7 | 24.25% | 2,090 |; | 3.7 | 13.97% | 1,204 |; | 3.5 | 12.43% | 1,071 |; | 3.4 | 1.94% | 167 |; | 2.6 | 0.09% | 8 |; | Total | | 8,619 |. #### 2017; | python_version | percent | download_count |; | -------------- | ------: | -------------: |; | 2.7 | 51.55% | 4,333 |; ",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/997:803,predict,predicted,803,https://qutip.org,https://github.com/qutip/qutip/issues/997,1,['predict'],['predicted']
Safety,"Redundant to #1768, we will keep that one for those 2 files.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642:0,Redund,Redundant,0,https://qutip.org,https://github.com/qutip/qutip/pull/1769#issuecomment-1015730642,1,['Redund'],['Redundant']
Safety,"Repeating just changes the probability of failure, rather than actually detecting whether it was a rare fail, and `mesolve` tests aren't always the fastest, so repetition here isn't great. For simple unitary qubit operations, I think it should be easy enough to work out how the tolerance translates. It's difficult to say that if there's a numerical error then the error will be much greater - I caught some errors in the `test_gates.py` (I think) that were sneaking through because the tolerances were set too high. It's probably best to keep as tight a tolerance as is reasonable - here I think `2 * qutip.Options.rtol` would always be correct if the numerics are.",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1249#issuecomment-625344751:72,detect,detecting,72,https://qutip.org,https://github.com/qutip/qutip/pull/1249#issuecomment-625344751,2,['detect'],['detecting']
Safety,"Required due to changes in scipy 1.6.1. Using an explicit dtype will make matrix construction more robust. Fixes qutip Issue #1451. Tested on Debian unstable, with this patch tests/test_sparse.py now passes with scipy 1.6.1. **Description**. scipy 1.6.1 changed the API for constructing sparse matrices with `scipy.sparse.csr_matrix` (affecting the COO format). This caused qutip TestDicke tests in test_piqs.py (test_lindbladian, test_lindbladian_dims, test_liouvillian) to fail. . This patch avoids the problem by setting the dtype explicitly to np,complex128. . **Related issues or PRs**. fixes #1451. **Changelog**; Provide explicit dtype=np.complex128 when constructing sparse matrixes with csr_matrix. Required for working with scipy 1.6.1.",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1452:494,avoid,avoids,494,https://qutip.org,https://github.com/qutip/qutip/pull/1452,1,['avoid'],['avoids']
Safety,"Revert ""Fix redundancy and sign error in jmat.""",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/567:12,redund,redundancy,12,https://qutip.org,https://github.com/qutip/qutip/pull/567,1,['redund'],['redundancy']
Safety,"Scipy 1.5 changed the methods of performing the matrix multiplication to; avoid copying the `indptr` matrix multiple times. This is actually not an; issue at all for us, because we only allow int32 indices (so if the; indices were to upcast, we just throw and exception), but the underlying; private Cython call structure also changed, and our `fast_csr_matrix` was; a direct clone. We add try/catch blocks to switch on the correct types (the overhead; from a failed lookup is trivial compared to the matrix multiplication; time), because we have to support more than just the most recent version; of scipy. We could look up the version of scipy installed, but the; ""try it and see"" approach is more typical Python. This problem should be eliminated by the move to the new data types, as; we will stop relying on private scipy code. See: commit scipy/scipy@53fac7a",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/1298:74,avoid,avoid,74,https://qutip.org,https://github.com/qutip/qutip/pull/1298,1,['avoid'],['avoid']
Safety,Seems like a good fix. Can't see any risks.,MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/375#issuecomment-142891700:37,risk,risks,37,https://qutip.org,https://github.com/qutip/qutip/pull/375#issuecomment-142891700,1,['risk'],['risks']
Safety,"Setting up the testing environment with `conda` avoids the segfault, but hangs indefinitely while running the tests. I'm using the following `run_tests_conda.sh`:; ~~~; #!/usr/bin/env bash; conda create -y -p venv python=3.8 'cython>=0.21' 'numpy>=1.12' 'scipy>=1.0' matplotlib ipython pytest; ./venv/bin/python setup.py install; ./venv/bin/pip freeze > test.log; ./venv/bin/python -c 'import scipy; print(""Scipy config:""); scipy.__config__.show()' >> test.log; ./venv/bin/python -c 'import numpy; print(""Numpy config:""); numpy.__config__.show()' >> test.log; (cd venv && ./bin/python -c 'from qutip.testing import run; run()' 2>&1 | tee -a ../test.log); ~~~. This produces the attached [`test.log`](https://github.com/qutip/qutip/files/4307943/test.log): testing hangs at `test_mcsolve.py::test_MCTDFunc`",MatchSource.ISSUE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939:48,avoid,avoids,48,https://qutip.org,https://github.com/qutip/qutip/issues/1197#issuecomment-596652939,1,['avoid'],['avoids']
Safety,"Since NumPy 1.12, `np.linspace` raises a DeprecationWarning when its third `num` parameter cannot be safely interpreted as an integer. This method is used in the `mesolve` tests. Fixed by feeding the calls to `linspace` 100 instead of 100.0. The warning (in Travis CI):; ; ![image](https://user-images.githubusercontent.com/220701/27771317-c325fe9c-5f4c-11e7-8d4b-66980255dcfd.png). The deprecation: https://github.com/numpy/numpy/releases/tag/v1.12.0",MatchSource.ISSUE,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/pull/708:101,safe,safely,101,https://qutip.org,https://github.com/qutip/qutip/pull/708,1,['safe'],['safely']
