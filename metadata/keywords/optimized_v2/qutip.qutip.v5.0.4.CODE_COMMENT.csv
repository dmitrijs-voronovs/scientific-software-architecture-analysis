quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to st",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1407,toler,tolerance,1407,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['toler'],['tolerance']
Availability," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3690,toler,tolerance,3690,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['toler'],['tolerance']
Availability," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3733,toler,tolerance,3733,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['toler'],['tolerance']
Availability," None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (they can be mixed) or; a single operator or callable function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lengh",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2925,error,errors,2925,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['error'],['errors']
Availability," Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4836,toler,tolerance,4836,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['toler'],['tolerance']
Availability," ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. args : dict, optional {None}; Change the ``args`` of the RHS for the evolution. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (they can be mixed) or; a single operator or callable function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1763,avail,available,1763,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['avail'],['available']
Availability," also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2054,error,errors,2054,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['error'],['errors']
Availability," format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Retur",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3153,error,error,3153,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['error'],['error']
Availability," is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2662,error,errors,2662,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['errors']
Availability," will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.opt",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3357,avail,available,3357,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['avail'],['available']
Availability,""""""" Return true if Q1 and Q2 are equal to within the given tolerance. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:59,toler,tolerance,59,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['toler'],['tolerance']
Availability,""""""" measure_observable: check input errors """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:36,error,errors,36,qutip/tests/test_measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py,1,['error'],['errors']
Availability,""""""" measure_povm: check input errors """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:30,error,errors,30,qutip/tests/test_measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py,1,['error'],['errors']
Availability,""""""" measurement_statistics_observable: check input errors """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:51,error,errors,51,qutip/tests/test_measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py,1,['error'],['errors']
Availability,""""""" measurement_statistics_povm: check input errors """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:45,error,errors,45,qutip/tests/test_measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py,1,['error'],['errors']
Availability,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:854,error,error,854,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['error'],['error']
Availability,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:1099,toler,tolerance,1099,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,2,['toler'],['tolerance']
Availability,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:791,toler,tolerance,791,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,4,['toler'],['tolerance']
Availability,"""""""; Add a trajectory to the evolution. Trajectories can be saved or average canbe extracted depending on the; options ``keep_runs_results``. Parameters; ----------; trajectory_info : tuple of seed and trajectory; - seed: int, SeedSequence; Seed used to generate the trajectory.; - trajectory : :class:`Result`; Run result for one evolution over the times. Returns; -------; remaing_traj : number; Return the number of trajectories still needed to reach the target; tolerance. If no tolerance is provided, return infinity.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:466,toler,tolerance,466,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,2,['toler'],['tolerance']
Availability,"""""""; Applies a channel to every subsystem indicated by a mask, by; repeatedly applying the channel to each affected subsystem.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:57,mask,mask,57,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['mask'],['mask']
Availability,"""""""; Check that the error is proportional to `dt`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_stochastic_system.py:20,error,error,20,qutip/tests/solver/test_stochastic_system.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_stochastic_system.py,1,['error'],['error']
Availability,"""""""; Common functionality for parallel_map, loky_pmap and mpi_pmap.; The parameters `setup_executor`, `extract_result` and `shutdown_executor`; are callback functions with the following signatures:. setup_executor: () -> ProcessPoolExecutor. extract_result: Future -> (Any, BaseException); If there was an exception e, returns (None, e).; Otherwise returns (result, None). shutdown_executor: (executor: ProcessPoolExecutor,; active_tasks: set[Future]) -> None; executor: The ProcessPoolExecutor that was created in setup_executor; active_tasks: A set of Futures that are currently still being executed; (non-empty if: timeout, error, or reduce_func requesting exit); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:627,error,error,627,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['error'],['error']
Availability,"""""""; Compute the error on the expectation values using jackknife resampling.; Return the approximate number of trajectories needed to have this; error within the tolerance fot all e_ops and times.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:17,error,error,17,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,3,"['error', 'toler']","['error', 'tolerance']"
Availability,"""""""; Compute the maximum step length to stay under the desired tolerance.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:63,toler,tolerance,63,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['toler'],['tolerance']
Availability,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:671,reliab,reliability,671,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['reliab'],['reliability']
Availability,"""""""; Convert the underlying data store of this `Qobj` into a different; storage representation. The different storage representations available are the ""data-layer; types"" which are known to :obj:`qutip.core.data.to`. By default, these; are :class:`~qutip.core.data.CSR`, :class:`~qutip.core.data.Dense` and; :class:`~qutip.core.data.Dia`, which respectively construct a; compressed sparse row matrix, diagonal matrix and a dense one. Certain; algorithms and operations may be faster or more accurate when using a; more appropriate data store. Parameters; ----------; data_type : type, str; The data-layer type or its string alias that the data of this; :class:`Qobj` should be converted to. copy : Bool; If the data store is already in the format requested, whether the; function should return returns `self` or a copy. Returns; -------; Qobj; A :class:`Qobj` with the data stored in the requested format.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:134,avail,available,134,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['avail'],['available']
Availability,"""""""; Expand time-evolution using the Transfer Tensor Method [1]_, based on a set; of precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`.Qobj`, callable; List of precomputed dynamical maps (superoperators) for the first times; of ``times`` or a callback function that returns the superoperator at a; given time. state0 : :class:`.Qobj`; Initial density matrix or state vector (ket). times : array_like; List of times :math:`t_n` at which to compute results.; Must be uniformily spaced. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. num_learning : int, default: 0; Number of times used to construct the dynmaps operators when; ``dynmaps`` is a callable. options : dictionary, optional; Dictionary of options for the solver. - store_final_state : bool; Whether or not to store the final state of the evolution in the; result class.; - store_states : bool, None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - normalize_output : bool; Normalize output state to hide ODE numerical errors.; - threshold : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. Returns; -------; output: :class:`.Result`; An instance of the class :class:`.Result`. .. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nonmarkov/transfertensor.py:1336,error,errors,1336,qutip/solver/nonmarkov/transfertensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nonmarkov/transfertensor.py,1,['error'],['errors']
Availability,"""""""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:62,avail,available,62,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['avail'],['available']
Availability,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:506,toler,tolerance,506,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['toler'],['tolerance']
Availability,"""""""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:907,toler,tolerance,907,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['toler'],['tolerance']
Availability,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:409,error,errors,409,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['error'],"['error', 'errors']"
Availability,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:420,error,errors,420,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,2,['error'],"['error', 'errors']"
Availability,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:498,error,error,498,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['error'],['error']
Availability,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:512,error,error,512,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['error'],['error']
Availability,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:700,error,error,700,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,3,"['avail', 'error']","['available', 'error', 'errors']"
Availability,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:51,toler,tolerance,51,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,4,['toler'],['tolerance']
Availability,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1330,error,error,1330,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['error'],['error']
Availability,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1378,error,error,1378,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['error'],['error']
Availability,"""""""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:. - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10"") # doctest: +SKIP; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") # doctest: +SKIP; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:412,down,down,412,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['down'],['down']
Availability,"""""""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int or list of ints, default: 2; Space dimension for each particle:; int if there are the same, list if they are different. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10"") # doctest: +SKIP; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:412,down,down,412,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['down'],['down']
Availability,"""""""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:684,avail,available,684,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['avail'],['available']
Availability,"""""""; Read user provided seed(s) and produce one for each trajectory.; Let numpy raise error for inputs that cannot be seeds.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:86,error,error,86,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,1,['error'],['error']
Availability,"""""""; Regression test for gh-1350, comparing explicitly stored values in the; matrix (but below the tolerance for allowable Hermicity) to implicit; zeros.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:99,toler,tolerance,99,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['toler'],['tolerance']
Availability,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:105,toler,tolerance,105,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,3,['toler'],['tolerance']
Availability,"""""""; Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`.Qobj`; Quantum object with small elements removed.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:100,toler,tolerance,100,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['toler'],['tolerance']
Availability,"""""""; Represents a list of bath expansion exponents. Parameters; ----------; exponents : list of BathExponent; The exponents of the correlation function describing the bath. Attributes; ----------. All of the parameters are available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:223,avail,available,223,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['avail'],['available']
Availability,"""""""; Return eigenvalues and eigenvectors for a CSR matrix. This specialisation; may take some extra keyword arguments in addition to the full documentation; specified in :func:`.eigs`. This method is typically slower and less accurate than the dense eigenvalue; solver; you probably want that, unless memory concerns deem it impossible. Extra keyword arguments; -----------------------; tol : float (0); Tolerance for sparse eigensolver. Sufficiently small tolerances (such; as 0) cause the solver to use machine precision.; maxiter : int (100_000); Max number of iterations used by sparse eigensolver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/eigen.py:457,toler,tolerances,457,qutip/core/data/eigen.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/eigen.py,1,['toler'],['tolerances']
Availability,"""""""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`.Qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str {""dense"", ""sparse""}, default: ""dense""; Choice of method. The ""sparse"" implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`.Qobj`; A density matrix with the selected subsystems transposed. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:68,mask,mask,68,qutip/partial_transpose.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py,5,['mask'],['mask']
Availability,"""""""; Returns the result of applying the propagator `channel` to the; subsystems indicated in `mask`, which comprise the density operator; `state`. Parameters; ----------; state : :class:`.Qobj`; A density matrix or ket. channel : :class:`.Qobj`; A propagator, either an `oper` or `super`. mask : *list* / *array*; A mask that selects which subsystems should be subjected to the; channel. reference : bool; Decides whether explicit Kraus map should be used to evaluate action; of channel. Returns; -------; rho_out: :class:`.Qobj`; A density matrix with the selected subsystems transformed; according to the specified channel.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:94,mask,mask,94,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,3,['mask'],['mask']
Availability,"""""""; Runs final states if available, average otherwise.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:26,avail,available,26,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,2,['avail'],['available']
Availability,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1302,error,error,1302,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['error'],['error']
Availability,"""""""; Set the condition to stop the computing trajectories when the certain; condition are fullfilled.; Supported end condition for multi trajectories computation are:. - Reaching a number of trajectories.; - Error bar on the expectation values reach smaller than a given; tolerance. Parameters; ----------; ntraj : int; Number of trajectories expected. target_tol : float, array_like, [optional]; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance, a pair of; absolute and relative tolerance, in that order. Lastly, it can be a; list of pairs of (atol, rtol) for each e_ops. Error estimation is done with jackknife resampling.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:272,toler,tolerance,272,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,7,"['error', 'toler']","['error', 'tolerance']"
Availability,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1271,error,errors,1271,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['error'],['errors']
Availability,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:402,error,errors,402,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,2,['error'],"['error', 'errors']"
Availability,"""""""; Supported options by Order 1.5 strong Taylor Stochastic Integrators:. dt : float, default: 0.001; Internal time step. tol : float, default: 1e-10; Relative tolerance. derr_dt : float, default: 1e-6; Finite time difference used to compute the derrivative of the; hamiltonian and ``sc_ops``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:161,toler,tolerance,161,qutip/solver/sode/itotaylor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py,1,['toler'],['tolerance']
Availability,"""""""; Supported options by Rouchon Stochastic Integrators:. dt : float, default: 0.001; Internal time step. tol : float, default: 1e-7; Relative tolerance.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:144,toler,tolerance,144,qutip/solver/sode/rouchon.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py,1,['toler'],['tolerance']
Availability,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:84,toler,tolerance,84,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['toler'],['tolerance']
Availability,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:80,toler,tolerance,80,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['toler'],['tolerance']
Availability,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:83,toler,tolerance,83,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['toler'],['tolerance']
Availability,"""""""; Supported options by verner method:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 1000; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. interpolate : bool, default: True; Whether to use interpolation step, faster most of the time.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:80,toler,tolerance,80,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,2,['toler'],['tolerance']
Availability,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:83,toler,tolerance,83,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['toler'],['tolerance']
Availability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:53,error,error,53,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['error'],['error']
Availability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:53,error,error,53,qutip/tests/core/data/test_dense.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py,1,['error'],['error']
Availability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:53,error,error,53,qutip/tests/core/data/test_dia.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py,1,['error'],['error']
Availability,"""""""; Test that the operation produces a suitable error if the shape is not a; square matrix.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,error,error,49,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['error'],['error']
Availability,"""""""; Test that the operation produces a suitable error if the shape of the; given operand is not compatible with the operation. Useful for; operations that require square matrices (trace, pow, ...).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,error,error,49,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['error'],['error']
Availability,"""""""; Test that the operation produces a suitable error if the shape of the; operand is not square.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_ptrace.py:49,error,error,49,qutip/tests/core/data/test_ptrace.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_ptrace.py,1,['error'],['error']
Availability,"""""""; Test that the operation produces a suitable error if the shapes of the; given operands are not compatible.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:49,error,error,49,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,2,['error'],['error']
Availability,"""""""; Whether `eigh` call is reliable.; Some implementation of blas have some issues on some OS.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:28,reliab,reliable,28,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['reliab'],['reliable']
Availability,"""""""; force_omp = False; if qset.has_openmp:; if options.use_openmp is None:; options.use_openmp = True; else:; force_omp = bool(options.use_openmp); elif (not qset.has_openmp) and options.use_openmp:; raise Exception('OPENMP not available.'); else:; options.use_openmp = False; force_omp = False; # Disable OPENMP in parallel mode unless explicitly set.; if not force_omp and os.environ['QUTIP_IN_PARALLEL'] == 'TRUE':; options.use_openmp = False""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/utilities.py:229,avail,available,229,qutip/core/cy/openmp/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/utilities.py,1,['avail'],['available']
Availability,"""""""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:436,toler,tolerance,436,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['toler'],['tolerance']
Availability,"""""""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:449,toler,tolerance,449,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['toler'],['tolerance']
Availability,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:139,toler,tolerance,139,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,2,['toler'],['tolerance']
Availability,"""""""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists or a dimension object,; flattens it down to a list of the scalars within the original list. Parameters; ----------; l : scalar, list, Space, Dimension; Object to flatten. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. Notes; -----; Any scalar will be returned wrapped in a list: ``flaten(1) == [1]``.; A non-list iterable will not be treated as a list by flatten. For example, flatten would treat a tuple; as a scalar.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:135,down,down,135,qutip/core/dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py,1,['down'],['down']
Availability,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:279,toler,tolerance,279,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['toler'],['tolerance']
Availability,"""""""get funtion 'convert_{}_to_{}' when available for coverage """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_utilities.py:39,avail,available,39,qutip/tests/test_utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_utilities.py,1,['avail'],['available']
Availability,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1014,error,errors,1014,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['error'],['errors']
Availability,"# @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:57,avail,available,57,qutip/tests/test_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py,2,['avail'],['available']
Availability,"# Accept 5% error.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py:12,error,error,12,qutip/tests/solver/test_brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py,2,['error'],['error']
Availability,"# Allow an average absolute tolerance for each eigenvalue; we expect; # uncertainty in the sum to add in quadrature.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigen.py:28,toler,tolerance,28,qutip/tests/core/test_eigen.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigen.py,1,['toler'],['tolerance']
Availability,"# Big tolerance because we actually want to test the inverse.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:6,toler,tolerance,6,qutip/tests/core/test_gates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py,1,['toler'],['tolerance']
Availability,"# CalledProcessError is for if the git command fails for internal; # reasons (e.g. we're not in a git repository), OSError is for if; # something goes wrong when trying to run git (e.g. it's not installed,; # or a permission error).",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:225,error,error,225,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['error'],['error']
Availability,"# Catch possible edge case where it shouldn't be Hermitian, but faulty; # loop logic doesn't fully compare all rows.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:64,fault,faulty,64,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['fault'],['faulty']
Availability,"# Compare to B first, so that an error is raised; # as soon as possible.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:33,error,error,33,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['error'],['error']
Availability,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:141,toler,tolerance,141,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['toler'],['tolerance']
Availability,"# Everything should be explicitly imported, not made available by default.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:53,avail,available,53,qutip/core/dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py,1,['avail'],['available']
Availability,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:113,error,error,113,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['error'],['error']
Availability,"# Find the weight, no good dispatched function available...",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:47,avail,available,47,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['avail'],['available']
Availability,"# For 1D subspaces, the special cases don't really matter since there's; # only really one type of matrix available, so this is parametrised; # with only case for each input argument.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:106,avail,available,106,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['avail'],['available']
Availability,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:207,down,down,207,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['down'],['down']
Availability,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:260,toler,tolerance,260,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['toler'],['tolerance']
Availability,"# If the system is huge, don't attempt to convert to a dense matrix; # and then to string, because it is pointless and is likely going; # to produce memory errors. Instead print the sparse data string; # representation.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:156,error,errors,156,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['error'],['errors']
Availability,"# In development (at least for QuTiP ~4.5 and ~5.0) sometimes the; # Cythonised time-dependent coefficients would get dropped in the; # qutip directory if you weren't careful - this is just trying to; # minimise the occasional developer error.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:237,error,error,237,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['error'],['error']
Availability,"# It's not enough to be accurate within a tolerance here - there's no; # mathematics, so they should be _identical_.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:42,toler,tolerance,42,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,3,['toler'],['tolerance']
Availability,"# Massively relax the tolerance for the Monte-Carlo approach to avoid a; # long simulation time.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:22,toler,tolerance,22,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['toler'],['tolerance']
Availability,"# Previously compiled coefficient not available: create the cython code",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:38,avail,available,38,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['avail'],['available']
Availability,"# Set error messages",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:6,error,error,6,qutip/_mkl/spsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py,1,['error'],['error']
Availability,"# Set up the data conversions that are known by us. All types covered by; # conversions will be made available for use in the dispatcher functions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/__init__.py:101,avail,available,101,qutip/core/data/__init__.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/__init__.py,1,['avail'],['available']
Availability,"# TODO: krylov_dim, max_step and error (atol) are related by; # err ~= exp(-krylov_dim / dt**(1~2)); # We could ask for 2 and determine the third one.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:33,error,error,33,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['error'],['error']
Availability,"# The first error term of the method is dt**0.5 greater than the solver; # order.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sode_method.py:12,error,error,12,qutip/tests/solver/test_sode_method.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sode_method.py,1,['error'],['error']
Availability,"# Theme options are theme-specific and customize the look and feel of a theme; # further. For a list of options available for each theme, see the; # documentation.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:112,avail,available,112,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['avail'],['available']
Availability,"# This happen when the collapse is caused by numerical error",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:55,error,error,55,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['error'],['error']
Availability,"# This tol should be less strick than the tol for the eigensolver; # so it's numerical errors are not seens as degenerate states.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:87,error,errors,87,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['error'],['errors']
Availability,"# We use U * S since S is 1-index, such that this is equivalent to; # U . diag(S), but easier to write down.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:103,down,down,103,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,1,['down'],['down']
Availability,"# all available QobjEvo types",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:6,avail,available,6,qutip/tests/core/test_qobjevo.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py,1,['avail'],['available']
Availability,"# all tasks have been submitted, timeout has not been reaches; # -> wait for all workers to finish before shutting down",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:115,down,down,115,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['down'],['down']
Availability,"# check error",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:8,error,error,8,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,2,['error'],['error']
Availability,"# checked affected subsystems print arange(len(state.dims[0]))[mask]",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:63,mask,mask,63,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['mask'],['mask']
Availability,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:143,failure,failure,143,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,3,"['avail', 'failure']","['available', 'failure', 'failures']"
Availability,"# error",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,error,error,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,2,['error'],['error']
Availability,"# estimate error correction efficiency from the CASCADE algorithm ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:11,error,error,11,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['error'],['error']
Availability,"# general absolute tolerance",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:19,toler,tolerance,19,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['toler'],['tolerance']
Availability,"# general relative tolerance",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:19,toler,tolerance,19,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['toler'],['tolerance']
Availability,"# if qset.has_openmp:; # from qutip.core.cy.openmp.benchmark import _spmvpy, _spmvpy_openmp; # @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:150,avail,available,150,qutip/tests/test_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py,1,['avail'],['available']
Availability,"# make sure qutip is available at engines",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:21,avail,available,21,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,1,['avail'],['available']
Availability,"# mean(expect**2) - mean(expect)**2 can something be very small; # negative (-1e-15) which raise an error for float sqrt.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:100,error,error,100,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,2,['error'],['error']
Availability,"# raise error if N not integer",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:8,error,error,8,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,2,['error'],['error']
Availability,"# space and time available, add tasks",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:17,avail,available,17,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['avail'],['available']
Availability,"# spin down",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:7,down,down,7,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['down'],['down']
Availability,"# test error",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:7,error,error,7,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['error'],['error']
Availability,"# use auto tidyup absolute tolerance",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:27,toler,tolerance,27,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['toler'],['tolerance']
Availability,"# we divide by atol and take the log so that the error returned is 0; # at atol, which is convenient for calling root_scalar with.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:49,error,error,49,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['error'],['error']
Availability,"#Lets look at what happens to the secure key rate and ; #the quantum bit error rate as the loss gets worse.; #Analogous to distance with fiber optic links.; #define the fock space",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:73,error,error,73,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['error'],['error']
Availability,"'''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:68,error,error,68,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['error'],['error']
Availability,")`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t``",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3160,error,error,3160,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['error'],['error']
Availability,", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3522,toler,tolerance,3522,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['toler'],['tolerance']
Availability,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4380,avail,available,4380,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['avail'],['available']
Availability,"------; L : Qobj; A Liouvillian superoperator for which to compute the pseudo inverse. rhoss : Qobj, optional; A steadystate density matrix as Qobj instance, for the Liouvillian; superoperator L. w : double, optional; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool, optional; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : str, optional; Method used to compte matrix inverse.; Choice are 'pinv' to use scipy's function of the same name, or a linear; system solver.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab"", ""splu""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve"",; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``L`` use these data backends, see the corresponding; libraries ``linalg`` for available solver. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Notes; -----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1860,avail,available,1860,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['avail'],['available']
Availability,"-----; L : Qobj; A Liouvillian superoperator for which to compute the pseudo inverse. rhoss : Qobj, optional; A steadystate density matrix as Qobj instance, for the Liouvillian; superoperator L. w : double, optional; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool, optional; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : str, optional; Method used to compte matrix inverse.; Choice are 'pinv' to use scipy's function of the same name, or a linear; system solver.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab"", ""splu""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve"",; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``L`` use these data backends, see the corresponding; libraries ``linalg`` for available solver. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Notes; -----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1206,avail,available,1206,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['avail'],['available']
Availability,".Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2199,error,errors,2199,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['error'],['errors']
Availability,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3720,toler,tolerance,3720,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['toler'],['tolerance']
Availability,"`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2170,error,errors,2170,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['error'],['errors']
Availability,"``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2909,error,errors,2909,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['errors']
Availability,"ack function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3347,error,error,3347,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['error'],['error']
Availability,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, a",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2289,error,error,2289,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['error'],['error']
Availability,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2434,error,error,2434,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['error'],['error']
Availability,"an then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1247,avail,available,1247,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['avail'],['available']
Availability,"bjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1667,toler,tolerance,1667,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['toler'],['tolerance']
Availability,"ble format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1486,error,error,1486,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:1292,toler,tolerance,1292,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,6,"['error', 'toler']","['error', 'tolerance']"
Availability,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1985,error,error,1985,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['error'],['error']
Availability,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE nu",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1881,error,error,1881,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['error']
Availability,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2777,toler,tolerance,2777,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['toler'],['tolerance']
Availability,"e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2302,error,error,2302,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['error'],['error']
Availability,"ed deterministically. state : :class:`.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and r",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1661,toler,tolerance,1661,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['toler'],['tolerance']
Availability,"esult class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. improved_sampling: Bool, default: False; Whether to use the improved sampling algorithm; of Abdelhafez et al. PRA (2019); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:1484,avail,available,1484,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['avail'],['available']
Availability,"h time in ``.times``. runs_expect : list of array of expectation values; A list containing the values of each ``e_op`` for each trajectories.; The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Only available if the; storing of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. average_e_data : dict; A dictionary containing the values of each ``e_op`` averaged over each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. average_e_data : dict; A dictionary containing the standard derivation of each ``e_op`` over; each trajectories. If the ``e_ops`` were supplied as a dictionary, the; keys are the same as in that dictionary. Otherwise the keys are the; index of the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. runs_e_data : dict; A dictionary containing the values of each ``e_op`` for each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. Only available if the storing; of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : :obj:`~SolverResultsOptions`; The options for this result class.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:4070,avail,available,4070,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['avail'],['available']
Availability,"h to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state t",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1621,error,error,1621,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['error']
Availability,"ignature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1702,toler,tolerance,1702,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['toler'],['tolerance']
Availability,"ional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3144,error,error,3144,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['error']
Availability,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2645,toler,tolerance,2645,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['toler'],['tolerance']
Availability,"math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-od",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3112,error,errors,3112,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['error'],['errors']
Availability,"me for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2897,error,error,2897,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['error'],['error']
Availability,"olver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the index of the ``e_op``; in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. e_ops : dict; A dictionary containing the supplied e_ops as ``ExpectOp`` instances.; The keys of the dictionary are the same as for ``.e_data``.; Each value is object where ``.e_ops[k](t, state)`` calculates the; value of ``e_op`` ``k`` at time ``t`` and the given ``state``, and; ``.e_ops[k].op`` is the original object supplied to create the; ``e_op``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : dict; The options for this result class.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:1768,avail,available,1768,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['avail'],['available']
Availability,"on mode) within the; decomposition of the correlation functions of a bath. Parameters; ----------; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------; fermionic : bool; True if the type of the exponent is a Fermionic type (i.e. either; ""+"" or ""-"") and False otherwise. All of the parameters are also available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:2026,avail,available,2026,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['avail'],['available']
Availability,"or which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : flo",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2918,error,errors,2918,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['error'],['errors']
Availability,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4915,error,error,4915,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,5,"['error', 'toler']","['error', 'tolerance']"
Availability,"rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3567,error,error,3567,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['error'],['error']
Availability,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2405,error,error,2405,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"s in `L`, but the `c_ops` given here does not; necessarily need to be all collapse operators contributing to dissipation; in the Liouvillian. Optionally, the steadystate density matrix `rhoss`; and the current operators `J_ops` correpsonding to the current collapse; operators `c_ops` can also be specified. If either of; `rhoss` and `J_ops` are omitted, they will be computed internally.; 'wlist' is an optional list of frequencies at which to evaluate the noise; spectrum. Parameters; ----------. L : :class:`.Qobj`; Qobj representing the system Liouvillian. c_ops : array / list; List of current collapse operators. rhoss : :class:`.Qobj` (optional); The steadystate density matrix corresponding the system Liouvillian; `L`. wlist : array / list (optional); List of frequencies at which to evaluate (if none are given, evaluates; at zero frequency). J_ops : array / list (optional); List of current superoperators. sparse : bool [True]; Flag that indicates whether to use sparse or dense matrix methods when; computing the pseudo inverse. Default is false, as sparse solvers; can fail for small systems. For larger systems the sparse solvers; are recommended. method : str, ['direct']; Method used to compute the noise. The default, 'direct' with; ``sparse=True``, compute the noise directly. It is the recommended; method for larger systems. Otherwise, the pseudo inverse is computed; using the given method. Pseudo inverse supports 'splu' and 'spilu' for; sparse matrices and 'direct', 'scipy' and 'numpy' methods for; ``sparse=False``. .. note::; The algoryth is described in page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis, available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-counting-st. Returns; --------; I, S : tuple of arrays; The currents `I` corresponding to each current collapse operator; `c_ops` (or, equivalently, each current superopeator `J_ops`) and the; zero-frequency cross-current correlation `S`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py:1889,avail,available,1889,qutip/solver/countstat.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py,1,['avail'],['available']
Availability,"same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rat",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1498,avail,available,1498,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['avail'],['available']
Availability,"ss:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : boo",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1746,error,error,1746,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"t` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already norma",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1962,toler,tolerance,1962,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['toler'],['tolerance']
Availability,"te is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dictionary containing the values of each ``e_ops``; at tme ``t``. The keys are those given by ``e_ops`` if it was; a dict, otherwise they are the indexes of the supplied ``e_ops``. See :class:`~HEOMResult` and :class:`.Result` for the complete; list of attributes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:4220,avail,available,4220,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['avail'],['available']
Availability,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2485,toler,tolerance,2485,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['toler'],['tolerance']
Availability,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1277,down,down,1277,qutip/measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py,2,['down'],['down']
Availability,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3791,avail,available,3791,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['avail'],['available']
Availability,"verage_expect : list of array of expectation values; A list containing the values of each ``e_op`` averaged over each; trajectories. The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. std_expect : list of array of expectation values; A list containing the standard derivation of each ``e_op`` over each; trajectories. The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. runs_expect : list of array of expectation values; A list containing the values of each ``e_op`` for each trajectories.; The list is in the same order in which the ``e_ops`` were; supplied and empty if no ``e_ops`` were given. Only available if the; storing of trajectories was requested. The order of the elements is ``runs_expect[e_ops][trajectory][time]``. Each element is itself an array and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. average_e_data : dict; A dictionary containing the values of each ``e_op`` averaged over each; trajectories. If the ``e_ops`` were supplied as a dictionary, the keys; are the same as in that dictionary. Otherwise the keys are the index of; the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. average_e_data : dict; A dictionary containing the standard derivation of each ``e_op`` over; each trajectories. If the ``e_ops`` were supplied as a dictionary, the; keys are the same as in that dictionary. Otherwise the keys are the; index of the ``e_op`` in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. runs_e_data",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:2786,avail,available,2786,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['avail'],['available']
Availability,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3544,avail,available,3544,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['avail'],['available']
Deployability," : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3504,integrat,integrator,3504,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Deployability," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3614,integrat,integration,3614,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,3,['integrat'],"['integration', 'integrator']"
Deployability," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3657,integrat,integration,3657,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,3,['integrat'],"['integration', 'integrator']"
Deployability," format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Retur",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3167,install,installed,3167,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['install'],['installed']
Deployability," run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2569,integrat,integration,2569,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Deployability," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4138,integrat,integration,4138,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Deployability,""""""" Location of the mkl installation. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:24,install,installation,24,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['install'],['installation']
Deployability,""""""" Return the initialted integrator. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:26,integrat,integrator,26,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Deployability,""""""" Whether qutip found an mkl installation. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:31,install,installation,31,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['install'],['installation']
Deployability,"""""""2D trapezium-method integration assuming a square grid.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:23,integrat,integration,23,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['integrat'],['integration']
Deployability,"""""""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:281,update,update,281,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['update'],['update']
Deployability,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:306,integrat,integrator,306,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,7,['integrat'],['integrator']
Deployability,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:172,integrat,integrator,172,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,7,['integrat'],['integrator']
Deployability,"""""""; Adds the 'short_version', 'version' and 'release' options. Read from the VERSION file to discover the version. This should be a; single line file containing valid Python package public identifier (see PEP; 440), for example; 4.5.2rc2; 5.0.0; 5.1.1a1; We do that here rather than in setup.cfg so we can apply the local; versioning number as well.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:46,release,release,46,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['release'],['release']
Deployability,"""""""; An abstract progress bar with some shared functionality. Example usage:. n_vec = linspace(0, 10, 100); pbar = TextProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); pbar.finished(). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:166,update,update,166,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['update'],['update']
Deployability,"""""""; Base class for storing results for solver using multiple trajectories. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. Function ``e_ops`` must return a number so the average can be computed. options : dict; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. average_states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested) averaged over all trajectories as a density matrix. runs_states : list of list of :obj:`.Qobj`; The state for each trajectory and each time ``t`` (if the recording of; the states and trajectories was requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested); averaged over all trajectories as a density matrix. runs_final_state : list of :obj:`.Qobj`; The final state for each trajectory (if the recording of the final; state and trajectories was requested). average_expect : list of array of expectation values; A list containing the values of each ``e_op`` averaged over each; trajectories. The list is in the same order in which the ``e_ops`` were",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:952,update,update,952,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['update'],['update']
Deployability,"""""""; Base class for storing solver results. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``e_data`` and ``expect`` attributes of; this result object. ``e_data`` is a dictionary and ``expect`` is a; list, where each item contains the values of the corresponding; ``e_op``. options : dict; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the ind",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:894,update,update,894,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['update'],['update']
Deployability,"""""""; Basic ode integrator; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:15,integrat,integrator,15,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['integrat'],['integrator']
Deployability,"""""""; Class for storing Monte-Carlo solver results. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. options : :obj:`~SolverResultsOptions`; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results.; Must include a value for ""num_collapse"". kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; collapse : list; For each runs, a list of every collapse as a tuple of the time it; happened and the corresponding ``c_ops`` index.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:871,update,update,871,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['update'],['update']
Deployability,"""""""; Class for storing the results of the non-Markovian Monte-Carlo solver. Parameters; ----------; e_ops : :obj:`.Qobj`, :obj:`.QobjEvo`, function or list or dict of these; The ``e_ops`` parameter defines the set of values to record at; each time step ``t``. If an element is a :obj:`.Qobj` or; :obj:`.QobjEvo` the value recorded is the expectation value of that; operator given the state at ``t``. If the element is a function, ``f``,; the value recorded is ``f(t, state)``. The values are recorded in the ``.expect`` attribute of this result; object. ``.expect`` is a list, where each item contains the values; of the corresponding ``e_op``. options : :obj:`~SolverResultsOptions`; The options for this result class. solver : str or None; The name of the solver generating these results. stats : dict; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results.; Must include a value for ""num_collapse"". kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; average_trace : list; The average trace (i.e., averaged over all trajectories) at each time. std_trace : list; The standard deviation of the trace at each time. runs_trace : list of lists; For each recorded trajectory, the trace at each time.; Only present if ``keep_runs_results`` is set in the options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:896,update,update,896,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['update'],['update']
Deployability,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:42,integrat,integrator,42,qutip/solver/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py,3,"['integrat', 'update']","['integrator', 'updated']"
Deployability,"""""""; Compare integrated evolution of unitary operator with state evo; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,integrat,integrated,13,qutip/tests/solver/test_sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py,1,['integrat'],['integrated']
Deployability,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,integrat,integrated,13,qutip/tests/solver/test_sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py,2,['integrat'],['integrated']
Deployability,"""""""; Compilation options:. use_cython: bool; Whether to compile strings as cython code or use python's ``exec``. try_parse: bool [True]; Whether to try parsing the string for reuse and static typing. static_types : bool [True]; Whether to use C types for constant and args. accept_int : None, bool; Whether to use the type ``int`` for integer constants and args or; upgrade it to ``float`` or ``complex``.; If `None`, it will only use ``int`` when subscription is found in the; code. accept_float : bool; Whether to use the type ``float`` or upgrade them to ``complex``. recompile : bool; Do not use previously made files but build a new one. compiler_flags : str; Flags to pass to the compiler, ex: ""-Wall -O3""...; Flags not matching your comiler and OS may cause compilation to fail.; Use ""recompile=True"", when trying to if the string pattern was; previously used. link_flags : str; Libraries to link to pass to the compiler. They can not be used to add; function to the string coefficient. extra_import : str; Cython code to add at the head of the file. Can be used to add extra; import or cimport code, ex:; extra_import=""from scipy.linalg import det""; extra_import=""from qutip.core.data cimport CSR"". clean_on_error : bool [True]; When writing a cython file that cannot be imported, erase it. build_dir: str [None]; cythonize's build_dir.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:366,upgrade,upgrade,366,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,2,['upgrade'],['upgrade']
Deployability,"""""""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class:`.Qobj` or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class:`.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class:`.Qobj`, optional; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool, default: True; Whether an effective Hamiltonian should be constructed from H and; c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:17,integrat,integrated,17,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['integrat'],['integrated']
Deployability,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:141,install,installed,141,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['install'],['installed']
Deployability,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:803,integrat,integration,803,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['integrat'],['integration']
Deployability,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:215,release,release,215,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,2,['release'],['release']
Deployability,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,integrat,integrator,44,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],['integrator']
Deployability,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:34,integrat,integrate,34,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,2,['integrat'],['integrate']
Deployability,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:34,integrat,integrate,34,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,2,['integrat'],['integrate']
Deployability,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:560,integrat,integrate,560,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,3,['integrat'],"['integrate', 'integrators']"
Deployability,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; floquet_basis : :class:`FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. c_ops : list of :obj:`.Qobj`; The collapse operators describing the dissipation. kmax : int; The truncation of the number of sidebands (default 5). ntimes : int [100]; The number of integration steps (for calculating X) within one period. Returns; -------; X : list of dict of :class:`.Data`; A dict of the sidebands ``k`` for the X matrices of each c_ops; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:350,integrat,integration,350,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['integrat'],['integration']
Deployability,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:286,integrat,integrator,286,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['integrat'],['integrator']
Deployability,"""""""; Integrator solving the ODE by diagonalizing the system and solving; analytically. It can only solve constant system and has a long preparation; time, but the integration is fast. Usable with ``method=""diag""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:163,integrat,integration,163,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,1,['integrat'],['integration']
Deployability,"""""""; Integrator using Scipy `ode` with dop853 integrator. Eight order; runge-kutta method by Dormand & Prince. Use fortran implementation; from [E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary Differential; Equations i. Nonstiff Problems. 2nd edition. Springer Series in; Computational Mathematics, Springer-Verlag (1993)]. Usable with ``method=""dop853""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:46,integrat,integrator,46,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""; Integrator using Scipy `ode` with lsoda integrator. ODE solver by netlib; (https://www.netlib.org/odepack) Automatically choose between 'Adams' and; 'BDF' methods to solve both stiff and non-stiff systems. Usable with ``method=""lsoda""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""; Integrator using Scipy `ode` with zvode integrator using adams method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""adams""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""; Integrator using Scipy `ode` with zvode integrator using bdf method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""bdf""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""; Location in which qutip place cython string coefficient folders.; The default is ""$HOME/.qutip"".; Can be updated.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:110,update,updated,110,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['update'],['updated']
Deployability,"""""""; Location in which qutip save cython string coefficient files.; Usually ""{qutip.settings.tmproot}/qutip_coeffs_X.X"".; Can be updated.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:129,update,updated,129,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['update'],['updated']
Deployability,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`MESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:265,integrat,integrating,265,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integrating']
Deployability,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:287,integrat,integrating,287,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integrating']
Deployability,"""""""; Method called when options are changed, either through; ``solver.options[key] = value`` or ``solver.options = options``.; Allow to update the solver with the new options; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:136,update,update,136,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['update'],['update']
Deployability,"""""""; Noise used for Ito-Taylor integrators of order up to 1.5.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:31,integrat,integrators,31,qutip/solver/sode/_noise.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py,1,['integrat'],['integrators']
Deployability,"""""""; Numerical integration of the correlation function given an array of; expectation values.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:15,integrat,integration,15,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['integrat'],['integration']
Deployability,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:597,install,installed,597,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,3,"['install', 'integrat']","['installed', 'integration', 'integrators']"
Deployability,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:604,install,installed,604,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,2,"['install', 'integrat']","['installed', 'integrator']"
Deployability,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:512,install,installed,512,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,2,"['install', 'integrat']","['installed', 'integration']"
Deployability,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:526,install,installed,526,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,2,"['install', 'integrat']","['installed', 'integration']"
Deployability,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:713,install,installed,713,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,"['install', 'integrat']","['installed', 'integration']"
Deployability,"""""""; Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, QobjEvo compatible format.; System Hamiltonian, with period `T`. T : float; Period of the Hamiltonian. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict [None]; Options used by sesolve to compute the floquet modes. sparse : bool [False]; Whether to use the sparse eigen solver when computing the; quasi-energies. sort : bool [True]; Whether to sort the quasi-energies. precompute : list [None]; If provided, a list of time at which to store the propagators; for later use when computing modes and states. Default is; ``linspace(0, T, 101)`` corresponding to the default integration; steps used for the floquet tensor computation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:709,integrat,integration,709,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['integrat'],['integration']
Deployability,"""""""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:187,configurat,configuration,187,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['configurat'],['configuration']
Deployability,"""""""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Parameters; ----------; verbose : bool, default: False; Add extra information about install location. Returns; -------; version_table: str; Return an HTML-formatted string containing version information for; QuTiP dependencies. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:373,install,install,373,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,1,['install'],['install']
Deployability,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:17,integrat,integrator,17,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,3,['integrat'],['integrator']
Deployability,"""""""; Returns the value of the influence martingale along the current; trajectory. The value of the martingale is the product of the; continuous and the discrete contribution. The current time and the; collapses that have happened are read out from the internal integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:133,continuous,continuous,133,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,2,"['continuous', 'integrat']","['continuous', 'integrator']"
Deployability,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:172,integrat,integrating,172,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['integrat'],['integrating']
Deployability,"""""""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. Returns; =======; result: list; A dictionary of the type `qutip.piqs.Result` which holds the; results of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:246,integrat,integrate,246,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,1,['integrat'],['integrate']
Deployability,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:272,integrat,integrator,272,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,['integrat'],"['integration', 'integrator']"
Deployability,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:586,install,installed,586,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,2,"['install', 'integrat']","['installed', 'integration']"
Deployability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:628,integrat,integration,628,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['integrat'],['integration']
Deployability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:643,integrat,integration,643,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['integrat'],['integration']
Deployability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:689,integrat,integration,689,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integration']
Deployability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:623,integrat,integration,623,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['integrat'],['integration']
Deployability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:600,integrat,integration,600,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['integrat'],['integration']
Deployability,"""""""; Stochastic integration method keeping the positivity of the density matrix.; See eq. (4) Pierre Rouchon and Jason F. Ralpha,; *Efficient Quantum Filtering for Quantum Feedback Control*,; `arXiv:1410.5345 [quant-ph] <https://arxiv.org/abs/1410.5345>`_,; Phys. Rev. A 91, 012118, (2015). - Order: strong 1. Notes; -----; This method should be used with very small ``dt``. Unlike other; methods that will return unphysical state (negative eigenvalues, Nans); when the time step is too large, this method will return state that; seems normal.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:16,integrat,integration,16,qutip/solver/sode/rouchon.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py,1,['integrat'],['integration']
Deployability,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:33,integrat,integrator,33,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],"['integrate', 'integrator']"
Deployability,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:841,integrat,integrator,841,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['integrat'],['integrator']
Deployability,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,integrat,integrator,32,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,integrat,integrator,32,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],['integrator']
Deployability,"""""""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:65,continuous,continuous,65,qutip/continuous_variables.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py,1,['continuous'],['continuous']
Deployability,"""""""; method: str; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:55,integrat,integration,55,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integration']
Deployability,"""""""; removes margins about z = 0 and improves the style; by monkey patching; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:67,patch,patching,67,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['patch'],['patching']
Deployability,"""""""; updates the x-axis; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,update,updates,5,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['update'],['updates']
Deployability,"""""""; updates the y-axis; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,update,updates,5,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['update'],['updates']
Deployability,"""""""; updates the z-axis; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:5,update,updates,5,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['update'],['updates']
Deployability,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:913,integrat,integrator,913,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['integrat'],['integrator']
Deployability,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:45,integrat,integrate,45,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrate']
Deployability,"""""""ODE integrator from scipy.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:7,integrat,integrator,7,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Deployability,"""""""Test dynamically updated arguments are usable.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:20,update,updated,20,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['update'],['updated']
Deployability,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:251,continuous,continuous-variable,251,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['continuous'],['continuous-variable']
Deployability,"# -- General configuration ------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; #",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:13,configurat,configuration,13,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['configurat'],['configuration']
Deployability,"# -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #; # Check for Matplotlib",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:139,configurat,configuration,139,qutip/__init__.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py,1,['configurat'],['configuration']
Deployability,"# Add any paths that contain custom themes here, relative to this directory.; # The name for this set of Sphinx documents. If None, it defaults to; # ""<project> v<release> documentation"".",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:163,release,release,163,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['release'],['release']
Deployability,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,integrat,integration,48,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,2,['integrat'],['integration']
Deployability,"# CalledProcessError is for if the git command fails for internal; # reasons (e.g. we're not in a git repository), OSError is for if; # something goes wrong when trying to run git (e.g. it's not installed,; # or a permission error).",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:195,install,installed,195,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['install'],['installed']
Deployability,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:160,integrat,integrator,160,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Deployability,"# Evolving backward in time is not supported by all integrator.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:52,integrat,integrator,52,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,1,['integrat'],['integrator']
Deployability,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:347,integrat,integration,347,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integration']
Deployability,"# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,; # using the given strftime format.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:21,update,updated,21,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['update'],['updated']
Deployability,"# If we can't locate it for some reason, then we don't attempt to patch.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:66,patch,patch,66,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['patch'],['patch']
Deployability,"# Iteratively integrate to obtain single value",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:14,integrat,integrate,14,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['integrat'],['integrate']
Deployability,"# Let's try a weird tensor contraction; this will likely never come up in; # practice, but it should serve as a good canary for more reasonable; # contractions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py:117,canary,canary,117,qutip/tests/core/test_tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py,1,['canary'],['canary']
Deployability,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:151,integrat,integrate,151,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,3,"['continuous', 'integrat']","['continuous', 'integrate']"
Deployability,"# Many coefficients. These should not be publicly exposed; # and will all need to be updated in _arguments():",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:85,update,updated,85,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['update'],['updated']
Deployability,"# Options should be overwritten by each integrators.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:40,integrat,integrators,40,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrators']
Deployability,"# Partial args update",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py:15,update,update,15,qutip/tests/core/test_coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py,1,['update'],['update']
Deployability,"# Some of the keys are used by the integrator.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:35,integrat,integrator,35,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Deployability,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:28,integrat,integrator,28,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,4,"['integrat', 'update']","['integrator', 'update']"
Deployability,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:178,integrat,integrator,178,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Deployability,"# The name of the integrator",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,integrat,integrator,18,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrator']
Deployability,"# The version info for the project you're documenting, acts as replacement for; # |version| and |release|, also used in various other places throughout the; # built documents.; # The full version, including alpha/beta/rc tags.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:97,release,release,97,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['release'],['release']
Deployability,"# Trigger an update of the Bloch sphere if it is already shown:",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:13,update,update,13,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['update'],['update']
Deployability,"# We wait for the lock to be released and then retry the import.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:29,release,released,29,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['release'],['released']
Deployability,"# Whether the integrator used the system QobjEvo as a blackbox",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:14,integrat,integrator,14,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrator']
Deployability,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:53,integrat,integration,53,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integration']
Deployability,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:88,continuous,continuous,88,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['continuous'],['continuous']
Deployability,"# configuration declares the location of the examples directory for; # Sphinx Gallery",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,configurat,configuration,2,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['configurat'],['configuration']
Deployability,"# find value of continuous martingale at given time",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:16,continuous,continuous,16,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['continuous'],['continuous']
Deployability,"# mesolve integration for comparison",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:10,integrat,integration,10,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['integrat'],['integration']
Deployability,"# nm_mcsolve integration",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,integrat,integration,13,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['integrat'],['integration']
Deployability,"# update `args` dictionary before precomputing martingale",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2,update,update,2,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['update'],['update']
Deployability,"# update default_opts from input options",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:2,update,update,2,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['update'],['update']
Deployability,"# upgrade H_sys to a Liouvillian if needed and add the; # bath terminator",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2,upgrade,upgrade,2,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['upgrade'],['upgrade']
Deployability,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:43,configurat,configurations,43,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['configurat'],['configurations']
Deployability,")`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t``",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3174,install,installed,3174,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['install'],['installed']
Deployability,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4439,integrat,integration,4439,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Deployability,"; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list conta",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3644,integrat,integration,3644,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integration']
Deployability,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3741,integrat,integrator,3741,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Deployability,"ack function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3361,install,installed,3361,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['install'],['installed']
Deployability,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, a",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2303,install,installed,2303,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['install'],['installed']
Deployability,"allable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vector",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2448,install,installed,2448,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['install'],['installed']
Deployability,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2701,integrat,integration,2701,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,3,['integrat'],"['integration', 'integrator']"
Deployability,"e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2316,install,installed,2316,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['install'],['installed']
Deployability,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2612,integrat,integration,2612,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Deployability,"ional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3158,install,installed,3158,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['install'],['installed']
Deployability,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2666,integrat,integrator,2666,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integrator']
Deployability,"me for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation in",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2911,install,installed,2911,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['install'],['installed']
Deployability,"nitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1350,integrat,integration,1350,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integration']
Deployability,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2419,install,installed,2419,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,4,"['install', 'integrat']","['installed', 'integration', 'integrator']"
Deployability,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2506,integrat,integrator,2506,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,2,['integrat'],['integrator']
Deployability,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3371,integrat,integration,3371,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,4,['integrat'],"['integration', 'integrator']"
Deployability,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3124,integrat,integration,3124,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,4,['integrat'],"['integration', 'integrator']"
Energy Efficiency," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3470,efficient,efficient,3470,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['efficient'],['efficient']
Energy Efficiency," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4128,adapt,adaptive,4128,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['adapt'],['adaptive']
Energy Efficiency,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:154,power,power,154,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['power'],['power']
Energy Efficiency,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; The four tests below determine whether efficient numerics, naive numerics; and semi-analytic results are identical.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py:125,efficient,efficient,125,qutip/tests/test_subsys_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Animation of the Fock distribution for a density matrix (or ket); that describes an oscillator mode. Parameters; ----------; rhos : :class:`.Result` or list of :class:`.Qobj`; The density matrix (or ket) of the state to visualize. fock_numbers : list of strings, optional; list of x ticklabels to represent fock numbers. color : color or list of colors, default: ""green""; The colors of the bar faces. unit_y_range : bool, default: True; Set y-axis limits [0, 1] or not. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ani : tuple; A tuple of the matplotlib figure and the animation instance; used to produce the figure.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py:369,green,green,369,qutip/animation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py,1,['green'],['green']
Energy Efficiency,"""""""; Applies a channel to a state on one subsystem, by breaking it into; blocks and applying a reduced channel to each block.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:95,reduce,reduced,95,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 2/9 for maximally entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 2/9). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:30,power,power,30,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,2,['power'],['power']
Energy Efficiency,"""""""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:129,reduce,reduced,129,qutip/distributions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: bool, default: False; boolean parameter for using a positive exponent in the Fourier; Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py:19,power,power,19,qutip/solver/spectrum.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/spectrum.py,2,['power'],['power']
Energy Efficiency,"""""""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:144,reduce,reduced-dimensionality,144,qutip/distributions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:789,power,power,789,qutip/solver/floquet_bwcomp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py,1,['power'],['power']
Energy Efficiency,"""""""; Calculate the total number of distinct ENR states for a given set of; subspaces. This method is not intended to be fast or efficient, it's; intended to be obviously correct for testing purposes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py:128,efficient,efficient,128,qutip/tests/test_enr_state_operator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1586,efficient,efficient,1586,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:1194,efficient,efficient,1194,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. method : str, {""direct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:497,power,power,497,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,4,['power'],['power']
Energy Efficiency,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:952,schedul,scheduling,952,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:926,schedul,scheduling,926,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['schedul'],"['scheduled', 'scheduling']"
Energy Efficiency,"""""""; Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:59,power,powers,59,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,2,['power'],"['power', 'powers']"
Energy Efficiency,"""""""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`.Qobj`; time-propagator for reduced system dynamics; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:460,reduce,reduced,460,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Compute the cross-current noise spectrum for a list of collapse operators; `c_ops` corresponding to monitored currents, given the system; Liouvillian `L`. The current collapse operators `c_ops` should be part; of the dissipative processes in `L`, but the `c_ops` given here does not; necessarily need to be all collapse operators contributing to dissipation; in the Liouvillian. Optionally, the steadystate density matrix `rhoss`; and the current operators `J_ops` correpsonding to the current collapse; operators `c_ops` can also be specified. If either of; `rhoss` and `J_ops` are omitted, they will be computed internally.; 'wlist' is an optional list of frequencies at which to evaluate the noise; spectrum. Parameters; ----------. L : :class:`.Qobj`; Qobj representing the system Liouvillian. c_ops : array / list; List of current collapse operators. rhoss : :class:`.Qobj` (optional); The steadystate density matrix corresponding the system Liouvillian; `L`. wlist : array / list (optional); List of frequencies at which to evaluate (if none are given, evaluates; at zero frequency). J_ops : array / list (optional); List of current superoperators. sparse : bool [True]; Flag that indicates whether to use sparse or dense matrix methods when; computing the pseudo inverse. Default is false, as sparse solvers; can fail for small systems. For larger systems the sparse solvers; are recommended. method : str, ['direct']; Method used to compute the noise. The default, 'direct' with; ``sparse=True``, compute the noise directly. It is the recommended; method for larger systems. Otherwise, the pseudo inverse is computed; using the given method. Pseudo inverse supports 'splu' and 'spilu' for; sparse matrices and 'direct', 'scipy' and 'numpy' methods for; ``sparse=False``. .. note::; The algoryth is described in page 67 of ""Electrons in nanostructures""; C. Flindt, PhD Thesis, available online:; https://orbit.dtu.dk/en/publications/electrons-in-nanostructures-coherent-manipulation-and-co",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py:105,monitor,monitored,105,qutip/solver/countstat.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/countstat.py,1,['monitor'],['monitored']
Energy Efficiency,"""""""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`.Qobj`; density matrix at time :math:`t`; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:17,reduce,reduced,17,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:537,power,power,537,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['power'],['power']
Energy Efficiency,"""""""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit `orig` to unit `to`. Parameters; ----------; value : float / array; The energy in the old unit. orig : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""meV""; The name of the original unit. to : str, {""J"", ""eV"", ""meV"", ""GHz"", ""mK""}, default: ""GHz""; The name of the new unit. Returns; -------; value_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:16,energy,energy,16,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,3,['energy'],['energy']
Energy Efficiency,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:1093,efficient,efficient,1093,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Floquet-Markov master equation gamma matrices. Parameters; ----------; X : list of dict of :class:`.Data`; Floquet X matrices created by :func:`_floquet_X_matrices`. delta : np.ndarray; Floquet delta tensor created by :func:`_floquet_delta_tensor`. J_cb : list of callables; A list callback functions that compute the noise power spectrum as; a function of frequency. The list should contain one callable for each; collapse operator `c_op`, in the same order as the elements of `X`.; Each callable should accept a numpy array of frequencies and return a; numpy array of corresponding noise power. Returns; -------; gammas : dict of :class:`.Data`; A dict mapping the sidebands ``k`` to their gamma matrices.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:329,power,power,329,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,['power'],['power']
Energy Efficiency,"""""""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int, default: -Nmax; Lowest charge state to consider. frac : float, default: 1; Specify fractional charge if needed. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; C : Qobj; Charge operator over [Nmin, Nmax]. Notes; -----; .. versionadded:: 3.2. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:27,charge,charge,27,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,5,['charge'],['charge']
Energy Efficiency,"""""""; Generator that yields powers of an operator `op`,; through to `N`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:27,power,powers,27,qutip/core/gates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py,1,['power'],['powers']
Energy Efficiency,"""""""; Given a scipy.sparse.csr_matrix, shuffle the indices within each row and; return a new array. This should represent the same matrix, but in the less; efficient, ""unsorted"" manner. All mathematical operations should still; work the same after this, but may be slower. This is not guaranteed to change the order of the indices in every case.; If there is at most one value per row, there is no unsorted order. In; general, we attempt to shuffle, and if this returns the same order as; before, we just reverse it to ensure it's different.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/conftest.py:155,efficient,efficient,155,qutip/tests/core/data/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/conftest.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:739,reduce,reduced,739,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['reduce'],['reduced']
Energy Efficiency,"""""""; Object pointing to LU factorization of a sparse matrix; generated by mkl_splu. Methods; -------; solve(b, verbose=False); Solve system of equations using given RHS vector 'b'.; Returns solution ndarray with same shape as input. info(); Returns the statistics of the factorization and; solution in the lu.info attribute. delete(); Deletes the allocated solver memory. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:347,allocate,allocated,347,qutip/_mkl/spsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py,1,['allocate'],['allocated']
Energy Efficiency,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:944,efficient,efficient,944,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; PIQS: Test the energy degeneracy (m) of Dicke state | j, m >.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:20,energy,energy,20,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['energy'],['energy']
Energy Efficiency,"""""""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :obj:`.Qobj`; The density matrix (or ket) of the state to visualize. fock_numbers : list of strings, optional; list of x ticklabels to represent fock numbers. color : color or list of colors, default: ""green""; The colors of the bar faces. unit_y_range : bool, default: True; Set y-axis limits [0, 1] or not. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, output : tuple; A tuple of the matplotlib figure and the axes instance or animation; instance used to produce the figure.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:330,green,green,330,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['green'],['green']
Energy Efficiency,"""""""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. h_lables : List of string, optional; A list of xticklabels for each Hamiltonian. energy_levels : List of string, optional; A list of yticklabels to the left of energy levels of the initial; Hamiltonian. N : int, default: 0; The number of energy levels to plot. fig : a matplotlib Figure instance, optional; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance, optional; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:14,energy,energy,14,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,5,['energy'],['energy']
Energy Efficiency,"""""""; Provide a cython implimentation verner 'most-efficient'; order 7 runge-Kutta method.; See https://www.sfu.ca/~jverner/; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner7efficient.py:50,efficient,efficient,50,qutip/solver/integrator/verner7efficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner7efficient.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; Provide a cython implimentation verner 'most-efficient'; order 9 runge-Kutta method.; See https://www.sfu.ca/~jverner/; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner9efficient.py:50,efficient,efficient,50,qutip/solver/integrator/verner9efficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/verner9efficient.py,1,['efficient'],['efficient']
Energy Efficiency,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 7. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern7""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:46,efficient,efficient,46,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,2,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 9. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern9""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:46,efficient,efficient,46,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,2,['efficient'],"['efficient', 'efficiently']"
Energy Efficiency,"""""""; Solve the dynamics for the system using the Floquet-Markov master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Wheth",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:946,power,power,946,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['power'],['power']
Energy Efficiency,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:505,power,power,505,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['power'],['power']
Energy Efficiency,"""""""; Uses scalar-matrix multiplication to efficiently apply a channel to; the leftmost register in the tensor product, given a unitary matrix; for a channel.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:42,efficient,efficiently,42,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['efficient'],['efficiently']
Energy Efficiency,"""""""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:26,schedul,scheduling,26,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,1,['schedul'],['scheduling']
Energy Efficiency,"""""""Calculate the number of Dicke states with same energy. The use of the ``Decimals`` class allows to explore N > 1000,; unlike the built-in function ``scipy.special.binom``. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:50,energy,energy,50,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,3,['energy'],['energy']
Energy Efficiency,"""""""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; ----------; bra : :class:`.Qobj`; Quantum object of type 'bra' or 'ket'. ket : :class:`.Qobj`; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Notes; -----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:378,efficient,efficient,378,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['efficient'],['efficient']
Energy Efficiency,"# Construct the Pauli basis by vertically stacking rows in sparse format.; # The CSR format is much more efficient at handling row-stacking, so we; # actually have to do a little dance through adjoint/transpose to get it; # into the right format.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:105,efficient,efficient,105,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,1,['efficient'],['efficient']
Energy Efficiency,"# TODO Write more efficient code for single-matrix map on pure states; # TODO Write more efficient code for single-subsystem map . . .",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:18,efficient,efficient,18,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,2,['efficient'],['efficient']
Energy Efficiency,"# The fidelity for pure states reduces to the modulus of their; # inner product.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:31,reduce,reduces,31,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['reduce'],['reduces']
Energy Efficiency,"# The scipy solvers for the Pade approximant are more efficient with the; # CSC format than the CSR one.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py:54,efficient,efficient,54,qutip/core/data/expm.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py,1,['efficient'],['efficient']
Energy Efficiency,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:87,efficient,efficiently,87,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['efficient'],['efficiently']
Energy Efficiency,"# allocate the rest qutbits (not targets) to the empty; # position in new_order",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:2,allocate,allocate,2,qutip/core/tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py,1,['allocate'],['allocate']
Energy Efficiency,"# array of spin energy splittings and coupling strengths. here we use; # uniform parameters, but in general we don't have too",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:16,energy,energy,16,qutip/core/cy/openmp/bench_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py,1,['energy'],['energy']
Energy Efficiency,"# calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py:16,power,power,16,doc/guide/scripts/spectrum_ex1.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py,1,['power'],['power']
Energy Efficiency,"# calculates powers of Qobj",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:13,power,powers,13,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['power'],['powers']
Energy Efficiency,"# energy splitting terms",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:2,energy,energy,2,qutip/core/cy/openmp/bench_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py,1,['energy'],['energy']
Energy Efficiency,"# energy; # parameters for the fermionic leads",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:2,energy,energy,2,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['energy'],['energy']
Energy Efficiency,"# noise power spectrum",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex3.py:8,power,power,8,doc/guide/scripts/floquet_ex3.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex3.py,1,['power'],['power']
Energy Efficiency,"# partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add).; # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py:10,reduce,reduce,10,qutip/core/gates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/gates.py,3,['reduce'],['reduce']
Energy Efficiency,"# rcm should reduce bandwidth",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:13,reduce,reduce,13,qutip/tests/solver/test_steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py,1,['reduce'],['reduce']
Energy Efficiency,"# to support v4's ""power-gmres"" method",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:19,power,power-gmres,19,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['power'],['power-gmres']
Energy Efficiency,"ct"", ""eigen"", ""svd"", ""power""}, default: ""direct""; The allowed methods are composed of 2 parts, the steadystate method:; - ""direct"": Solving ``L(rho_ss) = 0``; - ""eigen"" : Eigenvalue problem; - ""svd"" : Singular value decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1481,power,power,1481,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['power'],['power']
Energy Efficiency,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2602,adapt,adaptive,2602,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['adapt'],['adaptive']
Energy Efficiency,"eters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float, default: sqrt(2); Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool, optional; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool, optional; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1117,efficient,efficient,1117,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['efficient'],['efficient']
Energy Efficiency,"g; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:2031,power,power,2031,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,4,['power'],['power']
Energy Efficiency,"lue decomposition; - ""power"" : Inverse-power method. solver : str, optional; 'direct' and 'power' methods only.; Solver to use when solving the ``L(rho_ss) = 0`` equation.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extension to qutip, such as qutip-tensorflow, can use come with their; own solver. When ``A`` and ``c_ops`` use these data backends, see the; corresponding libraries ``linalg`` for available solver. Extra options for these solver can be passed in ``**kw``. use_rcm : bool, default: False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian.; Used with 'direct' or 'power' method. use_wbm : bool, default: False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only. Used with 'direct' or 'power' method. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; Used with 'direct' method. power_tol : float, default: 1e-12; Tolerance for the solution when using the 'power' method. power_maxiter : int, default: 10; Maximum number of iteration to use when looking for a solution when; using the 'power' method. power_eps: double, default: 1e-15; Small weight used in the ""power"" method. sparse: bool, default: True; Whether to use the sparse eigen solver with the ""eigen"" method; (default sparse). With ""direct"" and ""power"" method, when the solver is; not specified, it is used to set whether ""solve"" or ""spsolve"" is; used as default solver. **kwargs :; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:1692,power,power,1692,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['power'],['power']
Integrability," : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3504,integrat,integrator,3504,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Integrability," Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options]. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3614,integrat,integration,3614,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,4,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Integrability," Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by ``tlist``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3657,integrat,integration,3657,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,4,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Integrability," and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allo",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:1605,depend,dependent,1605,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['depend'],['dependent']
Integrability," operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of para",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1206,depend,depend,1206,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['depend'],['depend']
Integrability," run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2569,integrat,integration,2569,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Integrability," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4138,integrat,integration,4138,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Integrability,""""""" Assert that calling .steady_state() on a HEOMSolver with; a time-dependent Hamiltonian raises the appropriate exception.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:69,depend,dependent,69,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['depend'],['dependent']
Integrability,""""""" Return the initialted integrator. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:26,integrat,integrator,26,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Integrability,""""""" `Integrator`: ODE solver wrapper to use in qutip's Solver """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:29,wrap,wrapper,29,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['wrap'],['wrapper']
Integrability,"""""""2D trapezium-method integration assuming a square grid.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:23,integrat,integration,23,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['integrat'],['integration']
Integrability,"""""""; A Test class for using time-dependent array coefficients; as step functions instead of doing interpolation; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:33,depend,dependent,33,qutip/tests/solver/test_mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py,1,['depend'],['dependent']
Integrability,"""""""; A generator of propagator for a system. Usage:. U = Propagator(H, c_ops). psi_t = U(t) @ psi_0. Save some previously computed propagator are stored to speed up subsequent; computation. Changing ``args`` will erase these stored probagator. Parameters; ----------; system : :obj:`.Qobj`, :obj:`.QobjEvo`, :class:`.Solver`; Possibly time-dependent system driving the evolution, either already; packaged in a solver, such as :class:`.SESolver` or :class:`.BRSolver`,; or the Liouvillian or Hamiltonian as a :obj:`.Qobj`,; :obj:`.QobjEvo`. ``list`` of [:obj:`.Qobj`, :obj:`.Coefficient`]; or callable that can be made into :obj:`.QobjEvo` are also accepted. Solvers that run non-deterministacilly, such as :class:`.MCSolver`, are; not supported. c_ops : list, optional; List of :obj:`.Qobj` or :obj:`.QobjEvo` collapse operators. args : dictionary, optional; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Options for the solver. memoize : int, default: 10; Max number of propagator to save. tol : float, default: 1e-14; Absolute tolerance for the time. If a previous propagator was computed; at a time within tolerance, that propagator will be returned. Notes; -----; The :class:`Propagator` is not a :obj:`.QobjEvo` so; it cannot be used for operations with :obj:`.Qobj` or; :obj:`.QobjEvo`. It can be made into a; :obj:`.QobjEvo` with ::. U = QobjEvo(Propagator(H)). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:340,depend,dependent,340,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,2,['depend'],['dependent']
Integrability,"""""""; A helper class for creating an :class:`HEOMSolver` that is backwards; compatible with the ``HSolverDL`` provided in ``qutip.nonmarkov.heom``; in QuTiP 4.6 and below. See :class:`HEOMSolver` and :class:`DrudeLorentzBath` for more; descriptions of the underlying solver and bath construction. An exact copy of the QuTiP 4.6 HSolverDL is provided in; ``qutip.nonmarkov.dlheom_solver`` for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. .. note::. Unlike the version of ``HSolverDL`` in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian ``H_sys``. .. note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : f",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:612,depend,dependent,612,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['depend'],['dependent']
Integrability,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:7,wrap,wrapper,7,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,11,"['depend', 'integrat', 'interface', 'wrap']","['dependent', 'depending', 'integrator', 'interface', 'wrapper']"
Integrability,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:7,wrap,wrapper,7,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,10,"['depend', 'integrat', 'wrap']","['dependent', 'depending', 'integrator', 'wrapper']"
Integrability,"""""""; Add a trajectory to the evolution. Trajectories can be saved or average canbe extracted depending on the; options ``keep_runs_results``. Parameters; ----------; trajectory_info : tuple of seed and trajectory; - seed: int, SeedSequence; Seed used to generate the trajectory.; - trajectory : :class:`Result`; Run result for one evolution over the times. Returns; -------; remaing_traj : number; Return the number of trajectories still needed to reach the target; tolerance. If no tolerance is provided, return infinity.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:93,depend,depending,93,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['depend'],['depending']
Integrability,"""""""; Basic ode integrator; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:15,integrat,integrator,15,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['integrat'],['integrator']
Integrability,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:193,depend,dependent,193,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,4,['depend'],"['depend', 'dependent', 'depending']"
Integrability,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:554,depend,dependent,554,qutip/solver/floquet_bwcomp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py,2,['depend'],"['dependence', 'dependent']"
Integrability,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:772,depend,depend,772,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,1,['depend'],['depend']
Integrability,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:551,depend,depend,551,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,2,['depend'],"['depend', 'dependent']"
Integrability,"""""""; Calculates the effective steady state for a driven; system with a time-dependent cosinusoidal term:. .. math::. \\mathcal{\\hat{H}}(t) = \\hat{H}_0 +; \\mathcal{\\hat{O}} \\cos(\\omega_d t). Parameters; ----------; H_0 : :obj:`.Qobj`; A Hamiltonian or Liouvillian operator. c_ops : list; A list of collapse operators. Op_t : :obj:`.Qobj`; The the interaction operator which is multiplied by the cosine. w_d : float, default: 1.0; The frequency of the drive. n_it : int, default: 3; The number of iterations for the solver. sparse : bool, default: False; Solve for the steady state using sparse algorithms. solver : str, optional; Solver to use when solving the linear system.; Default supported solver are:. - ""solve"", ""lstsq""; dense solver from numpy.linalg; - ""spsolve"", ""gmres"", ""lgmres"", ""bicgstab""; sparse solver from scipy.sparse.linalg; - ""mkl_spsolve""; sparse solver by mkl. Extensions to qutip, such as qutip-tensorflow, may provide their own; solvers. When ``H_0`` and ``c_ops`` use these data backends, see their; documentation for the names and details of additional solvers they may; provide. **kwargs:; Extra options to pass to the linear system solver. See the; documentation of the used solver in ``numpy.linalg`` or; ``scipy.sparse.linalg`` to see what extra arguments are supported. Returns; -------; dm : qobj; Steady state density matrix. Notes; -----; See: Sze Meng Tan,; https://painterlab.caltech.edu/wp-content/uploads/2019/06/qe_quantum_optics_toolbox.pdf,; Section (16). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:76,depend,dependent,76,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['depend'],['dependent']
Integrability,"""""""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:146,depend,depending,146,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,1,['depend'],['depending']
Integrability,"""""""; Class for basic functionality for qutip's options. Define basic method to wrap an ``options`` dict.; Default options are in a class _options dict.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:79,wrap,wrap,79,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['wrap'],['wrap']
Integrability,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:42,integrat,integrator,42,qutip/solver/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py,2,['integrat'],['integrator']
Integrability,"""""""; Collapse of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""cols"": MCSolver.CollapseFeedback()})``. The ``func`` will receive a list of ``(time, operator number)`` for; each collapses of the trajectory as ``cols``. .. note::. CollapseFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, default : []; Default function used outside the solver. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:50,depend,dependent,50,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['depend'],['dependent']
Integrability,"""""""; Command line output of information on QuTiP and dependencies.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/about.py:53,depend,dependencies,53,qutip/about.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/about.py,1,['depend'],['dependencies']
Integrability,"""""""; Compare integrated evolution of unitary operator with state evo; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,integrat,integrated,13,qutip/tests/solver/test_sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py,1,['integrat'],['integrated']
Integrability,"""""""; Compare integrated evolution with analytical result; If U0 is not None then operator evo is checked; Otherwise state evo; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py:13,integrat,integrated,13,qutip/tests/solver/test_sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_sesolve.py,2,['integrat'],['integrated']
Integrability,"""""""; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters; ----------; H : :class:`.Qobj` or list; System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; `c_ops`.; psi0 : :class:`.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`.; n_emissions : int; Number of photons emitted by the system (into any combination of; waveguides).; c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class:`.Qobj`, optional; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool, default: True; Whether an effective Hamiltonian should be constructed from H and; c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:17,integrat,integrated,17,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['integrat'],['integrated']
Integrability,"""""""; Construct a tensor that represents the master equation in the floquet; basis. Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------; H : :obj:`.QobjEvo`, :obj:`.FloquetBasis`; Periodic Hamiltonian a floquet basis system. T : float, optional; The period of the time-dependence of the hamiltonian. Optional if ``H``; is a ``FloquetBasis`` object. c_ops : list of :class:`.Qobj`; list of collapse operators. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. w_th : float, default: 0.0; The temperature in units of frequency. kmax : int, default: 5; The truncation of the number of sidebands (default 5). nT : int, default: 100; The number of integration steps (for calculating X) within one period. Returns; -------; output : array; The Floquet-Markov master equation tensor `R`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:309,depend,dependence,309,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,"['depend', 'integrat']","['dependence', 'integration']"
Integrability,"""""""; Contract subspaces of the tensor structure which are 1D. Not defined; on superoperators. If all dimensions are scalar, a Qobj of dimension; [[1], [1]] is returned, i.e. _multiple_ scalar dimensions are; contracted, but one is left. Parameters; ----------; inplace: bool, optional; If ``True``, modify the dimensions in place. If ``False``, return; a copied object. Returns; -------; out: :class:`.Qobj`; Quantum object with dimensions contracted. Will be ``self`` if; ``inplace`` is ``True``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:208,contract,contracted,208,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,2,['contract'],['contracted']
Integrability,"""""""; Creates a random CPTP map on an N-dimensional Hilbert space in Kraus; form. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper_list : list of qobj; N^2 x N x N qobj operators. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:385,depend,depending,385,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['depend'],['depending']
Integrability,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:689,depend,dependencies,689,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['depend'],['dependencies']
Integrability,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:44,integrat,integrator,44,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],['integrator']
Integrability,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool [True]; Whether to return a copy of the state or the state itself. Returns; -------; (t, state, noise) : (float, qutip.Data, np.ndarray); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:34,integrat,integrate,34,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,2,['integrat'],['integrate']
Integrability,"""""""; Evolve to t. Before calling `integrate` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:34,integrat,integrate,34,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,2,['integrat'],['integrate']
Integrability,"""""""; Evolve toward the time ``t``. If ``t`` is larger than the present state's ``t``, advance the internal; state toward ``t``. If ``t`` is smaller than the present ``t``, but; larger than the previous one, it does an interpolation step and returns; the state at that time. When advancing the state, it may return it at a; time between present time and the asked ``t`` if more efficent for; subsequent interpolation step. Before calling `mcstep` for the first time, the initial state should; be set with `set_state`. Parameters; ----------; t : float; Time to integrate to, should be larger than the previous time. If; the last integrate call was use with ``step=True``, the time can be; between the time at the start of the last call and now. copy : bool, default: True; Whether to return a copy of the state or the state itself. Returns; -------; (t, state) : (float, qutip.Data); The state of the solver at ``t``. The returned time ``t`` can; differ from the input time only when ``step=True``. .. note:; The default implementation may be overridden by integrators that; can provide a more efficient one.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:560,integrat,integrate,560,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,3,['integrat'],"['integrate', 'integrators']"
Integrability,"""""""; Expect of the state of the evolution to be used in a time-dependent; operator. Not not implemented for FMESolver; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:63,depend,dependent,63,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependent']
Integrability,"""""""; Expectation value of the instantaneous state of the evolution to be; used by a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""E0"": Solver.ExpectFeedback(oper)})``. The ``func`` will receive ``expect(oper, state)`` as ``E0`` during the; evolution. Parameters; ----------; operator : Qobj, QobjEvo; Operator to compute the expectation values of. default : float, default : 0.; Initial value to be used at setup.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:89,depend,dependent,89,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['depend'],['dependent']
Integrability,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; f_energies : np.ndarray; The Floquet energies. kmax : int; The truncation of the number of sidebands (default 5). T : float; The period of the time-dependence of the Hamiltonian. Returns; -------; delta : np.ndarray; Floquet delta tensor.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:220,depend,dependence,220,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependence']
Integrability,"""""""; Floquet-Markov master equation X matrices. Parameters; ----------; floquet_basis : :class:`FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. c_ops : list of :obj:`.Qobj`; The collapse operators describing the dissipation. kmax : int; The truncation of the number of sidebands (default 5). ntimes : int [100]; The number of integration steps (for calculating X) within one period. Returns; -------; X : list of dict of :class:`.Data`; A dict of the sidebands ``k`` for the X matrices of each c_ops; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:134,wrap,wrapped,134,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,"['integrat', 'wrap']","['integration', 'wrapped']"
Integrability,"""""""; Get the inverse of the propagator at ``t``, such that; ``psi_0 = U.inv(t) @ psi_t``. Parameters; ----------; t : float; Time at which to compute the propagator.; args : dict; Argument to pass to a time dependent Hamiltonian.; Updating ``args`` take effect since ``t=0`` and the new ``args``; will be used in future call.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:207,depend,dependent,207,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,1,['depend'],['dependent']
Integrability,"""""""; Get the propagator from ``t_start`` to ``t``. Parameters; ----------; t : float; Time at which to compute the propagator.; t_start: float [0]; Time at which the propagator start such that:; ``psi[t] = U.prop(t, t_start) @ psi[t_start]``; args : dict; Argument to pass to a time dependent Hamiltonian.; Updating ``args`` take effect since ``t=0`` and the new ``args``; will be used in future call.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:283,depend,dependent,283,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,1,['depend'],['dependent']
Integrability,"""""""; HEOM solver that supports multiple baths. The baths must be all either bosonic or fermionic baths. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. Attributes; ----------; ados : :obj:`HierarchyADOs`; The description of the hierarchy constructed from the given bath; and maximum depth. rhs : :obj:`.QobjEvo`; The right-hand side (RHS) of the hierarchy evolution ODE. Internally; the system and bath coupling operators are converted to; :class:`qutip.data.CSR` instances during construction of the RHS,; so the operators in the ``rhs`` will all be sparse.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:177,depend,dependent,177,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['depend'],['dependent']
Integrability,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:410,depend,dependent,410,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['depend'],['dependent']
Integrability,"""""""; Identity operator. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int), Space; Number of basis states in the Hilbert space. If provided as a list of; ints, then the dimension is the product over this list, but the; ``dims`` property of the new Qobj are set to this list. This can; produce either `oper` or `super` depending on the passed `dimensions`. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Identity operator Qobj. Examples; --------; >>> qeye(3) # doctest: +SKIP; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, \; isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, \; isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:352,depend,depending,352,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,1,['depend'],['depending']
Integrability,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:286,integrat,integrator,286,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['integrat'],['integrator']
Integrability,"""""""; Integrator solving the ODE by diagonalizing the system and solving; analytically. It can only solve constant system and has a long preparation; time, but the integration is fast. Usable with ``method=""diag""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:163,integrat,integration,163,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,1,['integrat'],['integration']
Integrability,"""""""; Integrator using Scipy `ode` with dop853 integrator. Eight order; runge-kutta method by Dormand & Prince. Use fortran implementation; from [E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary Differential; Equations i. Nonstiff Problems. 2nd edition. Springer Series in; Computational Mathematics, Springer-Verlag (1993)]. Usable with ``method=""dop853""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:46,integrat,integrator,46,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"""""""; Integrator using Scipy `ode` with lsoda integrator. ODE solver by netlib; (https://www.netlib.org/odepack) Automatically choose between 'Adams' and; 'BDF' methods to solve both stiff and non-stiff systems. Usable with ``method=""lsoda""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"""""""; Integrator using Scipy `ode` with zvode integrator using adams method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""adams""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"""""""; Integrator using Scipy `ode` with zvode integrator using bdf method.; Ordinary Differential Equation solver by netlib; (https://www.netlib.org/odepack). Usable with ``method=""bdf""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:45,integrat,integrator,45,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"""""""; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. .. math::. \\mathcal{D}[a,b]\\rho = a \\rho b^\\dagger -; \\frac{1}{2}a^\\dagger b\\rho - \\frac{1}{2}\\rho a^\\dagger b. Parameters; ----------; a : Qobj or QobjEvo; Left part of collapse operator. b : Qobj or QobjEvo, optional; Right part of collapse operator. If not specified, b defaults to a. chi : float, optional; In some systems it is possible to determine the statistical moments; (mean, variance, etc) of the probability distribution of the occupation; numbers of states by numerically evaluating the derivatives of the; steady state occupation probability as a function of an artificial; phase parameter ``chi`` which multiplies the ``a \\rho a^dagger`` term; of the dissipator by ``e ^ (i * chi)``. The factor ``e ^ (i * chi)`` is; introduced via the generating function of the statistical moments. For; examples of the technique, see `Full counting statistics of; nano-electromechanical systems; <https://arxiv.org/abs/cond-mat/0410322>`_ and `Photon-mediated; electron transport in hybrid circuit-QED; <https://arxiv.org/abs/1303.7449>`_. This parameter is deprecated and; may be removed in QuTiP 5. data_only : bool, default: False; Return the data object instead of a Qobj. Returns; -------; D : qobj, QobjEvo; Lindblad dissipator superoperator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:1116,mediat,mediated,1116,qutip/core/superoperator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py,1,['mediat'],['mediated']
Integrability,"""""""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Deprecated from qutip v5. Use :class:`.FloquetBasis` instead:. f_modes_table_t = fbasis = FloquetBasis(...); f_mode_t = f_modes_table_t.mode(t); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:117,depend,dependence,117,qutip/solver/floquet_bwcomp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py,1,['depend'],['dependence']
Integrability,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`MESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:265,integrat,integrating,265,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,2,"['depend', 'integrat']","['dependent', 'integrating']"
Integrability,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:287,integrat,integrating,287,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integrating']
Integrability,"""""""; Monte Carlo Solver for Lindblad equations with ""rates"" that may be; negative. The ``c_ops`` parameter of :class:`.MCSolver` is replaced by; an ``ops_and_rates`` parameter to allow for negative rates. Options for the; underlying ODE solver are given by the Options class. Parameters; ----------; H : :class:`.Qobj`, :class:`.QobjEvo`, ``list``, callable.; System Hamiltonian as a Qobj, QobjEvo. It can also be any input type; that QobjEvo accepts (see :class:`.QobjEvo` documentation).; ``H`` can also be a superoperator (liouvillian) if some collapse; operators are to be treated deterministically. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. Each rate ``Gamma`` may be; just a number (in the case of a constant rate) or, otherwise, specified; using any format accepted by :func:`qutip.coefficient`. args : None / dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : SolverOptions, [optional]; Options for the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1073,depend,dependent,1073,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['depend'],['dependent']
Integrability,"""""""; Noise used for Ito-Taylor integrators of order up to 1.5.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:31,integrat,integrators,31,qutip/solver/sode/_noise.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py,1,['integrat'],['integrators']
Integrability,"""""""; Numerical integration of the correlation function given an array of; expectation values.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:15,integrat,integration,15,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['integrat'],['integration']
Integrability,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:845,integrat,integration,845,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['integrat'],"['integration', 'integrators']"
Integrability,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1077,integrat,integrator,1077,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['integrat'],['integrator']
Integrability,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:867,integrat,integration,867,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['integrat'],['integration']
Integrability,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:881,integrat,integration,881,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Integrability,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1147,integrat,integration,1147,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['integrat'],['integration']
Integrability,"""""""; Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, QobjEvo compatible format.; System Hamiltonian, with period `T`. T : float; Period of the Hamiltonian. args : None / *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict [None]; Options used by sesolve to compute the floquet modes. sparse : bool [False]; Whether to use the sparse eigen solver when computing the; quasi-energies. sort : bool [True]; Whether to sort the quasi-energies. precompute : list [None]; If provided, a list of time at which to store the propagators; for later use when computing modes and states. Default is; ``linspace(0, T, 101)`` corresponding to the default integration; steps used for the floquet tensor computation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:229,depend,dependent,229,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,"['depend', 'integrat']","['dependent', 'integration']"
Integrability,"""""""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Parameters; ----------; verbose : bool, default: False; Add extra information about install location. Returns; -------; version_table: str; Return an HTML-formatted string containing version information for; QuTiP dependencies. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:75,depend,dependencies,75,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['depend'],['dependencies']
Integrability,"""""""; Refers to ``average_trace`` or ``runs_trace``, depending on whether; ``keep_runs_results`` is set in the options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:52,depend,depending,52,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['depend'],['depending']
Integrability,"""""""; Register an integrator. Parameters; ----------; integrator : Integrator; The ODE solver to register. keys : list of str; Values of the method options that refer to this integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:17,integrat,integrator,17,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,3,['integrat'],['integrator']
Integrability,"""""""; Returns a randomly drawn superoperator acting on operators acting on; N dimensions. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. superrop : str, default: ""super""; Representation of the super operator. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:393,depend,depending,393,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['depend'],['depending']
Integrability,"""""""; Returns the value of the influence martingale along the current; trajectory. The value of the martingale is the product of the; continuous and the discrete contribution. The current time and the; collapses that have happened are read out from the internal integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:261,integrat,integrator,261,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integrator']
Integrability,"""""""; Schrodinger equation evolution of a state vector for time independent; Hamiltonians using Krylov method. Evolve the state vector (""psi0"") finding an approximation for the time; evolution operator of Hamiltonian (""H"") by obtaining the projection of; the time evolution operator on a set of small dimensional Krylov; subspaces (m << dim(H)). The output is either the state vector or unitary matrix at arbitrary points; in time (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. krylov_dim: int; Dimension of Krylov approximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:895,depend,dependent,895,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['depend'],['dependent']
Integrability,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:172,integrat,integrating,172,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,3,"['depend', 'integrat']","['dependent', 'integrating']"
Integrability,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. options : dict, optional; Options for the solver, see :obj:`SESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:206,depend,dependent,206,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['depend'],['dependent']
Integrability,"""""""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state : :class:`.Qobj`; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. Returns; =======; result: list; A dictionary of the type `qutip.piqs.Result` which holds the; results of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:246,integrat,integrate,246,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,1,['integrat'],['integrate']
Integrability,"""""""; Solve stochastic Schrodinger equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:188,depend,dependent,188,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['depend'],['dependent']
Integrability,"""""""; Solve stochastic master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; re",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:183,depend,dependent,183,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['depend'],['dependent']
Integrability,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:749,depend,dependence,749,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependence']
Integrability,"""""""; Solve the dynamics for the system using the Floquet-Markov master equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Wheth",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:545,depend,dependent,545,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependent']
Integrability,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:216,wrap,wrapped,216,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,4,"['depend', 'integrat', 'wrap']","['dependent', 'integration', 'integrator', 'wrapped']"
Integrability,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:834,integrat,integration,834,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['integrat'],['integration']
Integrability,"""""""; Solves for the dynamics of a system using the Bloch-Redfield master; equation, given an input Hamiltonian, Hermitian bath-coupling terms and; their associated spectral functions, as well as possible Lindblad collapse; operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, sta",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:307,depend,dependent,307,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['depend'],['dependent']
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. Not not implemented for FMESolver; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:49,depend,dependent,49,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependent']
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": BRMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. The state will not be in the lab basis, but in the evolution basis. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:49,depend,dependent,49,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,3,"['depend', 'integrat']","['dependent', 'depending', 'integration']"
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MCSolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. open : bool, default False; Set to ``True`` when using the monte carlo solver for open systems. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:49,depend,dependent,49,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,3,"['depend', 'integrat']","['dependent', 'depending', 'integration']"
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": MESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when computing propagators.; The default with take the shape of the propagator instead of a; state. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:49,depend,dependent,49,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,3,"['depend', 'integrat']","['dependent', 'depending', 'integration']"
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SESolver.StateFeedback()})``. The ``func`` will receive the ket as ``state`` during the evolution. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. prop : bool, default : False; Set to True when using sesolve for computing propagators. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:49,depend,dependent,49,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,3,"['depend', 'integrat']","['dependent', 'depending', 'integration']"
Integrability,"""""""; State of the evolution to be used in a time-dependent operator. When used as an args:. ``QobjEvo([op, func], args={""state"": SMESolver.StateFeedback()})``. The ``func`` will receive the density matrix as ``state`` during the; evolution. .. note::. Not supported by the ``rouchon`` mehtod. Parameters; ----------; default : Qobj or qutip.core.data.Data, default : None; Initial value to be used at setup of the system. raw_data : bool, default : False; If True, the raw matrix will be passed instead of a Qobj.; For density matrices, the matrices can be column stacked or square; depending on the integration method. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:49,depend,dependent,49,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,3,"['depend', 'integrat']","['dependent', 'depending', 'integration']"
Integrability,"""""""; Stochastic integration method keeping the positivity of the density matrix.; See eq. (4) Pierre Rouchon and Jason F. Ralpha,; *Efficient Quantum Filtering for Quantum Feedback Control*,; `arXiv:1410.5345 [quant-ph] <https://arxiv.org/abs/1410.5345>`_,; Phys. Rev. A 91, 012118, (2015). - Order: strong 1. Notes; -----; This method should be used with very small ``dt``. Unlike other; methods that will return unphysical state (negative eigenvalues, Nans); when the time step is too large, this method will return state that; seems normal.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py:16,integrat,integration,16,qutip/solver/sode/rouchon.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/rouchon.py,1,['integrat'],['integration']
Integrability,"""""""; Supported options by dop853 integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic). ifactor, dfactor : float, default: 6., 0.3; Maximum factor to increase/decrease step size by in one step. beta : float, default: 0; Beta parameter for stabilised step size control. See scipy.integrate.ode ode for more detail; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:33,integrat,integrator,33,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],"['integrate', 'integrator']"
Integrability,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:841,integrat,integrator,841,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['integrat'],['integrator']
Integrability,"""""""; Supported options by lsoda integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. nsteps : int, default: 2500; Max. number of internal steps/call. max_order_ns : int, default: 12; Maximum order used in the nonstiff case (<= 12). max_order_s : int, default: 5; Maximum order used in the stiff case (<= 5). first_step : float, default: 0; Size of initial step (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped. min_step : float, default: 0; Minimum step size (0 = automatic); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,integrat,integrator,32,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"""""""; Supported options by zvode integrator:. atol : float, default: 1e-8; Absolute tolerance. rtol : float, default: 1e-6; Relative tolerance. order : int, default: 12, 'adams' or 5, 'bdf'; Order of integrator <=12 'adams', <=5 'bdf'. nsteps : int, default: 2500; Max. number of internal steps/call. first_step : float, default: 0; Size of initial step (0 = automatic). min_step : float, default: 0; Minimum step size (0 = automatic). max_step : float, default: 0; Maximum step size (0 = automatic); When using pulses, change to half the thinest pulse otherwise it; may be skipped.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:32,integrat,integrator,32,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['integrat'],['integrator']
Integrability,"""""""; Test correlations with time-dependent operators using a two-level system; (2LS) or a three-level system (3LS).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:33,depend,dependent,33,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['depend'],['dependent']
Integrability,"""""""; Test that `mcsolve` correctly solves the system when the collapse operators; are time-dependent.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:91,depend,dependent,91,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,1,['depend'],['dependent']
Integrability,"""""""; Test that nm_mcsolve correctly solves the system when the; collapse rates are time-dependent.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:88,depend,dependent,88,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['depend'],['dependent']
Integrability,"""""""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:72,rout,routines,72,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['rout'],['routines']
Integrability,"""""""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py:57,depend,depending,57,qutip/distributions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/distributions.py,1,['depend'],['depending']
Integrability,"""""""; Wiener function of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""W"": SMESolver.WienerFeedback()})``. The ``func`` will receive a function as ``W`` that return an array of; wiener processes values at ``t``. The wiener process for the i-th; sc_ops is the i-th element for homodyne detection and the (2i, 2i+1); pairs of process in heterodyne detection. The process is a step; function with step of length ``options[""dt""]``. .. note::. WienerFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, optional; Default function used outside the solver.; When not passed, a function returning ``np.array([0])`` is used. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:57,depend,dependent,57,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['depend'],['dependent']
Integrability,"""""""; Zero operator. Parameters; ----------; dimensions : int, list of int, list of list of int, Space; Number of basis states in the Hilbert space. If provided as a list of; ints, then the dimension is the product over this list, but the; ``dims`` property of the new Qobj are set to this list. This can; produce either `oper` or `super` depending on the passed `dimensions`. dims_right : int, list of int, list of list of int, Space, optional; Number of basis states in the right Hilbert space when the operator is; rectangular. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; qzero : qobj; Zero operator Qobj. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:338,depend,depending,338,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,1,['depend'],['depending']
Integrability,"""""""; method: str; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:55,integrat,integration,55,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integration']
Integrability,"""""""Build ``Coefficient`` for time dependent systems:. ```; QobjEvo = Qobj + Qobj * Coefficient + Qobj * Coefficient + ...; ```. The coefficients can be a function, a string or a numpy array. Other; packages may add support for other kind of coefficients. For function based coefficients, the function signature must be either:. * ``f(t, ...)`` where the other arguments are supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline int",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:34,depend,dependent,34,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['depend'],['dependent']
Integrability,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:913,integrat,integrator,913,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['integrat'],['integrator']
Integrability,"""""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------; qobj: Qobj; Operator to contract subspaces on. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:195,contract,contract,195,qutip/core/tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py,3,['contract'],"['contract', 'contracted']"
Integrability,"""""""Creates a random ket vector. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 1; Density between [0,1] of output ket state when using the ``fill``; method. distribution : str {""haar"", ""fill""}, default: ""haar""; Method used to obtain the kets. - haar : Haar random pure state obtained by applying a Haar random; unitary to a fixed pure state.; - fill : Fill the ket with uniformly distributed random complex number. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Ket quantum state vector.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:336,depend,depending,336,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['depend'],['depending']
Integrability,"""""""Creates a random sparse Hermitian quantum object. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 0.30; Density between [0,1] of output Hermitian operator. distribution : str {""fill"", ""pos_def"", ""eigen""}, default: ""fill""; Method used to obtain the density matrices. - ""fill"" : Uses :math:`H=0.5*(X+X^{+})` where :math:`X` is a randomly; generated quantum operator with elements uniformly distributed; between ``[-1, 1] + [-1j, 1j]``.; - ""eigen"" : A density matrix with the given ``eigenvalues``. It uses; random complex Jacobi rotations to shuffle the operator.; - ""pos_def"" : Return a positive semi-definite matrix by diagonal; dominance. eigenvalues : array_like, optional; Eigenvalues of the output Hermitian matrix. The len must match the; shape of the matrix. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : :obj:`.Qobj`; Hermitian quantum operator. Notes; -----; If given a list of eigenvalues the object is created using complex Jacobi; rotations. While this method is fast for small matrices, it should not be; repeatedly used for generating matrices larger than ~1000x1000.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:357,depend,depending,357,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['depend'],['depending']
Integrability,"""""""Error from the ODE solver being unable to integrate with the given; parameters. Example; -------; - The solver cannot reach the desired tolerance within the maximum number; of steps.; - The step needed to be within desired tolerance is too small.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:45,integrat,integrate,45,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrate']
Integrability,"""""""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists or a dimension object,; flattens it down to a list of the scalars within the original list. Parameters; ----------; l : scalar, list, Space, Dimension; Object to flatten. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. Notes; -----; Any scalar will be returned wrapped in a list: ``flaten(1) == [1]``.; A non-list iterable will not be treated as a list by flatten. For example, flatten would treat a tuple; as a scalar.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py:388,wrap,wrapped,388,qutip/core/dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/dimensions.py,1,['wrap'],['wrapped']
Integrability,"""""""Generates a random stochastic matrix. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the ``dims`` property of; the new Qobj are set to this list. This can produce either `oper` or; `super` depending on the passed `dimensions`. density : float, default: 0.75; Density between [0,1] of output density matrix. kind : str {""left"", ""right""}, default: ""left""; Generate 'left' or 'right' stochastic matrix. seed : int, SeedSequence, Generator, optional; Seed to create the random number generator or a pre prepared; generator. When none is suplied, a default generator is used. dtype : type or str, optional; Storage representation. Any data-layer known to ``qutip.data.to`` is; accepted. Returns; -------; oper : qobj; Quantum operator form of stochastic matrix.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:345,depend,depending,345,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['depend'],['depending']
Integrability,"""""""ODE integrator from scipy.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:7,integrat,integrator,7,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integrator']
Integrability,"# Calculate the analytical results by numerical integration",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,integrat,integration,48,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,2,['integrat'],['integration']
Integrability,"# Can evolve time dependent system",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,depend,dependent,18,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['depend'],['dependent']
Integrability,"# Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:147,contract,contracting,147,qutip/core/tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py,1,['contract'],['contracting']
Integrability,"# Create the floquet system for the time-dependent hamiltonian",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex1.py:41,depend,dependent,41,doc/guide/scripts/floquet_ex1.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex1.py,1,['depend'],['dependent']
Integrability,"# Don't normalize output if input is not normalized.; # Use the settings atol instead of the solver one since the second; # refer to the ODE tolerance and some integrator do not use it.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:160,integrat,integrator,160,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Integrability,"# Evolving backward in time is not supported by all integrator.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:52,integrat,integrator,52,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,1,['integrat'],['integrator']
Integrability,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:119,message,messages,119,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['message'],['messages']
Integrability,"# Here we want to advance up to t doing maximum one step.; # lsoda officially support step, but sometime it does more work than; # needed, so we ask it to advance a fraction of the last step, where it; # will advance one internal step of length allowed by the tolerance and; # interpolate back to the asked time, effictively getting the single; # integration step we want. The first step and abrupt changes in the; # `rhs` can cause exceptions to this, but _backstep catch those cases.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:347,integrat,integration,347,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integration']
Integrability,"# In development (at least for QuTiP ~4.5 and ~5.0) sometimes the; # Cythonised time-dependent coefficients would get dropped in the; # qutip directory if you weren't careful - this is just trying to; # minimise the occasional developer error.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:85,depend,dependent,85,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['depend'],['dependent']
Integrability,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:14,depend,dependent,14,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,4,['depend'],"['dependent', 'dependents']"
Integrability,"# Iteratively integrate to obtain single value",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:14,integrat,integrate,14,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['integrat'],['integrate']
Integrability,"# Let's try a weird tensor contraction; this will likely never come up in; # practice, but it should serve as a good canary for more reasonable; # contractions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py:27,contract,contraction,27,qutip/tests/core/test_tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_tensor.py,2,['contract'],"['contraction', 'contractions']"
Integrability,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:48,interface,interfaces,48,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,10,"['integrat', 'interface']","['integrate', 'interface', 'interfaces']"
Integrability,"# Options should be overwritten by each integrators.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:40,integrat,integrators,40,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrators']
Integrability,"# Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:13,contract,contracted,13,qutip/core/tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py,1,['contract'],['contracted']
Integrability,"# Set error messages",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py:12,message,messages,12,qutip/_mkl/spsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/_mkl/spsolve.py,1,['message'],['messages']
Integrability,"# Some matrices _cannot_ be unsorted (e.g. if they have only one entry; # per row), so we add in this additional assertion message just to help; # out.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:123,message,message,123,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['message'],['message']
Integrability,"# Some of the keys are used by the integrator.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:35,integrat,integrator,35,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['integrat'],['integrator']
Integrability,"# TODO: It would be nice if integrator could give evolution statistics; # stats.update(_integrator.stats)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:28,integrat,integrator,28,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,2,['integrat'],['integrator']
Integrability,"# TODO: revisit when creation routines have dispatching.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:30,rout,routines,30,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,1,['rout'],['routines']
Integrability,"# TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:65,depend,dependencies,65,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['depend'],['dependencies']
Integrability,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:178,integrat,integrator,178,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Integrability,"# The name of the integrator",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:18,integrat,integrator,18,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrator']
Integrability,"# The objective, however, depends on J.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:26,depend,depends,26,qutip/core/semidefinite.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py,2,['depend'],['depends']
Integrability,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:20,depend,dependencies,20,qutip/core/superoperator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py,4,['depend'],['dependencies']
Integrability,"# When the Hamiltonian is time-dependent, the transformation of `L` to; # eigenbasis is not optimized.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:31,depend,dependent,31,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,1,['depend'],['dependent']
Integrability,"# Whether the integrator used the system QobjEvo as a blackbox",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:14,integrat,integrator,14,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['integrat'],['integrator']
Integrability,"# While DOP853 support changing the direction of the integration,; # it does not do so efficiently. We do it manually.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:53,integrat,integration,53,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['integrat'],['integration']
Integrability,"# axis_idxs.index effectively evaluates the mapping from original index; # labels to the labels after contraction.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py:102,contract,contraction,102,qutip/core/tensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/tensor.py,1,['contract'],['contraction']
Integrability,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:1067,depend,depends,1067,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['depend'],['depends']
Integrability,"# find the floquet modes for the time-dependent hamiltonian",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex2.py:38,depend,dependent,38,doc/guide/scripts/floquet_ex2.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/floquet_ex2.py,1,['depend'],['dependent']
Integrability,"# mesolve integration for comparison",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:10,integrat,integration,10,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['integrat'],['integration']
Integrability,"# nm_mcsolve integration",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,integrat,integration,13,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['integrat'],['integration']
Integrability,"#IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:18,rout,routines,18,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['rout'],['routines']
Integrability,", float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; result",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4390,depend,depending,4390,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,2,"['depend', 'integrat']","['depending', 'integration']"
Integrability,"; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list conta",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3644,integrat,integration,3644,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integration']
Integrability,"Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1080,depend,dependent,1080,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['depend'],['dependent']
Integrability,"`None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of the simulation run, with the following important; attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if the results option ``ado_return`` was set to ``True``).; Each element is an instance of :class:`HierarchyADOsState`.; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`extract`. * ``expect``: a list containing the values of each ``e_ops`` at; time ``t``. * ``e_data``: a dic",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3741,integrat,integrator,3741,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['integrat'],['integrator']
Integrability,"ator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:1750,depend,dependent,1750,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['depend'],['dependent']
Integrability,"ator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method t",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:2639,depend,dependent,2639,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['depend'],['dependent']
Integrability,"e recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1746,depend,dependent,1746,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['depend'],['dependent']
Integrability,"e supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspli",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1356,interface,interface,1356,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,2,['interface'],['interface']
Integrability,"e.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation values for the times specified; by ``tlist``, and/or a *list* ``result.states`` of state vectors or; density matrices corresponding to the times in ``tlist`` [if ``e_ops``; is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2701,integrat,integration,2701,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,4,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Integrability,"esponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progres",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2239,depend,dependent,2239,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['depend'],['dependent']
Integrability,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2612,integrat,integration,2612,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integration']
Integrability,"ject represents a map, and if that map is; completely positive (CP).; ishp : bool; Indicates if the quantum object represents a map, and if that map is; hermicity preserving (HP).; istp : bool; Indicates if the quantum object represents a map, and if that map is; trace preserving (TP).; iscptp : bool; Indicates if the quantum object represents a map that is completely; positive and trace preserving (CPTP).; isket : bool; Indicates if the quantum object represents a ket.; isbra : bool; Indicates if the quantum object represents a bra.; isoper : bool; Indicates if the quantum object represents an operator.; issuper : bool; Indicates if the quantum object represents a superoperator.; isoperket : bool; Indicates if the quantum object represents an operator in column vector; form.; isoperbra : bool; Indicates if the quantum object represents an operator in row vector; form. Methods; -------; copy(); Create copy of Qobj; conj(); Conjugate of quantum object.; contract(); Contract subspaces of the tensor structure which are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:2611,contract,contract,2611,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['contract'],['contract']
Integrability,"keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``nor",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2666,integrat,integrator,2666,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['integrat'],['integrator']
Integrability,"llapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_o",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1066,depend,dependent,1066,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['depend'],['dependent']
Integrability,"n. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectat",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:1109,depend,dependent,1109,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['depend'],['dependent']
Integrability,"nitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1350,integrat,integration,1350,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['integrat'],['integration']
Integrability,"ouple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:1664,depend,dependent,1664,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['depend'],['dependent']
Integrability,"r equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 / psi0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of :class:`.Qobj`, optional; List of collapse operators. Time dependent collapse operators are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``r",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1081,depend,dependence,1081,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependence']
Integrability,"r the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); Single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store t",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1783,depend,dependent,1783,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['depend'],['dependent']
Integrability,"rs are not; supported. Fall back on :func:`fsesolve` if not provided. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values.; The states are reverted to the lab basis before applying the. spectra_cb : list callback functions, default: ``lambda w: (w > 0)``; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. The default value; ``0`` indicates that the 'tlist' spans a single period of the driving. w_th : float, default: 0.0; The temperature of the environment in units of frequency.; For example, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:1589,depend,dependent,1589,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['depend'],['dependent']
Integrability,"s given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by ``tlist``, and/or the; state density matrices corresponding to the times.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2672,integrat,integration,2672,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,4,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Integrability,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2506,integrat,integrator,2506,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,2,['integrat'],['integrator']
Integrability,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3371,integrat,integration,3371,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,6,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Integrability,"ty matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density matrix or state vector (ket). tlist : *l",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:1034,depend,dependent,1034,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['depend'],['dependent']
Integrability,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3124,integrat,integration,3124,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,6,"['depend', 'integrat']","['depending', 'integration', 'integrator']"
Modifiability," `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation valu",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:2311,enhance,enhanced,2311,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['enhance'],['enhanced']
Modifiability," to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:4128,adapt,adaptive,4128,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['adapt'],['adaptive']
Modifiability,"""""""; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:174,coupling,coupling,174,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing a Lorentzian fermionic bath from the; bath parameters (see parameters below). .. note::. This Matsubara expansion used in this bath converges very slowly; and ``Nk > 20`` may be required to get good convergence. The; Padé expansion used by :class:`LorentzianPadeBath` converges much; more quickly. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:393,coupling,coupling,393,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:832,coupling,coupling,832,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Padé exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:780,coupling,coupling,780,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function. If the correlation functions ``C(t)`` is split into real and imaginary; parts::. C(t) = C_real(t) + i * C_imag(t). then::. C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ``ck`` and the frequencies ``vk``. Note that the ``ck`` and ``vk`` may be complex, even through ``C_real(t)``; and ``C_imag(t)`` (i.e. the sum) is real. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_real : list of complex; The coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_real : list of complex; The frequencies (exponents) of the expansion terms for the real part of; the correlation function. The corresponding ceofficients are passed as; ck_real. ck_imag : list of complex; The coefficients of the expansion terms in the imaginary part of the; correlation function. The corresponding frequencies are passed as; vk_imag. vk_imag : list of complex; The frequencies (exponents) of the expansion terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:602,coupling,coupling,602,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing a fermionic bath from the expansion; coefficients and frequencies for the ``+`` and ``-`` modes of; the bath correlation function. There must be the same number of ``+`` and ``-`` modes and their; coefficients must be specified in the same order so that ``ck_plus[i],; vk_plus[i]`` are the plus coefficient and frequency corresponding; to the minus mode ``ck_minus[i], vk_minus[i]``. In the fermionic case the order in which excitations are created or; destroyed is important, resulting in two different correlation functions; labelled ``C_plus(t)`` and ``C_plus(t)``::. C_plus(t) = sum(ck_plus * exp(- vk_plus * t)); C_minus(t) = sum(ck_minus * exp(- vk_minus * t)). where the expansions above define the coeffiients ``ck`` and the; frequencies ``vk``. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_plus : list of complex; The coefficients of the expansion terms for the ``+`` part of the; correlation function. The corresponding frequencies are passed as; vk_plus. vk_plus : list of complex; The frequencies (exponents) of the expansion terms for the ``+`` part; of the correlation function. The corresponding ceofficients are passed; as ck_plus. ck_minus : list of complex; The coefficients of the expansion terms for the ``-`` part of the; correlation function. The corresponding frequencies are passed as; vk_minus. vk_minus : list of complex; The frequencies (exponents) of the expansion terms for the ``-`` part; of the correlation function. The corresponding ceofficients are passed; as ck_minus. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:829,coupling,coupling,829,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['coupling'],['coupling']
Modifiability,"""""""; A helper class for constructing an under-damped bosonic bath from the; bath parameters (see parameters below). Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. w0 : float; Bath spectral density resonance frequency. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:174,coupling,coupling,174,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,2,['coupling'],['coupling']
Modifiability,"""""""; A wrapper around ODE solvers.; It ensures a common interface for Solver usage.; It takes and return states as :class:`.Data`, it may return; a different data-type than the input type. Parameters; ----------; system: qutip.QobjEvo; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:267,evolve,evolve,267,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['evolve'],['evolve']
Modifiability,"""""""; A wrapper around stochastic ODE solvers. Parameters; ----------; system: qutip.StochasticSystem; Quantum system in which states evolve. options: dict; Options for the integrator. Class Attributes; ----------------; name : str; The name of the integrator. supports_blackbox : bool; If True, then the integrator calls only ``system.matmul``,; ``system.matmul_data``, ``system.expect``, ``system.expect_data`` and; ``isconstant``, ``isoper`` or ``issuper``. This allows the solver using; the integrator to modify the system in creative ways. In particular,; the solver may modify the system depending on *both* the time ``t``; *and* the current ``state`` the system is being applied to. If the integrator calls any other methods, set to False. supports_time_dependent : bool; If True, then the integrator supports time dependent systems. If False,; ``supports_blackbox`` should usually be ``False`` too. integrator_options : dict; A dictionary of options used by the integrator and their default; values. Once initiated, ``self.options`` will be a dict with the same; keys, not the full options object passed to the solver. Options' keys; included here will be supported by the :cls:SolverOdeOptions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:133,evolve,evolve,133,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,1,['evolve'],['evolve']
Modifiability,"""""""; Add the 'openmp' option to the collection, based on the passed command-line; arguments or environment variables. If using PEP517 builds, one can pass these options on the command-line; using, for example:. python -m build \; --wheel \; --config-setting=""--global-option=--with-openmp""; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:107,variab,variables,107,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,2,"['config', 'variab']","['config-setting', 'variables']"
Modifiability,"""""""; An enhanced text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:8,enhance,enhanced,8,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Bloch Redfield equation evolution of a density matrix for a given; Hamiltonian and set of bath coupling operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`; The corresponding bath spectra. As a `Coefficient` using an 'w'; args. Can depend on ``t`` only if a_op is a :obj:`.QobjEvo`.; :obj:`SpectraCoefficient` can be used to conver a coefficient; depending on ``t`` to one depending on ``w``. Example:. .. code-block::. a_ops = [; (a+a.dag(), coefficient('w>0', args={'w':0})),; (QobjEvo([b+b.dag(), lambda t: ...]),; coefficient(lambda t, w: ...), args={""w"": 0}),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list of :obj:`.Qobj`, :obj:`.QobjEvo`; Single collapse operator, or list of collapse operators, or a list; of Lindblad dissipator. None is equivalent to an empty list. options : dict, optional; Options for the solver, see :obj:`BRSolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. Attributes; ----------; stats: dict; Diverse diagnostic statistics of the evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:100,coupling,coupling,100,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,3,['coupling'],['coupling']
Modifiability,"""""""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. .. note ::. Deprecated. For the Floquet-Markov master equation's tensor, use; :func:`floquet_tensor`. For the rates matrices, use; :func:`floquet_delta_tensor`, :func:`floquet_X_matrices`,; :func:`floquet_gamma_matrices` and/or s:func:`floquet_A_matrix`. Parameters; ----------; f_modes_0 : Any; No longer used.; f_energies : Any; No longer used.; c_op : :class:`.Qobj`; The collapse operators describing the dissipation.; H : :class:`.Qobj`; System Hamiltonian, time-dependent with period `T`.; T : float; The period of the time-dependence of the hamiltonian.; args : dictionary; Dictionary with variables required to evaluate H.; J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`.; w_th : float; The temperature in units of frequency.; kmax : int, default=5; The truncation of the number of sidebands.; f_modes_table_t : Any; No longer used. Returns; -------; output : list; A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py:683,variab,variables,683,qutip/solver/floquet_bwcomp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet_bwcomp.py,1,['variab'],['variables']
Modifiability,"""""""; Calculates the Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system's coupling to its environment. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used; for array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. c_ops : list; List of system collapse operators. sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :class:`qutip.Qobj`, tuple of :class:`qutip.Qobj`; If ``fock_basis``, return the Bloch Redfield tensor in the laboratory; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:147,coupling,coupling,147,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,3,['coupling'],['coupling']
Modifiability,"""""""; Calculates the contribution of one coupling operator to the Bloch-Redfield; tensor. Parameters; ----------. H : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; System Hamiltonian. a_op : :class:`qutip.Qobj`, :class:`qutip.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, func, str; The corresponding bath spectra.; Can be a :obj:`.Coefficient` using an 'w' args, a function of the; frequency or a string. The :class:`SpectraCoefficient` can be used for; array based coefficient.; The spectra can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. coefficient('w>0', args={""w"": 0}); SpectraCoefficient(coefficient(array, tlist=...)). sec_cutoff : float {0.1}; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. fock_basis : bool {False}; Whether to return the tensor in the input basis or the diagonalized; basis. sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver on the Hamiltonian. br_dtype : ['sparse', 'dense', 'data']; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. Returns; -------; R, [evecs]: :obj:`.Qobj`, :obj:`.QobjEvo` or tuple; If ``fock_basis``, return the Bloch Redfield tensor in the outside; basis. Otherwise return the Bloch Redfield tensor in the diagonalized; Hamiltonian basis and the eigenvectors of the Hamiltonian as hstacked; column. The tensors and, if given, evecs, will be :obj:`.QobjEvo` if; the ``H`` and ``a_op`` is time dependent, :obj:`.Qobj` otherwise.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:40,coupling,coupling,40,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,3,['coupling'],['coupling']
Modifiability,"""""""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:104,extend,extend,104,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,1,['extend'],['extend']
Modifiability,"""""""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py:123,extend,extend,123,qutip/core/superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superop_reps.py,1,['extend'],['extend']
Modifiability,"""""""; Create a cyclic colormap for representing the phase of complex variables. Returns; -------; cmap :; A matplotlib linear segmented colormap.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py:68,variab,variables,68,qutip/matplotlib_utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py,1,['variab'],['variables']
Modifiability,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. args : dict, optional {None}; Update the ``args`` of the system.; The change is effective from the beginning of the interval.; Changing ``args`` can slow the evolution. copy : bool, optional {True}; Whether to return a copy of the data or the data in the ODE solver. Notes; -----; The state must be initialized first by calling :meth:`start` or; :meth:`run`. If :meth:`run` is called, :meth:`step` will continue from; the last time and state obtained. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py:115,evolve,evolve,115,qutip/solver/solver_base.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/solver_base.py,1,['evolve'],['evolve']
Modifiability,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. args : dict, optional; Update the ``args`` of the system.; The change is effective from the beginning of the interval.; Changing ``args`` can slow the evolution. copy : bool, default: True; Whether to return a copy of the data or the data in the ODE solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:115,evolve,evolve,115,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,1,['evolve'],['evolve']
Modifiability,"""""""; Evolve the state to ``t`` and return the state as a :obj:`.Qobj`. Parameters; ----------; t : double; Time to evolve to, must be higher than the last call. copy : bool, optional {True}; Whether to return a copy of the data or the data in the ODE solver. floquet : bool, optional {False}; Whether to return the state in the floquet basis or laboratory; basis. args : dict, optional {None}; Not supported. Notes; -----; The state must be initialized first by calling ``start`` or; ``run``. If ``run`` is called, ``step`` will continue from the last; time and state obtained.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:115,evolve,evolve,115,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['evolve'],['evolve']
Modifiability,"""""""; Function to solve for an open quantum system using the; reaction coordinate (RC) model. Parameters; ----------; Hsys: Qobj; The system hamiltonian.; psi0: Qobj; Initial state of the system.; tlist: List.; Time over which system evolves.; e_ops: list of :class:`.Qobj` / callback function single; Single operator or list of operators for which to evaluate; expectation values.; Q: Qobj; The coupling between system and bath.; wc: Float; Cutoff frequency.; alpha: Float; Coupling strength.; N: Integer; Number of cavity fock states.; w_th: Float; Temperature.; sparse: Boolean; Optional argument to call the sparse eigenstates solver if needed.; options : dict; Options for the solver. Returns; -------; output: Result; System evolution.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py:233,evolve,evolves,233,qutip/legacy/rcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py,2,"['coupling', 'evolve']","['coupling', 'evolves']"
Modifiability,"""""""; Get a boolean value from the environment variable `var`. This evalutes to; `default` if the environment variable is not present. The false-y values; are '0', 'false', 'none' and empty string, insensitive to case. All other; values are truth-y.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:46,variab,variable,46,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,2,['variab'],['variable']
Modifiability,"""""""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:187,coupling,coupling,187,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,3,['coupling'],['coupling']
Modifiability,"""""""; HEOM solver that supports multiple baths. The baths must be all either bosonic or fermionic baths. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. Attributes; ----------; ados : :obj:`HierarchyADOs`; The description of the hierarchy constructed from the given bath; and maximum depth. rhs : :obj:`.QobjEvo`; The right-hand side (RHS) of the hierarchy evolution ODE. Internally; the system and bath coupling operators are converted to; :class:`qutip.data.CSR` instances during construction of the RHS,; so the operators in the ``rhs`` will all be sparse.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:515,coupling,coupling,515,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['coupling'],['coupling']
Modifiability,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:748,coupling,coupling,748,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,"""""""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (``rho0``) using a given; Hamiltonian or Liouvillian (``H``) and an optional set of collapse operators; (``c_ops``), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. If either ``H`` or the Qobj elements in ``c_ops`` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. **Additional options**. Additional options to mesolve can be set via the ``options`` argument. Many; ODE integration options can be set this way, and the ``store_states`` and; ``store_final_state`` options can be used to store states even though; expectation values are requested via the ``e_ops`` argument. Notes; -----; When no collapse operator are given and the `H` is not a superoperator,; it will defer to :func:`sesolve`. Parameters; ----------. H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. rho0 : :obj:`.Qobj`; initial density ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:419,evolve,evolved,419,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['evolve'],['evolved']
Modifiability,"""""""; Options for HEOMSolver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use. state_data_type: str, default: ""dense""; Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrators; support only work with `Dense`. store_ados : bool, default: False; Whether or not to store the HEOM ADOs. Only relevant when using; the HEOM solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:445,enhance,enhanced,445,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Options for bloch redfield solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: False; Normalize output state to hide ODE numerical errors. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error if; not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. tensor_type: str ['sparse', 'dense', 'data'], default: ""sparse""; Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient. sparse_eigensolver: bool, default: False; Whether to use the sparse eigensolver. method: str, default: ""adams""; Which ODE integrator methods are supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:456,enhance,enhanced,456,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Options for monte carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:360,enhance,enhanced,360,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Options for non-Markovian Monte Carlo solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum numbe",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:374,enhance,enhanced,374,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:562,enhance,enhanced,562,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Uses the mpi4py module to execute the tasks asynchronously with MPI; processes. For more information, consult the documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All rema",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:666,variab,variable,666,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,2,['variab'],['variable']
Modifiability,"""""""; Photon scattering in quantum optical systems. This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py:187,config,configuration,187,qutip/solver/scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/scattering.py,1,['config'],['configuration']
Modifiability,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 7. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern7""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:124,variab,variable,124,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,1,['variab'],['variable']
Modifiability,"""""""; QuTiP's implementation of Verner's ""most efficient"" Runge-Kutta method; of order 9. These are Runge-Kutta methods with variable steps and dense; output. The implementation uses QuTiP's Data objects for the state, allowing; sparse, GPU or other data layer objects to be used efficiently by the; solver in their native formats. See https://www.sfu.ca/~jverner/ for a detailed description of the; methods. Usable with ``method=""vern9""``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py:124,variab,variable,124,qutip/solver/integrator/qutip_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/qutip_integrator.py,1,['variab'],['variable']
Modifiability,"""""""; Read the code and rewrite it in a reutilisable form:; Ins:; '2.*cos(a*t)', {""a"":5+1j}; Outs:; code = 'self._cte_dbl0 * cos ( self._arg_cpl0 * t )'; variables = [('self._arg_cpl0', 'a', 'complex')]; ordered_constants = [('self._cte_dbl0', 2, 'double')]; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:23,rewrite,rewrite,23,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,2,"['rewrite', 'variab']","['rewrite', 'variables']"
Modifiability,"""""""; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian. Evolve the state vector (``psi0``) using a given; Hamiltonian (``H``), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. **Time-dependent operators**. For time-dependent problems, ``H`` and ``c_ops`` can be a :obj:`.QobjEvo`; or object that can be interpreted as :obj:`.QobjEvo` such as a list of; (Qobj, Coefficient) pairs or a function. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :obj:`.Qobj`; initial state vector (ket); or initial unitary operator `psi0 = U`. tlist : *list* / *array*; list of times for :math:`t`. e_ops : :obj:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:266,evolve,evolve,266,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['evolve'],['evolve']
Modifiability,"""""""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; Periodic system Hamiltonian as :obj:`.QobjEvo`. List of; [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). If an operator is provided,. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`.Qobj` / callback function, optional; List of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float, default=tlist[-1]; The period of the time-dependence of the hamiltonian. args : dictionary, optional; Dictionary with variables required to evaluate H. options : dict, optional; Options for the results. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized. Returns; -------; output : :class:`.Result`; An instance of the class :class:`.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:825,variab,variables,825,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['variab'],['variables']
Modifiability,"""""""; Solver's options:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. normalize_output: bool, default: True; Normalize output state to hide ODE numerical errors. progress_bar: str {""text"", ""enhanced"", ""tqdm"", """"}, default: """"; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"": 10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. method: str, default: ""adams""; Which ordinary differential equation integration method to use.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py:438,enhance,enhanced,438,qutip/solver/sesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sesolve.py,1,['enhance'],['enhanced']
Modifiability,"""""""; Solves for the dynamics of a system using the Bloch-Redfield master; equation, given an input Hamiltonian, Hermitian bath-coupling terms and; their associated spectral functions, as well as possible Lindblad collapse; operators. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list of (a_op, spectra); Nested list of system operators that couple to the environment,; and the corresponding bath spectra. a_op : :obj:`.Qobj`, :obj:`.QobjEvo`; The operator coupling to the environment. Must be hermitian. spectra : :obj:`.Coefficient`, str, func; The corresponding bath spectral responce.; Can be a `Coefficient` using an 'w' args, a function of the; frequence or a string. Coefficient build from a numpy array are; understood as a function of ``w`` instead of ``t``. Function are; expected to be of the signature ``f(w)`` or ``f(t, w, **args)``. The spectra function can depend on ``t`` if the corresponding; ``a_op`` is a :obj:`.QobjEvo`. Example:. .. code-block::. a_ops = [; (a+a.dag(), ('w>0', args={""w"": 0})),; (QobjEvo(a+a.dag()), 'w > exp(-t)'),; (QobjEvo([b+b.dag(), lambda t: ...]), lambda w: ...)),; (c+c.dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, sta",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:127,coupling,coupling,127,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,2,['coupling'],['coupling']
Modifiability,"""""""; Test Floquet-Markov Master Equation for a two-level system; subject to dissipation with multiple coupling operators; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py:102,coupling,coupling,102,qutip/tests/solver/test_floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py,1,['coupling'],['coupling']
Modifiability,"""""""; Test that the BR solver handles collapse and coupling operators correctly; relative to the standard ME solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py:50,coupling,coupling,50,qutip/tests/solver/test_brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_brmesolve.py,1,['coupling'],['coupling']
Modifiability,"""""""; The Permutation Invariant Matrix class. Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state `p` as:. dp/dt = Mp. Parameters; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. Attributes; ----------; N: int; The number of two-level systems. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; Collective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: float; Collective dephasing coefficient.; default: 0.0. collective_pumping: float; Collective pumping coefficient.; default: 0.0. M: dict; A nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:139,evolve,evolves,139,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,1,['evolve'],['evolves']
Modifiability,"""""""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:76,variab,variable,76,qutip/continuous_variables.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py,1,['variab'],['variable']
Modifiability,"""""""; This module contains utility functions that enhance Matplotlib; in one way or another.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py:49,enhance,enhance,49,qutip/matplotlib_utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/matplotlib_utilities.py,1,['enhance'],['enhance']
Modifiability,"""""""Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters; ----------; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns; -------; cg_coeff : float; Requested Clebsch-Gordan coefficient. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py:50,coupling,coupling,50,qutip/utilities.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/utilities.py,1,['coupling'],['coupling']
Modifiability,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:267,coupling,coupling,267,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,2,['coupling'],['coupling']
Modifiability,"""""""Look for floating and complex constants and replace them with variable.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:65,variab,variable,65,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['variab'],['variable']
Modifiability,"""""""This tests ensures that expect still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:175,layers,layers,175,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['layers'],['layers']
Modifiability,"""""""This tests ensures that trace still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:174,layers,layers,174,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['layers'],['layers']
Modifiability,"""""""replace the constant following a pattern with variable""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:49,variab,variable,49,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['variab'],['variable']
Modifiability,"""""""takes the density matrix or state vector of any finite state and; generates the Wigner function for that state on a sphere, generating a spin; Wigner function useful for displaying the quasi-probability for a qubit or; any qudit. For the standard, continuous-variable Wigner function for; position and momentum variables, wigner() should be used. Parameters; ----------; psi : qobj; a state vector or density matrix.; j : int; the total angular momentum of the quantum state.; fullparity : bool; should the parity of the full SU space be used?; steps : int; number of points at which the Wigner transform is calculated.; slicearray : list of str; the angle slice to be used for each particle in case of a; multi-particle quantum state. 'l' yields an equal angle; slice. 'x', 'y' and 'z' angle slices can also be chosen. Returns; ----------; wigner : list of float; the wigner transformation at `steps` different theta and phi. Raises; ------; ComplexWarning; This can be ignored as it is caused due to rounding errors. Notes; ------; See example notebook wigner_visualisation. References; ------; [1] T. Tilma, M. J. Everitt, J. H. Samson, W. J. Munro,; and K. Nemoto, Phys. Rev. Lett. 117, 180401 (2016).; [2] R. P. Rundle, P. W. Mills, T. Tilma, J. H. Samson, and; M. J. Everitt, Phys. Rev. A 96, 022117 (2017).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:262,variab,variable,262,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,2,['variab'],"['variable', 'variables']"
Modifiability,"# -- General configuration ------------------------------------------------; # If your documentation needs a minimal Sphinx version, state it here.; #",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:13,config,configuration,13,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['config'],['configuration']
Modifiability,"# -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #; # Check for Matplotlib",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:139,config,configuration,139,qutip/__init__.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py,1,['config'],['configuration']
Modifiability,"# -----------------------------------------------------------------------------; # Look to see if we are running with OPENMP; #; # Set environ variable to determin if running in parallel mode; # (i.e. in parfor or parallel_map)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py:143,variab,variable,143,qutip/__init__.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/__init__.py,1,['variab'],['variable']
Modifiability,"# Arbitrary coupling and bath temperature.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:12,coupling,coupling,12,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,2,['coupling'],['coupling']
Modifiability,"# Can evolve time dependent system",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py:6,evolve,evolve,6,qutip/solver/integrator/integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/integrator.py,1,['evolve'],['evolve']
Modifiability,"# Cascade coupling",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:10,coupling,coupling,10,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['coupling'],['coupling']
Modifiability,"# Conditional variable for first argument to savefig; # that is set in subsequent if-elses",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:14,variab,variable,14,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['variab'],['variable']
Modifiability,"# Construct Hamiltonian and coupling operator",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:28,coupling,coupling,28,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,"# In the time dependent case, we construct the parameters; # for the ODE gradient function under the assumption that; #; # RHSmat(t) = RHSmat + time dependent terms that only affect the; # diagonal blocks of the RHS matrix.; #; # This assumption holds because only _grad_n dependents on; # the system Liouvillian (and not _grad_prev or _grad_next) and; # the bath coupling operators are not time-dependent.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:364,coupling,coupling,364,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,"# Make a complex variable for X.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:17,variab,variable,17,qutip/core/semidefinite.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py,1,['variab'],['variable']
Modifiability,"# Make complex variables for rho0 and rho1.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:15,variab,variables,15,qutip/core/semidefinite.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py,1,['variab'],['variables']
Modifiability,"# Old variable used in V4 to customise the color of the points",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:6,variab,variable,6,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['variab'],['variable']
Modifiability,"# Remove -Wstrict-prototypes from the CFLAGS variable that the Python build; # process uses in addition to user-specified ones; the flag is not valid; # for C++ compiles, but CFLAGS gets appended to those compiles anyway.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:45,variab,variable,45,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['variab'],['variable']
Modifiability,"# Start assembling constraints and variables.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py:35,variab,variables,35,qutip/core/semidefinite.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/semidefinite.py,1,['variab'],['variables']
Modifiability,"# TODO: rewrite using Data object",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py:8,rewrite,rewrite,8,qutip/simdiag.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py,1,['rewrite'],['rewrite']
Modifiability,"# This list needs to populated manually at the moment. Each element of the; # list is a two-tuple (colour, modules), where the `colour` is the text colour; # in the output, and `modules` is a set of module names that will be that; # colour. You can also put package names into the set of modules---any; # submodules of that package will inherit the same colour. You don't need to; # include the ""qutip."" prefix to the modules. It's a list not a dictionary; # because the order is important to the output.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:337,inherit,inherit,337,doc/QuTiP_tree_plot/qutip-structure.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py,1,['inherit'],['inherit']
Modifiability,"# We send other to mul instead of complex(other) to be more flexible.; # The dispatcher can then decide how to handle other and return; # TypeError if it does not know what to do with the type of other.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:60,flexible,flexible,60,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['flexible'],['flexible']
Modifiability,"# array of spin energy splittings and coupling strengths. here we use; # uniform parameters, but in general we don't have too",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py:38,coupling,coupling,38,qutip/core/cy/openmp/bench_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/cy/openmp/bench_openmp.py,1,['coupling'],['coupling']
Modifiability,"# configuration declares the location of the examples directory for; # Sphinx Gallery",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,config,configuration,2,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['config'],['configuration']
Modifiability,"# coupling strength",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py:2,coupling,coupling,2,doc/guide/scripts/spectrum_ex1.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/spectrum_ex1.py,8,['coupling'],['coupling']
Modifiability,"# coupling to oscillator; # collapse operators",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_steady.py:2,coupling,coupling,2,doc/guide/scripts/ex_steady.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_steady.py,1,['coupling'],['coupling']
Modifiability,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:844,variab,variables,844,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['variab'],['variables']
Modifiability,"# evolve and calculate expectation values",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_bloch_animation.py:2,evolve,evolve,2,doc/guide/scripts/ex_bloch_animation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/guide/scripts/ex_bloch_animation.py,2,['evolve'],['evolve']
Modifiability,"# find first if the variable is use more than once and reuse",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:20,variab,variable,20,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['variab'],['variable']
Modifiability,"# non-hermitean H causes state to evolve non-unitarily",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:34,evolve,evolve,34,qutip/tests/solver/test_mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py,2,['evolve'],['evolve']
Modifiability,"# reaction coordinate coupling",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py:22,coupling,coupling,22,qutip/legacy/rcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/rcsolve.py,1,['coupling'],['coupling']
Modifiability,"# very weak bosonic coupling which should not affect the dynamics of; # the interaction between the system and the fermionic bath:",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:20,coupling,coupling,20,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,"#; # This code was contributed by Ben Criger. Resemblance to; # partial_transpose is intentional, and meant to enhance legibility.; #",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:111,enhance,enhance,111,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['enhance'],['enhance']
Modifiability,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:43,config,configurations,43,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['config'],['configurations']
Modifiability,". note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : float; Bath spectral density cutoff frequency. Referred to as ``gamma`` in; :class:`DrudeLorentzBath`. bnd_cut_approx : bool; Use boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). Keyword only.; Default: False. options : dict, optional; Generic solver options.; If set to None the default options will be used. Keyword only.; Default: None. combine : bool, default: True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details.; Keyword only. Default: True.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:2549,coupling,coupling,2549,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,".dag(), SpectraCoefficient(coefficient(array, tlist=ws))),; ]. .. note:; ``Cubic_Spline`` has been replaced by :obj:`.Coefficient`:; ``spline = qutip.coefficient(array, tlist=times)``. Whether the ``a_ops`` is time dependent is decided by the type of; the operator: :obj:`.Qobj` vs :obj:`.QobjEvo` instead of the type; of the spectra. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse'",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:2477,coupling,coupling,2477,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['coupling'],['coupling']
Modifiability,"Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.opti",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3021,enhance,enhanced,3021,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['enhance'],['enhanced']
Modifiability,"ample, if the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion:. temperature = 25e-3 # unit K; h = 6.626e-34; kB = 1.38e-23; args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonian. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_floquet_states : bool; | Whether or not to store the density matrices in the floquet basis; in ``result.floquet_states``.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; the expectation values for the times specified by `",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:2282,enhance,enhanced,2282,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['enhance'],['enhanced']
Modifiability,"ble function. For an operator ``op``, the; result will be computed using ``(state * op).tr()`` and the state; at each time ``t``. For callable functions, ``f``, the result is; computed using ``f(t, ado_state)``. The values are stored in the; ``expect`` and ``e_data`` attributes of the result (see the return; section below). args : dict, optional; Change the ``args`` of the RHS for the evolution. options : dict, optional; Generic solver options. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_ados : bool; | Whether or not to store the HEOM ADOs.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | state_data_type: str {'dense', 'CSR', 'Dia', }; | Name of the data type of the state used during the ODE evolution.; Use an empty string to keep the input state type. Many integrator; can only work with `Dense`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float,; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Returns; -------; :class:`~HEOMResult`; The results of ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:3037,enhance,enhanced,3037,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['enhance'],['enhanced']
Modifiability,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2602,adapt,adaptive,2602,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['adapt'],['adaptive']
Modifiability,"etail of operator expectation. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; List of collapse operators. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. The key ``w`` is reserved for the spectra function. sec_cutoff : float, default: 0.1; Cutoff for secular approximation. Use ``-1`` if secular approximation; is not used when evaluating bath-coupling terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | tensor_type : str ['sparse', 'dense', 'data']; | Which data type to use when computing the brtensor.; With a cutoff 'sparse' is usually the most efficient.; - | sparse_eigensolver : bool {False}; Whether to use the sparse eigensolver; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float, 0; | Maximum lenght of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse. Other options could be supported ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py:3030,enhance,enhanced,3030,qutip/solver/brmesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/brmesolve.py,1,['enhance'],['enhanced']
Modifiability,"for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. .. note::. Unlike the version of ``HSolverDL`` in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian ``H_sys``. .. note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : float; Bath temperature. Referred to as ``T`` in :class:`DrudeLorentzBath`. N_cut : int; The maximum depth of the hierarchy. See ``max_depth`` in; :class:`HEOMSolver` for a full description. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. The equivalent ``Nk`` in :class:`DrudeLorentzBath` is one; less than ``N_exp`` (see note above). cut_freq : float; Bath spectral density cutoff frequency. Referred to as ``gamma`` in; :class:`DrudeLorentzBath`. bnd_cut_approx : bool; Use boundary cut off approximation. If true, the Matsubara; terminator is added to the system Liouvillian (and H_sys is; promoted to a Liouvillian if it was a Hamiltonian). Keyword only.; Default: False. options : dict, optional; Generic solver options.; If set",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:1391,coupling,coupling,1391,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['coupling'],['coupling']
Modifiability,"ise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while """,MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:2179,enhance,enhanced,2179,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['enhance'],['enhanced']
Modifiability,"n be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.opti",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2774,enhance,enhanced,2774,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['enhance'],['enhanced']
Modifiability,"n superoperators. None is equivalent to an empty list. e_ops : list of :obj:`.Qobj` / callback function, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one ``tlist``; step.; - | max_step : float; | Maximum lenght of one internal step. When using pulses, it should be; less than half the width of the thinnest pulse. Other options could be supported depending on the integration method,; see `Integrator <./classes.html#classes-ode>`_. Returns; -------; result: :obj:`.Result`. An instance of the class :obj:`.Result`, which contains a *list of; array* ``result.expect`` of expectation valu",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py:3224,enhance,enhanced,3224,qutip/solver/mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mesolve.py,1,['enhance'],['enhanced']
Modifiability,"on mode) within the; decomposition of the correlation functions of a bath. Parameters; ----------; type : {""R"", ""I"", ""RI"", ""+"", ""-""} or BathExponent.ExponentType; The type of bath exponent. ""R"" and ""I"" are bosonic bath exponents that appear in the real and; imaginary parts of the correlation expansion. ""RI"" is combined bosonic bath exponent that appears in both the real; and imaginary parts of the correlation expansion. The combined exponent; has a single ``vk``. The ``ck`` is the coefficient in the real; expansion and ``ck2`` is the coefficient in the imaginary expansion. ""+"" and ""-"" are fermionic bath exponents. These fermionic bath; exponents must specify ``sigma_bar_k_offset`` which specifies; the amount to add to ``k`` (the exponent index within the bath of this; exponent) to determine the ``k`` of the corresponding exponent with; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------; fermionic : bool; True if the type of the exponent is a Fermionic type (i.e. either; ""+"" or ""-"") and False otherwise. All of the parameters are also available as attributes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:1135,coupling,coupling,1135,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['coupling'],['coupling']
Modifiability,"proximation subspaces used for the time; evolution approximation. e_ops : :class:`.Qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2166,enhance,enhanced,2166,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['enhance'],['enhanced']
Modifiability,"s.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspline`` are; also converted to interpolated coefficients (the same kind of coefficient; created from ``ndarray``). Other interpolation methods from; scipy are converted to a function-based coefficient (the same kind of; ",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1594,variab,variables,1594,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['variab'],['variables']
Performance,"""""""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] `https://en.wikipedia.org/wiki/Concurrence_(quantum_computing)`. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:19,concurren,concurrence,19,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['concurren'],['concurrence']
Performance,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:246,load,load-balanced,246,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['load'],['load-balanced']
Performance,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:273,load,load-balanced,273,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,2,['load'],['load-balanced']
Performance,"""""""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`.Qobj`; time-propagator for reduced system dynamics; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:342,perform,performed,342,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['perform'],['performed']
Performance,"""""""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(7) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(12) in; https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling; :meth:`extract`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:327,perform,performs,327,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['perform'],['performs']
Performance,"""""""; Do the check for concurrent use of the integrator and reset if used; elsewhere.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:22,concurren,concurrent,22,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,2,['concurren'],['concurrent']
Performance,"""""""; Get U(t) from cache or compute it.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py:19,cache,cache,19,qutip/solver/propagator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/propagator.py,1,['cache'],['cache']
Performance,"""""""; Loads data file from file ``filename`` in current directory. Parameters; ----------; filename : str or pathlib.Path; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/fileio.py:146,load,loaded,146,qutip/fileio.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/fileio.py,1,['load'],['loaded']
Performance,"""""""; PIQS: Test the calculation of gamma2. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma3. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma4. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma5. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma6. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma7. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma8. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of gamma9. PIQS: Test performed for N = 4.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:54,perform,performed,54,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; PIQS: Test the calculation of the correct collapse operators (c_ops) list. In the ""uncoupled"" basis of N two-level system (TLS).; The test is performed for N = 2 and emission = 1.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:147,perform,performed,147,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['perform'],['performed']
Performance,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:54,perform,performing,54,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,3,['perform'],"['perform', 'performing']"
Performance,"""""""; Solver for the Floquet-Markov master equation. .. note ::; Operators (``c_ops`` and ``e_ops``) are in the laboratory basis. Parameters; ----------; floquet_basis : :class:`.FloquetBasis`; The system Hamiltonian wrapped in a FloquetBasis object. Choosing a; different integrator for the ``floquet_basis`` than for the evolution; of the floquet state can improve the performance. a_ops : list of tuple(:class:`.Qobj`, callable); List of collapse operators and the corresponding function for the noise; power spectrum. The collapse operator must be a :obj:`.Qobj` and; cannot be time dependent. The spectrum function must take and return; an numpy array. w_th : float; The temperature of the environment in units of Hamiltonian frequency. kmax : int [5]; The truncation of the number of sidebands.. nT : int [20*kmax]; The number of integration steps (for calculating X) within one period. options : dict, optional; Options for the solver, see :obj:`FMESolver.options` and; `Integrator <./classes.html#classes-ode>`_ for a list of all options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py:370,perform,performance,370,qutip/solver/floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/floquet.py,1,['perform'],['performance']
Performance,"""""""; Take the partial trace of the quantum object leaving the selected; subspaces. In other words, trace out all subspaces which are _not_; passed. This is typically a function which acts on operators; bras and kets; will be promoted to density matrices before the operation takes place; since the partial trace is inherently undefined on pure states. For operators which are currently being represented as states in the; superoperator formalism (i.e. the object has type `operator-ket` or; `operator-bra`), the partial trace is applied as if the operator were; in the conventional form. This means that for any operator `x`,; ``operator_to_vector(x).ptrace(0) == operator_to_vector(x.ptrace(0))``; and similar for `operator-bra`. The story is different for full superoperators. In the formalism that; QuTiP uses, if an operator has dimensions (`dims`) of; `[[2, 3], [2, 3]]` then it can be represented as a state on a Hilbert; space of dimensions `[2, 3, 2, 3]`, and a superoperator would be an; operator which acts on this joint space. This function performs the; partial trace on superoperators by letting the selected components; refer to elements of the _joint_ _space_, and then returns a regular; operator (of type `oper`). Parameters; ----------; sel : int or iterable of int; An ``int`` or ``list`` of components to keep after partial trace.; The selected subspaces will _not_ be reordered, no matter order; they are supplied to `ptrace`. Returns; -------; oper : :class:`.Qobj`; Quantum object representing partial trace with selected components; remaining.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:1052,perform,performs,1052,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['perform'],['performs']
Performance,"""""""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:83,perform,performs,83,qutip/partial_transpose.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py,1,['perform'],['performs']
Performance,"""""""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:101,perform,perform,101,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['perform'],['perform']
Performance,"""""""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:507,perform,performed,507,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['perform'],['performed']
Performance,"""""""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:519,perform,performed,519,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['perform'],['performed']
Performance,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:350,perform,performed,350,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['perform'],['performed']
Performance,"# -- Configure MathJax for maths output in HTML targets; # Currently (2021-04-10) Sphinx 3.5.3 loads MathJax 2.7, which does not have; # support for the 'physics' package. MathJax 3 does, so once Sphinx is using; # that (should be in Sphinx 4), you will be able to swap to using that. In the; # meantime, we just have to define all the functions we're going to use.; #; # See:; # - https://docs.mathjax.org/en/v3.0-latest/input/tex/extensions/physics.html",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:95,load,loads,95,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['load'],['loads']
Performance,"# Check the cached isherm, if any exists.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:12,cache,cached,12,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['cache'],['cached']
Performance,"# Check the cached isunitary.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:12,cache,cached,12,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['cache'],['cached']
Performance,"# Dia is bad at vector, the following matmul is 10x slower with Dia; # than CSR and Dia is missing optimization such as `use_wbm`.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py:99,optimiz,optimization,99,qutip/solver/steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/steadystate.py,1,['optimiz'],['optimization']
Performance,"# FIXME: this needs to be cached in the same ways as isherm.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:26,cache,cached,26,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,2,['cache'],['cached']
Performance,"# Force a reset of the cached value for isherm.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:23,cache,cached,23,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['cache'],['cached']
Performance,"# Force a reset of the cached value for isunitary.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:23,cache,cached,23,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['cache'],['cached']
Performance,"# If the channel is a super-operator, perform second block decomposition;; # block-size matches Hilbert space of affected subsystem:; # FIXME use state shape?",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py:38,perform,perform,38,qutip/core/subsystem_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/subsystem_apply.py,1,['perform'],['perform']
Performance,"# Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:257,optimiz,optimization,257,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['optimiz'],['optimization']
Performance,"# Pauli spin-1/2 operators.; #; # These are so common in quantum information that we want them to be; # near-instantaneous to initialise, so we cache them at package import, and; # just return copies when someone requests one.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:144,cache,cache,144,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,1,['cache'],['cache']
Performance,"# We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.); # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U.; # There's a lot of conditions to check for this path. Only check if they; # aren't superoperators. The difference of unitaries optimization is; # currently only implemented for d == 2. Much of the code below is more; # general, though, in anticipation of generalizing the optimization.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:765,optimiz,optimization,765,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,2,['optimiz'],['optimization']
Performance,"# We test on a copy because scipy attempts to cache; # `has_sorted_indices`, but since it's a view, it has no idea what; # we've done to the indices behind the scenes and typically would not; # notice the change. The copy will return a difference scipy matrix,; # so the cache will not be built.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:46,cache,cache,46,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,2,['cache'],['cache']
Performance,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:392,perform,performing,392,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['perform'],['performing']
Performance,"# When the Hamiltonian is time-dependent, the transformation of `L` to; # eigenbasis is not optimized.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py:92,optimiz,optimized,92,qutip/core/blochredfield.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/blochredfield.py,1,['optimiz'],['optimized']
Performance,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3,cache,cache,3,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['cache'],['cache']
Performance,"# clear cached values",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,cache,cached,8,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['cache'],['cached']
Performance,"# defines what happens when loading a pickled Qobj",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:28,load,loading,28,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['load'],['loading']
Performance,"ich are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; overlap(other); Overlap between two state vectors or two operators.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; purity(); Calculates the purity of a quantum object.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:4072,perform,performing,4072,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['perform'],['performing']
Performance,"the given state. This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. tol : float, optional; Smallest value for the probabilities.; Default is qutip's core settings' ``atol``. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py:1637,perform,perform,1637,qutip/measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/measurement.py,2,['perform'],['perform']
Performance,"vec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float, default: sqrt(2); Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}, default: 'clenshaw'; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool, optional; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool, optional; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally. References; ----------. Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:1615,perform,performance,1615,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['perform'],['performance']
Safety," will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and relative tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.opt",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3335,detect,detect,3335,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['detect'],['detect']
Safety,"""""""; 	Binomial coefficient function for the detector model.; 	; 	Parameters; 	----------; 	n : int; 	 Number of elements.; 	k : int; 	 Number of subelements.; 	; 	Returns; 	-------; 	coeff : int; 	 Binomial coefficient.; 	; 	""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:44,detect,detector,44,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detector']
Safety,"""""""; 	Bucket detector model based on H. Lee, U. Yurtsever, P. Kok, G. Hockney, C. Adami, S. Braunstein,; 	and J. Dowling, ""Towards photostatistics from photon-number discriminating detectors,""; 	Journal of Modern Optics, vol. 51, p. 15171528, 2004.; 	; 	Parameters; 	----------; 	N : int ; 	 The Fock Space dimension.; 	efficiency : float; 	 The channel efficiency.; 	n_factor : float; 	 The average number of dark counts per detection window APD (Bucket Detector).; 	; 	Returns; 	-------; 	[proj, un_proj] : list; 	 The projection and unprojection operators.; 	; 	""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:13,detect,detector,13,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,3,['detect'],"['detection', 'detector', 'detectors']"
Safety,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:387,detect,detection,387,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,3,['detect'],['detection']
Safety,"""""""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e, 2}, default: e; Base of logarithm. Defaults to e.; sparse : bool, default: False; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float, default: 1e-12; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:555,detect,detect,555,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['detect'],['detect']
Safety,"""""""; Common functionality for parallel_map, loky_pmap and mpi_pmap.; The parameters `setup_executor`, `extract_result` and `shutdown_executor`; are callback functions with the following signatures:. setup_executor: () -> ProcessPoolExecutor. extract_result: Future -> (Any, BaseException); If there was an exception e, returns (None, e).; Otherwise returns (result, None). shutdown_executor: (executor: ProcessPoolExecutor,; active_tasks: set[Future]) -> None; executor: The ProcessPoolExecutor that was created in setup_executor; active_tasks: A set of Futures that are currently still being executed; (non-empty if: timeout, error, or reduce_func requesting exit); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:618,timeout,timeout,618,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"""""""; Define whether log handler should be:; - default: switch based on IPython detection; - stream: set up non-propagating StreamHandler; - basic: call basicConfig; - null: leave logging to the user; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:79,detect,detection,79,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['detect'],['detection']
Safety,"""""""; Determine all runtime options, returning a dictionary of the results. The; keys are:; 'rootdir': str; The root directory of the setup. Almost certainly the directory; that this setup.py file is contained in.; 'release': bool; Is this a release build (True) or a local development build (False); 'openmp': bool; Should we build our OpenMP extensions and attempt to link in OpenMP; libraries? (Not supported in this version.); 'cflags': list of str; Flags to be passed to the C++ compiler.; 'ldflags': list of str; Flags to be passed to the linker.; 'include': list of str; Additional directories to be added to the header files include; path. These files will be detected by Cython as dependencies, so; changes to them will trigger recompilation of .pyx files, whereas; includes added in 'cflags' as '-I/path/to/include' may not.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/setup.py:667,detect,detected,667,setup.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/setup.py,1,['detect'],['detected']
Safety,"""""""; Do the evolution of the Quantum system. For a ``state`` at time ``tlist[0]`` do the evolution as directed by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simula",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:906,timeout,timeout,906,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,1,['timeout'],['timeout']
Safety,"""""""; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of Peter E. Kloeden and Exkhard Platen,; *Numerical Solution of Stochastic Differential Equations*. - Order strong 0.5, weak 1.0; - Codes to only correct the stochastic part (:math:`\\alpha=0`,; :math:`\\eta=1/2`): ``'pred-corr'``, ``'predictor-corrector'`` or; ``'pc-euler'``; - Codes to correct both the stochastic and deterministic parts; (:math:`\\alpha=1/2`, :math:`\\eta=1/2`): ``'pc-euler-imp'``,; ``'pc-euler-2'`` or ``'pred-corr-2'``; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py:386,predict,predictor-corrector,386,qutip/solver/sode/sode.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/sode.py,1,['predict'],['predictor-corrector']
Safety,"""""""; Hierarchical Equations of Motion (HEOM) solver that supports multiple; baths. The baths must be all either bosonic or fermionic baths. If you need to run many evolutions of the same system and bath, consider; using :class:`HEOMSolver` directly to avoid having to continually; reconstruct the equation hierarchy for every evolution. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`; Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or; QobjEvo. list of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable that; can be made into :obj:`.QobjEvo` are also accepted. bath : Bath or list of Bath; A :obj:`Bath` containing the exponents of the expansion of the; bath correlation funcion and their associated coefficients; and coupling operators, or a list of baths. If multiple baths are given, they must all be either fermionic; or bosonic baths. max_depth : int; The maximum depth of the heirarchy (i.e. the maximum number of bath; exponent ""excitations"" to retain). state0 : :obj:`.Qobj` or :class:`~HierarchyADOsState` or array-like; If ``rho0`` is a :obj:`.Qobj` the it is the initial state; of the system (i.e. a :obj:`.Qobj` density matrix). If it is a :class:`~HierarchyADOsState` or array-like, then; ``rho0`` gives the initial state of all ADOs. Usually the state of the ADOs would be determine from a previous; call to ``.run(...)`` with the solver results option ``store_ados``; set to True. For example, ``result = solver.run(...)`` could be; followed by ``solver.run(result.ado_states[-1], tlist)``. If a numpy array-like is passed its shape must be; ``(number_of_ados, n, n)`` where ``(n, n)`` is the system shape; (i.e. shape of the system density matrix) and the ADOs must; be in the same order as in ``.ados.labels``. tlist : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / QobjEvo / callable / list / dict / None, optional; A list or dictionary of operators as :obj:`.Qobj`,; :obj:`.QobjEvo` and/or callable functions (",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:252,avoid,avoid,252,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['avoid'],['avoid']
Safety,"""""""; Measurements for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:121,detect,detection,121,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Measurements for each trajectories and stochastic collapse operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:145,detect,detection,145,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Measurements operators. Default are:. m_ops = sc_ops + sc_ops.dag(). for homodyne detection, and. m_ops = sc_ops + sc_ops.dag(), -1j*(sc_ops - sc_ops.dag()). for heterodyne detection. Measurements opput is computed as:. expect(m_ops_i, state(t)) + dW_i / dt * dW_factors. Where ``dW`` follows a gaussian distribution with norm 0 and derivation; of ``dt**0.5``. ``dt`` is the time difference between step in the; ``tlist``. ``m_ops`` can be overwritten, but the number of operators must be; constant.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:87,detect,detection,87,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Number of cpu detected.; Use the solver options to control the number of cpus used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:19,detect,detected,19,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,1,['detect'],['detected']
Safety,"""""""; Options for stochastic solver:. store_final_state: bool, default: False; Whether or not to store the final state of the evolution in the; result class. store_states: None, bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. store_measurement: bool, default: False; Whether to store the measurement for each trajectories.; Storing measurements will also store the wiener process, or; brownian noise for each trajectories. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress. 'tqdm' uses the python module; of the same name and raise an error if not installed. Empty string; or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. normalize_output: bool; Normalize output state to hide ODE numerical errors. method: str, default: ""platen""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int, default: None; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64DXSM"", ...}, default: None; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1757,detect,detect,1757,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['detect'],['detect']
Safety,"""""""; Options used by the core of qutip such as the tolerance of :obj:`.Qobj`; comparison or coefficient's format. Values can be changed in ``qutip.settings.core`` or by using context:; ``with CoreOptions(atol=1e-6): ...``. Options; -------; auto_tidyup : bool; Whether to tidyup during sparse operations. auto_tidyup_dims : bool [False]; Use auto tidyup dims on multiplication, tensor, etc.; Without auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1, 1]]``; With auto_tidyup_dims:; ``basis([2, 2]).dims == [[2, 2], [1]]``. auto_herm : boolTrue; detect hermiticity. atol : float {1e-12}; General absolute tolerance. rtol : float {1e-12}; General relative tolerance; Used to choose QobjEvo.expect output type. auto_tidyup_atol : float {1e-14}; The absolute tolerance used in automatic tidyup (see the; ``auto_tidyup`` parameter above) and the default value of ``atol`` used; in :meth:`Qobj.tidyup`. function_coefficient_style : str {""auto""}; The signature expected by function coefficients. The options are:. - ""pythonic"": the signature should be ``f(t, ...)`` where ``t``; is the time and the ``...`` are the remaining arguments passed; directly into the function. E.g. ``f(t, w, b=5)``. - ""dict"": the signature shoule be ``f(t, args)`` where ``t`` is; the time and ``args`` is a dict containing the remaining arguments.; E.g. ``f(t, {""w"": w, ""b"": 5})``. - ""auto"": select automatically between the two options above based; on the signature of the supplied function. If the function signature; is exactly ``f(t, args)`` then ``dict`` is used. Otherwise; ``pythonic`` is used. default_dtype : Nonetype, str, type {None}; When set, functions creating :obj:`.Qobj`, such as :func:""qeye"" or; :func:""rand_herm"", will use the specified data type. Any data-layer; known to ``qutip.data.to`` is accepted. When ``None``, these functions; will default to a sensible data type.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:550,detect,detect,550,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['detect'],['detect']
Safety,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1188,timeout,timeout,1188,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1236,timeout,timeout,1236,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:135,detect,detect,135,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['detect'],['detect']
Safety,"""""""; Return the index of the ADO label within the list of labels,; i.e. within ``self.labels``. Parameters; ----------; label : tuple; The label to look up. Returns; -------; int; The index of the label within the list of ADO labels. Notes; -----; This implementation of the ``.idx(...)`` method is just for; reference and documentation. To avoid the cost of a Python; function call, it is replaced with; ``self._label_idx.__getitem__`` when the instance is created.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:341,avoid,avoid,341,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['avoid'],['avoid']
Safety,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1219,timeout,timeout,1219,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"""""""; Supported options by krylov method:. atol : float, default: 1e-7; Absolute tolerance. nsteps : int, default: 100; Max. number of internal steps/call. min_step, max_step : float, default: (1e-5, 1e5); Minimum and maximum step size. krylov_dim: int, default: 0; Dimension of Krylov approximation subspaces used for the time; evolution approximation. If the defaut 0 is given, the dimension is calculated; from the system size N, using `min(int((N + 100)**0.5), N-1)`. sub_system_tol: float, default: 1e-7; Tolerance to detect a happy breakdown. A happy breakdown occurs; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. always_compute_step: bool, default: False; If True, the step length is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:522,detect,detect,522,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['detect'],['detect']
Safety,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:154,safe,safely,154,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['safe'],['safely']
Safety,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:156,safe,safely,156,qutip/tests/core/data/test_dense.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py,1,['safe'],['safely']
Safety,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:154,safe,safely,154,qutip/tests/core/data/test_dia.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py,1,['safe'],['safely']
Safety,"""""""; Wiener function of the trajectory argument for time dependent systems. When used as an args:. ``QobjEvo([op, func], args={""W"": SMESolver.WienerFeedback()})``. The ``func`` will receive a function as ``W`` that return an array of; wiener processes values at ``t``. The wiener process for the i-th; sc_ops is the i-th element for homodyne detection and the (2i, 2i+1); pairs of process in heterodyne detection. The process is a step; function with step of length ``options[""dt""]``. .. note::. WienerFeedback can't be added to a running solver when updating; arguments between steps: ``solver.step(..., args={})``. Parameters; ----------; default : callable, optional; Default function used outside the solver.; When not passed, a function returning ``np.array([0])`` is used. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:342,detect,detection,342,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Wiener increment for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)-1); for homodyne detection, and; (len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:125,detect,detection,125,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Wiener increment for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:150,detect,detection,150,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Wiener processes for each stochastic collapse operators. The output shape is; (len(sc_ops), len(tlist)); for homodyne detection, and; (len(sc_ops), 2, len(tlist)); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:123,detect,detection,123,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""; Wiener processes for each trajectories and stochastic collapse; operators. The output shape is; (ntraj, len(sc_ops), len(tlist)-1); for homodyne detection, and; (ntraj, len(sc_ops), 2, len(tlist)-1); for heterodyne detection.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:150,detect,detection,150,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,2,['detect'],['detection']
Safety,"""""""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:389,safe,safe,389,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['safe'],['safe']
Safety,"""""""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list, array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool, default: True; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float, default: 1e-14; Tolerance for detecting degenerate eigenstates. safe_mode : bool, default: True; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; -------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py:347,detect,detecting,347,qutip/simdiag.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/simdiag.py,1,['detect'],['detecting']
Safety,"# Files with the same name, but differents extension than the pyx file, are; # erased during cythonization process, breaking filelock.; # Adding a prefix make them safe to use.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:164,safe,safe,164,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['safe'],['safe']
Safety,"# First, a sanity check before thinking of compiling",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:11,sanity check,sanity check,11,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['sanity check'],['sanity check']
Safety,"# Fix the seed to avoid failing due to bad luck",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_results.py:18,avoid,avoid,18,qutip/tests/solver/test_results.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_results.py,1,['avoid'],['avoid']
Safety,"# From here on, excitations is not None; # General idea of algorithm: add excitations one by one in last mode (idx =; # len(dims)-1), and carry over to the next index when the limit is reached.; # Keep track of the number of excitations while doing so to avoid having to; # do explicit sums over the states.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:255,avoid,avoid,255,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['avoid'],['avoid']
Safety,"# If there is a subscript: a[b] int are always accepted to be safe; # with TypeError",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:62,safe,safe,62,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['safe'],['safe']
Safety,"# Massively relax the tolerance for the Monte-Carlo approach to avoid a; # long simulation time.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:64,avoid,avoid,64,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['avoid'],['avoid']
Safety,"# Scipy's DOP853 does not have a step function.; # It has a safe step length, but can be 0 if unknown.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py:60,safe,safe,60,qutip/solver/integrator/scipy_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/scipy_integrator.py,1,['safe'],['safe']
Safety,"# Set of modules that we don't want to include in the output. Any modules that; # are detected inside `qutip` but are not either in this set or the; # `module_groups` list will generate a warning when the script is run.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:86,detect,detected,86,doc/QuTiP_tree_plot/qutip-structure.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py,1,['detect'],['detected']
Safety,"# TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:50,avoid,avoid,50,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['avoid'],['avoid']
Safety,"# Take advantage of the fact that the density operator for A; # is a projector to avoid a sqrtm call.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:82,avoid,avoid,82,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['avoid'],['avoid']
Safety,"# Task was aborted due to timeout etc",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:11,abort,aborted,11,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,2,"['abort', 'timeout']","['aborted', 'timeout']"
Safety,"# Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:23,avoid,avoid,23,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,2,['avoid'],['avoid']
Safety,"# To avoid circular dependencies",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py:5,avoid,avoid,5,qutip/core/superoperator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/superoperator.py,4,['avoid'],['avoid']
Safety,"# We do the partial trace over the first index by using dense reshape; # operations, so that we can avoid bouncing to a sparse representation; # and back.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:100,avoid,avoid,100,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['avoid'],['avoid']
Safety,"# We don't actually need the whole matrix here, just the trace; # of its square root, so let's just get its eigenenergies instead.; # We also truncate negative eigenvalues to avoid nan propagation;; # even for positive semidefinite matrices, small negative eigenvalues; # can be reported.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:175,avoid,avoid,175,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['avoid'],['avoid']
Safety,"# We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:37,avoid,avoid,37,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['avoid'],['avoid']
Safety,"# We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:37,avoid,avoid,37,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['avoid'],['avoid']
Safety,"# We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:44,avoid,avoid,44,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['avoid'],['avoid']
Safety,"# abort if exception occurs",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py:2,abort,abort,2,doc/conf.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/conf.py,1,['abort'],['abort']
Safety,"# abs to avoid problems with sqrt for very small negative numbers",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:9,avoid,avoid,9,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['avoid'],['avoid']
Safety,"# all tasks have been submitted, timeout has not been reaches; # -> wait for all workers to finish before shutting down",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:33,timeout,timeout,33,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"# detect hermiticity",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py:2,detect,detect,2,qutip/core/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/options.py,1,['detect'],['detect']
Safety,"# make small numbers real, to avoid random colors",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/qpt.py:30,avoid,avoid,30,doc/contrib/qpt.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/qpt.py,1,['avoid'],['avoid']
Safety,"# model detectors",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:8,detect,detectors,8,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detectors']
Safety,"# np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1 when; # hellinger_dist(A, B) is called for A=B",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:21,avoid,avoid,21,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['avoid'],['avoid']
Safety,"# sanity check",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py:2,sanity check,sanity check,2,qutip/core/operators.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/operators.py,1,['sanity check'],['sanity check']
Safety,"# small hack to avoid add_done_callback not supporting; # extra arguments and closures inside loops retaining; # a reference not a value:",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:16,avoid,avoid,16,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['avoid'],['avoid']
Safety,"# the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:93,avoid,avoid,93,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['avoid'],['avoid']
Safety,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:86,avoid,avoid,86,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['avoid'],['avoid']
Safety,"# we add a very weak system hamiltonian here to avoid having; # singular system that causes problems for the scipy.sparse.linalg; # superLU solver used in spsolve.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:48,avoid,avoid,48,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,2,['avoid'],['avoid']
Safety,"#APD (Bucket Detector) un_detector (=gives probability for 0-detection)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:61,detect,detection,61,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detection']
Safety,"#Determine QBER from returned detection probabilities",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:30,detect,detection,30,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detection']
Safety,"#expectation values for different detector configurations",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:34,detect,detector,34,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detector']
Safety,"#i,j,k,l means Ha,Va,Hb,Vb, 0 means detector clicked, 1 means detector did not click",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:36,detect,detector,36,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,2,['detect'],['detector']
Safety,"#measure detection probabilities",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:9,detect,detection,9,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['detect'],['detection']
Safety,":obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. rho0 : :class:`.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. c_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format), optional; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`.expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Ove",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1263,detect,detection,1263,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['detect'],['detection']
Safety,"by; ``rhs`` and for each time in ``tlist`` store the state and/or; expectation values in a :class:`.Result`. The evolution method and; stored results are determined by ``options``. Parameters; ----------; state : :obj:`.Qobj`; Initial state of the evolution. tlist : list of double; Time for which to save the results (state and/or expect) of the; evolution. The first element of the list is the initial time of the; evolution. Time in the list must be in increasing order, but does; not need to be uniformly distributed. ntraj : int; Number of trajectories to add. args : dict, optional; Change the ``args`` of the rhs for the evolution. e_ops : list; list of Qobj or QobjEvo to compute the expectation values.; Alternatively, function[s] with the signature f(t, state) -> expect; can be used. timeout : float, optional; Maximum time in seconds for the trajectories to run. Once this time; is reached, the simulation will end even if the number; of trajectories is less than ``ntraj``. The map function, set in; options, can interupt the running trajectory or wait for it to; finish. Set to an arbitrary high number to disable. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower; than this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife; resampling. ``target_tol`` can be an absolute tolerance or a pair; of absolute and relative tolerance, in that order. Lastly, it can; be a list of pairs of (atol, rtol) for each e_ops. seeds : {int, SeedSequence, list}, optional; Seed or list of seeds for each trajectories. Returns; -------; results : :class:`.MultiTrajResult`; Results of the evolution. States and/or expect will be saved. You; can control the saved data in the options. .. note:; The simulation will end when the first end condition is reached; between ``ntraj``, ``timeout`` and ``target_tol``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:2077,timeout,timeout,2077,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,1,['timeout'],['timeout']
Safety,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1843,timeout,timeout,1843,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['timeout'],['timeout']
Safety,"ed deterministically. state : :class:`.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ops_and_rates : list; A ``list`` of tuples ``(L, Gamma)``, where the Lindblad operator ``L``; is a :class:`.Qobj` and ``Gamma`` represents the corresponding; rate, which is allowed to be negative. The Lindblad operators must be; operators even if ``H`` is a superoperator. If none are given, the; solver will defer to ``sesolve`` or ``mesolve``. Each rate ``Gamma``; may be just a number (in the case of a constant rate) or, otherwise,; specified using any format accepted by; :func:`~qutip.core.coefficient.coefficient`. e_ops : list, optional; A ``list`` of operator as Qobj, QobjEvo or callable with signature of; (t, state: Qobj) for calculating expectation values. When no ``e_ops``; are given, the solver will default to save the states. ntraj : int, default: 500; Maximum number of trajectories to run. Can be cut short if a time limit; is passed with the ``timeout`` keyword or if the target tolerance is; reached, see ``target_tol``. args : dict, optional; Arguments for time-dependent Hamiltonian and collapse operator terms. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str [""adams"", ""bdf"", ""lsoda"", ""dop853"", ""vern9"", etc.]; | Which differential equation integration method to use.; - | atol, rtol : float; | Absolute and r",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1626,timeout,timeout,1626,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['timeout'],['timeout']
Safety,"equation. Parameters; ----------; H : :obj:`.Qobj`, :obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format.; System Hamiltonian as a Qobj or QobjEvo for time-dependent; Hamiltonians. List of [:obj:`.Qobj`, :obj:`.Coefficient`] or callable; that can be made into :obj:`.QobjEvo` are also accepted. psi0 : :class:`.Qobj`; Initial state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. sc_ops : list of (:obj:`.QobjEvo`, :obj:`.QobjEvo` compatible format); List of stochastic collapse operators. e_ops : :class:`.qobj`, callable, or list, optional; Single operator or list of operators for which to evaluate; expectation values or callable or list of callable.; Callable signature must be, `f(t: float, state: Qobj)`.; See :func:`expect` for more detail of operator expectation. args : dict, optional; Dictionary of parameters for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dicti",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1066,detect,detection,1066,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['detect'],['detection']
Safety,"esult class. store_states: bool, default: None; Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given. progress_bar: str {'text', 'enhanced', 'tqdm', ''}, default: ""text""; How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. improved_sampling: Bool, default: False; Whether to use the improved sampling algorithm; of Abdelhafez et al. PRA (2019); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py:1462,detect,detect,1462,qutip/solver/mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/mcsolve.py,2,['detect'],['detect']
Safety,"esults: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). martingale_quad_limit: float or int, default: 100; An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1730,detect,detect,1730,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['detect'],['detect']
Safety,"for time-dependent Hamiltonians and; collapse operators. ntraj : int, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the s",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:1841,timeout,timeout,1841,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['timeout'],['timeout']
Safety,"rmining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. target_tol : float, tuple, list, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; (atol, rtol) for each e_ops. timeout : float, optional; Maximum time for the evolution in seconds. When reached, no more; trajectories will be computed. Returns; -------; results : :class:`.NmmcResult`; Object storing all results from the simulation. Compared to a result; returned by ``mcsolve``, this result contains the additional field; ``trace`` (and ``runs_trace`` if ``store_final_state`` is set). Note; that the states on the individual trajectories are not normalized. This; field contains the average of their trace, which will converge to one; in the limit of sufficiently many trajectories.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:5270,timeout,timeout,5270,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['timeout'],['timeout']
Safety,"same name and raise an error; if not installed. Empty string or False will disable the bar. progress_kwargs: dict, default: {""chunk_size"":10}; Arguments to pass to the progress_bar. Qutip's bars use; ``chunk_size``. keep_runs_results: bool, default: False; Whether to store results from all trajectories or just store the; averages. method: str, default: ""adams""; Which differential equation integration method to use. map: str {""serial"", ""parallel"", ""loky"", ""mpi""}, default: ""serial""; How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so. mpi_options: dict, default: {}; Only applies if map is ""mpi"". This dictionary will be passed as; keyword arguments to the `mpi4py.futures.MPIPoolExecutor`; constructor. Note that the `max_workers` argument is provided; separately through the `num_cpus` option. num_cpus: None, int; Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus. bitgenerator: {None, ""MT19937"", ""PCG64"", ""PCG64DXSM"", ...}; Which of numpy.random's bitgenerator to use. With ``None``, your; numpy version's default is used. mc_corr_eps: float, default: 1e-10; Small number used to detect non-physical collapse caused by; numerical imprecision. norm_t_tol: float, default: 1e-6; Tolerance in time used when finding the collapse. norm_tol: float, default: 1e-4; Tolerance in norm used when finding the collapse. norm_steps: int, default: 5; Maximum number of tries to find the collapse. completeness_rtol: float, default: 1e-5; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rate). completeness_atol: float, default: 1e-8; Used in determining whether the given Lindblad operators satisfy; a certain completeness relation. If they do not, an additional; Lindblad operator is added automatically (with zero rat",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:1476,detect,detect,1476,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['detect'],['detect']
Safety,"t, default: 500; Number of trajectories to compute. heterodyne : bool, default: False; Whether to use heterodyne or homodyne detection. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds are saved in the result and they can be reused with::. seeds=prev_result.seeds. When using a parallel map, the trajectories can be re-ordered. target_tol : {float, tuple, list}, optional; Target tolerance of the evolution. The evolution will compute; trajectories until the error on the expectation values is lower than; this tolerance. The maximum number of trajectories employed is; given by ``ntraj``. The error is computed using jackknife resampling.; ``target_tol`` can be an absolute tolerance or a pair of absolute and; relative tolerance, in that order. Lastly, it can be a list of pairs of; ``(atol, rtol)`` for each e_ops. timeout : float, optional; Maximum time for the evolution in second. When reached, no more; trajectories will be computed. Overwrite the option of the same name. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and rais",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:2105,timeout,timeout,2105,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['timeout'],['timeout']
Safety,"te: Qobj)`.; See :func:`~qutip.core.expect.expect` for more detail of operator; expectation. args : dict, optional; dictionary of parameters for time-dependent Hamiltonians. options : dict, optional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | atol: float; | Absolute tolerance of the ODE integrator.; - | nsteps : int; | Maximum number of (internally defined) steps allowed in one; ``tlist`` step.; - | min_step, max_step : float; | Miniumum and maximum lenght of one internal step.; - | always_compute_step: bool; | If True, the step lenght is computed each time a new Krylov; subspace is computed. Otherwise it is computed only once when; creating the integrator.; - | sub_system_tol: float; | Tolerance to detect an happy breakdown. An happy breakdown happens; when the initial ket is in a subspace of the Hamiltonian smaller; than ``krylov_dim``. Returns; -------; result: :class:`.Result`. An instance of the class :class:`.Result`, which contains; a *list of array* ``result.expect`` of expectation values for the times; specified by ``tlist``, and/or a *list* ``result.states`` of state; vectors or density matrices corresponding to the times in ``tlist`` [if; ``e_ops`` is an empty list of ``store_states=True`` in options].; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py:2927,detect,detect,2927,qutip/solver/krylovsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/krylovsolve.py,1,['detect'],['detect']
Safety,"tional; Dictionary of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; | Whether to store the measurement and wiener process for each; trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SMESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3769,detect,detect,3769,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['detect'],['detect']
Safety,"umber of (internally defined) steps allowed in one; ``tlist`` step.; - | max_step : float; | Maximum length of one internal step. When using pulses, it should; be less than half the width of the thinnest pulse.; - | keep_runs_results : bool, [False]; | Whether to store results from all trajectories or just store the; averages.; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | norm_t_tol, norm_tol, norm_steps : float, float, int; | Parameters used to find the collapse location. ``norm_t_tol`` and; ``norm_tol`` are the tolerance in time and norm respectively.; An error will be raised if the collapse could not be found within; ``norm_steps`` tries.; - | mc_corr_eps : float; | Small number used to detect non-physical collapse caused by; numerical imprecision.; - | completeness_rtol, completeness_atol : float, float; | Parameters used in determining whether the given Lindblad operators; satisfy a certain completeness relation. If they do not, an; additional Lindblad operator is added automatically (with zero; rate).; - | martingale_quad_limit : float or int; | An upper bound on the number of subintervals used in the adaptive; integration of the martingale. Note that the 'improved_sampling' option is not currently supported.; Additional options are listed under `options; <./classes.html#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `Integrator <./classes.html#classes-ode>`_. seeds : int, SeedSequence, list, optional; Seed for the random number generator. It can be a single seed used to; spawn seeds for each trajectory or a list of seeds, one for each; trajectory. Seeds ar",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:3702,detect,detect,3702,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['detect'],['detect']
Safety,"y of options for the solver. - | store_final_state : bool; | Whether or not to store the final state of the evolution in the; result class.; - | store_states : bool, None; | Whether or not to store the state vectors or density matrices.; On `None` the states will be saved if no expectation operators are; given.; - | store_measurement: bool; Whether to store the measurement and wiener process, or brownian; noise for each trajectories.; - | keep_runs_results : bool; | Whether to store results from all trajectories or just store the; averages.; - | normalize_output : bool; | Normalize output state to hide ODE numerical errors. Only normalize; the state if the initial state is already normalized.; - | progress_bar : str {'text', 'enhanced', 'tqdm', ''}; | How to present the solver progress.; 'tqdm' uses the python module of the same name and raise an error; if not installed. Empty string or False will disable the bar.; - | progress_kwargs : dict; | kwargs to pass to the progress_bar. Qutip's bars use `chunk_size`.; - | method : str; | Which stochastic differential equation integration method to use.; Main ones are {""euler"", ""rouchon"", ""platen"", ""taylor1.5_imp""}; - | map : str {""serial"", ""parallel"", ""loky"", ""mpi""}; | How to run the trajectories. ""parallel"" uses the multiprocessing; module to run in parallel while ""loky"" and ""mpi"" use the ""loky"" and; ""mpi4py"" modules to do so.; - | num_cpus : NoneType, int; | Number of cpus to use when running in parallel. ``None`` detect the; number of available cpus.; - | dt : float; | The finite steps lenght for the Stochastic integration method.; Default change depending on the integrator. Additional options are listed under; `options <./classes.html#qutip.solver.stochastic.SSESolver.options>`__.; More options may be available depending on the selected; differential equation integration method, see; `SIntegrator <./classes.html#classes-sode>`_. Returns; -------. output: :class:`.Result`; An instance of the class :class:`.Result`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:3522,detect,detect,3522,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['detect'],['detect']
Security,"""""""; 	Simulate skr with an SPDC state.; 	; 	Parameters; 	----------; 	eps : float; 	 The squeezing factor, sort of analogous to the amount of ; 	 pumping power to the spdc source, but not really.; 	loss_a : float; 	 Efficiency of the quantum channel going to Alice.; 	loss_b : float; 	 Efficiency of the quantum channel going to Bob. ; 	n_factor_a : float; 	 Background noise in Alice's detection.; 	n_factor_b : float; 	 Background noise in Bob's detection.; 	N : int; 	 Size of the fock space that we allow for the states; 	; 	Returns; 	-------; 	qber : float; 	 The Quantum Bit Error Rate; 	twofolds : float; 	 Probability of Alice and Bob getting a simultaneous detection ; 	 of a photon pair (also referred to as coincidences) within a ; 	 timing window.; 	skr : float; 	 Probability of getting a secure key bit within a timing window, ; 	 assuming error correction and privacy amplification, in the ; 	 limit of many coincidences.; ; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:802,secur,secure,802,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['secur'],['secure']
Security,"""""""; Animation of Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension. Allows to see entanglement between first; 2k particles and the rest. .. note::. colorblind_safe does not apply because of its unique colormap. Parameters; ----------; kets : :class:`.Result` or list of :class:`.Qobj`; Pure states for animation. theme : str {'light', 'dark'}, default: 'light'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : str {'pairs', 'pairs_skewed', 'before_after'}, default: 'pairs'; Type of Qubism plotting. Options:. - 'pairs' - typical coordinates,; - 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; - 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int, default: 1; Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int or 'grid_iteration' or 'all', default: 0; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance, optional; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance, optional; The axis context in which the plot will be drawn. Returns; -------; fig, ani : tuple; A tuple of the matplotlib figure and the animation instance; used to produce the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py:1862,access,access,1862,qutip/animation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/animation.py,1,['access'],['access']
Security,"""""""; Provides convenient access to the full hierarchy ADO state at a particular; point in time, ``t``. Parameters; ----------; rho : :class:`.Qobj`; The current state of the system (i.e. the 0th component of the; hierarchy).; ados : :class:`HierarchyADOs`; The description of the hierarchy.; ado_state : numpy.array; The full state of the hierarchy. Attributes; ----------; rho : Qobj; The system state. In addition, all of the attributes of the hierarchy description,; i.e. ``HierarchyADOs``, are provided directly on this class for; convenience. E.g. one can access ``.labels``, or ``.exponents`` or; call ``.idx(label)`` directly. See :class:`HierarchyADOs` for a full list of the available attributes; and methods.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:25,access,access,25,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,2,['access'],['access']
Security,"""""""; Qubism plot for pure states of many qudits. Works best for spin chains,; especially with even number of particles of the same dimension. Allows to; see entanglement between first 2k particles and the rest. .. note::. colorblind_safe does not apply because of its unique colormap. Parameters; ----------; ket : Qobj; Pure state for plotting. theme : str {'light', 'dark'}, default: 'light'; Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : str {'pairs', 'pairs_skewed' or 'before_after'}, default: 'pairs'; Type of Qubism plotting. Options:. - 'pairs' - typical coordinates,; - 'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,; - 'before_after' - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int, default: 1; Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int or 'grid_iteration' or 'all', default: 0; Show labels for first ``2*legend_iteration`` particles. Option; 'grid_iteration' sets the same number of particles as for; grid_iteration. Option 'all' makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance, optional; The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance, optional; The axis context in which the plot will be drawn. Returns; -------; fig, output : tuple; A tuple of the matplotlib figure and the axes instance or animation; instance used to produce the figure. Notes; -----; See also [1]_. References; ----------; .. [1] J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, *Qubism: self-similar visualization of many-body; wavefunctions*, `New J. Phys. 14 053028; <https://dx.doi.org/10.1088/1367-2630/14/5/053028>`_, arXiv:1112.3560; (2012), open access.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py:1829,access,access,1829,qutip/visualization.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/visualization.py,1,['access'],['access']
Security,"""""""; Recursively access every accessible element of the given module, building; up a complete tree structure where the keys are the parts of the module; name, and the eventual leaves are public functions and classes defined in; that particular module (so ignoring any names that leak in from other; imports). For example,; >>> import qutip; >>> python_object_tree(qutip); {; ""mesolve"" : {; ""mesolve"": <function qutip.mesolve.mesolve(...)>,; },; ...; }; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:17,access,access,17,doc/QuTiP_tree_plot/qutip-structure.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py,2,['access'],"['access', 'accessible']"
Security,"# Also do our parent package, if we have one. In theory it's possible to; # get into a situation with packages and overzealous use of ""del"" in init; # scripts where a submodule may be accessible but its parent isn't.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:184,access,accessible,184,doc/QuTiP_tree_plot/qutip-structure.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py,1,['access'],['accessible']
Security,"# If the provided num_cpus is None, we use the default value instead.; # We thus intentionally make it impossible to call; # MPIPoolExecutor(max_workers=None, ...); # in which case mpi4py would determine a default value. That would be; # useful, but unfortunately mpi4py provides no public API to access the; # actual number of workers that is used in that case, which we would need.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:297,access,access,297,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['access'],['access']
Security,"# MCSolver (and NonMarkovianMCSolver) offer two interfaces, i.e., two ways; # of interacting with them: either call `start` first and then manually; # integrate a single trajectory with subsequent calls to `step`, or call; # `run` to integrate a large number of trajectories, saving the results in; # an `NmmcResult`.; # We are responsible for (a) keeping our `_martingale` object in the; # correct state throughout and (b) multiplying all state density matrices; # with the martingale before passing them on to the user.; #; # Regarding (a), we firstly assume that start, step and run are only; # accessed by a single thread. start and step thus cannot be called while; # run is being executed. Secondly, we reset the martingale object at the; # beginning and end of run, requiring the user to call start again after; # calling run before calling step. Internal state of the martingale; # object accumulated by using one interface can thus not influence; # computations with the other interface.; # Note that the start/step-interface allows updating the `args` dictionary; # at each step. This action does not mess up the martingale state since we; # do not precompute any martingale values in this interface. In the; # run-interface we do precompute the values of the continuous part of the; # martingale, but the `args` dictionary cannot be changed in the middle of; # the run.; #; # Regarding (b), in the start/step-interface we just include the martingale; # in the step method. In order to include the martingale in the; # run-interface, we use a custom trajectory-resultclass that grabs the; # martingale value from the NonMarkovianMCSolver whenever a state is added.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:598,access,accessed,598,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['access'],['accessed']
Security,"# Many coefficients. These should not be publicly exposed; # and will all need to be updated in _arguments():",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:50,expose,exposed,50,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['expose'],['exposed']
Security,"# The ParameterSet is actually a pretty hidden type, so it's easiest to access; # it like this.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:72,access,access,72,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['access'],['access']
Security,"# This script currently relies on all packages being imported by the; # import qutip; # command. If in the future some packages are not imported, then you'll need; # to add more import lines below it to make sure they're all in. We do this; # rather than file-based discovery so we have more access to information; # included by the import system, such as which names are meant to be public.; # It also means that we can import Cythonised modules to investigate their; # internals as well.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py:292,access,access,292,doc/QuTiP_tree_plot/qutip-structure.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/QuTiP_tree_plot/qutip-structure.py,1,['access'],['access']
Security,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:31,expose,exposed,31,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['expose'],['exposed']
Security,"#Lets look at what happens to the secure key rate and ; #the quantum bit error rate as the loss gets worse.; #Analogous to distance with fiber optic links.; #define the fock space",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:34,secur,secure,34,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['secur'],['secure']
Security,"#security analysis - calculate skr in infinite key limit; #See Chris Erven's PhD thesis or Xiongfeng Ma's paper ; #to understand where this equation comes from",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:1,secur,security,1,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['secur'],['security']
Security,"'''; Code for simulating secure key rate, twofolds, and quantum bit error rate; Written in Python and QuTIP by Catherine Holloway (c2hollow@iqc.ca). Detector model and squashing functions by Catherine Holloway,; based on code by Dr. Thomas Jennewein (tjennewe@iqc.ca). Contributed to the QuTiP project on June 06, 2012 by Catherine Holloway.; '''",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py:25,secur,secure,25,doc/contrib/sim_ent_qkd/sim_ent_qkd.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/doc/contrib/sim_ent_qkd/sim_ent_qkd.py,1,['secur'],['secure']
Security,"r this result class. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. Note; that the solver may update the stats directly while producing results. kw : dict; Additional parameters specific to a result sub-class. Attributes; ----------; times : list; A list of the times at which the expectation values and states were; recorded. states : list of :obj:`.Qobj`; The state at each time ``t`` (if the recording of the state was; requested). final_state : :obj:`.Qobj`:; The final state (if the recording of the final state was requested). expect : list of arrays of expectation values; A list containing the values of each ``e_op``. The list is in; the same order in which the ``e_ops`` were supplied and empty if; no ``e_ops`` were given. Each element is itself a list and contains the values of the; corresponding ``e_op``, with one value for each time in ``.times``. The same lists of values may be accessed via the ``.e_data`` dictionary; and the original ``e_ops`` are available via the ``.e_ops`` attribute. e_data : dict; A dictionary containing the values of each ``e_op``. If the ``e_ops``; were supplied as a dictionary, the keys are the same as in; that dictionary. Otherwise the keys are the index of the ``e_op``; in the ``.expect`` list. The lists of expectation values returned are the *same* lists as; those returned by ``.expect``. e_ops : dict; A dictionary containing the supplied e_ops as ``ExpectOp`` instances.; The keys of the dictionary are the same as for ``.e_data``.; Each value is object where ``.e_ops[k](t, state)`` calculates the; value of ``e_op`` ``k`` at time ``t`` and the given ``state``, and; ``.e_ops[k].op`` is the original object supplied to create the; ``e_op``. solver : str or None; The name of the solver generating these results. stats : dict or None; The stats generated by the solver while producing these results. options : dict; The options for th",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:1696,access,accessed,1696,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['access'],['accessed']
Testability,""""""" A list of coefficients and a tlist of times to test at. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/cy/test_nm_mcsolve.py:51,test,test,51,qutip/tests/solver/cy/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/cy/test_nm_mcsolve.py,1,['test'],['test']
Testability,""""""" Analytic Drude-Lorentz pure-dephasing model for testing the HEOM; solver.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:52,test,testing,52,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,2,['test'],['testing']
Testability,""""""" Analytic discrete level current model for testing the HEOM solver; with a fermionic bath (and optionally a bosonic mode).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:46,test,testing,46,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['test'],['testing']
Testability,"""""""; A rough test that nm_mcsolve agress with mesolve in the; presence of negative rates.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:13,test,test,13,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['test'],['test']
Testability,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superop_reps.py:7,test,test,7,qutip/tests/core/test_superop_reps.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superop_reps.py,1,['test'],['test']
Testability,"""""""; A test class for the QuTiP function for applying superoperators to; subsystems.; The four tests below determine whether efficient numerics, naive numerics; and semi-analytic results are identical.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py:7,test,test,7,qutip/tests/test_subsys_apply.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_subsys_apply.py,2,['test'],"['test', 'tests']"
Testability,"""""""; A test class for the QuTiP function for matrix/vector conversion.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:7,test,test,7,qutip/tests/core/test_superoper.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py,1,['test'],['test']
Testability,"""""""; A test class for the QuTiP functions for Floquet formalism.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py:7,test,test,7,qutip/tests/solver/test_floquet.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_floquet.py,1,['test'],['test']
Testability,"""""""; A test class for the QuTiP functions for the evolution of JC model; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py:7,test,test,7,qutip/tests/solver/test_mesolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mesolve.py,1,['test'],['test']
Testability,"""""""; A test class for the QuTiP quantum optical scattering module. These tests; only use the two-level system for comparison, since larger systems can; take a long time to run.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:7,test,test,7,qutip/tests/solver/test_scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py,2,['test'],"['test', 'tests']"
Testability,"""""""; A test class for the QuTiP superoperator functions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:7,test,test,7,qutip/tests/core/test_superoper.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py,1,['test'],['test']
Testability,"""""""; Abstract base mix-in which sets up the test generation for the two basic; test operations, and puts in the very generic test generator. This does; not actually define the tests themselves, because subclasses need to define; them so the method arguments can be introspected to parametrise over the; correct number of arguments. The tests `mathematically_correct` and `incorrect_shape_raises` will; parametrise Data types over method arguments which have names `data_*`. The class arguments defined here are effectively parametrising the; mathematical tests. Attributes; ----------; op_numpy: *args -> np.ndarray; Function which takes the same arguments as the mathematical operation,; but with all data arguments numpy arrays, and returns the expected; result. atol: float; The absolute tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. rtol: float; The relative tolerance to use when comparing the test value with the; expected value. If the output is a Data type, the tolerance is; per-element of the output. shapes: list of (list of shapes); A list of the sets of shapes which should be used for the tests of; mathematical correctness. Each element of the list is a set of shapes,; each one corresponding to one of the arguments of the operation. bad_shapes: list of (list of shapes); Similar to `shapes`, but these should be shapes which are invalid for; the given mathematical operation. specialisations: list of (function, Type, Type, [Type, ...]); The specialisations of each mathematical function, and the types that; it takes in and returns. For example, the function; add(CSR, Dense) -> Other; would be specified as `(add, CSR, Dense, Other)`.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:44,test,test,44,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,9,['test'],"['test', 'tests']"
Testability,"""""""; Calculate the total number of distinct ENR states for a given set of; subspaces. This method is not intended to be fast or efficient, it's; intended to be obviously correct for testing purposes.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py:182,test,testing,182,qutip/tests/test_enr_state_operator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_enr_state_operator.py,1,['test'],['testing']
Testability,"""""""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:274,log,logarithm,274,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['log'],['logarithm']
Testability,"""""""; Calculates the fidelity (pseudo-metric) between two density matrices. Notes; -----; Uses the definition from Nielsen & Chuang, ""Quantum Computation and Quantum; Information"". It is the square root of the fidelity defined in; R. Jozsa, Journal of Modern Optics, 41:12, 2315 (1994), used in; :func:`qutip.core.metrics.process_fidelity`. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; fid : float; Fidelity pseudo-metric between A and B. Examples; --------; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:621,test,testing,621,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['test'],['testing']
Testability,"""""""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : ndarray; The covariance matrix. g : float, default: sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``, default ``g = sqrt(2)``.; The value of ``g`` is related to the value of ``hbar`` in the; commutation relation ``[x, y] = i * hbar`` via ``hbar=2/g ** 2`` giving; the default value ``hbar=1``. Returns; -------. N : float; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py:20,log,logarithmic,20,qutip/continuous_variables.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/continuous_variables.py,2,['log'],['logarithmic']
Testability,"""""""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:380,log,logarithm,380,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['log'],['logarithm']
Testability,"""""""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e, 2}, default: e; Base of logarithm. Defaults to e.; sparse : bool, default: False; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float, default: 1e-12; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:342,log,logarithm,342,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,2,['log'],"['log', 'logarithm']"
Testability,"""""""; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------!=; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A.; tol : float, default: 0; Tolerance used by sparse eigensolver, if used. (0 = Machine precision); sparse : bool, default: False; Use sparse eigensolver. Returns; -------; tracedist : float; Trace distance between A and B. Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:567,test,testing,567,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['test'],['testing']
Testability,"""""""; Define whether log handler should be:; - default: switch based on IPython detection; - stream: set up non-propagating StreamHandler; - basic: call basicConfig; - null: leave logging to the user; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py:20,log,log,20,qutip/settings.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/settings.py,2,['log'],"['log', 'logging']"
Testability,"""""""; Mix-in for unary mathematical operations on Data instances, but that also; take in a numeric scalar (e.g. scalar multiplication). Only generates; the test `mathematically_correct`, since there can't be a shape mismatch; when there's only one Data argument.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:155,test,test,155,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"""""""; Mixin class to test the states and expectation values from ``mcsolve``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:20,test,test,20,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,1,['test'],['test']
Testability,"""""""; Mixin class to test the states and expectation values from nm_mcsolve.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:20,test,test,20,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['test'],['test']
Testability,"""""""; PIQS: Test if the Dicke basis (j, m, m') is constructed correctly. We test the state with for N = 2,. 0 0 0.3 0; 0 0.5 0 0; 0.3 0 0 0; 0 0 0 0.5; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:75,test,test,75,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"""""""; PIQS: Test the calculation of the correct collapse operators (c_ops) list. In the ""uncoupled"" basis of N two-level system (TLS).; The test is performed for N = 2 and emission = 1.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:139,test,test,139,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"""""""; Perform the parametrisation over the test cases, performing the; explicit broadcasting into separate test cases when required. We detect whether to perform explicit broadcasting over one of the; arguments of the `_Case` by looking for a singular/plural name of the; parameter in the test. If the parameter is singular, then we manually; perform the broadcasting rule for that fixture, and parametrise over; the resulting list, taking care to pick out the correct parts of the; reference array.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:42,test,test,42,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,3,['test'],['test']
Testability,"""""""; Regression test for gh-1325. ptrace should work the same independently of; the order of the input; no transposition in done in the trace operation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_ptrace.py:16,test,test,16,qutip/tests/core/test_ptrace.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_ptrace.py,1,['test'],['test']
Testability,"""""""; Regression test for gh-1350, comparing explicitly stored values in the; matrix (but below the tolerance for allowable Hermicity) to implicit; zeros.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:16,test,test,16,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['test'],['test']
Testability,"""""""; Regression test of gh-1350. Larger matrices where all off-diagonal elements are below the; absolute tolerance, so everything should always appear Hermitian, but; with random patterns of non-zero elements. It doesn't matter that it; isn't Hermitian if scaled up; everything is below absolute tolerance,; so it should appear so. We also set the diagonal to be larger to the; tolerance to ensure isherm can't just compare everything to zero.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:16,test,test,16,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['test'],['test']
Testability,"""""""; Return a list of `pytest.ParameterSet` which is a flat list of all the; special cases that should be tested for this operator specialisation `op`,; which takes in several types `types`, where the arguments have shapes taken; from the iterable of iterables `shapes`. If `out_type` is specified, it; will be added into the output parameter set and its name added to the id,; but is otherwise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *dat",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:106,test,tested,106,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,2,['test'],['tested']
Testability,"""""""; Run the test scripts for QuTiP. Parameters; ----------; full: bool; If True run all test (30 min). Otherwise skip few variants of the; slowest tests.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:13,test,test,13,qutip/testing.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py,3,['test'],"['test', 'tests']"
Testability,"""""""; Skip the current test item if Cython is unavailable for import, or isn't a; high enough version.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:22,test,test,22,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['test'],['test']
Testability,"""""""; Taken almost verbatim from `np.testing._private.utils`, except this version; doesn't truncate output if it's longer than three lines. LICENCE; -------; Copyright (c) 2005-2020, NumPy Developers.; All rights reserved. Redistribution and use in source and binary forms, with or without; modification, are permitted provided that the following conditions are met:. - Redistributions of source code must retain the above copyright notice,; this list of conditions and the following disclaimer. - Redistributions in binary form must reproduce the above copyright notice,; this list of conditions and the following disclaimer in the documentation; and/or other materials provided with the distribution. - Neither the name of the NumPy Developers nor the names of any; contributors may be used to endorse or promote products derived from this; software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE); ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE; POSSIBILITY OF SUCH DAMAGE.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:36,test,testing,36,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['test'],['testing']
Testability,"""""""; Test cases based on comparisons to pre-existing dnorm implementations.; In particular, the targets for the following test cases were generated; using QuantumUtils for MATLAB (https://goo.gl/oWXhO9).; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:122,test,test,122,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['test'],['test']
Testability,"""""""; Test that __init__ does not throw when passed a 3-tuple. Also tests; the as_scipy() method succeeds.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:67,test,tests,67,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,2,['test'],['tests']
Testability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that CSR safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:107,test,test,107,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,2,['test'],"['test', 'tests']"
Testability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dense safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py:107,test,test,107,qutip/tests/core/data/test_dense.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dense.py,2,['test'],"['test', 'tests']"
Testability,"""""""; Test that the __init__ method raises a suitable error when passed; incorrectly formatted inputs. This test also serves as a *partial* check that Dia safely handles; deallocation in the presence of exceptions in its __init__ method. If; the tests segfault, it's quite likely that the memory management isn't; being done correctly in the hand-off us setting our data buffers up and; marking the numpy actually owns the data.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py:107,test,test,107,qutip/tests/core/data/test_dia.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_dia.py,2,['test'],"['test', 'tests']"
Testability,"""""""; Test the deep mapping. To simplify generation of edge-cases, this tests; against an equivalent (but slower) operation of flattening and unflattening; the list. We can get false negatives if the `flatten` or `unflatten`; functions are broken, but other tests should catch those.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:71,test,tests,71,qutip/tests/core/test_dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py,2,['test'],['tests']
Testability,"""""""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py:156,test,testing,156,qutip/partial_transpose.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/partial_transpose.py,1,['test'],['testing']
Testability,"""""""; This module includes a collection of testing functions for the QuTiP scattering; module. Tests are approximate with low resolution to minimize runtime.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:42,test,testing,42,qutip/tests/solver/test_scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py,1,['test'],['testing']
Testability,"""""""; Unit tests for QuTiP partial transpose functions.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py:10,test,tests,10,qutip/tests/test_partial_transpose.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py,1,['test'],['tests']
Testability,"""""""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e, 2}, default: e; Base of logarithm.; sparse : bool, default: False; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:132,log,logarithm,132,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['log'],['logarithm']
Testability,"""""""; Wiener process generator used for tests.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py:39,test,tests,39,qutip/solver/sode/_noise.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/_noise.py,1,['test'],['tests']
Testability,"""""""Base shapes to test for unary functions.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:18,test,test,18,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"""""""Matrix logarithm `ln(A)` for a matrix `A`.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py:10,log,logarithm,10,qutip/core/data/expm.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/data/expm.py,1,['log'],['logarithm']
Testability,"""""""Matrix logarithm of quantum operator. Input operator must be square. Returns; -------; oper : :class:`.Qobj`; Logarithm of the quantum operator. Raises; ------; TypeError; Quantum operator is not square.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:10,log,logarithm,10,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['log'],['logarithm']
Testability,"""""""This file provides tests for expect specialisation. For tests at Qobj level; see `qutip/tests/core/test_expect.py`""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py:22,test,tests,22,qutip/tests/core/data/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_expect.py,3,['test'],['tests']
Testability,"""""""This test checks that the dtype is properly kept with `sprepost`; function.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:8,test,test,8,qutip/tests/core/test_superoper.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py,1,['test'],['test']
Testability,"""""""This test checks that the dtype is properly kept with the; `operation` function.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py:8,test,test,8,qutip/tests/core/test_superoper.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_superoper.py,1,['test'],['test']
Testability,"""""""This test compares the output correlation_2op_1 solution to an analytical; solution.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:8,test,test,8,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,1,['test'],['test']
Testability,"""""""This tests ensures that expect still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:8,test,tests,8,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['test'],['tests']
Testability,"""""""This tests ensures that trace still works even if the output of a; specialisation does not have the ``real`` attribute. This is the case for; the tensorflow and cupy data layers.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,test,tests,8,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['tests']
Testability,"""""""measure_povm: test on basis states using different projectors """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py:17,test,test,17,qutip/tests/test_measurement.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_measurement.py,1,['test'],['test']
Testability,"""""""partial transpose: randomized tests on tripartite system""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py:33,test,tests,33,qutip/tests/test_partial_transpose.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_partial_transpose.py,1,['test'],['tests']
Testability,"""""""wigner: testing the SU2 parity of the first Bell state.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: testing the SU2 parity of the fourth Bell state.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: testing the SU2 wigner transformation of a pure state.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: testing the SU2 wigner transformation of the GHZ state.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: testing the parity function.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: testing the parity of the fourth Bell state using the parity of; the full space.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,testing,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['testing']
Testability,"""""""wigner: tests angle slicing.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:11,test,tests,11,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['tests']
Testability,"# A similar test if the structures are different, but it's not; # Hermitian.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:12,test,test,12,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['test'],['test']
Testability,"# Also parametrise left, right as if they're the names of two states for tests; # that need to take two states.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:73,test,tests,73,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['test'],['tests']
Testability,"# And now finally we get into the meat of the actual mathematical tests.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:66,test,tests,66,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['tests']
Testability,"# Assume for the purposes of the test that S maps square operators to; # square operators.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:33,test,test,33,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:18,log,log,18,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['log'],['log']
Testability,"# Be sure to test a full spectrum bra-type, ket-type and square and; # non-square operators. Keep the dimension sensible, particularly for; # things like kron, since these shapes are reused to build the shapes for; # higher-order functions too.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:13,test,test,13,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"# Big tolerance because we actually want to test the inverse.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:44,test,test,44,qutip/tests/core/test_gates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py,1,['test'],['test']
Testability,"# Build numpy version test.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:22,test,test,22,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,3,['test'],['test']
Testability,"# Call about to get all version info printed with tests",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:50,test,tests,50,qutip/testing.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py,1,['test'],['tests']
Testability,"# Catch possible edge case where it shouldn't be Hermitian, but faulty; # loop logic doesn't fully compare all rows.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:79,log,logic,79,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['log'],['logic']
Testability,"# Deactivate warning for test without cython",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_integrator.py:25,test,test,25,qutip/tests/solver/test_integrator.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_integrator.py,3,['test'],['test']
Testability,"# Disable tests for python2 as qutip.piqs does not support python2.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:10,test,tests,10,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['tests']
Testability,"# Ensure the latest version is tested",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py:31,test,tested,31,qutip/tests/core/test_coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_coefficient.py,1,['test'],['tested']
Testability,"# Factory methods for generating the cases, mapping type to the function.; # _ALL_CASES is for getting all the special cases to test, _RANDOM is for; # getting just a single case from each.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:128,test,test,128,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"# Find the private module used by numpy to store its testing utility functions; # so that we can monkeypatch the error messages to be more verbose. QuTiP; # supports numpy from 1.12 upwards, so we have to search.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py:53,test,testing,53,qutip/tests/conftest.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/conftest.py,1,['test'],['testing']
Testability,"# First we construct a solver with the boson modelled as part of the; # system and only a single Fermionic bath. This will provide the; # reference result for the test:",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:163,test,test,163,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['test'],['test']
Testability,"# For every test function ""test_xyz"", we use the test generator; # ""generate_xyz"" if it exists. This allows derived classes to add; # their own tests and generators without overiding this method, cutting; # down on boilerplate, but also that derived classes _may_ override the; # generation of tests defined in a base class, say if they have; # additional special arguments that need parametrising over.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:12,test,test,12,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,4,['test'],"['test', 'tests']"
Testability,"# If this first line fails, the zero has been stored explicitly and so; # the test is invalid.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:78,test,test,78,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,1,['test'],['test']
Testability,"# Make sure the stub modules is the one imported",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_qip.py:16,stub,stub,16,qutip/tests/test_qip.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_qip.py,1,['stub'],['stub']
Testability,"# Make test objects.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:7,test,test,7,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# Normalize to a super of type choi or chi.; # We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence; # preserves the CP and TP conditions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:54,test,test,54,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['test'],['test']
Testability,"# Now we start to actually build up all the test cases. Since all the; # mathematical operations are really pretty similar, and most just need the; # basic testing functionality, we do this with a series of mix-in classes which; # provide various components of the testing and test-generation infrastructure.; #; # In each, we use the idiom that ""test_<x>"" is a test function which pytest; # will collect for us, and ""generate_<x>"" a method which will be called by; # `pytest_generate_tests` in order to generate all the parametrisations for the; # given test.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:44,test,test,44,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,6,['test'],"['test', 'test-generation', 'testing']"
Testability,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:49,test,tests,49,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,14,['test'],"['test', 'tested', 'testing', 'tests']"
Testability,"# Promote all parameters to Space to simplify later logic.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:52,log,logic,52,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['log'],['logic']
Testability,"# Return the negativity value (or its logarithm if specified)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:38,log,logarithm,38,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,1,['log'],['logarithm']
Testability,"# Run the test",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py:10,test,test,10,qutip/tests/solver/test_scattering.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_scattering.py,3,['test'],['test']
Testability,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:30,log,log,30,qutip/tests/test_entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py,2,['log'],['log']
Testability,"# S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py:30,log,log,30,qutip/entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/entropy.py,2,['log'],['log']
Testability,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:64,test,tested,64,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,6,['test'],"['test', 'tested', 'tests']"
Testability,"# Similar test when it must be non-Hermitian. We set the diagonal; # to be real because we want to test off-diagonal implicit zeros,; # and having an imaginary first element would automatically fail.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py:10,test,test,10,qutip/tests/core/data/test_properties.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_properties.py,2,['test'],['test']
Testability,"# Some matrices _cannot_ be unsorted (e.g. if they have only one entry; # per row), so we add in this additional assertion message just to help; # out.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:113,assert,assertion,113,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['assert'],['assertion']
Testability,"# Specify parametrisation over a random Hamiltonian by specifying the; # dimensions, rather than duplicating that logic.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigenstates.py:114,log,logic,114,qutip/tests/core/test_eigenstates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_eigenstates.py,1,['log'],['logic']
Testability,"# Technically we could avoid hitting the limits of floating-point; # exponents for longer by doing all this in logarithmic space (using; # scipy.special.gammaln), but that ends up involving more; # floating-point operations overall, and needs special care around the; # point alpha = 0 to avoid nan appearing, due to how Python handles; # mixed-width arithmetic operations.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:111,log,logarithmic,111,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['log'],['logarithmic']
Testability,"# The assertion that rhs_mat has data type CSR is just a sanity; # check on the RHS creation. The base solver class will still; # convert the RHS to the type required by the ODE integrator if; # needed.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py:6,assert,assertion,6,qutip/solver/heom/bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_solvers.py,1,['assert'],['assertion']
Testability,"# The class names have an unusual naming convention to make them more; # convenient to use with the `pytest -k ""expr""` selection syntax. They start; # with the standard `Test`, but then are the name of the function they are; # testing in the function naming convention, so it's easy to remember the; # selector to choose a particular function.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:227,test,testing,227,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['test'],['testing']
Testability,"# The inner product is a bit more specialist, since it has to handle inputs; # in a 1D space specially. In order to keep things simple, we just; # generate those test cases completely separately from the standard; # `mathematically_correct`.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:162,test,test,162,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"# The test of exactitude is done in test_csr, test_dense.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_convert.py:6,test,test,6,qutip/tests/core/data/test_convert.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_convert.py,1,['test'],['test']
Testability,"# There are also some cases in the file where this fixture is explicitly; # overridden by a more local mark. That is deliberate; this dimension is; # intended for non-superoperators, and may cause inordinantly long tests if; # (for example) something uses dimension=100 then makes a superoperator out; # of it.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:215,test,tests,215,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['test'],['tests']
Testability,"# These ones are the metrics functions that we actually want to test.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:64,test,test,64,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['test'],['test']
Testability,"# This function might not need to be public, and consequently might not; # need to be tested here.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:86,test,tested,86,qutip/tests/core/test_dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py,2,['test'],['tested']
Testability,"# This is an exact copy of the pre-4.7 QuTiP HSolverDL test and; # is repeated here to ensure the new HSolverDL remains compatibile; # with the old one until it is removed.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:55,test,test,55,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['test'],['test']
Testability,"# This is the minimal set of test cases, with a Fock system and a qubit system; # both in ket form and dm form. The reference expectations are a 2D array; # which would be found by broadcasting `operator` against `state` and applying; # `qutip.expect` to the pairs.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:29,test,test,29,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['test'],['test']
Testability,"# Use indirection so that the tests can still be collected if there's a bug; # in the generating QuTiP functions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py:30,test,tests,30,qutip/tests/test_wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_wigner.py,1,['test'],['tests']
Testability,"# We can test with either Choi or chi, since the basis; # transformation between them is unitary and hence preserves; # the CP and TP conditions.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:9,test,test,9,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['test'],['test']
Testability,"# We check for the method, not the type to accept pseudo non-random; # generator for debug/testing purpose.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py:91,test,testing,91,qutip/solver/multitraj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/multitraj.py,1,['test'],['testing']
Testability,"# We do not allow yet qobj being multiplied by a numpy array that does not; # represent a scalar. If we include the feature of numpy broadcasting an qobj; # as scalar, this test should be removed.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:173,test,test,173,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# We only choose a small subset of dtypes to test so it isn't crazy.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:45,test,test,45,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,2,['test'],['test']
Testability,"# We test on a copy because scipy attempts to cache; # `has_sorted_indices`, but since it's a view, it has no idea what; # we've done to the indices behind the scenes and typically would not; # notice the change. The copy will return a difference scipy matrix,; # so the cache will not be built.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:5,test,test,5,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['test'],['test']
Testability,"# We test that the output dtype is a know type: accepted by `to.parse`.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:5,test,test,5,qutip/tests/core/test_qobjevo.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py,1,['test'],['test']
Testability,"# We use the master equation version as a base, but it doesn't actually; # matter - if all the tests fail, it implies that the ""me"" solver might be; # broken, whereas if only one fails, then it implies that only that one is; # broken. We test that all solvers are equivalent by transitive equality; # to the ""me"" solver.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py:95,test,tests,95,qutip/tests/solver/test_correlation.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_correlation.py,2,['test'],"['test', 'tests']"
Testability,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:13,test,test,13,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,4,['test'],['test']
Testability,"# We're just testing the output value, so it's important whether certain; # things are complex or real, but not what the magnitudes of constants are.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:13,test,testing,13,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,4,['test'],['testing']
Testability,"# dnorm tests have always been slightly flaky; in some cases, cvxpy will fail; # to solve the problem, and this can cause an entire test-suite failure. As; # long as we are using random tests (perhaps not ideal), this will happen; # occasionally. This isn't entirely a bug, it's just a reality of using a; # one-size-fits-all solver; we've historically assumed users who come up; # against this sort of thing will be accepting of the fact that dnorm; # calculation is nontrivial, and isn't always entirely feasible.; #; # To deal with it, we allow each test to be rerun twice, using; # pytest-rerunfailures. This should forbid pathological cases where the test; # is failing every time, but not penalise one-off failures. As far as we know,; # the failing tests always involve a random step, so triggering a re-run will; # have them choose new variables as well.; #; # The warning filter is to account for cvxpy < 1.1.10 which uses np.complex,; # which is deprecated as of numpy 1.20.; #; # Skip dnorm tests if we don't have cvxpy or cvxopt available, since dnorm; # depends on them.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:8,test,tests,8,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,7,['test'],"['test', 'test-suite', 'tests']"
Testability,"# for a single impurity we converge with max_depth = 2; # we specify the bosonic bath first to ensure that the test checks; # that the sums inside HEOMSolver grad-next/prev work when the bosonic; # mode is before the fermionic ones",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py:111,test,test,111,qutip/tests/solver/heom/test_bofin_solvers.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_bofin_solvers.py,1,['test'],['test']
Testability,"# if qset.has_openmp:; # from qutip.core.cy.openmp.benchmark import _spmvpy, _spmvpy_openmp; # @unittest.skipIf(qset.has_openmp == False, 'OPENMP not available.')",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py:51,benchmark,benchmark,51,qutip/tests/test_openmp.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_openmp.py,1,['benchmark'],['benchmark']
Testability,"# just assert that the baths are importable",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py:7,assert,assert,7,qutip/tests/solver/heom/test_heom.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py,1,['assert'],['assert']
Testability,"# just assert that the solvers and associated classes are importable",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py:7,assert,assert,7,qutip/tests/solver/heom/test_heom.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/heom/test_heom.py,1,['assert'],['assert']
Testability,"# qsave _always_ appends a suffix to the file name at the time of writing, but; # in case this changes in the future, to ensure that we never leak a temporary; # file into the user's folders, we simply apply these tests in a temporary; # directory. Windows also does not allow temporary files to be opened multiple; # times, so using a temporary directory is best.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py:214,test,tests,214,qutip/tests/test_fileio.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py,1,['test'],['tests']
Testability,"# real_num_cpu = qset.num_cpus; # real_thresh = qset.openmp_thresh; # if qset.has_openmp:; # For travis which VMs have only 1 cpu.; # Make sure the openmp version of the functions are tested.; # qset.num_cpus = 2; # qset.openmp_thresh = 100",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:184,test,tested,184,qutip/testing.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py,1,['test'],['tested']
Testability,"# runs tests in qutip.tests module only; # Restore previous settings; # if qset.has_openmp:; # qset.num_cpus = real_num_cpu; # qset.openmp_thresh = real_thresh",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py:7,test,tests,7,qutip/testing.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/testing.py,2,['test'],['tests']
Testability,"# scale=None is testing that the default value returns the identity.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:16,test,testing,16,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,3,['test'],['testing']
Testability,"# test 1; # mixed state with non-symmetrical block matrix elements",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"# test 2; # all elements in block-diagonal matrix",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"# test addition of one hermitan and one nonhermitian operator",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,test,test,2,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# test addition of two hermitan operators",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,test,test,2,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# test addition of two nonhermitian operators adding up to be hermitian",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,test,test,2,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# test creation of QobjEvo and call",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:2,test,test,2,qutip/tests/core/test_qobjevo.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py,1,['test'],['test']
Testability,"# test creation of QobjEvo with Qobj * Coefficient; # Skip pure func: QobjEvo(f(t, args) -> Qobj)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py:2,test,test,2,qutip/tests/core/test_qobjevo.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobjevo.py,1,['test'],['test']
Testability,"# test different shape and dims",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:2,test,test,2,qutip/tests/test_entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py,1,['test'],['test']
Testability,"# test error",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"# test measurement operators based on lambda functions",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:2,test,test,2,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['test'],['test']
Testability,"# test same shape, difference dims",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:2,test,test,2,qutip/tests/test_entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py,1,['test'],['test']
Testability,"# test trace",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,2,['test'],['test']
Testability,"# test using all combinations of the following operators",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:2,test,test,2,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['test'],['test']
Testability,"# test with linear function (trace)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,2,['test'],['test']
Testability,"# test with nonlinear function",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,test,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,2,['test'],['test']
Testability,"# tests 1",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,tests,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['tests']
Testability,"# tests 2",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:2,test,tests,2,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['tests']
Testability,"# this tests that simple methods correctly determine the steadystate; # with high accuracy for a small Liouvillian requiring correct weighting.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:7,test,tests,7,qutip/tests/solver/test_steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py,1,['test'],['tests']
Testability,"# users are not expected to be exposed to; # csr.empty directly, but it is good to; # avoid segfaults, so we test passing; # csr.empty(..) blocks here explicitly",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py:109,test,test,109,qutip/tests/core/data/test_csr.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_csr.py,1,['test'],['test']
Testability,"# vector L2-norm test",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:17,test,test,17,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# vector max (inf) norm test",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:24,test,test,24,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['test'],['test']
Testability,"# we divide by atol and take the log so that the error returned is 0; # at atol, which is convenient for calling root_scalar with.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py:33,log,log,33,qutip/solver/integrator/krylov.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/integrator/krylov.py,1,['log'],['log']
Testability,"## test for N even",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:3,test,test,3,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,"## test for N odd",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py:3,test,test,3,qutip/tests/piqs/test_piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/piqs/test_piqs.py,1,['test'],['test']
Testability,", sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.logspace(-5,0,100); H = QobjEvo(np.exp(-1j*tlist), tlist=tlist). ``scipy.interpolate``'s ``CubicSpline``, ``PPoly`` and ``Bspline`` are; also converted to interpolated coefficients (the same kind of coefficient; created from ``ndarray``). Other interpolation methods from; scipy are converted to a function-based coefficient (the same kind of; coefficient created from callables). Parameters; ----------; base : object; Base object to make into a Coefficient. args : dict, optional; Dictionary of arguments to pass to the function or string coefficient. order : int, default=3; Order of the spline for array based coefficient. tlist : iterable, optional; Times for each element of an array based coefficient. function_style : str {""dict"", ""pythonic"", None}, optional; Function signature of function based coefficients. args_ctypes : dict, optional; C type for the args when compiling array based coefficients. compile_opt : CompilationOptions, optional; Sets of options for the compilation of string based coefficients",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:2246,log,logspace,2246,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['log'],['logspace']
Testability,"ficients. For function based coefficients, the function signature must be either:. * ``f(t, ...)`` where the other arguments are supplied as ordinary; ""pythonic"" arguments (e.g. ``f(t, w, a=5)``); * ``f(t, args)`` where the arguments are supplied in a ""dict"" named; ``args``. By default the signature style is controlled by the; ``qutip.settings.core[""function_coefficient_style""]`` setting, but it; may be overriden here by specifying either ``function_style=""pythonic""``; or ``function_style=""dict""``. *Examples*:. - pythonic style function signature::. def f1_t(t, w):; return np.exp(-1j * t * w). coeff1 = coefficient(f1_t, args={""w"": 1.}). - dict style function signature::. def f2_t(t, args):; return np.exp(-1j * t * args[""w""]). coeff2 = coefficient(f2_t, args={""w"": 1.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin, cos, tan, asin, acos, atan, pi,; sinh, cosh, tanh, asinh, acosh, atanh,; exp, log, log10, erf, zerf, sqrt,; real, imag, conj, abs, norm, arg, proj,; numpy as np,; scipy.special as spe (python interface); and cython_special (scipy cython interface). *Examples*::. coeff = coefficient('exp(-1j*w1*t)', args={""w1"":1.}). 'args' is needed for string coefficient at compilation.; It is a dict of (name:object). The keys must be a valid variables string. Compilation options can be passed as ""compile_opt=CompilationOptions(...)"". For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used to compute the; coefficient at time t. The keyword ``order`` sets the order of the; interpolation. When ``order = 0``, the interpolation is step function that; evaluates to the most recent value. *Examples*::. tlist = np.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:1242,log,log,1242,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['log'],['log']
Testability,"ise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *data_inputs, ?out_type]; where `data_inputs` is of the same length as the input parameter; `types` and represents the Data arguments to the specialisation `op`.; Each element of `data_inputs` is a generator function which takes no; arguments and returns a data.Data subclass of the correct type and; shape. `out_type` is present in the output only if it were given as a; parameter itself.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1932,test,test,1932,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"op`,; which takes in several types `types`, where the arguments have shapes taken; from the iterable of iterables `shapes`. If `out_type` is specified, it; will be added into the output parameter set and its name added to the id,; but is otherwise not used. Parameters; ----------; cases_lookup: Map[Type, (shape: 2-tuple) -> list]; Mapping to get the special case generator from. This is one of; _ALL_CASES or _RANDOM (or similar). The elements of the list returned; from the case generator should all be closures of the form `() -> Data`; (e.g. `lambda: data.csr.identity(10)`), or a `pytest.ParameterSet`; containing exactly one value, which is the same closure type. op: Function; The specialisation of a mathematical operation that is being tested.; This is actually generally unused - it's just added in to the output; ParameterSet at the end so that it will get correctly parametrised. types: Tuple[Type]; A tuple of data.Data subclass types (not instances). This defines the; inputs to this particular specialisation under test. There should be; as many types as there are Data arguments to `op`. shapes: Iterable[Tuple[(int, int) | ParameterSet[(int, int)]]]; An iterable containing several sets of shapes to parameterise over.; Each element of the iterable should be s tuple of shapes, or; `pytest.ParameterSet` instances each containing a single shape. A; shape is a 2-tuple of integers. There should be as many elements of; this inner tuple as there are `types`, since each individual `shape`; goes with a `type`. out_type: Type; The output type for this specialisation. Not used other than its name; being added to the id, and it being added at the end of the; specialisation (if it is given), similarly to `op`. Returns; -------; List[ParameterSet]; A list of individual test cases for parametrisation. Each ParameterSet; will be; [op, *data_inputs, ?out_type]; where `data_inputs` is of the same length as the input parameter; `types` and represents the Data arguments to the specialisa",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:1178,test,test,1178,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['test'],['test']
Testability,"tum object.; contract(); Contract subspaces of the tensor structure which are 1D.; cosm(); Cosine of quantum object.; dag(); Adjoint (dagger) of quantum object.; data_as(format, copy); Vector / matrix representation of quantum object.; diag(); Diagonal elements of quantum object.; dnorm(); Diamond norm of quantum operator.; dual_chan(); Dual channel of quantum object representing a CP map.; eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object.; eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object.; expm(); Matrix exponential of quantum object.; full(order='C'); Returns dense array of quantum object `data` attribute.; groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object.; inv(); Return a Qobj corresponding to the matrix inverse of the operator.; logm(); Matrix logarithm of quantum operator.; matrix_element(bra, ket); Returns the matrix element of operator between `bra` and `ket` vectors.; norm(norm='tr', sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator.; overlap(other); Overlap between two state vectors or two operators.; permute(order); Returns composite qobj with indices reordered.; proj(); Computes the projector for a ket or bra vector.; ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace.; purity(); Calculates the purity of a quantum object.; sinm(); Sine of quantum object.; sqrtm(); Matrix square root of quantum object.; tidyup(atol=1e-12); Removes small elements from quantum object.; tr(); Trace of quantum object.; trans(); Transpose of quantum object.; transform(inpt, inverse=False); Performs a basis transformation defined by `inpt` matrix.; trunc_neg(method='clip'); Removes negative eigenvalues and returns a new Qobj that is; a valid density operator.; unit(norm='tr', sparse=",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:3577,log,logm,3577,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,2,['log'],"['logarithm', 'logm']"
Usability,""""""" A simplified relative entropy implementation for use in; double-checking the optimised implementation within; QuTiP itself.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py:6,simpl,simplified,6,qutip/tests/test_entropy.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_entropy.py,1,['simpl'],['simplified']
Usability,"""""""; A helper class for constructing a Padé expansion for Lorentzian fermionic; bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`LorentzianBath` which constructs; a simpler exponential expansion that converges much more slowly in; this particular case. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. gamma : float; The coupling strength between the system and the bath. w : float; The width of the environment. mu : float; The chemical potential of the bath. T : float; Bath temperature. Nk : int; Number of exponential terms used to approximate the bath correlation; functions. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:686,simpl,simpler,686,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['simpl'],['simpler']
Usability,"""""""; A helper class for constructing a Padé expansion for a Drude-Lorentz; bosonic bath from the bath parameters (see parameters below). A Padé approximant is a sum-over-poles expansion (; see https://en.wikipedia.org/wiki/Pad%C3%A9_approximant). The application of the Padé method to spectrum decompoisitions is described; in ""Padé spectrum decompositions of quantum distribution functions and; optimal hierarchical equations of motion construction for quantum open; systems"" [1]. The implementation here follows the approach in the paper. [1] J. Chem. Phys. 134, 244106 (2011); https://doi.org/10.1063/1.3602466. This is an alternative to the :class:`DrudeLorentzBath` which constructs; a simpler exponential expansion. Parameters; ----------; Q : Qobj; Operator describing the coupling between system and bath. lam : float; Coupling strength. gamma : float; Bath spectral density cutoff frequency. T : float; Bath temperature. Nk : int; Number of Padé exponentials terms used to approximate the bath; correlation functions. combine : bool, default True; Whether to combine exponents with the same frequency (and coupling; operator). See :meth:`BosonicBath.combine` for details. tag : optional, str, tuple or any other object; A label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py:691,simpl,simpler,691,qutip/solver/heom/bofin_baths.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/heom/bofin_baths.py,1,['simpl'],['simpler']
Usability,"""""""; A progress bar using tqdm module; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,progress bar,progress bar,7,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['progress bar'],['progress bar']
Usability,"""""""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,simpl,simple,7,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,2,"['progress bar', 'simpl']","['progress bar', 'simple']"
Usability,"""""""; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. - Order: 0.5; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:7,simpl,simple,7,qutip/solver/sode/itotaylor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py,1,['simpl'],['simple']
Usability,"""""""; A simple text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:7,simpl,simple,7,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,2,"['progress bar', 'simpl']","['progress bar', 'simple']"
Usability,"""""""; An abstract progress bar with some shared functionality. Example usage:. n_vec = linspace(0, 10, 100); pbar = TextProgressBar(len(n_vec)); for n in n_vec:; pbar.update(); compute_with_n(n); pbar.finished(). """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:17,progress bar,progress bar,17,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['progress bar'],['progress bar']
Usability,"""""""; An enhanced text-based progress bar.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py:28,progress bar,progress bar,28,qutip/ui/progressbar.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ui/progressbar.py,1,['progress bar'],['progress bar']
Usability,"""""""; Calculates the diamond norm of the quantum map q_oper, using; the simplified semidefinite program of [Wat13]_. The diamond norm SDP is solved by using `CVXPY <https://www.cvxpy.org/>`_. Parameters; ----------; A : Qobj; Quantum map to take the diamond norm of.; B : Qobj or None; If provided, the diamond norm of :math:`A - B` is taken instead.; solver : str {""CVXOPT"", ""SCS""}, default: ""CVXOPT""; Solver to use with CVXPY. ""SCS"" tends to be significantly faster, but; somewhat less accurate.; verbose : bool, default: False; If True, prints additional information about the solution.; force_solve : bool, default: False; If True, forces dnorm to solve the associated SDP, even if a special; case is known for the argument.; sparse : bool, default: True; Whether to use sparse matrices in the convex optimisation problem.; Default True. Returns; -------; dn : float; Diamond norm of q_oper. Raises; ------; ImportError; If CVXPY cannot be imported. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:71,simpl,simplified,71,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['simpl'],['simplified']
Usability,"""""""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1423,progress bar,progress bar,1423,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,1,['progress bar'],['progress bar']
Usability,"""""""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns; -------; result : list; The result list contains the value of ``task(value, args)`` for each; value in ``task_vec``, that is, it should be equivalent to; ``[task(v, args) for v in task_vec]``.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py:1397,progress bar,progress bar,1397,qutip/ipynbtools.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/ipynbtools.py,1,['progress bar'],['progress bar']
Usability,"""""""; Checks that binary ops preserve 'superrep'. .. note::. The random superoperators are not chosen in a way that reflects the; structure of that superrep, but are simply random matrices.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:165,simpl,simply,165,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['simpl'],['simply']
Usability,"""""""; Class to hold options for solver and integrator. Parameters; ----------; default : dict; Default dict, only keys in this will be accepted.; feedback : callable, ``f(keys : set) -> None``, optional; Function to called when an item is updated.; name : str, optional; Name of the solver or integrator that use this. Used in __repr__ only.; doc : str, optional; Overwrite the __doc__ of the instance.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py:145,feedback,feedback,145,qutip/solver/options.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/options.py,1,['feedback'],['feedback']
Usability,"""""""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:426,simpl,simplest,426,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['simpl'],['simplest']
Usability,"""""""; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable when derrivatives cannot be; analytically obtained.; See eq. (2.13) of chapter 11.2 of Peter E. Kloeden and Exkhard Platen,; *Numerical Solution of Stochastic Differential Equations.*. - Order: strong 1.5; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py:164,usab,usable,164,qutip/solver/sode/itotaylor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/sode/itotaylor.py,1,['usab'],['usable']
Usability,"""""""; Generate the matrix M governing the dynamics for diagonal cases. If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py:178,simpl,simple,178,qutip/piqs/piqs.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/piqs/piqs.py,1,['simpl'],['simple']
Usability,"""""""; In between object to store the stochastic system. It store the Hamiltonian (not Liouvillian when possible), and sc_ops.; dims and flags are provided to be usable the the base ``Solver`` class. We don't want to use the cython rhs (``StochasticOpenSystem``, etc.) since; the rouchon integrator need the part but does not use the usual drift and; diffusion computation.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py:160,usab,usable,160,qutip/solver/stochastic.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/stochastic.py,1,['usab'],['usable']
Usability,"""""""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py:846,simpl,simpler,846,qutip/wigner.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/wigner.py,1,['simpl'],['simpler']
Usability,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1113,progress bar,progress bar,1113,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['progress bar'],['progress bar']
Usability,"""""""; Parallel execution of a mapping of ``values`` to the function ``task``.; This is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. Use the loky module instead of multiprocessing. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1161,progress bar,progress bar,1161,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['progress bar'],['progress bar']
Usability,"""""""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of :func:`parallel_map`. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional argument to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword argument to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each tasks instead of; storing a them in a list. It should return None or a number.; When returning a number, it represent the estimation of the number of; task left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing:; - timeout: float, Maximum time (sec) for the whole map.; - fail_fast: bool, Raise an error at the first. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. If a ``reduce_func`` is provided, and empty list; will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1154,progress bar,progress bar,1154,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['progress bar'],['progress bar']
Usability,"""""""; Test the deep mapping. To simplify generation of edge-cases, this tests; against an equivalent (but slower) operation of flattening and unflattening; the list. We can get false negatives if the `flatten` or `unflatten`; functions are broken, but other tests should catch those.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py:31,simpl,simplify,31,qutip/tests/core/test_dimensions.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_dimensions.py,1,['simpl'],['simplify']
Usability,"""""""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:125,feedback,feedback,125,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,1,['feedback'],['feedback']
Usability,"""""""; Try to parse and verify that the result is still usable.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py:54,usab,usable,54,qutip/core/coefficient.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/coefficient.py,1,['usab'],['usable']
Usability,"""""""; We simply return None which does not have the `real` attribute.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:8,simpl,simply,8,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['simpl'],['simply']
Usability,"""""""; We simply return a string which does not have the `real` attribute.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:8,simpl,simply,8,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['simpl'],['simply']
Usability,"""""""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`.Qobj` / list of :class:`.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`.Qobj` / list of :class:`.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be; faster for long times (i.e., large Hilbert space). options : dict; Generic solver options.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py:100,feedback,feedback,100,qutip/legacy/nonmarkov/memorycascade.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/legacy/nonmarkov/memorycascade.py,4,['feedback'],['feedback']
Usability,"""""""Test dynamically updated arguments are usable.""""""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py:42,usab,usable,42,qutip/tests/solver/test_nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_nm_mcsolve.py,1,['usab'],['usable']
Usability,"""""""Truncates negative eigenvalues and renormalizes. Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters; ----------; method : str; Algorithm to use to remove negative eigenvalues. ""clip""; simply discards negative eigenvalues, then renormalizes.; ""sgs"" uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns; -------; oper : :class:`.Qobj`; A valid density operator.; """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:278,simpl,simply,278,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['simpl'],['simply']
Usability,"# Assert that each Clifford gate maps the set of Pauli gates back onto; # itself (though not necessarily in order). This condition is no; # stronger than simply considering each (gate, Pauli) pair separately.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py:154,simpl,simply,154,qutip/tests/core/test_gates.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_gates.py,1,['simpl'],['simply']
Usability,"# Check some other operations clear unitarity",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:30,clear,clear,30,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['clear'],['clear']
Usability,"# Finally, we add a known case from Johnston's QETLAB documentation,; # || Phi - I ||_♢,; # where Phi(X) = UXU⁺ and U = [[1, 1], [-1, 1]] / sqrt(2).",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py:107,UX,UXU,107,qutip/tests/core/test_metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_metrics.py,1,['UX'],['UXU']
Usability,"# Previously the ""states_only"" and ""expect_only"" tests were mixed in to; # every other test case. We move them out into the simplest set so that; # their behaviour remains tested, but isn't repeated as often to keep test; # runtimes shorter. The known-good cases are still tested in the other; # test cases, this is just testing the single-output behaviour.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py:124,simpl,simplest,124,qutip/tests/solver/test_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_mcsolve.py,2,['simpl'],['simplest']
Usability,"# Promote all parameters to Space to simplify later logic.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py:37,simpl,simplify,37,qutip/core/states.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/states.py,1,['simpl'],['simplify']
Usability,"# Set up the special cases for each type of matrix that will be tested. These; # should be kept low, because mathematical operations will test a Cartesian; # product of all the cases of the same order as the operation, which can get; # very large very fast. The operations should each complete in a small amount; # of time, so having 10000+ tests in this file still ought to take less than 2; # minutes, but it's easy to accidentally add orders of magnitude on.; #; # There is a layer of indirection---the cases are returned as 0-ary generator; # closures---for two reasons:; # 1. we don't have to store huge amounts of data at test collection time, but; # the matrices are only generated, and subsequently freed, within in each; # individual test.; # 2. each test can be repeated, and new random matrices will be generated for; # each repeat, rather than re-using the same set. This is somewhat; # ""defeating"" pytest fixtures, but here we're not worried about re-usable; # inputs, we just want the managed parametrisation.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:964,usab,usable,964,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['usab'],['usable']
Usability,"# Style of Bloch vectors, default = '-\|>' (or 'simple')",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py:48,simpl,simple,48,qutip/bloch.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/bloch.py,1,['simpl'],['simple']
Usability,"# TODO: coo_array from sicpy 1.8 would allow to simplify this.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py:48,simpl,simplify,48,qutip/random_objects.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/random_objects.py,1,['simpl'],['simplify']
Usability,"# The inner product is a bit more specialist, since it has to handle inputs; # in a 1D space specially. In order to keep things simple, we just; # generate those test cases completely separately from the standard; # `mathematically_correct`.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py:128,simpl,simple,128,qutip/tests/core/data/test_mathematics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/data/test_mathematics.py,1,['simpl'],['simple']
Usability,"# This gets called during the Monte-Carlo simulation of the associated; # completely positive master equation. To obtain the state of the actual; # system, we simply multiply the provided state with the current martingale; # before storing it / computing expectation values.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py:159,simpl,simply,159,qutip/solver/result.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/result.py,1,['simpl'],['simply']
Usability,"# We follow the strategy of using Watrous' simpler semidefinite; # program in its primal form. This is the same strategy used,; # for instance, by both pyGSTi and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.); # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U.; # There's a lot of conditions to check for this path. Only check if they; # aren't superoperators. The difference of unitaries optimization is; # currently only implemented for d == 2. Much of the code below is more; # general, though, in anticipation of generalizing the optimization.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py:43,simpl,simpler,43,qutip/core/metrics.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/metrics.py,1,['simpl'],['simpler']
Usability,"# We want to test the broadcasting rules for `qutip.expect` for a whole bunch; # of different systems, without having to repeatedly specify the systems over; # and over again. We first store a small number of test cases for known; # expectation value in the most bundled-up form, because it's easier to unroll; # these by applying the expected broadcasting rules explicitly ourselves than; # performing the inverse operation.; #; # We store a single test case in a record type, just to keep things neatly; # together while we're munging them, so it's clear at all times what; # constitutes a valid test case.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py:551,clear,clear,551,qutip/tests/core/test_expect.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_expect.py,1,['clear'],['clear']
Usability,"# `cache` may be 'clear', 'keep' or a new list of times for which; # to pre-compute the continuous contribution to the martingale",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py:18,clear,clear,18,qutip/solver/nm_mcsolve.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/nm_mcsolve.py,1,['clear'],['clear']
Usability,"# check that ttm result and exact solution are close in the learning times",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_transfertensor.py:60,learn,learning,60,qutip/tests/solver/test_transfertensor.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_transfertensor.py,1,['learn'],['learning']
Usability,"# clear cached values",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py:2,clear,clear,2,qutip/tests/core/test_qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/core/test_qobj.py,1,['clear'],['clear']
Usability,"# give complete information on Qobj without print statement in; # command-line we cant realistically serialize a Qobj into a string,; # so we simply return the informal __str__ representation instead.)",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py:142,simpl,simply,142,qutip/core/qobj.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/core/qobj.py,1,['simpl'],['simply']
Usability,"# qsave _always_ appends a suffix to the file name at the time of writing, but; # in case this changes in the future, to ensure that we never leak a temporary; # file into the user's folders, we simply apply these tests in a temporary; # directory. Windows also does not allow temporary files to be opened multiple; # times, so using a temporary directory is best.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py:195,simpl,simply,195,qutip/tests/test_fileio.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/test_fileio.py,1,['simpl'],['simply']
Usability,"# this tests that simple methods correctly determine the steadystate; # with high accuracy for a small Liouvillian requiring correct weighting.",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py:18,simpl,simple,18,qutip/tests/solver/test_steadystate.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/tests/solver/test_steadystate.py,1,['simpl'],['simple']
Usability,"documentation of mpi4py and; the mpi4py.MPIPoolExecutor class. Note: in keeping consistent with the API of `parallel_map`, the parameter; determining the number of requested worker processes is called `num_cpus`.; The value of `map_kw['num_cpus']` is passed to the MPIPoolExecutor as its; `max_workers` argument.; If this parameter is not provided, the environment variable; `QUTIP_NUM_PROCESSES` is used instead. If this environment variable is not; set either, QuTiP will use default values that might be unsuitable for MPI; applications. Parameters; ----------; task : a Python function; The function that is to be called for each value in ``task_vec``.; values : array / list; The list or array of values for which the ``task`` function is to be; evaluated.; task_args : list, optional; The optional additional arguments to the ``task`` function.; task_kwargs : dictionary, optional; The optional additional keyword arguments to the ``task`` function.; reduce_func : func, optional; If provided, it will be called with the output of each task instead of; storing them in a list. Note that the order in which results are; passed to ``reduce_func`` is not defined. It should return None or a; number. When returning a number, it represents the estimation of the; number of tasks left. On a return <= 0, the map will end early.; progress_bar : str, optional; Progress bar options's string for showing progress.; progress_bar_kwargs : dict, optional; Options for the progress bar.; map_kw: dict, optional; Dictionary containing entry for:; - timeout: float, Maximum time (sec) for the whole map.; - num_cpus: int, Number of jobs to run at once.; - fail_fast: bool, Abort at the first error.; All remaining entries of map_kw will be passed to the; mpi4py.MPIPoolExecutor constructor. Returns; -------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for; each value in ``values``. If a ``reduce_func`` is provided, and empty; list will be returned. """"""",MatchSource.CODE_COMMENT,qutip,qutip,v5.0.4,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py:1768,progress bar,progress bar,1768,qutip/solver/parallel.py,https://qutip.org,https://github.com/qutip/qutip/tree/v5.0.4/qutip/solver/parallel.py,1,['progress bar'],['progress bar']
