quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Energy Efficiency,"ject; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last upd",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:10628,power,power,10628,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['power'],['power']
Energy Efficiency,"ject; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/entropy.html:8564,power,power,8564,docs/4.5/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/entropy.html,1,['power'],['power']
Energy Efficiency,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17829,power,power,17829,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['power'],['power']
Energy Efficiency,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-parfor.html:6403,power,powerful,6403,docs/4.7/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html,2,['power'],['powerful']
Energy Efficiency,"l Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:1466,monitor,monitored,1466,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,2,['monitor'],['monitored']
Energy Efficiency,"l entanglement in a triple spin qubit"", ; arXiv:1604.02232. 171. Snijders et al., ""Purification of a single photon nonlinearity"", ; Nat. Commun. 7, 12578 (2016). 170. Levi et al., ""Designing spin-channel geometries for entanglement distribution"", ; Phys. Rev. A 94, 032302 (2016). 169. Vermersch et al., ""Implementation of chiral quantum optics with Rydberg and trapped-ion setups"", ; Phys. Rev. A 93, 063830 (2016). 168. Apollaro et al., ""Entanglement entropy in a periodically driven quantum Ising ring"", ; Phys. Rev. B 94, 134304 (2016). 167. Jonas, ""Fortran code for generating random probability vectors, unitaries, and quantum states"", ; Frontiers in ICT 3 (2016). 166. Ong et al., ""The Effect of Spin Squeezing on the Entanglement Entropy of Kicked Tops"", ; Entopy 18, 116 (2016). 165. Yang et al., ""Crosstalk-insensitive method for simultaneously coupling multiple pairs of resonators"", ; Phys. Rev. A 93, 042307 (2016). 164. Mavalankar et al., ""Photon-assisted tunneling and charge dephasing in a carbon nanotube double quantum dot"", ; Phys. Rev. B 93, 235428 (2016). 163. Hush et al., ""Quantum state transfer through time reversal of an optical channel"", ; Phys. Rev. A 94, 062302 (2016). 162. Royer et al., ""Fast and high-fidelity entangling gate through parametrically modulated longitudinal coupling"", ; Quantum 1, 11 (2017). 161. Lörch et al., ""Genuine Quantum Signatures in Synchronization of Anharmonic Self-Oscillators"", ; Phys. Rev. Lett. 117, 073601 (2016). 160. Ejtemaee et al., ""3D Sisyphus Cooling of Trapped Ions"", ; Phys. Rev. Lett. 119, 043001 (2017). 159. Rogers, ""The EPR Paradox Implies A Minimum Achievable Temperature"", ; Phys. Rev. E 95, 012149 (2017). 158. Fischer et al., ""Self-homodyne measurement of a dynamic Mollow triplet in the solid state"", ; Nat. Photonics 10, 163 (2016). 157. Zhao et al., ""Vacuum Rabi Splitting in Nanomechanical QED System with Nonlinear Resonator"", ; arXiv:1603.00215. 156. Türkpençe et al., ""Quantum fuel with multilevel atomic coherence ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:27583,charge,charge,27583,users.html,https://qutip.org,https://qutip.org/users.html,1,['charge'],['charge']
Energy Efficiency,"l gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13334,schedul,schedule,13334,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency,"l gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13300,schedul,schedule,13300,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['schedule']
Energy Efficiency,"l optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, optional, default = 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:105942,reduce,reduced,105942,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['reduce'],['reduced']
Energy Efficiency,"labels); ax.tick_params(axis='x', labelsize=12). # y axis; ytics = -0.5 + np.arange(M.shape[1]); ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/visualization.html:18255,energy,energy,18255,docs/4.6/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/visualization.html,2,['energy'],['energy']
Energy Efficiency,"lable_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` obtained by the method `find_topological_order`.; """"""; cycles_list = deepcopy(cycles_list). # distance to the start node; for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:; self.nodes[ind].distance_to_start = \; self.nodes[ind].duration; else:; self.nodes[ind].distance_to_start = max(; [; self.nodes[predecessor_ind].distance_to_start; for predecessor_ind; in self.nodes[ind].predecessors; ]; ) + self.nodes[ind].duration. # distance to the end node; cycles_list.reverse(); self.reverse_graph(); for cycle in cycles_list:; for ind in cycle:; if not self.nodes[ind].predecessors:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9842,schedul,schedule,9842,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"lculate all the expectation values, or output psi if; # no expectation value operators where defined; if output.num_expect == 0:; output.states.append(Qobj(psi_t)); else:; for e_idx, e in enumerate(e_ops):; output.expect[e_idx][t_idx] = expect(e, psi_t). return output. [docs]def floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T,; args, J_cb, w_th, kmax=5,; f_modes_table_t=None):; """"""; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); A list of initial Floquet modes. f_energies : array; The Floquet energies. c_op : :class:`qutip.qobj`; The collapse operators describing the dissipation. H : :class:`qutip.qobj`; System Hamiltonian, time-dependent with period `T`. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. J_cb : callback functions; A callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator `c_op`. w_th : float; The temperature in units of frequency. k_max : int; The truncation of the number of sidebands (default 5). f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table` (optional). Returns; -------. output : list. A list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. """""". N = len(f_energies); M = 2 * kmax + 1. omega = (2 * pi) / T. Delta = np.zeros((N, N, M)); X = np.zeros((N, N, M), dtype=complex); Gamma = np.zeros((N, N, M)); A = np.zeros((N, N)). nT = 100; dT = T / nT; tlist = np.arange(dT, T + dT / 2, dT). if f_modes_table_t is None:; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, nT + 1), H, T,; args). for t in tlist:; # TODO: repeated invocations of floquet_modes_t is; # ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:15693,power,power,15693,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,4,['power'],['power']
Energy Efficiency,"lf.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:6885,schedul,schedule,6885,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['schedule']
Energy Efficiency,"lf.pulses.append(; Pulse(sigmaz(), [m+1], spline_kind=self.spline_kind)); self.pulse_dict[""sz"" + str(m)] = index; index += 1; # coupling terms; a = tensor(; [destroy(self.num_levels)] +; [identity(2) for n in range(N)]); for n in range(N):; sm = tensor([identity(self.num_levels)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.pulses.append(; Pulse(a.dag() * sm + a * sm.dag(),; list(range(N+1)), spline_kind=self.spline_kind)); self.pulse_dict[""g"" + str(n)] = index; index += 1. [docs] def set_up_params(; self, N, num_levels, deltamax,; epsmax, w0, wq, eps, delta, g):; """"""; Save the parameters in the attribute `params` and check the validity.; The keys of `params` including ""sx"", ""sz"", ""w0"", ""eps"", ""delta""; and ""g"", each; mapped to a list for parameters corresponding to each qubits.; For coupling strength ""g"", list element i is the interaction; between qubits i and i+1. Parameters; ----------; N: int; The number of qubits in the system. num_levels: int; The number of energy levels in the resonator. deltamax: list; The coefficients of sigma-x for each of the qubits in the system. epsmax: list; The coefficients of sigma-z for each of the qubits in the system. wo: int; The base frequency of the resonator. wq: list; The frequency of the qubits. eps: list; The epsilon for each of the qubits in the system. delta: list; The delta for each of the qubits in the system. g: list; The interaction strength for each of the qubit with the resonator. Notes; -----; All parameters will be multiplied by 2*pi for simplicity; """"""; sx_para = 2 * np.pi * self.to_array(deltamax, N); self._params[""sx""] = sx_para; sz_para = 2 * np.pi * self.to_array(epsmax, N); self._params[""sz""] = sz_para; w0 = 2 * np.pi * w0; self._params[""w0""] = w0; eps = 2 * np.pi * self.to_array(eps, N); self._params[""eps""] = eps; delta = 2 * np.pi * self.to_array(delta, N); self._params[""delta""] = delta; g = 2 * np.pi * self.to_array(g, N); self._params[""g""] = g. # computed; self.wq = np.sqrt(eps**2 +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:6914,energy,energy,6914,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,4,['energy'],['energy']
Energy Efficiency,"like; A 2d NumPy array of the shape ``(len(ctrls), len(tlist))``. Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pulse_dict is not given, compute the number of pulses; num_controls = 0; for instruction in instruction_list:; for pulse_index, _ in instruction.pulse_info:; num_controls = max(num_controls, pulse_index); num_controls += 1. # schedule; # scheduled_start_time:; # An ordered list of the start_time for each pulse,; # corresponding to gates in the instruction_list.; # instruction_list reordered according to the scheduled result; instruction_list, scheduled_start_time = \; self._schedule(instruction_list, schedule_mode). # An instruction can be composed from several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeff",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:5797,schedul,schedule,5797,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['schedul'],['schedule']
Energy Efficiency,"lim_{t o \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\end{split}\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : list / array. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum: array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : list / array. list/array of times \(t\) which the correlation function is given. y : list / array. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, taulist, c_ops, a_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x105963998>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) = \lim_{t o \infty}; \frac{\langle a^\dagger(t+\tau)a(t)\rangle}; {\langle a^\dagger(t)a(t)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Note: g1 is only defined for stationary; statistics (uses steady state). Parameters:H : qutip.qobj.Qobj. system Hamiltonian. taulist : list / array. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (me for master-equation and; es for exponential series). options : qutip.solver.Options. solver options class. ntraj is taken as a two-element l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:86042,power,power,86042,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:151998,energy,energy,151998,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"lize. xlabels : list of strings. list of x labels. ylabels : list of strings. list of y labels. title : string. title of the plot (optional). limits : list/array with two float numbers. The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:80174,energy,energy,80174,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"llian operator. c_op_list : list. A list of collapse operators. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’. Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:105830,power,power,105830,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"llian operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = ‘iterative’; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_spec : str, optional, default=’COLAMD’; Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:107568,power,power,107568,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"locks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:152034,energy,energy,152034,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"loquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:98984,energy,energy,98984,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"loquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:68717,energy,energy,68717,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"lor=colors). if title and fig:; ax.set_title(title). # x axis; ax.axes.w_xaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:14408,energy,energy,14408,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,7,['energy'],['energy']
Energy Efficiency,"lot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:12355,efficient,efficient,12355,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,2,['efficient'],['efficient']
Energy Efficiency,"lot using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:12373,efficient,efficient,12373,docs/4.2/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html,1,['efficient'],['efficient']
Energy Efficiency,"lot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho (qutip.qobj.Qobj) – The density matrix (or ket) of the state to visualize.; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; title (string) – An optional title for the figure.; figsize ((width, height)) – The size of the matplotlib figure (in inches) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:117731,energy,energy,117731,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"lots the dispersion relationship for the lattice with the specified; number of unit cells. The dispersion of the infinte crystal is also; plotted if num_cell is smaller than MAXc.; """"""; MAXc = 20 # Cell numbers above which we do not plot the infinite; # crystal dispersion; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""). if self.num_cell <= MAXc:; (kxA, val_ks) = self.get_dispersion(101); (knxA, val_kns) = self.get_dispersion(); fig, ax = plt.subplots(); if self.num_cell <= MAXc:; for g in range(self._length_of_unit_cell):; ax.plot(kxA/np.pi, val_ks[g, :]). for g in range(self._length_of_unit_cell):; if self.num_cell % 2 == 0:; ax.plot(np.append(knxA, [np.pi])/np.pi,; np.append(val_kns[g, :], val_kns[g, 0]), 'ro'); else:; ax.plot(knxA/np.pi, val_kns[g, :], 'ro'); ax.set_ylabel('Energy'); ax.set_xlabel('$k_x(\pi/a)$'); plt.show(fig); fig.savefig('./Dispersion.pdf'). [docs] def get_dispersion(self, knpoints=0):; """"""; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns; -------; knxa : np.array; knxA[j][0] is the jth good Quantum number k. val_kns : np.array; val_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k.; """"""; # The _k_space_calculations() function is not used for get_dispersion; # because we calculate the infinite crystal dispersion in; # plot_dispersion using this coode and we do not want to calculate; # all the eigen-values, eigenvectors of the bulk Hamiltonian for too; # many points, as is done in the _k_space_calculations() function.; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""); if knpoints == 0:; knpoints = self.num_cell. a = 1 # The unit cell length is always considered 1; kn_start = 0; kn_end = 2*np.pi/a; val_kns = np.zeros((self._length_of_unit_cell, knpoints), dtype=float); knxA = np.zeros((knpoints, 1), dtype=float); G0_H = self._H_intra; # knxA = n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/lattice.html:25844,energy,energy,25844,docs/4.5/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/lattice.html,1,['energy'],['energy']
Energy Efficiency,"lt = False. ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional. ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, optional, default = 100. ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4. ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None. ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’. ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns:dm : qobj. Steady state density matrix. info : dict, optional. Dictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters:A : qobj. A Hamiltonian or Liou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:103784,reduce,reduced,103784,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['reduce'],['reduced']
Energy Efficiency,"lt = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’; ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns:; dm : qobj; Steady state density matrix. info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters:; A : qobj; A Hamiltonian or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:105518,reduce,reduced,105518,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['reduce'],['reduced']
Energy Efficiency,"ltiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; os.environ['QUTIP_IN_PARALLEL'] = 'TRUE'; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(); os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return par_return. except KeyboardInterrupt:; os.environ['QUTIP_IN_PARALLEL'] = 'FALSE'; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to::. result = [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/parallel.html:4454,Reduce,Reduce,4454,docs/4.6/modules/qutip/parallel.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/parallel.html,2,['Reduce'],['Reduce']
Energy Efficiency,"lues representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘iterative’, ‘laguerre’, ‘fft’}. Select method ‘iterative’, ‘laguerre’, or ‘fft’, where ‘iterative’ uses; an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘fft’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). parfor : bool {False, True}. Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:W : array. Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array. FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:76661,efficient,efficient,76661,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['efficient'],['efficient']
Energy Efficiency,"ly on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-tensor.html:4734,energy,energy,4734,docs/4.2/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-tensor.html,6,['energy'],['energy']
Energy Efficiency,"ly on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-tensor.html:5534,energy,energy,5534,docs/3.1.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html,1,['energy'],['energy']
Energy Efficiency,"ly on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:5391,energy,energy,5391,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"m several different pulse elements.; # We separate them an assign them to each pulse index.; pulse_instructions = [[] for tmp in range(num_controls)]; for instruction, start_time in \; zip(instruction_list, scheduled_start_time):; for pulse_name, coeff in instruction.pulse_info:; if self.pulse_dict:; try:; pulse_ind = self.pulse_dict[pulse_name]; except KeyError:; raise ValueError(; f""Pulse name {pulse_name} not found""; "" in pulse_dict.""); else:; pulse_ind = pulse_name; pulse_instructions[pulse_ind].append(; (start_time, instruction.tlist, coeff)). # concatenate pulses; compiled_tlist, compiled_coeffs = \; self._concatenate_pulses(; pulse_instructions, scheduled_start_time, num_controls); return compiled_tlist, compiled_coeffs. def _schedule(self, instruction_list, schedule_mode):; """"""; Schedule the instructions if required and ; reorder instruction_list accordingly; """"""; if schedule_mode:; scheduler = Scheduler(schedule_mode); scheduled_start_time = scheduler.schedule(instruction_list); time_ordered_pos = np.argsort(scheduled_start_time); instruction_list = [instruction_list[i] for i in time_ordered_pos]; scheduled_start_time.sort(); else: # no scheduling; scheduled_start_time = [0.]; for instruction in instruction_list[:-1]:; scheduled_start_time.append(; instruction.duration + scheduled_start_time[-1]); return instruction_list, scheduled_start_time. def _concatenate_pulses(; self, pulse_instructions, scheduled_start_time, num_controls):; """"""; Concatenate compiled pulses coefficients and tlist for each pulse.; If there is idling time, add zeros properly to prevent wrong spline.; """"""; # Concatenate tlist and coeffs for each control pulses; compiled_tlist = [[] for tmp in range(num_controls)]; compiled_coeffs = [[] for tmp in range(num_controls)]; for pulse_ind in range(num_controls):; last_pulse_time = 0.; for start_time, tlist, coeff in pulse_instructions[pulse_ind]:; # compute the gate time, step size and coeffs; # according to different pulse mode; gate_tlist, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:7104,schedul,schedule,7104,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['schedul'],['schedule']
Energy Efficiency,"m with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:4906,power,power,4906,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['power'],['power']
Energy Efficiency,"main work of converting between representations,; # and are exposed below by other functions that add postconditions about types.; #; # TODO: handle type='kraus' as a three-index Qobj, rather than as a list?. def _super_tofrom_choi(q_oper):; """"""; We exploit that the basis transformation between Choi and supermatrix; representations squares to the identity, so that if we munge Qobj.type,; we can use the same function. Since this function doesn't respect :attr:`Qobj.type`, we mark it as; private; only those functions which wrap this in a way so as to preserve; type should be called externally.; """"""; data = q_oper.data.toarray(); dims = q_oper.dims; new_dims = [[dims[1][1], dims[0][1]], [dims[1][0], dims[0][0]]]; d0 = np.prod(np.ravel(new_dims[0])); d1 = np.prod(np.ravel(new_dims[1])); s0 = np.prod(dims[0][0]); s1 = np.prod(dims[1][1]); return Qobj(dims=new_dims,; inpt=data.reshape([s0, s1, s0, s1]).; transpose(3, 1, 2, 0).reshape((d0, d1))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**floor(log2(dim)) == dim; for dim in flatten(dims); ]). def _super_to_superpauli(q_oper):; """"""; Converts a superoperator in the column-stacking basis to; the Pauli basis (assuming qubit dimensions). This is an internal function, as QuTiP does not currently have; a way to mark that superoperators are represented in the Pauli; basis as opposed to the column-stacking basis; a Pauli-basis; ``type='super'`` would thus break other conversion functions.; """"""; # Ensure we start with a column-stacking-basis superoperator.; sqobj = to_super(q_oper); if not _isqubitdims(sqobj.dims):; raise ValueError(""Pauli basis is only defined for qubits.""); nq = int(log2(sqobj.shape[0]) / 2); B = _pauli_basis(nq) / sqrt(2**nq); # To do this, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:6019,power,powers,6019,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,5,['power'],['powers']
Energy Efficiency,"many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters:; N: int; The number of two-level systems. Returns:; Nj: int; The number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters:; nds: int; The number of Dicke states. Returns:; N: int; The number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters:; mat: ndarray/Qobj; A 2D numpy array. Returns:; diag: bool; True/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters:; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns:; degeneracy: int; The state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters:; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns:; degeneracy: int; The m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters:; j, m: float; The value for j and m in the dicke basis |j,m>. Returns:; a_plus: float; The value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters:; j: float; The value for j. m: float; The value for m. Returns:; a_minus: float; The value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:121058,energy,energy,121058,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None). Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError. Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:rho : qutip.qobj.Qobj. The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance. The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance. The axes context in which the plot will be drawn. title : string. An optional title for the figure. figsize : (width, height). The size of the matplotlib figure (in inch",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:116675,energy,energy,116675,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"max=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100, options_modes=None)[source]¶; Solve the Schrodinger equation using the Floquet formalism. P",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:108408,energy,energy,108408,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"me for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:98538,power,power,98538,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"me-dependent Hamiltonian) The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f; (Qobj) The final unitary transformation that is realized by the evolution of the system with the GRAPE generated pulse sequences. class Dynamics(optimconfig)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before any of the methods; can be used.; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN Note value should be set using set_log_level. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. num_tslots; (integer) Number of timeslots, aka timeslices. num_ctrls; (integer) Number of controls. Note this is set when get_num_ctrls is called based on the length of ctrl_dyn_gen. evo_time; (float) Total time for the evolution. tau; (array[num_tslots] of float) Duration of each timeslot Note that if this is set before initialize_controls is called then num_tslots and evo_time are calculated from tau, otherwise tau is generated from num_tslots and evo_time, that is equal size time slices. ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:46005,reduce,reduce,46005,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['reduce'],['reduce']
Energy Efficiency,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:10882,energy,energy,10882,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:11130,energy,energy,11130,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,10,['energy'],['energy']
Energy Efficiency,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (5) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (5) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the same function (qutip.mesolve) is used for; evolution both according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:11223,energy,energy,11223,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency,"mentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing; Changelog Generation. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; Solver data layer integration; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. Completed Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; QIP migration; HEOM revamp. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/development.html:2152,Monitor,Monitoring,2152,docs/4.7/development/development.html,https://qutip.org,https://qutip.org/docs/4.7/development/development.html,1,['Monitor'],['Monitoring']
Energy Efficiency,"mi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise MemoryError if subsequently passed a state of sufficiently; large dimension that this bound would be exceeded. In those cases, use; qfunc with precompute_memory=None instead to force using; the slower, more memory-efficient algorithm. See also. qfunca single function version, which will involve computing several quantities multiple times in order to use less memory. Examples; Initialise the class for a square set of coordinates, with some states we; want to investigate.; >>> xvec = np.linspace(-2, 2, 101); >>> states = [qutip.rand_dm(10) for _ in [None]*10]; >>> qfunc = qutip.QFunc(xvec, xvec). Now we can calculate the Husimi-Q function over each of the states more; efficiently with:; >>> husimiq = np.array([qfunc(state) for state in states]). Cubic Spline¶. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]¶; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betafloatSecond-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, “Multidimensional Spline Interpolation:; Theory and Applications”, Comput Econ 30, 153 (2007). Attributes. afloatLower bound of the interval. bfloatUpper bound of the interval. coeffsndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOM",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:35093,efficient,efficiently,35093,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['efficient'],['efficiently']
Energy Efficiency,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:1704,adapt,adaptation,1704,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,6,['adapt'],"['adaptation', 'adaptations', 'adapted']"
Energy Efficiency,"more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:4568,efficient,efficient,4568,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"ms where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes:; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann’s constant. options : qutip.solver.Options; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : qutip.solver.Stats; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options : qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:24733,reduce,reduced,24733,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"ms` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.ten",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:20896,charge,charge,20896,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency,"mulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html:4335,monitor,monitored,4335,docs/4.6/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-stochastic.html,4,['monitor'],['monitored']
Energy Efficiency,"municate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:6495,reduce,reduce,6495,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['reduce'],['reduce']
Energy Efficiency,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2090,efficient,efficiently,2090,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html:2191,efficient,efficiently,2191,docs/3.1.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html,1,['efficient'],['efficiently']
Energy Efficiency,"n a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-tensor.html:4813,energy,energy,4813,docs/4.7/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:135578,power,power,135578,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,16,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"n np.abs(np.dot(alphas, (self._g * 0.5) * vector)) ** 2. def __call__(self, state: Qobj):; """"""; Get the Husimi-Q function for the given state vector or density matrix,; over the coordinates used to initialise the class. If called multiple; times, the states do not need to have the same dimensions, but none of; them can have tensor-product structure.; """"""; state = _qfunc_check_state(state); alphas = self._alphas(state.shape[0]); if state.isket:; return self._single(state.full().ravel(), alphas) / np.pi; # We don't use Qobj.eigenstates() to avoid building many unnecessary; # CSR versions of dense matrices.; values, vectors = eigh(state.full()); vectors = vectors.T; out = values[0] * self._single(vectors[0], alphas); for value, vector in zip(values[1:], vectors[1:]):; out += value * self._single(vector, alphas); return out / np.pi. def _qfunc_iterative_single(; vector: np.ndarray, alpha_grid: _QFuncCoherentGrid, g: float,; ):; r""""""; Get the Q function (without the :math:`\pi` scaling factor) of a single; state vector, using the iterative algorithm which recomputes the powers of; the coherent-state matrix.; """"""; ns = np.arange(vector.shape[0]); out = np.polyval(; (0.5*g * vector / np.sqrt(scipy.special.factorial(ns)))[::-1],; alpha_grid.grid,; ); out *= alpha_grid.prefactor; return np.abs(out)**2. [docs]def qfunc(; state: Qobj,; xvec,; yvec,; g: float = sqrt(2),; precompute_memory: float = 1024,; ):; r""""""; Husimi-Q function of a given state vector or density matrix at phase-space; points ``0.5 * g * (xvec + i*yvec)``. Parameters; ----------; state : :obj:`.Qobj`; A state vector or density matrix. This cannot have tensor-product; structure. xvec, yvec : array_like; x- and y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of :math:`\hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:24847,power,powers,24847,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['power'],['powers']
Energy Efficiency,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'. permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diag",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:32771,power,power,32771,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,14,['power'],['power']
Energy Efficiency,"n operator. c_op_list : list; A list of collapse operators. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:28503,power,power,28503,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency,"n rates.; In [1]: times = np.linspace(0,10.0,200). In [2]: a = destroy(10). In [3]: x = a.dag() + a. In [4]: H = a.dag() * a. In [5]: corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x). In [6]: corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x). In [7]: corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). In [8]: figure(); Out[8]: <Figure size 640x480 with 0 Axes>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x1a26dd45f8>,; <matplotlib.lines.Line2D at 0x1a26dd4668>,; <matplotlib.lines.Line2D at 0x1a250d2c18>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x1a2551cef0>. In [11]: xlabel(r'Time $t$'); Out[11]: Text(0.5,0,'Time $t$'). In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: Text(0,0.5,'Correlation $\\left<x(t)x(0)\\right>$'). In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; import pylab as plt; from qutip import *. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = ten",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-correlation.html:4999,power,power,4999,docs/4.5/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-correlation.html,1,['power'],['power']
Energy Efficiency,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWhether or not to show the legend. figa matplotlib Figure instanceThe Figure c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:168638,energy,energy,168638,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visualize. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. titlestringAn optional title for the figure. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:131046,energy,energy,131046,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"nal dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15877,schedul,schedule,15877,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"nalty""). progress_bar.start(R); for r in range(R - 1):; progress_bar.update(r). dt = times[1] - times[0]. if use_interp:; ip_funcs = [interp1d(times, u[r, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[r, j, -1]); for j in range(J)]. def _H_t(t, args=None):; return H0 + sum([float(ip_funcs[j](t)) * H_ops[j]; for j in range(J)]). U_list = [(-1j * _H_t(times[idx]) * dt).expm(); for idx in range(M-1)]. else:; def _H_idx(idx):; return H0 + sum([u[r, j, idx] * H_ops[j] for j in range(J)]). U_list = [(-1j * _H_idx(idx) * dt).expm() for idx in range(M-1)]. U_f_list = []; U_b_list = []. U_f = 1; U_b = 1; for n in range(M - 1):. U_f = U_list[n] * U_f; U_f_list.append(U_f). U_b_list.insert(0, U_b); U_b = U_list[M - 2 - n].dag() * U_b. for j in range(J):; for m in range(M-1):; P = U_b_list[m] * U; Q = 1j * dt * H_ops[j] * U_f_list[m]. if phase_sensitive:; du = - _overlap(P, Q); else:; du = - 2 * _overlap(P, Q) * _overlap(U_f_list[m], P). if alpha:; # penalty term for high power control signals u; du += -2 * alpha * u[r, j, m] * dt. if beta:; # penalty term for late control signals u; du += -2 * beta * m * u[r, j, m] * dt. u[r + 1, j, m] = u[r, j, m] + eps * du.real. if u_limits:; if u[r + 1, j, m] < u_limits[0]:; u[r + 1, j, m] = u_limits[0]; elif u[r + 1, j, m] > u_limits[1]:; u[r + 1, j, m] = u_limits[1]. u[r + 1, j, -1] = u[r + 1, j, -2]. if use_interp:; ip_funcs = [interp1d(times, u[R - 1, j, :], kind=interp_kind,; bounds_error=False, fill_value=u[R - 1, j, -1]); for j in range(J)]. H_td_func = [H0] + [[H_ops[j], lambda t, args, j=j: ip_funcs[j](t)]; for j in range(J)]; else:; H_td_func = [H0] + [[H_ops[j], u[-1, j, :]] for j in range(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:8159,power,power,8159,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['power'],['power']
Energy Efficiency,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. [docs]def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.lin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:12179,efficient,efficiently,12179,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,2,['efficient'],['efficiently']
Energy Efficiency,"nces = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.full(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]). J_dat = J.data. if not sparse:; # The parameters and constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji = dnorm_problem(dim). # Load the parameters with the Choi matrix passed in.; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(). Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices,; J_dat.indptr),; shape=J_dat.shape).toarray(); else:. # The parameters do not depend solely on the dimension,; # so we can not cache them efficiently.; problem = dnorm_sparse_problem(dim, J_dat). problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:13855,efficient,efficiently,13855,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['efficient'],['efficiently']
Energy Efficiency,"nd `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:20969,charge,charge,20969,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:3124,efficient,efficient,3124,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['efficient'],['efficient']
Energy Efficiency,"nd y-coordinates at which to calculate the Husimi-Q function. g : float, default sqrt(2); Scaling factor for ``a = 0.5 * g * (x + iy)``. The value of `g` is; related to the value of :math:`\hbar` in the commutation relation; :math:`[x,\,y] = i\hbar` via :math:`\hbar=2/g^2`, so the default; corresponds to :math:`\hbar=1`. precompute_memory : real, default 1024; Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set ``precompute_memory=None``. Returns; --------; ndarray; Values representing the Husimi-Q function calculated over the specified; range ``[xvec, yvec]``. See Also; --------; :obj:`.QFunc` :; a class-based version, more efficient if you want to calculate the; Husimi-Q function for several states over the same coordinates.; """"""; state = _qfunc_check_state(state); xvec, yvec = _qfunc_check_coordinates(xvec, yvec); required_memory = state.shape[0] * xvec.size * yvec.size * 16 / (1024 ** 2); enough_memory = (; precompute_memory is not None; and precompute_memory > required_memory; ); if state.isoper and enough_memory:; return QFunc(xvec, yvec, g)(state); if precompute_memory is not None and state.isoper:; warnings.warn(; ""Falling back to iterative algorithm due to lack of memory.""; f"" Needed {required_memory:.2f} MB, but only allowed to use""; f"" {precompute_memory:.2f} MB. Increase `precompute_memory` to""; "" raise limit, or set to `None` to suppress warning.""; ); alpha_grid = _QFuncCoherentGrid(xvec, yvec, g); if state.isket:; out = _qfunc_iterative_single(state.full().ravel(), alpha_grid, g); out /= np.pi; return out; # We don't use Qobj.eigenstates() to avoid building many unnecessary CSR; # versions of dense matrices.; values, vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:26426,efficient,efficient,26426,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['efficient'],['efficient']
Energy Efficiency,"nd('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = sp.csgraph.reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:26395,power,power,26395,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['power'],['power']
Energy Efficiency,"ndarray, optional) – Requested elements to include in array. Returns:samples – Original equally spaced sample array with additional; elements added. Return type:ndadrray. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 (float) – Total angular momentum 1.; j2 (float) – Total angular momentum 2.; j3 (float) – Total angular momentum 3.; m1 (float) – z-component of angular momentum 1.; m2 (float) – z-component of angular momentum 2.; m3 (float) – z-component of angular momentum 3. Returns:cg_coeff – Requested Clebsch-Gordan coefficient. Return type:float. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value (float / array) – The energy in the old unit.; orig (string) – The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”); to (string) – The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit – The energy in the new unit. Return type:float / array. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename (str) – Name of file containing reqested data.; sep (str) – Seperator used to store data. Returns:data – Data from selected file. Return type:array_like. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename (str) – Name of data file to be stored, including extension.; data (array_like) – Data to be written to file.; numtype (str {'complex, 'real'}) – Type of numerical data.; numformat (str {'decimal','exp'}) – Format for written data.; sep (str) – Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name (str) – Name of data file to be loaded. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:195017,energy,energy,195017,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"near solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. method : str, default = 'iterative'; Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use 'iterative'.; For power iterative methods use 'power'.; ; permc_spec : str, optional, default='COLAMD'; Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. fill_factor : float, optional, default = 100; Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tol : float, optional, default = 1e-4; Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional, default = None; Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = 'smilu_2'; Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns; -------; lu : object; Returns a SuperLU object representing iLU preconditioner. info : dict, optional; Dictionary containing solver-specific information.; """"""; ss_args = _default_steadystate_args(); ss_args['method'] = 'iterative'; for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(""Invalid keyword argument '"" + key +; ""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:29163,reduce,reduced,29163,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['reduce'],['reduced']
Energy Efficiency,"nenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value.; ; if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2); ; # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; ; Jr.value = sp.csr_matrix((J_dat.data.real, J_dat.indices, J_dat.indptr), ; shape=J_dat.shape); ; Ji.value = sp.csr_matrix((J_dat.data.imag, J_dat.indices, J_dat.indptr),; shape=J_dat.shape); # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose); ; return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchfor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/metrics.html:12021,efficient,efficiently,12021,docs/4.3/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/metrics.html,2,['efficient'],['efficiently']
Energy Efficiency,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more informati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:5915,reduce,reduce,5915,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,4,['reduce'],['reduce']
Energy Efficiency,"nerators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more informatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:7092,reduce,reduce,7092,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['reduce'],['reduce']
Energy Efficiency,"nergy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7364,energy,energy,7364,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"ng for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:1579,monitor,monitored,1579,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,2,['monitor'],['monitored']
Energy Efficiency,"ng of the valid; taus for this row and column of the Dicke space element. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:59287,reduce,reduced,59287,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any oth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15074,efficient,efficient,15074,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['efficient'],['efficient']
Energy Efficiency,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14760,efficient,efficient,14760,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['efficient'],['efficient']
Energy Efficiency,"ng; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); ; v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and settings.has_mkl:; lu.delete(); if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end = time.time(); ss_args['info']['solution_time'] = _power_end-_power_start; ss_args['info']['iterations'] = it; if ss_args['return_info']:; ss_args",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25741,power,power,25741,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"ngth = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffle=random_shuffle, repeat_num=0); current_length = max(gate_cycle_indices); if current_length < max_length:; result = gate_cycle_indices; max_length = current_length; return result. if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit. # Generate the quantum operations dependency graph.; instructions_graph = InstructionsGraph(gates); instructions_graph.generate_dependency_graph(; commuting=self.commutation_rules); if self.method == ""ALAP"":; instructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18194,Schedul,Schedule,18194,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,2,['Schedul'],['Schedule']
Energy Efficiency,"nnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:102006,power,power,102006,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,4,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-parfor.html:4773,power,powerful,4773,docs/3.0.1/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-parfor.html:4711,power,powerful,4711,docs/3.0.0/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:3317,power,power,3317,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['power'],['power']
Energy Efficiency,"nsure_int(N / 2 + m))); d2 = Decimal(factorial(_ensure_int(N / 2 - m))); degeneracy = numerator / (d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; r""""""Calculate the degeneracy of the Dicke state. Each state :math:`\lvert j, m\rangle` includes D(N,j) irreducible; representations :math:`\lvert j, m, \alpha\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2 * j + 1); denominator_1 = Decimal(factorial(_ensure_int(N / 2 + j + 1))); denominator_2 = Decimal(factorial(_ensure_int(N / 2 - j))); degeneracy = numerator / (denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; r""""""Calculate the number of Dicke states :math:`\lvert j, m\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N / 2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; r""""""; Calculate the coefficient ``ap`` by applying :math:`J_+\lvert j,m\rangle`. The action of ap is given by:; :math:`J_{+}\lvert j, m\rangle = A_{+}(j, m) \lvert j, m+1\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis :math:`\lvert j, m\rangle`. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j - m) * (j + m + 1)); return a_plus. [docs]def am(j, m):; r""""""Calculate the operator ``am`` used later. The actio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:17655,energy,energy,17655,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,4,['energy'],['energy']
Energy Efficiency,"nt time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'arccos', 'arccosh', 'arg', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:])",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:3086,efficient,efficient,3086,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"nt(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2*j + 1); denominator_1 = Decimal(factorial(N/2 + j + 1)); denominator_2 = Decimal(factorial(N/2 - j)); degeneracy = numerator/(denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N/2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; """"""Calculate the coefficient `ap` by applying J_+ |j, m>. The action of ap is given by:; :math:`J_{+}|j, m\\rangle = A_{+}(j, m)|j, m+1\\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis |j,m>. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j-m) * (j+m+1)); return a_plus. [docs]def am(j, m):; """"""Calculate the operator `am` used later. The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters; ----------; j: float; The value for j. m: float; The value for m. Returns; -------; a_minus: float; The value of :math:`a_{-}`.; """"""; a_minus = np.sqrt((j+m) * (j-m+1))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:14239,energy,energy,14239,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['energy'],['energy']
Energy Efficiency,"ntial series and; `pi` for psuedo-inverse). use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------. spectrum: *array*; An *array* with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(taulist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------. tlist : *list* / *array*; list/array of times :math:`t` which the correlation function is given. y : *list* / *array*; list/array of correlations corresponding to time delays :math:`t`. Returns; -------. w, S : *tuple*; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]). N = len(taulist); dt = taulist[1] - taulist[0]. F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:. .. math::. \lim_{t \to \infty} \left<A(t+\\tau)B(t)\\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:18719,power,power,18719,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"ntity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 5.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0.1 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 6.75; 0. 0. 0. 0. 0. 0.; 0. 0. 0.1118034 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 8. 0. 0. 0. 0. 0.; 0. 0. 0. 0.12247449 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 9",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-tensor.html:6217,energy,energy,6217,docs/4.7/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"ntract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsing; the version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochasti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:3637,power,power,3637,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['power'],['power']
Energy Efficiency,"ntract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:9071,power,power,9071,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,6,['power'],['power']
Energy Efficiency,"ntract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsingthe version number of the Cython package. Version 3.0.0 (July 17, 2014)¶. New Features¶. New module qutip.stochastic wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:35397,power,power,35397,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['power'],['power']
Energy Efficiency,"ntrol amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics¶; Dynamics (subclass instance) – describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config¶; OptimConfig instance – various configuration options; (see OptimConfig for details). termination_conditions¶; TerminationCondition instance – attributes determine when the optimisation will end. pulse_generator¶; PulseGen (subclass instance) – (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats¶; Stats – attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump¶; dump.OptimDump – Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping¶; string – level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file¶; bool – If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir¶; string – Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary¶; OptimIterSummary – Summary of the most recent iteration.; Note this is on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:62540,reduce,reduce,62540,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduce']
Energy Efficiency,"numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:131230,energy,energy,131230,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"o evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:; H (qutip.qobj) – System Hamiltonian.; a_ops (list of qutip.qobj) – List of system operators that couple to the environment.; spectra_cb (list of callback functions) – List of callback functions that evaluate the noise power spectrum; at a given frequency.; c_ops (list of qutip.qobj) – List of system collapse operators.; use_secular (bool) – Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets – R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. Return type:qutip.Qobj, list of qutip.Qobj. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:; R (qutip.qobj) – Bloch-Redfield tensor.; ekets (array of qutip.qobj) – Array of kets that make up a basis tranformation for the eigenbasis.; rho0 (qutip.qobj) – Initial density matrix.; tlist (list / array) – List of times for \(t\).; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; options (qutip.Qdeoptions) – Options fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:66797,power,power,66797,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"o.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:23826,power,power,23826,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['power'],['power']
Energy Efficiency,"o.transform(f_modes_t, False)). r.integrate(r.t + dt); t_idx += 1. return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:23570,power,power,23570,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,6,['power'],['power']
Energy Efficiency,"o]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7007,energy,energy,7007,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"oad-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:10358,schedul,scheduled,10358,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['scheduled']
Energy Efficiency,odule qutip.metrics). average_states (Options attribute). axes (Bloch attribute). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bnd_cut_approx (HSolverDL attribute). boltzmann (HEOMSolver attribute). bounds (Optimizer attribute). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops (StochasticSolverOptions attribute). c_ops_markov (MemoryCascade attribute). cache_dyn_gen_eigenvectors_adj (Dynamics attribute). cache_phased_dyn_gen (Dynamics attribute). cache_prop_grad (Dynamics attribute). calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.en,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/genindex.html:2578,charge,charge,2578,docs/4.0.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html,1,['charge'],['charge']
Energy Efficiency,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise Exception('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise Exception('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:10205,power,power,10205,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency,"of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_thresh : float, optional; ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, default 'smilu_2'; ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns; -------; dm : qobj; Steady state density matrix.; info : dict, optional; Dictionary containing solver-specific information about the solution. Notes; -----; The SVD method works only for dense operators (i.e. small systems).; """"""; if solver is None:; solver = 'scipy'; if settings.has_mkl:; if method in ['direct', 'power']:; solver = 'mkl'; elif solver == 'mkl' and \; (method not in ['direct', 'power']):; raise ValueError('MKL solver only for direct or power methods.'). elif solver not in ['scipy', 'mkl']:; raise ValueError('Invalid solver kwarg.'). ss_args = _default_steadystate_args(); ss_args['method'] = method; if solver is not None:; ss_args['solver'] = solver; ss_args['info']['solver'] = ss_args['solver']; ss_args['info']['method'] = ss_args['method']. for key in kwargs.keys():; if key in ss_args.keys():; ss_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; # set the weight to the mean of the non-zero absoluate values in A:; ss_args['weight'] = np.mean(np.ab",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:9194,power,power,9194,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency,"of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate bloc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:154877,energy,energy,154877,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, ‘scipy’, ‘mkl’}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {‘direct’, ‘eigen’, ‘iterative-gmres’,; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:102870,power,power,102870,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"ol amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:160307,energy,energy,160307,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['energy'],['energy']
Energy Efficiency,"ollowing functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the NumPy library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:4506,efficient,efficient,4506,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"olving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:3132,power,power,3132,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,4,['power'],['power']
Energy Efficiency,"ompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11508,schedul,scheduler,11508,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"ompiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. schedule_mode: str, optional; ``""ASAP""`` for ""as soon as possible"" or; ``""ALAP""`` for ""as late as possible"" or; ``False`` or ``None`` for no schedule.; Default is None. args: dict, optional; A dictionary of arguments used in a specific gate compiler; function. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape ``(len(ctrls), len(tlist))``. Each; row corresponds to the control pulse sequence for; one Hamiltonian.; """"""; if isinstance(circuit, QubitCircuit):; gates = circuit.gates; else:; gates = circuit; if args is not None:; self.args.update(args); instruction_list = []. # compile gates; for gate in gates:; if gate.name not in self.gate_compiler:; raise ValueError(""Unsupported gate %s"" % gate.name); instruction = self.gate_compiler[gate.name](gate, self.args); if instruction is None:; continue # neglecting global phase gate; instruction_list += instruction; if not instruction_list:; return None, None; if self.pulse_dict:; num_controls = len(self.pulse_dict); else: # if pu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:4639,schedul,schedule,4639,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['schedul'],['schedule']
Energy Efficiency,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/entropy.html:8894,power,power,8894,docs/4.7/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html,4,['power'],['power']
Energy Efficiency,"on; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html:30684,efficient,efficient,30684,docs/4.4/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulsegen.html,1,['efficient'],['efficient']
Energy Efficiency,"on; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs. self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs. if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)). if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs,; self.num_basis_funcs])*self.scaling. [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs. [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats; """"""; return self.coeffs.ravel().tolist(). [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:30684,efficient,efficient,30684,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['efficient'],['efficient']
Energy Efficiency,"on__) >= parse_version(""3.8""):; ax.axes.yaxis.set_major_locator(plt.FixedLocator(ytics)); else:; ax.axes.w_yaxis.set_major_locator(plt.FixedLocator(ytics)); if ylabels:; nylabels = len(ylabels); if nylabels != len(ytics):; raise ValueError(f""got {nylabels} ylabels but needed {len(ytics)}""); ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:24083,energy,energy,24083,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['energy'],['energy']
Energy Efficiency,"ondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; # FIXME: These atol keyword except checks can be removed once scipy 1.1; # is a minimum requirement; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; try:; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = gmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-lgmres':; try:; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = lgmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-bicgstab':; try:; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:28854,power,power,28854,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"onds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:161473,efficient,efficient,161473,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['efficient'],['efficient']
Energy Efficiency,"one, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; values (array / list) – The list or array of values for which the task function is to be; evaluated.; task_args (list / dictionary) – The optional additional argument to the task function.; task_kwargs (list / dictionary) – The optional additional keyword argument to the task function.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar during the execution of the parfor; loop. Returns:result – The result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. Return type:list. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns:version_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:202278,schedul,scheduling,202278,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['schedul'],['scheduling']
Energy Efficiency,"onian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, default False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbm : bool, default False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:5330,power,power,5330,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:135962,power,power,135962,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,16,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles.; """"""; circuit = deepcopy(circuit); if repeat_num > 0:; random_shuffle = True; result = [0]; max_length = 4294967296; for i in range(repeat_num):; gate_cycle_indices = self.schedule(; circuit, gates_schedule=gates_schedule,; return_cycles_list=return_cycles_list,; random_shuffl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16362,schedul,scheduler,16362,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,6,"['Schedul', 'schedul']","['Scheduler', 'scheduler']"
Energy Efficiency,"only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:4752,energy,energy,4752,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"ons,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. Wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5234,efficient,efficient,5234,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"onstraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a qua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12916,schedul,scheduler,12916,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,12,"['reduce', 'schedul']","['reduce', 'schedule', 'scheduler']"
Energy Efficiency,"op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_like",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:129926,power,power,129926,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian eleme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:101186,power,power,101186,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:135926,power,power,135926,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,8,['power'],['power']
Energy Efficiency,optimization() (Optimizer method). (OptimizerBFGS method). (OptimizerCrabFmin method). (OptimizerLBFGSB method). run_state() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). run_statistics() (CircuitSimulator method). (QubitCircuit method). rx() (in module qutip.qip.operations.gates). rx_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). ry() (in module qutip.qip.operations.gates). rz() (in module qutip.qip.operations.gates). rz_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). S. save() (Bloch method). save_amps() (Dynamics method). save_coeff() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). save_qasm() (in module qutip.qip.qasm). scattering_probability() (in module qutip.scattering). schedule() (Scheduler method). Scheduler (class in qutip.qip.compiler). serial_map() (in module qutip.parallel). sesolve() (in module qutip.sesolve). set_all_tlist() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). set_label_convention() (Bloch method). set_optim_var_vals() (PulseGenCrab method). set_phase_option() (FidCompUnitary method). set_total_time() (Stats method). set_up_ops() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). set_up_params() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). shape() (in module qutip.qobj). show() (Bloch method). sigmam() (in module qutip.operators). sigmap() (in module qutip.operators). sigmax() (in module qutip.operators). sigmay() (in module qutip.operators). sigmaz() (in module qutip.operators). simdi,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/genindex.html:29126,schedul,schedule,29126,docs/4.6/genindex.html,https://qutip.org,https://qutip.org/docs/4.6/genindex.html,1,['schedul'],['schedule']
Energy Efficiency,"options. Options for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:68779,power,power,68779,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"oquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:1543,efficient,efficiently,1543,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,3,['efficient'],['efficiently']
Energy Efficiency,"or i in range(2)][::-1]; return [Qobj(inpt=sqrt(val)*vec2mat(vec, shape=shape),; dims=q_oper.dims[0][::-1]); for val, vec in zip(vals, vecs) if abs(val) >= tol]. [docs]def kraus_to_choi(kraus_list):; """"""; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in `kraus_list`; """"""; kraus_mat_list = list(map(lambda x: x.data.toarray(), kraus_list)); op_rng = range(kraus_mat_list[0].shape[0]); choi_blocks = array([[sum([; np.outer(op[:, c_ix],; np.transpose(np.conjugate(op))[r_ix, :]); for op in kraus_mat_list]); for r_ix in op_rng]; for c_ix in op_rng]); return Qobj(inpt=hstack(hstack(choi_blocks)),; dims=[kraus_list[0].dims[::-1], kraus_list[0].dims[::-1]],; type='super', superrep='choi'). [docs]def kraus_to_super(kraus_list):; """"""; Converts a list of Kraus operators and returns a super operator.; """"""; return choi_to_super(kraus_to_choi(kraus_list)). def _nq(dims):; dim = np.product(dims[0][0]); nq = int(log2(dim)); if 2 ** nq != dim:; raise ValueError(""{} is not an integer power of 2."".format(dim)); return nq. [docs]def choi_to_chi(q_oper):; """"""; Converts a Choi matrix to a Chi matrix in the Pauli basis. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims; B.superrep = 'choi'. return Qobj(B.dag() * q_oper * B, superrep='chi'). [docs]def chi_to_choi(q_oper):; """"""; Converts a Chi matrix to a Choi matrix. NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions.; """"""; nq = _nq(q_oper.dims); B = _pauli_basis(nq); # Force the basis change to match the dimensions of; # the input.; B.dims = q_oper.dims. # We normally should not multiply objects of different; # superreps, so Qobj warns about that. Here, however, we're actively; # converting between, so the s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html:9283,power,power,9283,docs/4.6/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/superop_reps.html,2,['power'],['power']
Energy Efficiency,"or the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:5109,power,power,5109,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['power'],['power']
Energy Efficiency,"or the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:5504,power,power,5504,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['power'],['power']
Energy Efficiency,"or.; c_op_list (list) – A list of collapse operators.; return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian.; use_wbm (bool, optional, default = False) – Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner.; weight (float, optional) – Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; method (str, default = 'iterative') – Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’.; permc_spec (str, optional, default='COLAMD') – Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; fill_factor (float, optional, default = 100) – Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:106641,power,power,106641,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"orrelation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:5269,power,power,5269,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"ors is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times:; >>> times = [0.0, 1.0]; >>> result = mesolve(H, psi0, times, [], []); >>> result.states; [; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.+0.j]; [ 0.+0.j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.80901765+0.j ]; [ 0.00000000-0.58778584j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.3090168+0.j ]; [ 0.0000000-0.95105751j]]; , Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[-0.30901806+0.j ]; [ 0.00000000-0.95105684j]]; ]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:8008,energy,energy,8008,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"ors. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a prec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:102356,power,power,102356,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"ort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:4590,energy,energy,4590,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"ort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:4483,energy,energy,4483,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,7,['energy'],['energy']
Energy Efficiency,"ots the dispersion relationship for the lattice with the specified; number of unit cells. The dispersion of the infinte crystal is also; plotted if num_cell is smaller than MAXc.; """"""; MAXc = 20 # Cell numbers above which we do not plot the infinite; # crystal dispersion; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""). if self.num_cell <= MAXc:; (kxA, val_ks) = self.get_dispersion(101); (knxA, val_kns) = self.get_dispersion(); fig, ax = plt.subplots(); if self.num_cell <= MAXc:; for g in range(self._length_of_unit_cell):; ax.plot(kxA/np.pi, val_ks[g, :]). for g in range(self._length_of_unit_cell):; if self.num_cell % 2 == 0:; ax.plot(np.append(knxA, [np.pi])/np.pi,; np.append(val_kns[g, :], val_kns[g, 0]), 'ro'); else:; ax.plot(knxA/np.pi, val_kns[g, :], 'ro'); ax.set_ylabel('Energy'); ax.set_xlabel(r'$k_x(\pi/a)$'); plt.show(fig); fig.savefig('./Dispersion.pdf'). [docs] def get_dispersion(self, knpoints=0):; """"""; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns; -------; knxa : np.array; knxA[j][0] is the jth good Quantum number k. val_kns : np.array; val_kns[j][:] is the array of band energies of the jth band good at; all the good Quantum numbers of k.; """"""; # The _k_space_calculations() function is not used for get_dispersion; # because we calculate the infinite crystal dispersion in; # plot_dispersion using this coode and we do not want to calculate; # all the eigen-values, eigenvectors of the bulk Hamiltonian for too; # many points, as is done in the _k_space_calculations() function.; if self.period_bnd_cond_x == 0:; raise Exception(""The lattice is not periodic.""); if knpoints == 0:; knpoints = self.num_cell. a = 1 # The unit cell length is always considered 1; kn_start = 0; kn_end = 2*np.pi/a; val_kns = np.zeros((self._length_of_unit_cell, knpoints), dtype=float); knxA = np.zeros((knpoints, 1), dtype=float); G0_H = self._H_intra; # knxA = n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/lattice.html:24711,energy,energy,24711,docs/4.6/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html,4,['energy'],['energy']
Energy Efficiency,"ource]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:; H (qutip.qobj) – system Hamiltonian.; / psi0 (rho0) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; c_ops (list of qutip.qobj) – list of collapse operators.; e_ops (list of qutip.qobj / callback function) – list of operators for which to evaluate expectation values.; spectra_cb (list callback functions) – List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops.; T (float) – The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options (qutip.solver) – options for the ODE solver.; k_max (int) – The truncation of the number of sidebands (default 5). Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Return type:qutip.solver. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:69210,energy,energy,69210,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup: out.tidyup(); out._isherm = self._isherm; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return np.asarray(out.todense()); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.type not in ['oper', 'super']:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. except:; raise ValueError('Invalid choice of exponent.'). def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t + ""\n""); s += ""Qobj data =\n"". if shape[0] > 10000 or shape[1] > 10000:; # if the system is huge, don't attempt to convert to a; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:18505,power,power,18505,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['power'],['power']
Energy Efficiency,"ouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, ‘scipy’, ‘mkl’}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {‘direct’, ‘eigen’, ‘iterative-gmres’,; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:102907,power,power,102907,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,8,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"pdf)¶. The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:6958,efficient,efficient,6958,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,2,['efficient'],['efficient']
Energy Efficiency,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:181548,schedul,scheduler,181548,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,12,"['reduce', 'schedul']","['reduce', 'schedule', 'scheduler']"
Energy Efficiency,"pecial reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.03s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.03s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.04s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.04s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.04s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.04s. Est. time left: 00:00:00:05; 70.0%. Run time: 9.04s. Est. time left: 00:00:00:03; 80.0%. Run time: 10.04s. Est. time left: 00:00:00:02; 90.0%. Run time: 12.04s. Est. time left: 00:00:00:01; 100.0%. Run time: 13.05s. Est. time left: 00:00:00:00; Total run time: 13.06s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-parfor.html:7114,power,powerful,7114,docs/4.4/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"pecified; by THETA and PHI. Notes; Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:126735,efficient,efficient,126735,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['efficient'],['efficient']
Energy Efficiency,"pect[1]);. In [14]: ax.set_xlabel('Time');. In [15]: ax.set_ylabel('Expectation values');. In [16]: ax.legend((""Sigma-Z"", ""Sigma-Y""));. In [17]: show(). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; In [18]: times = [0.0, 1.0]. In [19]: result = mesolve(H, psi0, times, [], []); no collapse operator, using sesolve. In [20]: result.states; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html:6882,energy,energy,6882,docs/4.4/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html,1,['energy'],['energy']
Energy Efficiency,"pectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : array_like. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum : array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : array_like. list/array of times \(t\) which the correlation function is given. y : array_like. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:96771,power,power,96771,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"pectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference; qutip-jax JAX backend for qutip. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/qutip-tutorials/index.html:5603,charge,charge,5603,qutip-tutorials/index.html,https://qutip.org,https://qutip.org/qutip-tutorials/index.html,1,['charge'],['charge']
Energy Efficiency,"perm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:26813,power,power,26813,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"piler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11474,schedul,scheduler,11474,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"plots(); >>> ax.plot(result.times, result.expect[0]) ; >>> ax.plot(result.times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . (png, hires.png, pdf). If an empty list of operators is passed as fifth parameter, the qutip.mesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; >>> times = [0.0, 1.0]; >>> result = mesolve(H, psi0, times, [], []); >>> result.states ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:6501,energy,energy,6501,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['energy'],['energy']
Energy Efficiency,"plt.IndexLocator(1, -0.5)); if xlabels:; ax.set_xticklabels(xlabels); ax.tick_params(axis='x', labelsize=12). # y axis; ax.axes.w_yaxis.set_major_locator(plt.IndexLocator(1, -0.5)); if ylabels:; ax.set_yticklabels(ylabels); ax.tick_params(axis='y', labelsize=12). # z axis; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else mi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:14455,energy,energy,14455,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,7,['energy'],['energy']
Energy Efficiency,"pse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:38628,reduce,reduced,38628,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"pse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, aver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:37648,reduce,reduced,37648,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"put.states.append(rho); r.integrate(r.t + dt); return output. # -----------------------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:25279,power,power,25279,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['power'],['power']
Energy Efficiency,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=Fa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:18206,power,power,18206,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,6,['power'],['power']
Energy Efficiency,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y); ; # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", revers",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/correlation.html:18210,power,power,18210,docs/4.3/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (eta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1929,schedul,schedule,1929,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['schedul'],['schedule']
Energy Efficiency,qutip.control.optimizer — QuTiP 4.7 Documentation; qutip.control.optimresult — QuTiP 4.7 Documentation; qutip.control.propcomp — QuTiP 4.7 Documentation; qutip.control.pulsegen — QuTiP 4.7 Documentation; qutip.control.pulseoptim — QuTiP 4.7 Documentation; qutip.control.stats — QuTiP 4.7 Documentation; qutip.control.termcond — QuTiP 4.7 Documentation; qutip.control.tslotcomp — QuTiP 4.7 Documentation. /nonmarkov; ; qutip.nonmarkov.bofin_baths — QuTiP 4.7 Documentation; qutip.nonmarkov.bofin_solvers — QuTiP 4.7 Documentation; qutip.nonmarkov.dlheom_solver — QuTiP 4.7 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.7 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.7 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.7 Documentation. /compiler; ; qutip.qip.compiler.cavityqedcompiler — QuTiP 4.7 Documentation; qutip.qip.compiler.gatecompiler — QuTiP 4.7 Documentation; qutip.qip.compiler.instruction — QuTiP 4.7 Documentation; qutip.qip.compiler.scheduler — QuTiP 4.7 Documentation; qutip.qip.compiler.spinchaincompiler — QuTiP 4.7 Documentation. /device; ; qutip.qip.device.cavityqed — QuTiP 4.7 Documentation; qutip.qip.device.modelprocessor — QuTiP 4.7 Documentation; qutip.qip.device.optpulseprocessor — QuTiP 4.7 Documentation; qutip.qip.device.processor — QuTiP 4.7 Documentation; qutip.qip.device.spinchain — QuTiP 4.7 Documentation. /operations; ; qutip.qip.operations.gates — QuTiP 4.7 Documentation. qutip.qip.circuit — QuTiP 4.7 Documentation; qutip.qip.noise — QuTiP 4.7 Documentation; qutip.qip.pulse — QuTiP 4.7 Documentation; qutip.qip.qasm — QuTiP 4.7 Documentation; qutip.qip.qubits — QuTiP 4.7 Documentation. qutip.about — QuTiP 4.7 Documentation; qutip.bloch — QuTiP 4.7 Documentation; qutip.bloch_redfield — QuTiP 4.7 Documentation; qutip.bloch3d — QuTiP 4.7 Documentation; qutip.continuous_variables — QuTiP 4.7 Documentation; qutip.correlation — QuTiP 4.7 Documentation; qutip.dimensions — QuTiP 4.7 Documentation; qutip.distributions,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:62823,schedul,scheduler,62823,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['schedul'],['scheduler']
Energy Efficiency,"qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (currently only ‘me’). Returns:g2, G2: tuble of *array* :. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=, []**kwargs)¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-bicg’,. ‘iterative-gmres’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, SVD ‘svd’ (dense), or inverse-power method ‘power’. sparse : bool, optional, default=True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default=True. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default=False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:69825,power,power,69825,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"r priority; return self.nodes[ind1].distance_to_start - \; self.nodes[ind2].distance_to_start; else:; # higher distance_to_end, higher priority; return self.nodes[ind2].distance_to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12543,schedul,schedules,12543,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,8,"['reduce', 'schedul']","['reduce', 'schedules']"
Energy Efficiency,"r the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/operators.html:20833,charge,charge,20833,docs/4.3/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency,"r(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = ssesolve(H, psi0, times, sc_ops=[np.sqrt(0.1) * a], e_ops=[a.dag() * a, sm.dag() * sm], method=""homodyne""); Total run time: 0.01s. In [7]: figure(); Out[7]: <Figure size 640x480 with 0 Axes>. In [8]: plot(times, data.expect[0], times, data.expect[1]); Out[8]: ; [<matplotlib.lines.Line2D at 0x1a25a75c18>,; <matplotlib.lines.Line2D at 0x1a25a755c0>]. In [9]: title('Homodyne time evolution'); Out[9]: Text(0.5,1,'Homodyne time evolution'). In [10]: xlabel('Time'); Out[10]: Text(0.5,0,'Time'). In [11]: ylabel('Expectation values'); Out[11]: Text(0,0.5,'Expectation values'). In [12]: legend((""cavity photon number"", ""atom excitation probability"")); Out[12]: <matplotlib.legend.Legend at 0x1a263e9860>. In [13]: show(). Open system¶; In open systems, 2 types of collapse operators are considered, \(S_i\); represent the dissipation in the environment, \(C_i\) are monitored operators.; The deterministic part of the evolution is the liouvillian with both types of; collapses. (2)¶\[L(\rho(t)) = - i[H(t),\rho(t)]; + \sum_n D(S_n, \rho); + \sum_i D(C_i, \rho),\]; with. (3)¶\[D(C, \rho) = \frac{1}{2} \left[2 C \rho(t) C^{+}; - \rho(t) C^{+} C - C^{+} C \rho(t) \right].\]; The stochastic part is given by. (4)¶\[d_2 = \left(C \rho(t) + \rho(t) C^{+} - \rm{tr}\left(C \times \rho; + \rho \times C^{+} \right)\rho(t) \right),\]; resulting in the stochastic differential equation. (5)¶\[\delta \rho(t) = L(\rho(t)) \delta t + d_2 \delta \omega\]; The function smesolve covert these cases in QuTiP. Heterodyne detection¶; With heterodyne detection, two measurements are made in order to obtain; information about 2 orthogonal quadratures at once. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:3566,monitor,monitored,3566,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['monitor'],['monitored']
Energy Efficiency,"r2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:112083,Efficient,Efficient,112083,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['Efficient'],['Efficient']
Energy Efficiency,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:18476,efficient,efficient,18476,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"r; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. A example of this method is given in [pulseoptim QFT](http://nbviewer.ipython.org/github/qutip/qutip-notebooks/blob/master/examples/example-control-pulseoptim-QFT.ipynb). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-control.html:18476,efficient,efficient,18476,docs/4.1/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"racting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^{+} - \rho(t) C_n^{+} C_n - C_n^{+} C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html:9779,reduce,reduced,9779,docs/3.0.0/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html,3,['reduce'],['reduced']
Energy Efficiency,"raise Exception(; ""Invalid keyword argument '""+key+""' passed to steadystate.""). # Set column perm to NATURAL if using RCM and not specified by user; if ss_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; ss_args['permc_spec'] = 'NATURAL'. # Create & check Liouvillian; A = _steadystate_setup(A, c_op_list). # Set weight parameter to avg abs val in L if not set explicitly; if 'weight' not in kwargs.keys():; ss_args['weight'] = np.mean(np.abs(A.data.data.max())); ss_args['info']['weight'] = ss_args['weight']. if ss_args['method'] == 'direct':; if ss_args['sparse']:; return _steadystate_direct_sparse(A, ss_args); else:; return _steadystate_direct_dense(A, ss_args). elif ss_args['method'] == 'eigen':; return _steadystate_eigen(A, ss_args). elif ss_args['method'] in ['iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab']:; return _steadystate_iterative(A, ss_args). elif ss_args['method'] == 'svd':; return _steadystate_svd_dense(A, ss_args). elif ss_args['method'] == 'power':; return _steadystate_power(A, ss_args). else:; raise ValueError('Invalid method argument for steadystate.'). def _steadystate_setup(A, c_op_list):; """"""Build Liouvillian (if necessary) and check input.; """"""; if isoper(A):; if len(c_op_list) > 0:; return liouvillian(A, c_op_list). raise TypeError('Cannot calculate the steady state for a ' +; 'non-dissipative system ' +; '(no collapse operators given)'); elif issuper(A):; return A; else:; raise TypeError('Solving for steady states requires ' +; 'Liouvillian (super) operators'). def _steadystate_LU_liouvillian(L, ss_args):; """"""Creates modified Liouvillian for LU based SS methods.; """"""; perm = None; perm2 = None; rev_perm = None; n = prod(L.dims[0][0]); L = L.data.tocsc() + sp.csc_matrix(; (ss_args['weight']*np.ones(n), (np.zeros(n), [nn * (n + 1); for nn in range(n)])),; shape=(n ** 2, n ** 2)). if settings.debug:; old_band = sp_bandwidth(L)[0]; old_pro = sp_profile(L)[0]; logger.debug('Orig. NNZ: %i' % L.nnz); if ss_args['use_rcm']:; logger",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html:10434,power,power,10434,docs/3.1.0/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html,1,['power'],['power']
Energy Efficiency,"rall; else:; U_overall = U_overall * U. return U_overall. [docs]def gate_sequence_product(U_list, left_to_right=True,; inds_list=None, expand=False):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list: list; List of gates implementing the quantum circuit. left_to_right: Boolean, optional; Check if multiplication is to be done from left to right. inds_list: list of list of int, optional; If expand=True, list of qubit indices corresponding to U_list; to which each unitary is applied. expand: Boolean, optional; Check if the list of unitaries need to be expanded to full dimension. Returns; -------; U_overall : qobj; Unitary matrix corresponding to U_list. overall_inds : list of int, optional; List of qubit indices on which U_overall applies.; """""". if expand:; return _gate_sequence_product(U_list, inds_list); else:; return _gate_sequence_product_with_expansion(U_list, left_to_right). def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:30011,power,powers,30011,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,2,['power'],['powers']
Energy Efficiency,"rall; else:; U_overall = U_overall * U. return U_overall. [docs]def gate_sequence_product(U_list, left_to_right=True,; inds_list=None, expand=False):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list: list; List of gates implementing the quantum circuit. left_to_right: Boolean, optional; Check if multiplication is to be done from left to right. inds_list: list of list of int, optional; If expand=True, list of qubit indices corresponding to U_list; to which each unitary is applied. expand: Boolean, optional; Check if the list of unitaries need to be expanded to full dimension. Returns; -------; U_overall : qobj; Unitary matrix corresponding to U_list. overall_inds : list of int, optional; List of qubit indices on which U_overall applies.; """""". if expand:; return _gate_sequence_product(U_list, inds_list); else:; return _gate_sequence_product_with_expansion(U_list, left_to_right). def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (https://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:28276,power,powers,28276,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['power'],['powers']
Energy Efficiency,"rameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate blocks in the density matrix. Parameters. rhoqutip.QobjDensity matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins. Returns. purityfloatThe pu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:155012,energy,energy,155012,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (defaul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:20635,charge,charge,20635,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['charge'],['charge']
Energy Efficiency,"rdware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11842,schedul,scheduler,11842,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"re detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax.; ; Parameters; ----------; Nmax : int; Maximum charge state to consider.; ; Nmin : int (default = -Nmax); Lowest charge state to consider.; ; frac : float (default = 1); Specify fractional charge if needed.; ; Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax].; ; Notes; -----; .. versionadded:: 3.2; ; """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form ; :math:`\sum |N><N+m| + |N+m><N|`.; ; Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event.; ; Returns; -------; T : Qobj; Tunneling operator.; ; Notes; -----; .. versionadded:: 3.2; ; """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the modu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:21045,charge,charge,21045,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,3,['charge'],['charge']
Energy Efficiency,"re than one; element). c2 : qutip.Qobj. system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:: qutip.Qobj. time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:t : float. current time. tau : float. time-delay. notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`. time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). t : float. current time. tau : float. time-delay. Returns:: qutip.Qobj. density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver.; Attributes. dynmaps; (list of qutip.Qobj) List of precomputed dynamical maps (superoperators), or a callback function that returns the superoperator at a given time. times; (array_like) List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes; (array_like) List of times \(t_k\) to use as learning times if argument dynmaps is a callback function. thres; (float) Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below treshold. options; (qutip.solver.Options) Generic solver options. Solver Options and Results¶. class Options(atol=1e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:31198,reduce,reduced,31198,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['reduce'],['reduced']
Energy Efficiency,"re; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:186095,reduce,reduce,186095,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['reduce'],['reduce']
Energy Efficiency,"remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional addition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:6668,green,green,6668,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['green'],['green']
Energy Efficiency,"resenting the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). method : string {‘iterative’, ‘laguerre’, ‘fft’}. Select method ‘iterative’, ‘laguerre’, or ‘fft’, where ‘iterative’ uses; an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘fft’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). parfor : bool {False, True}. Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns:W : array. Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array. FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:99228,efficient,efficient,99228,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['efficient'],['efficient']
Energy Efficiency,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in bl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:8113,energy,energy,8113,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = meth_str.find('\n'); pub_len = len(pub_meth[ii] + ': '); print(pub_meth[ii] + ':' + ' ' * (ml+3-pub_len) + meth_str[:ind]). def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:8161,energy,energy,8161,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"rformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics.; FidelityComputer; The subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses.; PropagatorComputer; This object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above.; TimeslotComputer; Here the time evolution is computed by calling the methods of the other computer objects.; OptimResult; The result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:18188,efficient,efficient,18188,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"rgs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:254696,schedul,scheduling,254696,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['schedul'],['scheduling']
Energy Efficiency,"rgs['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; # FIXME: These atol keyword except checks can be removed once scipy 1.1; # is a minimum requirement; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; try:; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = gmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-lgmres':; try:; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = lgmres(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'power-bicgstab':; try:; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); except TypeError as e:; if ""unexpected keyword argument 'atol'"" in str(e):; v, check = bicgstab(L, v, tol=mtol,; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; call",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:28907,power,power-gmres,28907,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['power'],['power-gmres']
Energy Efficiency,"rig not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % orig). if to not in _unit_factor_tbl:; raise TypeError(""Unsupported unit %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6795,energy,energy,6795,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"ring the quantum states of light in a Kerr-nonlinear resonator by two-photon driving"", ; npj Quantum Information 3, 18 (2017). 184. Rossatto et al., ""Relaxation time for monitoring the quantumness of an intense cavity field"", ; Phys. Rev. A 94, 033819 (2016). 183. Shackerley-Bennett et al., ""The reachable set of single-mode quadratic Hamiltonians"", ; J. Phys. A: Math. Theor. 50, 155203 (2017). 182. Blumoff et al., ""Implementing and Characterizing Precise Multiqubit Measurements"", ; Phys. Rev. X 6, 031041 (2016). 181. Li et al., ""Entangling a single NV centre with a superconducting qubit via parametric couplings between photons and phonons in a hybrid system"", ; Journal of Modern Optics (2016). 180. Straubel et al., ""Entangled light from bimodal optical nanoantennas"", ; Phys. Rev. B 95, 085421 (2017). 179. Vool et al., ""Continuous Quantum Nondemolition Measurement of the Transverse Component of a Qubit"", ; Phys. Rev. Lett. 117, 133601 (2016). 178. Granade et al., ""Practical adaptive quantum tomography"", ; New J. Phys. 19, 113017 (2017). 177. Plankensteiner et al., ""Laser noise imposed limitations of ensemble quantum metrology"", ; J. Phys. B: At. Mol. Opt. Phys. 49, 245501 (2016). 176. Levi et al., ""Coherent exciton dynamics in a dissipative environment maintained by an off-resonant vibrational mode"", ; Phys. Rev. A 93, 042109 (2016). 175. Li et al., ""Proposal for a quantum delayed-choice experiment with a spin-mechanical setup"", ; Phys. Rev. A 94, 042130 (2016). 174. Lambert et al., ""Leggett-Garg inequality violations with a large ensemble of qubits"", ; Phys. Rev. A 94, 012105 (2016). 173. Ardelt et al., ""Optical control of nonlinearly dressed states in an individual quantum dot"", ; Phys. Rev. B 93, 165305 (2016). 172. Nakajima et al., ""Phase control of local and non-local entanglement in a triple spin qubit"", ; arXiv:1604.02232. 171. Snijders et al., ""Purification of a single photon nonlinearity"", ; Nat. Commun. 7, 12578 (2016). 170. Levi et al., ""Designing spin-chan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:25786,adapt,adaptive,25786,users.html,https://qutip.org,https://qutip.org/users.html,1,['adapt'],['adaptive']
Energy Efficiency,"ring] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:3663,efficient,efficient,3663,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,4,['efficient'],['efficient']
Energy Efficiency,"rix at points; `xvec + i * yvec`. Parameters; ----------. state : qobj; A state vector or density matrix. xvec : array_like; x-coordinates at which to calculate the Wigner function. yvec : array_like; y-coordinates at which to calculate the Wigner function. Does not; apply to the 'fft' method. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation; relation `[x, y] = i * hbar` via `hbar=2/g^2` giving the default; value `hbar=1`. method : string {'clenshaw', 'iterative', 'laguerre', 'fft'}; Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw'; and 'iterative' use an iterative method to evaluate the Wigner functions for density; matrices :math:`|m><n|`, while 'laguerre' uses the Laguerre polynomials; in scipy for the same task. The 'fft' method evaluates the Fourier; transform of the density matrix. The 'iterative' method is default, and; in general recommended, but the 'laguerre' method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The 'clenshaw' method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). 'clenshaw' is a fast and numerically stable method. sparse : bool {False, True}; Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parfor : bool {False, True}; Flag for calculating the Laguerre polynomial based Wigner function; method='laguerre' in parallel using the parfor function. Returns; -------. W : array; Values representing the Wigner function calculated over the specified; range [xvec,yvec]. yvex : array; FFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; -----; The 'fft' method accepts only an xvec input for the x-coordinate.; The y-coor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/wigner.html:8060,efficient,efficient,8060,docs/4.5/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/wigner.html,5,['efficient'],['efficient']
Energy Efficiency,"rm'].append('wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; wbm_pro = sp_profile(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band); logger.debug('WBM profile: %i' % wbm_pro); ; if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); ss_args['info']['perm'].append('rcm'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f' % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f' % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args; . def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Precondition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:23993,power,power,23993,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"rol modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. num_tslots : integer; Number of timeslots, aka timeslices. num_ctrls : integer; Number of controls.; Note this is set when get_num_ctrls is called based on the; length of ctrl_dyn_gen. evo_time : float; Total time for the evolution. tau : array[num_tslots] of float; Duration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:5494,reduce,reduce,5494,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['reduce'],['reduce']
Energy Efficiency,"rom elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters. startintThe starting value of the sequence. stopintThe stoping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data fil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:205666,energy,energy,205666,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"rom here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [3]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:8595,reduce,reduces,8595,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['reduce'],['reduces']
Energy Efficiency,"rom here on we will only consider optimising for infidelity minima). This means that we can terminate any pulse optimisation when the infidelity reaches zero (to a sufficient precision). This is however only possible for fully controllable systems; otherwise it is hard (if not impossible) to know that the minimum possible infidelity has been achieved. In the hill walking analogy the step size is roughly fixed to a stride, however, in computations the step size must be chosen. Clearly there is a trade-off here between the number of steps (or iterations) required to reach the minima and the possibility that we might step over a minima. In practice it is difficult to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables can be used to approximate the local landscape to a parabola. This way a step (or jump) can be made to where the minima would be if it were parabolic. This typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:8544,reduce,reduces,8544,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['reduce'],['reduces']
Energy Efficiency,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if has",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/utilities.html:7902,energy,energy,7902,docs/4.6/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/utilities.html,4,['energy'],['energy']
Energy Efficiency,"rom unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [GHz]; w_mK = w * 1.0e12 * (_h / _kB); return w_mK. def convert_mK_to_GHz(w):; """"""; Convert an energy from unit mK to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit. """"""; w_GHz = w * 1.0e-12 * (_kB / _h); return w_GHz. def view_methods(Q):; """"""; View the methods and corresponding doc strings; for a Qobj class. Parameters; ----------; Q : Qobj; Input Quantum object. """"""; meth = dir(Q); qobj_props = ['data', 'dims', 'isherm', 'shape', 'type']; pub_meth = [x for x in meth if x.find('_') and x not in qobj_props]; ml = max([len(x) for x in pub_meth]); nl = len(Q.__class__.__name__ + 'Class Methods:'); print(Q.__class__.__name__ + ' Class Methods:'); print('-' * nl); for ii in range(len(pub_meth)):; m = getattr(Q, pub_meth[ii]); meth_str = m.__doc__; ind = me",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7950,energy,energy,7950,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,7,['energy'],['energy']
Energy Efficiency,"rough of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:4908,reduce,reduced,4908,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,2,"['efficient', 'reduce']","['efficient', 'reduced']"
Energy Efficiency,"rray with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:; start : int; The starting value of the sequence. stop : int; The stoping values of the sequence. num : int, optional; Number of samples to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Forma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:207862,energy,energy,207862,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"rray([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain ` model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorith",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:11625,schedul,schedules,11625,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['schedules']
Energy Efficiency,"rsively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A (qobj) – A Hamiltonian or Liouvillian operator.; c_op_list (list) – A list of collapse operators.; method (str {'direct', 'eigen', 'iterative-gmres',) – ; ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info (bool, optional, default = False) – Return a dictionary of solver-specific infomation about the; solution and how it was obtained.; sparse (bool, optional, default = True) – Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.; use_rcm (bool, optional, default = False) – Use reverse Cuthill-Mckee reordering to minimize fill-in in the; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:101561,power,power,101561,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,4,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"rt expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The base frequency of the resonator. eps: int or list, optional; The epsilon for each of the qubits in the system. delta: int or list, optional; The epsilon for each of the qubits in the system. g: int or list, optional; The interaction strength for each of the qubit with the resonator. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; sx_ops: list; A list of sigmax Hamiltonians for each qubit. sz_ops: list; A list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: list; A list of interacting Hamiltonians be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:3483,energy,energy,3483,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,4,['energy'],['energy']
Energy Efficiency,"rt numpy as np; from numpy import pi, array, sin, cos, angle. try:; import matplotlib.pyplot as plt; import matplotlib as mpl; from matplotlib import cm; from mpl_toolkits.mplot3d import Axes3D; except:; pass. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.wigner import wigner; from qutip.tensor import tensor; from qutip.matplotlib_utilities import complex_phase_cmap; from qutip.superoperator import vector_to_operator; from qutip.superop_reps import _pauli_basis, to_super; from qutip.tensor import flatten. from qutip import settings. # Adopted from the SciPy Cookbook.; def _blob(x, y, w, w_max, area, cmap=None):; """"""; Draws a square-shaped blob with the given area (< 1) at; the given coordinates.; """"""; hs = np.sqrt(area) / 2; xcorners = array([x - hs, x + hs, x + hs, x - hs]); ycorners = array([y - hs, y - hs, y + hs, y + hs]). plt.fill(xcorners, ycorners,; color=cmap(int((w + w_max) * 256 / (2 * w_max)))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**np.floor(np.log2(dim)) == dim; for dim in flatten(dims); ]). def _cb_labels(left_dims):; """"""Creates plot labels for matrix elements in the computational basis. Parameters; ----------; left_dims : flat list of ints; Dimensions of the left index of a density operator. E. g.; [2, 3] for a qubit tensored with a qutrit. Returns; -------; left_labels, right_labels : lists of strings; Labels for the left and right indices of a density operator; (kets and bras, respectively).; """"""; # FIXME: assumes dims, such that we only need left_dims == dims[0].; basis_labels = list(map("","".join, it.product(*[; map(str, range(dim)); for dim in left_dims; ]))); return [; map(fmt.format, basis_labels) for fmt in; (; r""$|{}\rangle$"",; r""$\la",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:4943,power,powers,4943,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['power'],['powers']
Energy Efficiency,"rt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; In [41]: tracedist(y, x); Out[41]: 0.977156579211186. In [42]: np.sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.9771565700334389. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.778289048225615. In [44]: tracedist(x, z); Out[44]: 0.855902832886259. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:11756,energy,energy,11756,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['energy'],['energy']
Energy Efficiency,"ruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15408,schedul,schedule,15408,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"rue)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:69235,energy,energy,69235,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"rue, kmax=5)¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:48044,energy,energy,48044,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"rved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-parfor.html:6343,power,powerful,6343,docs/4.6/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-parfor.html,2,['power'],['powerful']
Energy Efficiency,"s a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:20567,charge,charge,20567,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['charge'],['charge']
Energy Efficiency,"s a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:91712,efficient,efficient,91712,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['efficient'],['efficient']
Energy Efficiency,"s a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. dimensional_norm; (float) Normalisation constant. fid_norm_func; (function) Used to normalise the fidelity See SU and PSU options for the unitary dynamics. grad_norm_func; (function) Used to n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:87364,efficient,efficient,87364,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['efficient'],['efficient']
Energy Efficiency,"s a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:; exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes:; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:99973,efficient,efficient,99973,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['efficient'],['efficient']
Energy Efficiency,"s a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator U. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args=args, options=copy(options)). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:3277,energy,energy,3277,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"s are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for calculating the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj) or not a.isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). # default spectrum; if not spectra_cb:; spectra_cb = [lambda w: 1.0 for _ in a_ops]. if c_ops is None:; c_ops = []. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); ; #only Lindblad collapse terms; if K==0:; Heb = H.transform(ekets); L = liouvillian(Heb, c_ops=[c_op.transform(ekets) for c_op in c_ops]); return L, e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:7884,power,power,7884,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['power'],['power']
Energy Efficiency,"s greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15634,power,power,15634,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['power'],['power']
Energy Efficiency,s method). add_states() (Bloch method). add_timing() (Stats method). add_vectors() (Bloch method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/genindex.html:1743,charge,charge,1743,docs/4.1/genindex.html,https://qutip.org,https://qutip.org/docs/4.1/genindex.html,1,['charge'],['charge']
Energy Efficiency,"s of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-polynomial reachable states, when allowing for a finite control precision and evolution time. You can think of this as the information content of the pulse (as being the only effective input) being very limited e.g. the pulse is compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:9859,efficient,efficient,9859,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['efficient'],['efficient']
Energy Efficiency,"s removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:3433,power,power,3433,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['power'],['power']
Energy Efficiency,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-control.html:17854,efficient,efficient,17854,docs/4.6/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency,"s spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (cent",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:17703,power,power,17703,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,2,['power'],['power']
Energy Efficiency,"s spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y); ; # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/correlation.html:17707,power,power,17707,docs/4.3/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"s to generate. elems : list/ndarray, optional; Requested elements to include in array. Returns:; samples : ndadrray; Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:; j1 : float; Total angular momentum 1. j2 : float; Total angular momentum 2. j3 : float; Total angular momentum 3. m1 : float; z-component of angular momentum 1. m2 : float; z-component of angular momentum 2. m3 : float; z-component of angular momentum 3. Returns:; cg_coeff : float; Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:; value : float / array; The energy in the old unit. orig : string; The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string; The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:; value_new_unit : float / array; The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:; filename : str; Name of file containing reqested data. sep : str; Seperator used to store data. Returns:; data : array_like; Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:; filename : str; Name of data file to be stored, including extension. data: array_like; Data to be written to file. numtype : str {‘complex, ‘real’}; Type of numerical data. numformat : str {‘decimal’,’exp’}; Format for written data. sep : str; Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:; name : str; Name of data file to be loaded. Returns:; qobject : instance / array_lik",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:208155,energy,energy,208155,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:25255,reduce,reduce,25255,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['reduce'],['reduce']
Energy Efficiency,"s to the output field in; question (only needs to be specified if self.L2 has more than one; element); notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for computing field correlation function. Return type:qutip.Qobj. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t (float) – current time; tau (float) – time-delay; notrace (bool {False}) – If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:time-propagator for reduced system dynamics. Return type:qutip.Qobj. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket); t (float) – current time; tau (float) – time-delay. Returns:density matrix at time \(t\). Return type:qutip.Qobj. class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. dynmaps¶; list of qutip.Qobj – List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times¶; array_like – List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes¶; array_like – List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=100",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:34494,reduce,reduced,34494,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"s typically vastly reduces the number of iterations, and removes the need to guess a step size. The method where all the second differentials are calculated explicitly is called the Newton-Raphson method. However, calculating the second-order differentials (the Hessian matrix) can be computationally expensive, and so there are a class of methods known as quasi-Newton that approximate the Hessian based on successive iterations. The most popular of these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is the L-BFGS-B method in Scipy, which is a wrapper to the implementation described in [Byrd95]. This limited memory and bounded method does not need to store the entire Hessian, which reduces the computer memory required, and allows bounds to be set for variable values, which considering these are field amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be calculated exactly, rather than approximated. For simple fidelity measures such as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each timeslot with respect to the control amplitudes is calculated. For closed systems, with unitary dynamics, a method using the eigendecomposition is used, which is efficient as it is also used in the propagator calculation (to exponentiate the combined Hamiltonian). More generally (for example open systems and symplectic dynamics) the Frechet derivative (or augmented matrix) method is used, which is described in [Flo12]. For other optimisation goals it may not be possible to calculate analytic gradients. In these cases it is necessary to approximate the gradients, but this can be very expensive, and can lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control problem is a polynomial function of the dimension of the manifold of the time-p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:9509,efficient,efficient,9509,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['efficient'],['efficient']
Energy Efficiency,"s, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, incl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:11336,schedul,scheduler,11336,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['schedul'],['scheduler']
Energy Efficiency,"s. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2476,reduce,reduced,2476,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,2,['reduce'],['reduced']
Energy Efficiency,"s. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html:1528,efficient,efficiently,1528,docs/4.6/development/ideas/tensorflow-data-backend.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/tensorflow-data-backend.html,2,['efficient'],['efficiently']
Energy Efficiency,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N) / (2 * np.pi); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/visualization.html:14787,energy,energy,14787,docs/4.1/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/visualization.html,4,['energy'],['energy']
Energy Efficiency,"s; if limits and isinstance(limits, list):; ax.set_zlim3d(limits); else:; ax.set_zlim3d([0, 1]) # use min/max; # ax.set_zlabel('abs'). # color axis; if colorbar:; cax, kw = mpl.colorbar.make_axes(ax, shrink=.75, pad=.0); cb = mpl.colorbar.ColorbarBase(cax, cmap=cmap, norm=norm); cb.set_ticks([-pi, -pi / 2, 0, pi / 2, pi]); cb.set_ticklabels(; (r'$-\pi$', r'$-\pi/2$', r'$0$', r'$\pi/2$', r'$\pi$')); cb.set_label('arg'). return fig, ax. [docs]def plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False,; figsize=(8, 12), fig=None, ax=None):; """"""; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters; ----------. H_list : List of Qobj; A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises; ------. ValueError; Input argument is not valid. """""". if not isinstance(H_list, list):; raise ValueError(""H_list must be a list of Qobj instances""). if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). H = H_list[0]; N = H.shape[0] if N == 0 else min(H.shape[0], N). xticks = []; yticks = []. x = 0; evals0 = H.eigenenergies(eigvals=N); for e_idx, e in enumerate(evals0[:N]):; ax.plot([x, x + 2], np.array([1, 1]) * e, 'b', linewidth=2); yticks.append(e); xticks.append(x + 1); x += 2. for H1 in H_list[1:]:. H = H + H1;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/visualization.html:14867,energy,energy,14867,docs/4.3/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/visualization.html,7,['energy'],['energy']
Energy Efficiency,"s['tol']; maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if settings.has_mkl and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L, ; ss_args, has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]; ; # Do preconditioning; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres', ; 'power-lgmres', 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)), ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning); ; ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return; ; _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if settings.has_mkl:; lu = mkl_splu(L); else: ; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug and _scipy_check:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; _tol = max(ss_args['tol']/10, 1e-15) # Should make this user accessible; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; ; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], restart=ss_args['restart'],; maxiter=ss_args['maxiter'], callback=_iter_count); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=_tol, M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, che",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/steadystate.html:25187,power,power,25187,docs/4.1/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/steadystate.html,3,['power'],['power']
Energy Efficiency,"s[1]). fig.tight_layout(). plt.show(). Husimi Q-function¶; The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. \[Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>\]; where \(\left|\alpha\right>\) is a coherent state and; \(\alpha = x + iy\). In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function qfunc, as; demonstrated below.; Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the QFunc class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling qfunc in a loop.; xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). Visualizing operators¶; Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements.; QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, qutip.visualization.matrix_histogram and; qutip.visualization.matrix_histogram_complex, and as Hinton diagram of weighted; squares, qutip.visualiza",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-visualization.html:8542,efficient,efficient,8542,docs/4.7/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html,2,['efficient'],['efficient']
Energy Efficiency,"s]def plot_fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; """"""; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (in inches) if it is to be created; (that is, if no 'fig' and 'ax' arguments are passed). Returns; -------; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure.; """""". if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). if isket(rho):; rho = ket2dm(rho). N = rho.shape[0]. ax.bar(np.arange(offset, offset + N), np.real(rho.diag()),; color=""green"", alpha=0.6, width=0.8); if unit_y_range:; ax.set_ylim(0, 1). ax.set_xlim(-.5 + offset, N + offset); ax.set_xlabel('Fock number', fontsize=12); ax.set_ylabel('Occupation probability', fontsize=12). if title:; ax.set_title(title). return fig, ax. def fock_distribution(rho, offset=0, fig=None, ax=None,; figsize=(8, 6), title=None, unit_y_range=True):; warnings.warn(""Deprecated: Use plot_fock_distribution""); return plot_fock_distribution(rho, offset=offset, fig=fig, ax=ax,; figsize=figsize, title=title,; unit_y_range=unit_y_range). [docs]def plot_wigner(rho, fig=None, ax=None, figsize=(6, 6),; cmap=None, alpha_max=7.5, colorbar=False,; method='clenshaw', projection='2d'):; """"""; Plot the the Wigner function for a density matrix (or ket) that describes; an oscillator mode. Parameters; ----------; rho : :class:`qutip.Qobj`; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/visualization.html:27340,green,green,27340,docs/4.7/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/visualization.html,2,['green'],['green']
Energy Efficiency,"s_bar=None,; show_scheduling=False, **kwargs):; """"""; Call the function ``task`` for each value in ``values`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, *args, **kwargs)``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:10003,schedul,scheduling,10003,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,11,['schedul'],['scheduling']
Energy Efficiency,"se) – ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases.; M ({sparse matrix, dense matrix, LinearOperator}, optional) – ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically.; fill_factor (float, optional, default = 100) – ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element.; ILU_MILU (str, optional, default = 'smilu_2') – ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns:; dm (qobj) – Steady state density matrix.; info (dict, optional) – Dictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]¶; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the ‘steadystate’ function. Parameters:; A (qobj) – A Hamilto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:104571,reduce,reduced,104571,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['reduce'],['reduced']
Energy Efficiency,"se:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_sca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:17296,efficient,efficient,17296,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,10,['efficient'],['efficient']
Energy Efficiency,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling ter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15232,power,power,15232,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['power'],['power']
Energy Efficiency,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:14918,power,power,14918,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['power'],['power']
Energy Efficiency,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:2675,efficient,efficient,2675,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,6,['efficient'],['efficient']
Energy Efficiency,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html:2814,efficient,efficient,2814,docs/4.6/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-master.html,2,['efficient'],['efficient']
Energy Efficiency,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2901,efficient,efficient,2901,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['efficient'],['efficient']
Energy Efficiency,"sing QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/cofc.html:2040,adapt,adapted,2040,cofc.html,https://qutip.org,https://qutip.org/cofc.html,1,['adapt'],['adapted']
Energy Efficiency,"sing task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 3.01s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.01s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.02s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.02s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.02s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.03s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.03s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.03s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.04s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.04s. Est. time left: 00:00:00:00; Total run time: 25.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-parfor.html:7122,power,powerful,7122,docs/4.3/guide/guide-parfor.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-parfor.html,1,['power'],['powerful']
Energy Efficiency,"solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(taulist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]). N = len(taulist); dt = taulist[1] - taulist[0]. F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:. .. math::. \lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/correlation.html:18005,power,power,18005,docs/4.0.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/correlation.html,2,['power'],['power']
Energy Efficiency,"solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:11599,efficient,efficient,11599,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['efficient'],['efficient']
Energy Efficiency,"solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user.; method (str, default = 'iterative') – Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’.; permc_spec (str, optional, default='COLAMD') – Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified.; fill_factor (float, optional, default = 100) – Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization.; drop_tol (float, optional, default = 1e-4) – Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization.; diag_pivot_thresh (float, optional, default = None) – Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element.; ILU_MILU (str, optional, default = 'smilu_2') – Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:; lu (object) – Returns a SuperLU object representing iLU preconditioner.; info (dict, optional) – Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:107304,reduce,reduced,107304,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['reduce'],['reduced']
Energy Efficiency,"spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters:start : int. The starting value of the sequence. stop : int. The stoping values of the sequence. num : int, optional. Number of samples to generate. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for writ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:193024,energy,energy,193024,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['energy'],['energy']
Energy Efficiency,"specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numbers; from collections.abc import Iterable; from itertools import product; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_oper']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi / 2)]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qip/gates.html:2170,reduce,reduce,2170,docs/4.4/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qip/gates.html,1,['reduce'],['reduce']
Energy Efficiency,"specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numbers; from collections.abc import Iterable; from itertools import product; from functools import partial, reduce; from operator import mul. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'qrot',; 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'molmer_sorensen',; 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group', 'expand_operator']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi /",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html:2216,reduce,reduce,2216,docs/4.5/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/operations/gates.html,1,['reduce'],['reduce']
Energy Efficiency,"ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; diag_pivot_thresh=ss_args['diag_pivot_thresh'],; options=dict(ILU_MILU=ss_args['ILU_MILU'])). if settings.debug:; L_nnz = lu.L.nnz; U_nnz = lu.U.nnz; logger.debug('L NNZ: %i ; U NNZ: %i' % (L_nnz, U_nnz)); logger.debug('Fill factor: %f' % ((L_nnz+U_nnz)/orig_nnz)). it = 0; while (la.norm(L * v, np.inf) > tol) and (it < maxiter):; check = 0; if ss_args['method'] == 'power':; v = lu.solve(v); elif ss_args['method'] == 'power-gmres':; v, check = gmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; restart=ss_args['restart'],; maxiter=ss_args['maxiter'],; callback=_iter_count, callback_type='legacy'); elif ss_args['method'] == 'power-lgmres':; v, check = lgmres(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'power-bicgstab':; v, check = bicgstab(L, v, tol=mtol, atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); if check > 0:; raise Exception(""{} failed to find solution in ""; ""{} iterations."".format(ss_args['method'],; check)); if check < 0:; raise Exception(""Breakdown in {}"".format(ss_args['method'])); v = v / la.norm(v, np.inf); it += 1; if ss_args['method'] == 'power' and ss_args['solver'] == 'mkl':; lu.delete(); if ss_args['return_info']:; ss_args['info']['max_iter_refine'] = ss_args['max_iter_refine']; ss_args['info']['scaling_vectors'] = ss_args['scaling_vectors']; ss_args['info']['weighted_matching'] = ss_args['weighted_matching']. if it >= maxiter:; raise Exception('Failed to find steady state after ' +; str(maxiter) + ' iterations'); _power_end ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:28371,power,power-gmres,28371,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,12,['power'],"['power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"stat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html:31344,reduce,reduce,31344,docs/4.6/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/operations/gates.html,4,['reduce'],['reduce']
Energy Efficiency,"steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:5685,power,power,5685,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,6,['power'],['power']
Energy Efficiency,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:8045,efficient,efficient,8045,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency,"system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:5333,power,power,5333,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['power'],['power']
Energy Efficiency,"system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:5728,power,power,5728,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['power'],['power']
Energy Efficiency,"s¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a prec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:101149,power,power,101149,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"t %s"" % to). return value * (_unit_factor_tbl[orig] / _unit_factor_tbl[to]). def convert_GHz_to_meV(w):; """"""; Convert an energy from unit GHz to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:6928,energy,energy,6928,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evalua",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:253439,schedul,scheduled,253439,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['schedul'],['scheduled']
Energy Efficiency,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]¶; Simultaneous diagonalization of commuting Hermitian m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:213133,schedul,scheduled,213133,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['schedul'],['scheduled']
Energy Efficiency,"t is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. log_level¶; integer – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more infor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:76835,reduce,reduce,76835,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduce']
Energy Efficiency,t method). add_states() (Bloch method). add_timing() (Stats method). add_vectors() (Bloch method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/genindex.html:1778,charge,charge,1778,docs/4.2/genindex.html,https://qutip.org,https://qutip.org/docs/4.2/genindex.html,1,['charge'],['charge']
Energy Efficiency,"t time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat le",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:3606,efficient,efficient,3606,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"t time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:3639,efficient,efficient,3639,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['efficient'],['efficient']
Energy Efficiency,"t(); idx_nonzero = eigvals != 0; eigvals = eigvals[idx_nonzero]; eigstates = eigstates[idx_nonzero]. if method == 'clip':; eigvals[eigvals < 0] = 0; elif method == 'sgs':; eigvals = eigvals[::-1]; eigstates = eigstates[::-1]. acc = 0.0; dim = self.shape[0]; n_eigs = len(eigvals). for idx in reversed(range(n_eigs)):; if eigvals[idx] + acc / (idx + 1) >= 0:; break; else:; acc += eigvals[idx]; eigvals[idx] = 0.0. eigvals[:idx+1] += acc / (idx + 1). return sum([; val * qutip.states.ket2dm(state); for val, state in zip(eigvals, eigstates); ], Qobj(np.zeros(self.shape), dims=self.dims); ).unit(). [docs] def matrix_element(self, bra, ket):; """"""Calculates a matrix element. Gives the matrix element for the quantum object sandwiched between a; `bra` and `ket` vector. Parameters; -----------; bra : qobj; Quantum object of type 'bra' or 'ket'. ket : qobj; Quantum object of type 'ket'. Returns; -------; elem : complex; Complex valued matrix element. Note; ----; It is slightly more computationally efficient to use a ket; vector for the 'bra' input. """"""; if not self.isoper:; raise TypeError(""Can only get matrix elements for an operator.""). else:; if bra.isbra and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,1). elif bra.isket and ket.isket:; return zcsr_mat_elem(self.data,bra.data,ket.data,0); else:; raise TypeError(""Can only calculate matrix elements for bra and ket vectors.""). [docs] def overlap(self, other):; """"""Overlap between two state vectors. Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. Parameters; -----------; other : qobj; Quantum object for a state vector of type 'ket' or 'bra'. Returns; -------; overlap : complex; Complex valued overlap. Raises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects. Notes; -----; Since QuTiP mainly deals with ket vectors, the most efficient inner product; call is the ket-ket version that computes the product <self|other> with; both v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:37620,efficient,efficient,37620,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['efficient'],['efficient']
Energy Efficiency,"t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12443,efficient,efficiently,12443,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"t,; using the presentation of the group given by Ross and Selinger; (https://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2),; _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:29464,reduce,reduce,29464,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['reduce'],['reduce']
Energy Efficiency,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :class:`qutip.solver.Options`; options for the ODE solver. For computing Floquet modes. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an *array* of expectation values for the times specified; by `tlist`.; """""". if _safe_m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:25738,energy,energy,25738,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:24285,energy,energy,24285,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, 500 + 1),; H, T, args). # get w_th from args if it exists; if 'w_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html:25237,energy,energy,25237,docs/3.1.0/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html,1,['energy'],['energy']
Energy Efficiency,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:24254,energy,energy,24254,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['energy'],['energy']
Energy Efficiency,"t-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops). f_modes_0, f_energies = floquet_modes(H, T, args). f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:24029,energy,energy,24029,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,4,['energy'],['energy']
Energy Efficiency,"t.dims = self.dims; if settings.auto_tidyup:; out.tidyup(); if isinstance(other, complex):; out._isherm = out.isherm; else:; out._isherm = self._isherm. out.superrep = self.superrep. return out. else:; raise TypeError(""Incompatible object for division""). def __neg__(self):; """"""; NEGATION operation.; """"""; out = Qobj(); out.data = -self.data; out.dims = self.dims; out.superrep = self.superrep; if settings.auto_tidyup:; out.tidyup(); out._isherm = self._isherm; out._isunitary = self._isunitary; return out. def __getitem__(self, ind):; """"""; GET qobj elements.; """"""; out = self.data[ind]; if sp.issparse(out):; return out.toarray(); else:; return out. def __eq__(self, other):; """"""; EQUALITY operator.; """"""; if (isinstance(other, Qobj) and; self.dims == other.dims and; not np.any(np.abs((self.data - other.data).data) >; settings.atol)):; return True; else:; return False. def __ne__(self, other):; """"""; INEQUALITY operator.; """"""; return not (self == other). def __pow__(self, n, m=None): # calculates powers of Qobj; """"""; POWER operation.; """"""; if self.shape[0] != self.shape[1]:; raise Exception(""Raising a qobj to some power works only for "" +; ""operators and super-operators (square matrices).""). if m is not None:; raise NotImplementedError(""modulo is not implemented for Qobj""). try:; data = self.data ** n; except (TypeError, ValueError):; raise ValueError('Invalid choice of exponent.'); out = Qobj(data, dims=self.dims); out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. def __abs__(self):; return abs(self.data). def __str__(self):; s = """"; t = self.type; shape = self.shape; if self.type in ['oper', 'super']:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape) +; "", type = "" + t +; "", isherm = "" + str(self.isherm) +; (; "", superrep = {0.superrep}"".format(self); if t == ""super"" and self.superrep != ""super""; else """"; ) + ""\n""); else:; s += (""Quantum object: "" +; ""dims = "" + str(self.dims) +; "", shape = "" + str(shape)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:20333,power,powers,20333,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,6,"['POWER', 'power']","['POWER', 'powers']"
Energy Efficiency,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:168223,energy,energy,168223,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['energy'],['energy']
Energy Efficiency,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:130631,energy,energy,130631,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"t=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. `CNOT 0, 1` commute with `CNOT 0, 2`.; """"""; instruction1 = instructions[ind1]; instruction2 = instructions[ind2]; if instruction1.name != instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:19176,schedul,schedule,19176,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"tation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTRLRX"", targets=[0,1], arg_value=np.pi/2). # qubit 1 controls qubit 0; qc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:6766,reduce,reduced,6766,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,4,['reduce'],['reduced']
Energy Efficiency,"tation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specif",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:68271,power,power,68271,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes three mandatory arguments: The system Hamiltonian \(H\), a lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:9619,power,power,9619,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,3,['power'],['power']
Energy Efficiency,"te. elems : list/ndarray, optional. Requested elements to include in array. Returns:samples : ndadrray. Original equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters:j1 : float. Total angular momentum 1. j2 : float. Total angular momentum 2. j3 : float. Total angular momentum 3. m1 : float. z-component of angular momentum 1. m2 : float. z-component of angular momentum 2. m3 : float. z-component of angular momentum 3. Returns:cg_coeff : float. Requested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters:value : float / array. The energy in the old unit. orig : string. The name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). to : string. The name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns:value_new_unit : float / array. The energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters:filename : str. Name of file containing reqested data. sep : str. Seperator used to store data. Returns:data : array_like. Data from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters:filename : str. Name of data file to be stored, including extension. data: array_like. Data to be written to file. numtype : str {‘complex, ‘real’}. Type of numerical data. numformat : str {‘decimal’,’exp’}. Format for written data. sep : str. Single-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters:name : str. Name of data file to be loaded. Returns:qobject : instance / array_like. Object retrieved from reques",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:193313,energy,energy,193313,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['energy'],['energy']
Energy Efficiency,"te: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'); ; F = scipy.fftpack.fft(y); # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -------------------------------------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:17619,power,power,17619,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,1,['power'],['power']
Energy Efficiency,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:181173,schedul,schedules,181173,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,8,"['reduce', 'schedul']","['reduce', 'schedules']"
Energy Efficiency,"tebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task (a Python function) – The function that is to be called for each value in task_vec.; task_vec (array / list) – The list or array of values for which the task function is to be; evaluated.; args (list / dictionary) – The optional additional argument to the task function. For example; a dictionary with parameter values.; client (IPython.parallel.Client) – The IPython.parallel Client instance that will be used in the; parfor execution.; view (a IPython.parallel.Client view) – The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view().; show_scheduling (bool {False, True}, default False) – Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster.; show_progressbar (bool {False, True}, default False) – Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result – The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. Return type:list. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:200506,schedul,scheduling,200506,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['schedul'],['scheduling']
Energy Efficiency,"ted during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-control.html:18196,efficient,efficient,18196,docs/4.5/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-control.html,1,['efficient'],['efficient']
Energy Efficiency,"teger x.; """"""; tot = 0; while x:; tot += 1; x &= x - 1; return tot. [docs]def hadamard_transform(N=1):; """"""Quantum object representing the N-qubit Hadamard gate. Returns; -------; q : qobj; Quantum object representation of the N-qubit Hadamard gate. """"""; data = 2 ** (-N / 2) * np.array([[(-1) ** _hamming_distance(i & j); for i in range(2 ** N)]; for j in range(2 ** N)]). return Qobj(data, dims=[[2] * N, [2] * N]). [docs]def gate_sequence_product(U_list, left_to_right=True):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list : list; List of gates implementing the quantum circuit. left_to_right : Boolean; Check if multiplication is to be done from left to right. Returns; -------; U_overall : qobj; Overall unitary matrix of a given quantum circuit. """"""; U_overall = 1; for U in U_list:; if left_to_right:; U_overall = U * U_overall; else:; U_overall = U_overall * U. return U_overall. def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html:17569,power,powers,17569,docs/4.1/modules/qutip/qip/gates.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qip/gates.html,6,['power'],['powers']
Energy Efficiency,"tem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:44619,reduce,reduced,44619,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['reduce'],['reduced']
Energy Efficiency,"ter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:105713,efficient,efficient,105713,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['efficient'],['efficient']
Energy Efficiency,"teratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory nee",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:3339,power,power,3339,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['power'],['power']
Energy Efficiency,"th IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:; task: a Python function; The function that is to be called for each value in task_vec. task_vec: array / list; The list or array of values for which the task function is to be; evaluated. args: list / dictionary; The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:; result : list; The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:213513,schedul,scheduling,213513,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['schedul'],['scheduling']
Energy Efficiency,"that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:: qutip.Qobj. time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:t : float. current time. tau : float. time-delay. notrace : bool {False}. If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`. time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:rho0 : qutip.Qobj. initial density matrix or state vector (ket). t : float. current time. tau : float. time-delay. Returns:: qutip.Qobj. density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver.; Attributes. dynmaps; (list of qutip.Qobj) List of precomputed dynamical maps (superoperators), or a callback function that returns the superoperator at a given time. times; (array_like) List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes; (array_like) List of times \(t_k\) to use as learning times if argument dynmaps is a callback function. thres; (float) Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below treshold. options; (qutip.solver.Options) Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:31264,reduce,reduced,31264,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['reduce'],['reduced']
Energy Efficiency,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:8466,reduce,reduce,8466,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,8,['reduce'],['reduce']
Energy Efficiency,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`qutip.control.dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:7702,reduce,reduce,7702,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,2,['reduce'],['reduce']
Energy Efficiency,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : dump.OptimDump; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:70203,reduce,reduce,70203,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduce']
Energy Efficiency,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:15302,power,power,15302,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,4,['power'],['power']
Energy Efficiency,"the given x and y labels; and title. Parameters:; M : Matrix of Qobj; The matrix to visualize. xlabels : list of strings; list of x labels. ylabels : list of strings; list of y labels. title : string; title of the plot (optional). limits : list/array with two float numbers; The z-axis limits [min, max] (optional). phase_limits : list/array with two float numbers; The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:130862,energy,energy,130862,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"the system.; targets : int or list of int; The indices of qubits that are acted on.; dims : list, optional; A list of integer for the dimension of each composite system.; E.g ``[2, 2, 2, 2, 2]`` for 5 qubits system. If None, qubits system; will be the default option.; cyclic_permutation : boolean, optional; Expand for all cyclic permutation of the targets.; E.g. if ``N=3`` and `oper` is a 2-qubit operator,; the result will be a list of three operators,; each acting on qubits 0 and 1, 1 and 2, 2 and 0. Returns; -------; expanded_oper : :class:`qutip.Qobj`; The expanded qubits operator acting on a system with N qubits. Notes; -----; This is equivalent to gate_expand_1toN, gate_expand_2toN,; gate_expand_3toN in ``qutip.qip.gate.py``, but works for any dimension.; """"""; if dims is None:; dims = [2] * N; targets = _targets_to_list(targets, oper=oper, N=N); _check_qubits_oper(oper, dims=dims, targets=targets). # Call expand_operator for all cyclic permutation of the targets.; if cyclic_permutation:; oper_list = []; for i in range(N):; new_targets = np.mod(np.array(targets)+i, N); oper_list.append(; expand_operator(oper, N=N, targets=new_targets, dims=dims)); return oper_list. # Generate the correct order for qubits permutation,; # eg. if N = 5, targets = [3,0], the order is [1,2,3,0,4].; # If the operator is cnot,; # this order means that the 3rd qubit controls the 0th qubit.; new_order = [0] * N; for i, t in enumerate(targets):; new_order[t] = i; # allocate the rest qutbits (not targets) to the empty; # position in new_order; rest_pos = [q for q in list(range(N)) if q not in targets]; rest_qubits = list(range(len(targets), N)); for i, ind in enumerate(rest_pos):; new_order[ind] = rest_qubits[i]; id_list = [identity(dims[i]) for i in rest_pos]; return tensor([oper] + id_list).permute(new_order). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html:40108,allocate,allocate,40108,docs/4.7/modules/qutip/qip/operations/gates.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/operations/gates.html,2,['allocate'],['allocate']
Energy Efficiency,"the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestr or pathlib.PathName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:259150,energy,energy,259150,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:247032,energy,energy,247032,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"thon notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters:task: a Python function :. The function that is to be called for each value in task_vec. task_vec: array / list :. The list or array of values for which the task function is to be; evaluated. args: list / dictionary :. The optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Client :. The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view :. The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False :. Display a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False :. Display a HTML-based progress bar duing the execution of the parfor; loop. Returns:result : list. The result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table()¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:108484,schedul,scheduling,108484,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['schedul'],['scheduling']
Energy Efficiency,"three different relaxation rates.; In [1]: times = np.linspace(0,10.0,200). In [2]: a = destroy(10). In [3]: x = a.dag() + a. In [4]: H = a.dag() * a. In [5]: corr1 = correlation_ss(H, times, [np.sqrt(0.5) * a], x, x). In [6]: corr2 = correlation_ss(H, times, [np.sqrt(1.0) * a], x, x). In [7]: corr3 = correlation_ss(H, times, [np.sqrt(2.0) * a], x, x). In [8]: figure(); Out[8]: <matplotlib.figure.Figure at 0x10b2196d0>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x10b4a3490>,; <matplotlib.lines.Line2D at 0x10b4a33d0>,; <matplotlib.lines.Line2D at 0x10b4fddd0>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x10df0d310>. In [11]: xlabel(r'Time $t$'); Out[11]: <matplotlib.text.Text at 0x10d29b1d0>. In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-correlation.html:5778,power,power,5778,docs/3.1.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html,1,['power'],['power']
Energy Efficiency,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:3509,reduce,reduces,3509,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['reduce'],['reduces']
Energy Efficiency,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:3518,reduce,reduces,3518,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,1,['reduce'],['reduces']
Energy Efficiency,"time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; ``[gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]``; Notice that gate3 and gate4 commut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:16037,schedul,scheduling,16037,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['scheduling']
Energy Efficiency,timizer method). (OptimizerBFGS method). (OptimizerCrabFmin method). (OptimizerLBFGSB method). run_state() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). run_statistics() (CircuitSimulator method). (QubitCircuit method). rx() (in module qutip.qip.operations.gates). rx_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). ry() (in module qutip.qip.operations.gates). rz() (in module qutip.qip.operations.gates). rz_compiler() (CavityQEDCompiler method). (SpinChainCompiler method). S. save() (Bloch method). (Bloch3d method). save_amps() (Dynamics method). save_coeff() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). save_qasm() (in module qutip.qip.qasm). scattering_probability() (in module qutip.scattering). schedule() (Scheduler method). Scheduler (class in qutip.qip.compiler). serial_map() (in module qutip.parallel). sesolve() (in module qutip.sesolve). set_all_tlist() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (OptPulseProcessor method). (Processor method). (SpinChain method). set_label_convention() (Bloch method). set_optim_var_vals() (PulseGenCrab method). set_phase_option() (FidCompUnitary method). set_total_time() (Stats method). set_up_ops() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (SpinChain method). set_up_params() (CircularSpinChain method). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). shape() (in module qutip.qobj). show() (Bloch method). (Bloch3d method). sigmam() (in module qutip.operators). sigmap() (in module qutip.operators). sigmax() (in module qutip.operators). sigmay() (in module qutip.operators). sigmaz() (in module qutip,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/genindex.html:30452,schedul,schedule,30452,docs/4.7/genindex.html,https://qutip.org,https://qutip.org/docs/4.7/genindex.html,1,['schedul'],['schedule']
Energy Efficiency,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:198963,reduce,reduces,198963,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['reduce'],['reduces']
Energy Efficiency,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142841,reduce,reduces,142841,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,6,['reduce'],['reduces']
Energy Efficiency,"tion solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:4570,power,power,4570,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"tionary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_ss(H, wlist, c_ops, a_op, b_op)[source]¶; Calculate the spectrum of the correlation function; \(\l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:130381,power,power,130381,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['power'],['power']
Energy Efficiency,"tlib axes instance; The axes context in which the plot will be drawn. threshold: float (None); Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:; fig, ax : tuple; A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:; ValueError; Input argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]¶; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters:; rho : qutip.qobj.Qobj; The density matrix (or ket) of the state to visualize. fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. title : string; An optional title for the figure. figsize : (width, height); The size of the matplotlib figure (i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:131296,energy,energy,131296,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns:; : :class:`qutip.Qobj`; time-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters:; t : float; current time. tau : float; time-delay. notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. ——-. : :class:`qutip.Qobj`; time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters:; rho0 : qutip.Qobj; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns:; : :class:`qutip.Qobj`; density matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes:; dynmaps : list of qutip.Qobj; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimes : array_like; List of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:32053,reduce,reduced,32053,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"to_end - \; self.nodes[ind1].distance_to_end. def add_constraint_dependency(self, constraint_dependency):; """"""; Add the dependency caused by hardware constraint to the graph. Parameters; ----------; constraint_dependency: list; `constraint_dependency` obtained by the method; `find_topological_order`.; """"""; for ind1, ind2 in constraint_dependency:; self.nodes[ind1].successors.add(ind2); self.nodes[ind2].predecessors.add(ind1). # Update the start and end nodes of the graph; start = []; end = []; for i, instruction in enumerate(self.nodes):; if not instruction.successors:; end.append(i); if not instruction.predecessors:; start.append(i); self.start = start; self.end = end. [docs]class Scheduler():; """"""; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419. The scheduler includes two methods,; ""ASAP"", as soon as possible, and ""ALAP"", as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits. The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters; ----------; method: str; ""ASAP"" for as soon as possible.; ""ALAP"" for as late as possible.; constraint_functions: list, optional; A list of hardware constraint functions.; Default includes a function `qubit_contraint`,; i.e. one qubit cannot be used by two gates at the same time.; """"""; def __init__(self, method=""ALAP"", constraint_functions=None):; self.method = method; if constraint_functions is None:; self.constraint_functions = [qubit_constraint]; else:; return constraint_functions. [docs] def schedule(self, circuit, gates_schedule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `Q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:12723,schedul,scheduler,12723,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['scheduler']
Energy Efficiency,"too aggressively.; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.000000",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:17636,charge,charge,17636,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,6,['charge'],['charge']
Energy Efficiency,"toping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:205869,energy,energy,205869,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"trix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis.; """"""; diagonal_system = Pim(N=self.N,; emission=self.emission,; dephasing=self.dephasing,; pumping=self.pumping,; collective_emission=self.collective_emission,; collective_dephasing=self.collective_dephasing,; collective_pumping=self.collective_pumping); coef_matrix = diagonal_system.coefficient_matrix(); return coef_matrix. # Utility functions for properties of the Dicke space; def energy_degeneracy(N, m):; """"""Calculate the number of Dicke states with same energy. The use of the `Decimals` class allows to explore N > 1000,; unlike the built-in function `scipy.special.binom`. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns; -------; degeneracy: int; The energy degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N/2 + m)); d2 = Decimal(factorial(N/2 - m)); degeneracy = numerator/(d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2*j + 1); denominator_1 = Decimal(factorial(N/2 + j + 1)); denominator_2 = Decimal(factorial(N/2 - j)); degeneracy = numerator/(denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy. Parameters",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:13034,energy,energy,13034,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['energy'],['energy']
Energy Efficiency,"truction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12853,schedul,scheduling,12853,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['scheduling']
Energy Efficiency,"truction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12819,schedul,scheduling,12819,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['scheduling']
Energy Efficiency,"tructions_graph.reverse_graph(). # Schedule without hardware constraints, then; # use this cycles_list to compute the distance.; cycles_list, _ = instructions_graph.find_topological_order(; priority=False, apply_constraint=None, random=random_shuffle); instructions_graph.compute_distance(cycles_list=cycles_list). # Schedule again with priority and hardware constraint.; cycles_list, constraint_dependency = \; instructions_graph.find_topological_order(; priority=True, apply_constraint=self.apply_constraint,; random=random_shuffle). # If we only need gates schedule, we can output the result here.; if gates_schedule or return_cycles_list:; if self.method == ""ALAP"":; cycles_list.reverse(); if return_cycles_list:; return cycles_list; gate_cycles_indices = [0] * len(gates); for cycle_ind, cycle in enumerate(cycles_list):; for instruction_ind in cycle:; gate_cycles_indices[instruction_ind] = cycle_ind; return gate_cycles_indices. # For pulse schedule,; # we add the hardware dependency to the graph; # and compute the longest distance to the start node again.; # The longest distance to the start node determines; # the start time of each pulse.; instructions_graph.add_constraint_dependency(constraint_dependency); instructions_graph.compute_distance(cycles_list=cycles_list). # Output pulse schedule result.; instruction_start_time = []; if self.method == ""ASAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instruction.distance_to_start - instruction.duration); elif self.method == ""ALAP"":; for instruction in instructions_graph.nodes:; instruction_start_time.append(; instructions_graph.longest_distance -; instruction.distance_to_start); return instruction_start_time. [docs] def commutation_rules(self, ind1, ind2, instructions):; """"""; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:. If the two gates do not have the same n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:18825,schedul,schedule,18825,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"try in the position operator. Returns. Qobj(xs)qutip.QobjThe position operator. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:73650,reduce,reduced,73650,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['reduce'],['reduced']
Energy Efficiency,"two float numbers. The phase-axis (colorbar) limits [min, max] (optional). ax : a matplotlib axes instance. The axes context in which the plot will be drawn. threshold: float (None) :. Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:H_list : List of Qobj. A list of Hamiltonians. labels : List of string; A list of labels for each Hamiltonian. show_ylabels : Bool (default False); Show y labels to the left of energy levels of the initial; Hamiltonian. N : int; The number of energy levels to plot. figsize : tuple (int,int); The size of the figure (width, height). fig : a matplotlib Figure instance; The Figure canvas in which the plot will be drawn. ax : a matplotlib axes instance; The axes context in which the plot will be drawn. Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. Raises:ValueError :. Input argument is not valid. wigner_cmap(W, levels=1024, shift=0, invert=False)¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters:W : array. Wigner function array, or any array. levels : int. Number of color levels to create. shift : float. Shifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -5e-3). invert : bool. Invert the color scheme for negative values so that smaller negative; values have darker color. Returns:R",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:80493,energy,energy,80493,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['energy'],['energy']
Energy Efficiency,"ty(x, x); Out[38]: 1.0000000208397526. In [39]: tracedist(y, y); Out[39]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [40]: tracedist(y, x); Out[40]: 0.9771565895267291. In [41]: np.sqrt(1 - fidelity(y, x) ** 2); Out[41]: 0.97715657013508528. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [42]: 1 - fidelity(x, z) ** 2; Out[42]: 0.7782890497791632. In [43]: tracedist(x, z); Out[43]: 0.8559028328862591. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [44]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [45]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [46]: vac; Out[46]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [47]: c = create(2). In [48]: c * vac; Out[48]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:12267,energy,energy,12267,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['energy'],['energy']
Energy Efficiency,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes three mandatory arguments: The system Hamiltonian \(H\), a li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html:9199,power,power,9199,docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,2,['power'],['power']
Energy Efficiency,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:9239,power,power,9239,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,8,['power'],['power']
Energy Efficiency,"uTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C++ code, the second option (string based) tends to be more efficient and will run faster [This is also the only format that is supported in the qutip.brmesolve solver]. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'imag', 'log', 'log10', 'norm', 'proj', 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above, than it is possible to call any of the f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:3128,efficient,efficient,3128,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['efficient'],['efficient']
Energy Efficiency,"uate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:107962,power,power,107962,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"uation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parame",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:91624,power,power,91624,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"ubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:182916,schedul,schedule,182916,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['schedul'],['schedule']
Energy Efficiency,"udes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters:; M (Matrix of Qobj) – The matrix to visualize; xlabels (list of strings) – list of x labels; ylabels (list of strings) – list of y labels; title (string) – title of the plot (optional); limits (list/array with two float numbers) – The z-axis limits [min, max] (optional); phase_limits (list/array with two float numbers) – The phase-axis (colorbar) limits [min, max] (optional); ax (a matplotlib axes instance) – The axes context in which the plot will be drawn.; threshold (float (None)) – Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters:; H_list (List of Qobj) – A list of Hamiltonians.; labels (List of string) – A list of labels for each Hamiltonian; show_ylabels (Bool (default False)) – Show y labels to the left of energy levels of the initial; Hamiltonian.; N (int) – The number of energy levels to plot; figsize (tuple (int,int)) – The size of the figure (width, height).; fig (a matplotlib Figure instance) – The Figure canvas in which the plot will be drawn.; ax (a matplotlib axes instance) – The axes context in which the plot will be drawn. Returns:fig, ax – A tuple of the matplotlib figure and axes instances used to produce; the figure. Return type:tuple. Raises:ValueError – Input argument is not valid. plot_fock_distribution(rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:117224,energy,energy,117224,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"ui.BaseProgressBar – Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data (array_like) – Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs (list) – List of arrays that spans the space for each coordinate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d – A new instances of Distribution that describes the marginal; distribution. Return type:Distributions. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d – A new instances of Distribution that describes the projection. Return type:Distributions. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:49148,reduce,reduced,49148,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"ulate the same thing with mesolve; p_ex_ref = mesolve(H, psi0, tlist, [], [num(2)], args).expect[0]. # plot the results; from pylab import *; plot(tlist, real(p_ex), 'ro', tlist, 1-real(p_ex), 'bo'); plot(tlist, real(p_ex_ref), 'r', tlist, 1-real(p_ex_ref), 'b'); xlabel('Time'); ylabel('Occupation probability'); legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); show(). (Source code, png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 10 * T, 101); psi0 = basis(2,0). H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); H1 = A/2.0 * sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = expect(num(2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:13575,efficient,efficiently,13575,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,8,['efficient'],['efficiently']
Energy Efficiency,"ule=False,; return_cycles_list=False, random_shuffle=False,; repeat_num=0):; """"""; Schedule a `QubitCircuit`,; a list of `Gates` or a list of `Instruction`.; For pulse schedule, the execution time for each `Instruction`; is given in its `duration` attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14635,schedul,schedule,14635,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 GHz = 4.1357e-6 eV = 4.1357e-3 meV; w_meV = w * 4.1357e-3; return w_meV. def convert_meV_to_GHz(w):; """"""; Convert an energy from unit meV to unit GHz. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 meV = 1.0/4.1357e-3 GHz; w_GHz = w / 4.1357e-3; return w_GHz. def convert_J_to_meV(w):; """"""; Convert an energy from unit J to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_meV = 1000.0 * w / _e; return w_meV. def convert_meV_to_J(w):; """"""; Convert an energy from unit meV to unit J. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 eV = 1.602e-19 J; w_J = 0.001 * w * _e; return w_J. def convert_meV_to_mK(w):; """"""; Convert an energy from unit meV to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_mK = w / 0.0000861740; return w_mK. def convert_mK_to_meV(w):; """"""; Convert an energy from unit mK to unit meV. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # 1 mK = 0.0000861740 meV; w_meV = w * 0.0000861740; return w_meV. def convert_GHz_to_mK(w):; """"""; Convert an energy from unit GHz to unit mK. Parameters; ----------; w : float / array; The energy in the old unit. Returns; -------; w_new_unit : float / array; The energy in the new unit.; """"""; # h v [Hz] = kB T [K]; # h 1e9 v [GHz] = kB 1e-3 T [mK]; # T [mK] = 1e12 * (h/kB) * v [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/utilities.html:7081,energy,energy,7081,docs/4.1/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/utilities.html,11,['energy'],['energy']
Energy Efficiency,"upling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). (png, hires.png, pdf). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steadystate. In QuTiP, we can evoluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:6302,power,power,6302,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"upling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-correlation.html:6312,power,power,6312,docs/4.7/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html,2,['power'],['power']
Energy Efficiency,"urce]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:149800,efficient,efficient,149800,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,5,['efficient'],['efficient']
Energy Efficiency,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 and later, P.D. Nation, J.R. Johans",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:17603,efficient,efficient,17603,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,8,['efficient'],['efficient']
Energy Efficiency,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A. © Copyright 2011 to 2021 inclusive, QuTiP developers",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html:16138,efficient,efficient,16138,docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,2,['efficient'],['efficient']
Energy Efficiency,"ute(L, perm2, perm2, kind); if settings.debug:; new_band = sp_bandwidth(L)[0]; new_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % new_band); logger.debug('Bandwidth reduction factor: %f'; % (old_band/new_band)); logger.debug('RCM profile: %i' % new_pro); logger.debug('Profile reduction factor: %f'; % (old_pro/new_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def _steadystate_power(L, ss_args):; """"""; Inverse power method for steady state solving.; """"""; ss_args['info'].pop('weight', None); if settings.debug:; logger.debug('Starting iterative inverse-power method solver.'); tol = ss_args['tol']; mtol = ss_args['mtol']; if mtol is None:; mtol = max(0.1*tol, 1e-15); maxiter = ss_args['maxiter']. use_solver(assumeSortedIndices=True); rhoss = Qobj(); sflag = issuper(L); if sflag:; rhoss.dims = L.dims[0]; else:; rhoss.dims = [L.dims[0], 1]; n = L.shape[0]; # Build Liouvillian; if ss_args['solver'] == 'mkl' and ss_args['method'] == 'power':; has_mkl = 1; else:; has_mkl = 0; L, perm, perm2, rev_perm, ss_args = _steadystate_power_liouvillian(L,; ss_args,; has_mkl); orig_nnz = L.nnz; # start with all ones as RHS; v = np.ones(n, dtype=complex); if ss_args['use_rcm']:; v = v[np.ix_(perm2,)]. # Do preconditioning; if ss_args['solver'] == 'scipy':; if ss_args['M'] is None and ss_args['use_precond'] and \; ss_args['method'] in ['power-gmres',; 'power-lgmres',; 'power-bicgstab']:; ss_args['M'], ss_args = _iterative_precondition(L, int(np.sqrt(n)),; ss_args); if ss_args['M'] is None:; warnings.warn(""Preconditioning failed. Continuing without."",; UserWarning). ss_iters = {'iter': 0}. def _iter_count(r):; ss_iters['iter'] += 1; return. _power_start = time.time(); # Get LU factors; if ss_args['method'] == 'power':; if ss_args['solver'] == 'mkl':; lu = mkl_splu(L, max_iter_refine=ss_args['max_iter_refine'],; scaling_vectors=ss_args['scaling_vectors'],; weighted_matching=ss_args['weighted_matching']); else:; lu = splu(L, permc_spec=ss_args['permc_spec'],; di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:27340,power,power,27340,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,7,['power'],['power']
Energy Efficiency,"ution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data (array_like) – Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs (list) – List of arrays that spans the space for each coordinate.; xlabels (list) – List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d – A new instances of Distribution that describes the marginal; distribution. Return type:Distributions. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim (int) – The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d – A new instances of Distribution that describes the projection. Return type:Distributions. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig; : matplotlib Figure instanceIf given, use this figure instance for the visualization,; ax; : matplotlib Axes instanceIf given, render the visualization using this axis instance.; figsize; : tupleSize of the new Figure instance, if one needs to be created.; colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used.; cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations.; style; : stringType of visualization: ‘colorma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:49569,reduce,reduced-dimensionality,49569,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['reduce'],['reduced-dimensionality']
Energy Efficiency,"valid; taus for this row and column of the Dicke space element. Distribution functions¶. class Distribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list; List of arrays that spans the space for each coordinate. xlabels : list; List of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:; d : Distributions; A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns:; d : Distributions; A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:54491,reduce,reduced,54491,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['reduce'],['reduced']
Energy Efficiency,"vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:9313,efficient,efficient,9313,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['efficient'],['efficient']
Energy Efficiency,"ve evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html:1569,efficient,efficiently,1569,docs/4.3/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-floquet.html,2,['efficient'],['efficiently']
Energy Efficiency,"vel systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it coint",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:121131,energy,energy,121131,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"vel systems. Returns. Nj: intThe number of Dicke ladders. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]¶; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. ap(j, m)[source]¶; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]¶; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]¶; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, …, (N-1),; is placed in a \(2^N\)-dimensional Hil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:121266,energy,energy,121266,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"ven a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems. use_rcm : bool, optional, default = False; Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:5722,power,power,5722,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,12,['power'],"['power', 'power-bicgstab', 'power-gmres', 'power-lgmres']"
Energy Efficiency,"w; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:4435,power,power,4435,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['power'],['power']
Energy Efficiency,"w; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:6998,power,power,6998,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,9,['power'],['power']
Energy Efficiency,"we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:8336,reduce,reduces,8336,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['reduce'],['reduces']
Energy Efficiency,"x warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refacto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:12115,schedul,scheduler,12115,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['schedul'],['scheduler']
Energy Efficiency,"x=5)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:58175,energy,energy,58175,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['energy'],['energy']
Energy Efficiency,"xed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. def _shift(self):; self.compiled = """"; self.args.update({""_t0"": 0}); new_ops = []; for op in self.ops:; new_op = [op.qobj, None, None, op.type]; if op.type == ""func"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; elif op.type == ""string"":; new_op[2] = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op.coeff + "" ""); new_op[1] = _StrWrapper(new_op[2]); elif op.type == ""array"":; new_op[2] = _Shift(op.get_coeff); new_op[1] = new_op[2]; new_op[3] = ""func""; self.type = ""mixed_callable""; elif op.type == ""spline"":; new_op[1] = _Shift(op.get_coeff); new_op[2] = new_op[1]; new_op[3] = ""func""; self.type = ""mixed_callable""; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops; return self. [docs] def expect(self, t, state, herm=False):; """"""; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time. This is more efficient than ``expect(QobjEvo(t), state)``. Parameters; ----------; t : float; The time to evaluate this operator at. state : Qobj or np.ndarray; The state to take the expectation value around. herm : bool, default False; Whether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See Also; --------; expect : General-purpose expectation values.; """"""; if not isinstance(t, (int, float)):; raise TypeError(""Time must be a real scalar""); if isinstance(state, Qobj):; if self.cte.dims[1] == state.dims[0]:; vec = state.full().ravel(""F""); elif self.cte.dims[1] == state.dims:; vec = state.full().ravel(""F""); else:; raise ValueError(""Dimensions do not fit""); elif isinstance(state, np.ndarray):; vec = state.ravel(""F""); else:; raise TypeError(""The vector must be an array or Qobj""). if vec.shape[0] == self.cte.shape[1]:; if self.compiled:; exp = self.compiled_qobjevo.expect(t, vec); elif self.cte.issuper:; self._dynamics_args_update(t, state); exp = cy_expec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:38654,efficient,efficient,38654,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['efficient'],['efficient']
Energy Efficiency,"xes3D; except:; pass. from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.wigner import wigner; from qutip.tensor import tensor; from qutip.matplotlib_utilities import complex_phase_cmap; from qutip.superoperator import vector_to_operator; from qutip.superop_reps import _pauli_basis, to_super; from qutip.tensor import flatten. from qutip import settings. # Adopted from the SciPy Cookbook.; def _blob(x, y, w, w_max, area, cmap=None):; """"""; Draws a square-shaped blob with the given area (< 1) at; the given coordinates.; """"""; hs = np.sqrt(area) / 2; xcorners = array([x - hs, x + hs, x + hs, x - hs]); ycorners = array([y - hs, y - hs, y + hs, y + hs]). plt.fill(xcorners, ycorners,; color=cmap(int((w + w_max) * 256 / (2 * w_max)))). def _isqubitdims(dims):; """"""Checks whether all entries in a dims list are integer powers of 2. Parameters; ----------; dims : nested list of ints; Dimensions to be checked. Returns; -------; isqubitdims : bool; True if and only if every member of the flattened dims; list is an integer power of 2.; """"""; return all([; 2**np.floor(np.log2(dim)) == dim; for dim in flatten(dims); ]). def _cb_labels(left_dims):; """"""Creates plot labels for matrix elements in the computational basis. Parameters; ----------; left_dims : flat list of ints; Dimensions of the left index of a density operator. E. g.; [2, 3] for a qubit tensored with a qutrit. Returns; -------; left_labels, right_labels : lists of strings; Labels for the left and right indices of a density operator; (kets and bras, respectively).; """"""; # FIXME: assumes dims, such that we only need left_dims == dims[0].; basis_labels = list(map("","".join, it.product(*[; map(str, range(dim)); for dim in left_dims; ]))); return [; map(fmt.format, basis_labels) for fmt in; (; r""$|{}\rangle$"",; r""$\langle{}|$""; ); ]. # Adopted from the SciPy Cookbook.; [docs]def hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None,; label_top=True):; """"""Draws a Hinton diagram for visu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html:5147,power,power,5147,docs/3.1.0/modules/qutip/visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/visualization.html,1,['power'],['power']
Energy Efficiency,"xplicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, default 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optionalITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:138842,reduce,reduced,138842,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['reduce'],['reduced']
Energy Efficiency,"xpm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been added. These always return Qobj. If the internal operator data type is not Qobj, then there could be signicant overhead in the conversion, and so this should be avoided during pulse optimisation.; If custom sub-classes are developed that use Qobj properties and methods (e.g. partial trace), then it is very likely that it will be more effic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:3652,charge,charge,3652,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,8,['charge'],['charge']
Energy Efficiency,"y 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:1459,efficient,efficiently,1459,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['efficient'],['efficiently']
Energy Efficiency,"y degeneracy; """"""; numerator = Decimal(factorial(N)); d1 = Decimal(factorial(N/2 + m)); d2 = Decimal(factorial(N/2 - m)); degeneracy = numerator/(d1 * d2); return int(degeneracy). [docs]def state_degeneracy(N, j):; """"""Calculate the degeneracy of the Dicke state. Each state :math:`|j, m\\rangle` includes D(N,j) irreducible; representations :math:`|j, m, \\alpha\\rangle`. Uses Decimals to calculate higher numerator and denominators numbers. Parameters; ----------; N: int; The number of two-level systems. j: float; Total spin eigenvalue (cooperativity). Returns; -------; degeneracy: int; The state degeneracy.; """"""; if j < 0:; raise ValueError(""j value should be >= 0""); numerator = Decimal(factorial(N)) * Decimal(2*j + 1); denominator_1 = Decimal(factorial(N/2 + j + 1)); denominator_2 = Decimal(factorial(N/2 - j)); degeneracy = numerator/(denominator_1 * denominator_2); degeneracy = int(np.round(float(degeneracy))); return degeneracy. [docs]def m_degeneracy(N, m):; """"""Calculate the number of Dicke states :math:`|j, m\\rangle` with; same energy. Parameters; ----------; N: int; The number of two-level systems. m: float; Total spin z-axis projection eigenvalue (proportional to the total; energy). Returns; -------; degeneracy: int; The m-degeneracy.; """"""; jvals = j_vals(N); maxj = np.max(jvals); if m < -maxj:; e = ""m value is incorrect for this N.""; e += "" Minimum m value can be {}"".format(-maxj); raise ValueError(e); degeneracy = N/2 + 1 - abs(m); return int(degeneracy). [docs]def ap(j, m):; """"""Calculate the coefficient `ap` by applying J_+ |j, m>. The action of ap is given by:; :math:`J_{+}|j, m\\rangle = A_{+}(j, m)|j, m+1\\rangle`. Parameters; ----------; j, m: float; The value for j and m in the dicke basis |j,m>. Returns; -------; a_plus: float; The value of :math:`a_{+}`.; """"""; a_plus = np.sqrt((j-m) * (j+m+1)); return a_plus. [docs]def am(j, m):; """"""Calculate the operator `am` used later. The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters; ---",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:14088,energy,energy,14088,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,2,['energy'],['energy']
Energy Efficiency,"y measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional; If the commuting gates are randomly scuffled to explore; larger search space.; repeat_num: int, optional; Repeat the scheduling several times and use the best result.; Used together with ``random_shuffle=Ture``. Returns; -------; gate_cycle_indices or instruction_start_time: list; The cycle indices for each gate or; the start time for each instruction. Examples; --------; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:15487,schedul,schedule,15487,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['schedul'],['schedule']
Energy Efficiency,"y state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,. SVD ‘svd’ (dense), or inverse-power method ‘power’. return_info : bool, optional, default = False. Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True. Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcm : bool, optional, default = False. Use reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbm : bool, optional, default = False. Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weight : float, optional. Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. use_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:89580,power,power,89580,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['power'],['power']
Energy Efficiency,"y(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cumming Hamiltonian can be constructed as:; >>> N = 10; >>> omega_a = 1.0; >>> omega_c = 1.25; >>> g = 0.05; >>> a = tensor(identity(2), destroy(N)); >>> sm = tensor(destroy(2), identity(N)); >>> sz = tensor(sigmaz(), identity(N)); >>> H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-tensor.html:6861,energy,energy,6861,docs/3.0.0/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html,2,['energy'],['energy']
Energy Efficiency,"y=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is followed; just by measurement on the first qubit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": cont",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html:7299,efficient,efficient,7299,docs/4.6/guide/qip/qip-simulator.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-simulator.html,4,['efficient'],['efficient']
Energy Efficiency,"ying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states.; Therefore, QuTiP includes predefined objects for a variety of states and operators:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:4897,charge,charge,4897,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,6,"['Charge', 'charge']","['Charge', 'charge']"
Energy Efficiency,"ynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quantum data"", ; Quantum Sci. Technol. 2, 045001 (2017). 241. Zhong, ""Controllable and fast quantum-information transfer between distant nodes in two-dimensional networks"", ; Sci. Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arX",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:16998,efficient,efficient,16998,users.html,https://qutip.org,https://qutip.org/users.html,1,['efficient'],['efficient']
Energy Efficiency,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:2868,efficient,efficiently,2868,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,6,['efficient'],['efficiently']
Energy Efficiency,"y}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : array_like. list of frequencies for \(\omega\). c_ops : list of qutip.qobj. list of collapse operators. a_op : qutip.qobj. operator A. b_op : qutip.qobj. operator B. use_pinv : bool. If True use numpy’s pinv method, otherwise use a generic solver. Returns:spectrum : array. An array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:tlist : array_like. list/array of times \(t\) which the correlation function is given. y : array_like. list/array of correlations corresponding to time delays \(t\). Returns:w, S : tuple. Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver cho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:95044,power,power,95044,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['power'],['power']
Energy Efficiency,"zed method for ode solver, using ""adams"".'); mc.mf = 10; # store ket and density matrix dims and shape for convenience; mc.psi0_dims = psi0.dims; mc.psi0_shape = psi0.shape; mc.dm_dims = (psi0 * psi0.dag()).dims; mc.dm_shape = (psi0 * psi0.dag()).shape; # use sparse density matrices during computation?; mc.sparse_dms = sparse_dms; # run in serial?; mc.serial_run = serial or (ntraj == 1); # are we doing a partial trace for returned states?; mc.ptrace_sel = ptrace_sel; if (ptrace_sel != []):; if debug:; print(""ptrace_sel set to "" + str(ptrace_sel)); print(""We are using dense density matrices during computation "" +; ""when performing partial trace. Setting sparse_dms = False""); print(""This feature is experimental.""); mc.sparse_dms = False; mc.dm_dims = psi0.ptrace(ptrace_sel).dims; mc.dm_shape = psi0.ptrace(ptrace_sel).shape; if (calc_entropy):; if (ptrace_sel == []):; if debug:; print(""calc_entropy = True, but ptrace_sel = []. Please set "" +; ""a list of components to keep when calculating average"" +; "" entropy of reduced density matrix in ptrace_sel. "" +; ""Setting calc_entropy = False.""); calc_entropy = False; mc.calc_entropy = calc_entropy. # construct output Result object; output = Result(). # Run; mc.run(); output.states = mc.sol.states; output.expect = mc.sol.expect; output.col_times = mc.sol.col_times; output.col_which = mc.sol.col_which; if (hasattr(mc.sol, 'entropy')):; output.entropy = mc.sol.entropy. output.solver = 'Fortran 90 Monte Carlo solver'; # simulation parameters; output.times = config.tlist; output.num_expect = config.e_num; output.num_collapse = config.c_num; output.ntraj = config.ntraj. return output. class _MC_class():; def __init__(self):; self.cpus = config.options.num_cpus; self.nprocs = self.cpus; self.sol = Result(); self.mf = 10; # If returning density matrices, return as sparse or dense?; self.sparse_dms = True; # Run in serial?; self.serial_run = False; self.ntraj = config.ntraj; self.ntrajs = []; self.seed = None; self.psi0_dims = None; s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:7828,reduce,reduced,7828,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['reduce'],['reduced']
Energy Efficiency,"{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; In [41]: tracedist(y, x); Out[41]: 0.9771565890327389. In [42]: np.sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.9771565710257347. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.778289048903402. In [44]: tracedist(x, z); Out[44]: 0.8559028328862639. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:11779,energy,energy,11779,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['energy'],['energy']
Energy Efficiency,"“ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instruct",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:182725,schedul,schedule,182725,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,"['Schedul', 'schedul']","['Schedule', 'schedule']"
Energy Efficiency,"﻿. Pulse-level circuit simulation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse is characterized by Pulse, consisting of the control Hamilt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:818,schedul,scheduler,818,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:852,schedul,scheduler,852,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['schedul'],['scheduler']
Energy Efficiency,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:922,efficient,efficiently,922,features.html,https://qutip.org,https://qutip.org/features.html,1,['efficient'],['efficiently']
Energy Efficiency,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index.html:548,efficient,efficient,548,index.html,https://qutip.org,https://qutip.org/index.html,1,['efficient'],['efficient']
Energy Efficiency,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:605,Monitor,Monitoring,605,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['Monitor'],['Monitoring']
Energy Efficiency,"﻿. Release and Distribution — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Setting Up The Release Branch; Updating the Changelog; Create a New Minor or Major Release; Create a Bug Fix Release. Build Release Distribution and Deploy; Build and Deploy; Download Built Files; Monitoring Progress (optional). Getting the Built Documentation; Making a Release on GitHub; Website; Copying New Files; HTML File Updates. Conda Forge. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; In short, the steps you need to take are:. Prepare the release branch (see git).; Run the “Build wheels, optionally deploy to PyPI” GitHub action to build binary and source packages and upload them to PyPI (see deploy).; Retrieve the built documentation from GitHub (see docbuild).; Create a GitHub release and uploaded the built files to it (see github).; Update qutip.org with the new links and documentation (web).; Update the conda feedstock, deploying the package to conda (cforge). Setting Up The Release Branch¶; In this step you will prepare a git branch on the main QuTiP repository that has the state of the code that is going to be released.; This procedure is quite different if you are releasing a new minor or major version compared to if you are making a bugfix patch release.; For a new minor or major version, do update-chang",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:590,Monitor,Monitoring,590,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['Monitor'],['Monitoring']
Integrability," != len(sso.m_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). elif sso.method == ""photocurrent"":; raise NotImplementedError(""Moved to 'photocurrent_mesolve'""). else:; raise Exception(""The method must be one of None, homodyne, heterodyne""). sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [op.compile() for op in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. if sso.solver_code in [103, 153]:; sso.imp = 1 - sso.LH * 0.5; sso.imp.compile(). sso.solver_obj = SMESolver; sso.solver_name = ""smesolve_"" + sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:22197,depend,depending,22197,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,6,['depend'],['depending']
Integrability," """"""; Raise ValueError if the dimensions of the Liouvillian and the density; matrix or superoperator state are incompatible with the master equation.; """"""; if L_dims[0] != L_dims[1]:; raise ValueError(""Liouvillian had nonsquare dims: "" + str(L_dims)); if not ((L_dims[1] == rho_dims) or (L_dims[1] == rho_dims[0])):; raise ValueError("""".join([; ""incompatible Liouvillian and state dimensions: "",; str(L_dims), "" and "", str(rho_dims),; ])). def _qobjevo_set(HS, rho0, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, rho0, e_ops); if issuper(rho0):; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif rho0.isket or rho0.isoper:; func = H_td.compiled_qobjevo.mul_vec; else:; # Should be caught earlier in mesolve.; raise ValueError(""rho0 must be a ket, density matrix or superoperator""); _test_liouvillian_dimensions(H_td.cte.dims, rho0.dims); return func, (). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; class _LiouvillianFromFunc:; def __init__(self, func, c_ops, rho_dims):; self.f = func; self.c_ops = c_ops; self.rho_dims = rho_dims. def H2L(self, t, rho, args):; Ht = self.f(t, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def H2L_with_state(self, t, rho, args):; Ht = self.f(t, rho, args); Lt = -1.0j * (spre(Ht) - spost(Ht)); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L(self, t, rho, args):; Lt = self.f(t, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. def L_with_state(self, t, rho, args):; Lt = self.f(t, rho, args); _test_liouvillian_dimensions(Lt.dims, self.rho_dims); Lt = Lt.data; for op in self.c_ops:; Lt += op(t).data; return Lt. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:13201,depend,dependence,13201,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['depend'],['dependence']
Integrability," """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, [",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:3937,depend,dependent,3937,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability," """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist). # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:5107,depend,dependent,5107,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability," """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """"""; if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops=[], e_ops=e_ops, args=args); ; # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist); # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:4187,depend,dependent,4187,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['depend'],['dependent']
Integrability," """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change the array; def f(a):; return a; ff = function(f, *args, **kw_args); for i, v in enumerate(op.coeff):; op.coeff[i] = ff(v); op.get_coeff = _CubicSplineWrapper(; self.tlist, op.coeff, args=self.args); else:; op.coeff = op.get_coeff; op.type = ""func""; if self.type == ""stri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:35147,depend,dependence,35147,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['depend'],['dependence']
Integrability," ""("" + self.ops[_set[0]].coeff + "")""; for i in _set[1:]:; new_str += "" + ("" + self.ops[i].coeff + "")""; new_op[1] = _StrWrapper(new_str); new_op[2] = new_str; new_ops.append(EvoElement.make(new_op)). elif self.ops[_set[0]].type == ""array"":; new_op = [self.ops[_set[0]].qobj, None, None, ""array""]; new_array = (self.ops[_set[0]].coeff).copy(); for i in _set[1:]:; new_array += self.ops[i].coeff; new_op[2] = new_array; new_op[1] = _CubicSplineWrapper(; self.tlist, new_array, args=self.args); new_ops.append(EvoElement.make(new_op)). self.ops = new_ops. def _compress_merge_func(self, fsets):; new_ops = []; for _set in fsets:; base = self.ops[_set[0]]; new_op = [None, base.get_coeff, base.coeff, base.type]; if len(_set) == 1:; new_op[0] = base.qobj; else:; new_op[0] = base.qobj.copy(); for i in _set[1:]:; new_op[0] += self.ops[i].qobj; new_ops.append(EvoElement.make(new_op)); self.ops = new_ops. [docs] def compress(self):; """"""; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object. Modifies the object inplace.; """"""; self.tidyup(); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops and N_fsets < num_ops:; # Both could be better; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; if N_sets < N_fsets:; self._compress_merge_qobj(sets); else:; self._compress_merge_func(fsets); sets, fsets = self._compress_make_set(); N_sets = len(sets); N_fsets = len(fsets); num_ops = len(self.ops). if N_sets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_qobj(sets); elif N_fsets < num_ops:; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self._compress_merge_func(fsets); self._reset_type(). def _reset_type(self):; op_type_count = [0, 0, 0, 0]; for op in self.ops:; if op.type == ""func"":; op_type_count[0] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:31913,depend,dependence,31913,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['depend'],['dependence']
Integrability," # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:5727,message,message,5727,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,8,['message'],['message']
Integrability," # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:12427,integrat,integrate,12427,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,2,['integrat'],['integrate']
Integrability," #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:10336,depend,dependence,10336,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,22,"['Wrap', 'depend']","['Wrap', 'dependence']"
Integrability," & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html:5172,message,message,5172,docs/4.5/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/pulseoptim.html,2,['message'],['message']
Integrability," ')',; '<string>', 'exec'); exec(code); elif config.tflag == 2:; ODE = ode(_cRHStd); ODE.set_f_params(config); elif config.tflag in [20, 22]:; if config.options.rhs_with_state:; ODE = ode(_tdRHStd_with_state); else:; ODE = ode(_tdRHStd); ODE.set_f_params(config); elif config.tflag == 3:; if config.options.rhs_with_state:; ODE = ode(_pyRHSc_with_state); else:; ODE = ode(_pyRHSc); ODE.set_f_params(config); else:; ODE = ode(cy_ode_rhs); ODE.set_f_params(config.h_data, config.h_ind, config.h_ptr). ODE.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); ODE.set_initial_value(config.psi0, config.tlist[0]); for jj in range(config.e_num):; expect_out[jj][0] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], config.psi0,; config.e_ops_isherm[jj]). for k in range(1, num_times):; ODE.integrate(config.tlist[k], step=0) # integrate up to tlist[k]; if ODE.successful():; state = ODE.y / dznrm2(ODE.y); for jj in range(config.e_num):; expect_out[jj][k] = cy_expect_psi_csr(; config.e_ops_data[jj], config.e_ops_ind[jj],; config.e_ops_ptr[jj], state,; config.e_ops_isherm[jj]); else:; raise ValueError('Error in ODE solver'). return expect_out. # -----------------------------------------------------------------------------; # single-trajectory for monte carlo; # -----------------------------------------------------------------------------; def _mc_alg_evolve(nt, config, opt, seeds):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. tlist = config.tlist; num_times = len(tlist). if not _cy_rhs_func:; _mc_func_load(config). if config.options.steady_state_average:; states_out = np.zeros((1), dtype=object); else:; states_out = np.ze",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:20924,integrat,integrate,20924,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['integrat'],['integrate']
Integrability," 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any ord",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:5346,depend,dependent,5346,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:7448,depend,dependabot,7448,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['depend'],['dependabot']
Integrability," (H=0). >>> Pulse(None, None). """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=None):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, targets, tlist, coeff); self.coherent_noise = []; self.lindblad_noise = []; self.label = label. @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:7714,depend,dependent,7714,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['depend'],['dependent']
Integrability," (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; Classes that enable the storing of historical objects created during the; pulse optimisation.; These are intented for debugging.; See the optimizer and dynamics objects for instrutcions on how to enable; data dumping.; """""". import os; import numpy as np; import copy; # QuTiP logging; import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); # QuTiP control modules; import qutip.control.io as qtrlio; from numpy.compat import asbytes. DUMP_DIR = ""~/.qtrl_dump"". def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Dump(object):; """"""; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes; ----------; parent : some control object (Dynamics or Optimizer); aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dir : str; directory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. level : string; level of data dumping: SUMMARY, FULL or CUSTOM; See property docstring for details; Set automatically if dump is created by the setting host dumping attrib. write_to_file : bool; When set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_ext : str; Default file extension for any file names that are auto generated. fname_base : str; First part of any auto generated file names.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:2845,depend,depends,2845,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,8,['depend'],['depends']
Integrability," (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a precalculated numpy array that specifies the values of the; Qobj-coefficients for each time step.; New functions for working with different superoperator representations,; including Kraus and Chi representation.; New functions for visualizing quantum states using Qubism and Schimdt plots:; plot_qubism and plot_schmidt.; Dynamics solver now support taking argument e_ops (expectation value; operators) in dictionary form.; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:2876,depend,dependent,2876,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,1,['depend'],['dependent']
Integrability," (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 ()¶. Improvements¶. Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:1979,depend,dependent,1979,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,2,"['depend', 'rout']","['dependent', 'routines']"
Integrability," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:84686,integrat,integrator,84686,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['integrat'],['integrator']
Integrability," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:80062,integrat,integrator,80062,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrator']
Integrability," (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:5745,depend,dependence,5745,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability," (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:12483,integrat,integrator,12483,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability," * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.array(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None,; options=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. options : :class:`qutip.solver.Options`; options for the ODE solver. For the propagator. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args, options=copy(options)). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None,; options=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:4198,depend,dependence,4198,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html:11940,depend,depend,11940,docs/4.0.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/metrics.html,1,['depend'],['depend']
Integrability," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:11940,depend,depend,11940,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,1,['depend'],['depend']
Integrability," * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positive, since then the largest; # eigenvalue is the same as the largest singular value. if not force_solve and J.iscp:; S_dual = to_super(J.dual_chan()); vec_eye = operator_to_vector(qeye(S_dual.dims[1][1])); op = vector_to_operator(S_dual * vec_eye); # The 2-norm was not implemented for sparse matrices as of the time; # of this writing. Thus, we must yet again go dense.; return la.norm(op.data.todense(), 2). # If we're still here, we need to actually solve the problem. # Assume square...; dim = np.prod(J.dims[0][0]); ; # The constraints only depend on the dimension, so; # we can cache them efficiently.; problem, Jr, Ji, X, rho0, rho1 = dnorm_problem(dim); ; # Load the parameters with the Choi matrix passed in.; J_dat = J.data; Jr.value, Ji.value = J_dat.real, J_dat.imag; ; # Finally, set up and run the problem.; problem.solve(solver=solver, verbose=verbose). return problem.value. def unitarity(oper):; """"""; Returns the unitarity of a quantum map, defined as the Frobenius norm; of the unital block of that map's superoperator representation. Parameters; ----------; oper : Qobj; Quantum map under consideration. Returns; -------; u : float; Unitarity of ``oper``.; """"""; Eu = _super_to_superpauli(oper).full()[1:, 1:]; #return np.real(np.trace(np.dot(Eu, Eu.conj().T))) / len(Eu); return np.linalg.norm(Eu, 'fro')**2 / len(Eu). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/metrics.html:11940,depend,depend,11940,docs/4.1/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/metrics.html,1,['depend'],['depend']
Integrability," **Passing arguments**. ``args`` is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string. There are some ""magic"" names that can be specified, whose objects will be; overwritten when used within :func:`.sesolve`, :func:`.mesolve` and; :func:`.mcsolve`. This allows access to the solvers' internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. - ``""state""``: the current state as a :class:`~Qobj`; - ``""state_vec""``: the current state as a column-stacked 1D ``np.ndarray``; - ``""state_mat""``: the current state as a 2D ``np.ndarray``; - ``""expect_op_<n>""``: the current expectation value of the element; ``e_ops[n]``, which is an argument to the solvers. Replace ``<n>`` with; an integer literal, e.g. ``""expect_op_0""``. This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; - ``""collapse""``: (:func:`.mcsolve` only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; ``(time: float, which: int)``, where ``time`` is the time this collapse; happened, and ``which`` is an integer indexing the ``c_ops`` argument to; :func:`.mcsolve`. Parameters; ----------; Q_object : list, :class:`~Qobj` or :class:`~QobjEvo`; The time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of ``[Qobj, time_dependence]`` pairs that are; summed to make the whole object. The ``time_dependence`` can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the ``Qobj`` instead; of the 2-element list. args : dict, optional; Mapping of ``{str: object}``, discussed in greater detail above. The; strings can be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:10025,depend,depending,10025,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['depend'],['depending']
Integrability," + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indices for k in config.h_td_inds]); config.h_td_ptr = np.array(; [Htd[k].data.indptr for k in config.h_td_inds]). elif config.tflag == 3:; # PYTHON FUNCTION BASED HAMILTONIAN; # ---------------------------------. # take care of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:38068,depend,dependent,38068,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['depend'],['dependent']
Integrability," += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:11944,depend,dependence,11944,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['depend'],['dependence']
Integrability," += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10977,depend,dependence,10977,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['depend'],['dependence']
Integrability," += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:11479,depend,dependence,11479,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['depend'],['dependence']
Integrability," += 1; elif op.type == ""array"":; op_type_count[2] += 1; elif op.type == ""spline"":; op_type_count[3] += 1. nops = sum(op_type_count); if not self.ops and self.dummy_cte is False:; self.type = ""cte""; elif op_type_count[0] == nops:; self.type = ""func""; elif op_type_count[1] == nops:; self.type = ""string""; elif op_type_count[2] == nops:; self.type = ""array""; elif op_type_count[3] == nops:; self.type = ""spline""; elif op_type_count[0]:; self.type = ""mixed_callable""; else:; self.type = ""mixed_compilable"". self.num_obj = (len(self.ops) if self.dummy_cte else len(self.ops) + 1). [docs] def permute(self, order):; """"""; Permute the tensor structure of the underlying matrices into a new; format. See Also; --------; Qobj.permute : the same operation on constant quantum objects.; """"""; res = self.copy(); res.cte = res.cte.permute(order); for op in res.ops:; op.qobj = op.qobj.permute(order); return res. [docs] def apply(self, function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:34019,depend,dependent,34019,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['depend'],['dependent']
Integrability," ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator"").",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3526,depend,dependent,3526,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,4,['depend'],['dependent']
Integrability," . API documentation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/apidoc.html:1307,depend,dependent,1307,docs/4.4/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability," 063401 (2015). 77. Schulte et al., ""Quantum Algorithmic Readout in Multi-Ion Clocks"", ; Phys. Rev. Lett. 116, 013002 (2016). 76. Dalmonte et al., ""Realizing dipolar spin models with arrays of superconducting qubits"", ; Phys. Rev. B 92, 174507 (2015). 75. Neilinger et al., ""Two-photon lasing by a superconducting qubit"", ; Phys. Rev. B 91, 104516 (2015). 74. Elliott et al., ""Enhancement and state tomography of a squeezed vacuum with circuit quantum electrodynamics"", ; Phys. Rev. A 92, 013826 (2015). 73. Borregaard et al., ""Heralded Quantum Gates with Integrated Error Detection in Optical Cavities"", ; Phys. Rev. Lett. 114, 110502 (2015). 72. Killoran et al., ""Enhancing light-harvesting power with coherent vibrational interactions: a quantum heat engine picture"", ; J. Chem. Phys. 143, 155102 (2015). 71. Lu et al., ""Squeezed Optomechanics with Phase-Matched Amplification and Dissipation"", ; Phys. Rev. Lett. 114, 093602 (2015). 70. Hush et al., ""Spin correlations as a probe of quantum synchronization in trapped-ion phonon lasers"", ; Phys. Rev. A 91, 061401(R) (2015). 69. Hauke et al., ""Probing entanglement in adiabatic quantum optimization with trapped ions"", ; Front. Phys. 3, 21 (2015). 68. Nation et al., ""Iterative solutions to the steady-state density matrix for optomechanical systems"", ; Phys. Rev. E 91, 013307 (2015). 67. Schlawin et al., ""Nonlinear spectroscopy of trapped ions"", ; Phys. Rev. A 90, 023603 (2014). 66. Dunning et al., ""Composite pulses for interferometry in a thermal cold atom cloud"", ; Phys. Rev. A 90, 033608 (2014). 65. Rosado et al., ""Upper-bounded and sliced Jaynes- and anti-Jaynes-Cummings Hamiltonians and Liouvillians in cavity quantum electrodynamics"", ; J. Modern Optics 62, 1561 (2015). 64. Braumüller et al., ""Multiphoton dressing of an anharmonic superconducting many-level quantum circuit"", ; Phys. Rev. B 91, 054523 (2015). 63. Hu et al., ""Quantum coherence in ultrastrong optomechanics"", ; Phys. Rev. A 91, 013812 (2015). 62. Weimer, ""Variation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:40160,synchroniz,synchronization,40160,users.html,https://qutip.org,https://qutip.org/users.html,1,['synchroniz'],['synchronization']
Integrability," 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quan",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:16052,rout,routers,16052,users.html,https://qutip.org,https://qutip.org/users.html,1,['rout'],['routers']
Integrability," 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve code",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/changelog.html:1431,depend,dependent,1431,docs/4.1/changelog.html,https://qutip.org,https://qutip.org/docs/4.1/changelog.html,1,['depend'],['dependent']
Integrability," 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]); vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],...]; = Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:; function: coeff(t, args) -> complex; str: ""sin(1j*w*t)""; np.array[complex, 1d] of length equal to the times array; The argument args for the function coeff is the args keyword argument of; the stochastic solver.; Likewisem in str cases, the parameters ('w' in this case) are taken from; the args keywords argument.; *While mixing coeff type does not results in errors, it is not recommended.*. For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ...]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_no",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:11367,depend,dependent,11367,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,2,['depend'],['dependent']
Integrability," 5.) ** 2)'. The Hamiltonian in this format would take the form:; >>> H = [H0, [H1, '9 * exp(-(t / 5.) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; >>> output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)':; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e or pi will mess things up when using the string-based format. Collapse operators are handled in the exact same way. Function Based Hamiltonian¶; In the previous version of QuTiP, the simulation of time-dependent problems required writing the Hamiltonian itself as a Python function. However, this method does not allow for time-dependent collapse operators, and is therefore more restrictive. Furthermore, it is less efficient than the other methods for all but the most basic of Hamiltonians (see the next section for a comparison of times.). In this format, the entire Hamiltonian is written as a Python function:; def Hfunc(t, args):; H0 = args[0]; H1 = args[1]; w = 9 * exp(-(t/5.)**2); return H0 - w * H1. where the args variable must always be given, and is now a list of Hamiltonian terms: args=[H0, H1]. In this format, our call to the master equation is now:; >>> output = mesolve(Hfunc, psi0, times, c_ops, [a.dag() * a], args=[H0, H1]). We cannot evaluate time-dependent collapse operators in this format, so we can not simulate the previous harmonic oscillator decay example. A Quick Comparison of Simulation Times¶; Here we give a table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Pyt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:13500,depend,dependent,13500,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). (png, hires.png, pdf). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). (png, hires.png, pdf). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html:18489,depend,dependent,18489,docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability," : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~QobjEvo`, :class:`~Qobj`, scalars.; - ``*``: :class:`~Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~Qobj` instances,; each of which *may* have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is :math:`Q(t)`, then it is constructed from a set of constant; :obj:`~Qobj` :math:`\\{Q_k\\}` and time-dependent scalars :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~Qobj`, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:6768,depend,dependence,6768,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,2,['depend'],['dependence']
Integrability," : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns:; eseries : qutip.eseries; eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian giv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:64643,depend,dependent,64643,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['depend'],['dependent']
Integrability," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:3730,integrat,integrator,3730,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,10,['integrat'],['integrator']
Integrability," :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType):; output.num_expect = 0; expt_callback = True. elif isinstance(e_ops, list):. output.num_expect = len(e_ops); expt_callback = False. if output.num_expect == 0:; output.states = []; else:; output.expect = []; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(len(tlist))); else:; output.expect.append(np.zeros(len(tlist), dtype=complex)). else:; raise TypeError(""e_ops must be a list Qobj or a callback function""). psi0_fb = psi0.transform(f_modes_0); for t_idx, t in enumerate(tlist):; f_modes_t = floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = floquet_states(f_modes_t, f_energies, t); psi_t = psi0_fb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:13437,depend,dependent,13437,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,9,['depend'],['dependent']
Integrability," :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary; def _transform_shift_one_coeff(op, args):; if isinstance(op, types.FunctionType):; # function-list based time-dependence; if isinstance(args, dict):; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i); fn = lambda t, args_i: \; op(t + args_i[""_t0""], args_i); else:; def fn(t, args_i):; return op(t + args_i[""_t0""], args_i[""_user_args""]); else:; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", "" "" + op + "" ""); return fn. def _transform_shift_one_op(op, args={}):; if isinstance(op, Qobj):; new_op = op; elif isinstance(op, QobjEvo):; new_op = op; new_op._shift; elif callable(op):; def new_op(t, args_i):; return op(t + args_i[""_t0""], args_i); elif isinstance(op, list):; new_op = []; for block in op:; if isinstance(block, list):; new_op.append([block[0],; _transform_shift_one_coeff(block[1], args)]); else:; new_op.append(block); return new_op. def _transform_L_t_shift_new(H, c_ops, args={}):; H_shifted = _transform_shift_one_op(H, args); c_ops_shifted = [_transform_shift_one_op(op, args) for op in c_ops]; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:38521,depend,dependence,38521,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['depend'],['dependence']
Integrability," = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, config.h_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:37832,depend,dependent,37832,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['depend'],['dependent']
Integrability," = -delta / 2.0 * sx; H1 = [sz, '-eps / 2.0 + A / 2.0 * sin(w * t)']; H_td = [H0, H1]; Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; opts = Options(rhs_reuse=True); rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; def task(args):; m, eps = args; p_mat_m = np.zeros(len(A_list)); for n, A in enumerate(A_list):; # change args sent to solver, w is really a constant though.; Hargs = {'w': w, 'eps': eps,'A': A}; U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; rho_ss = propagator_steadystate(U); p_mat_m[n] = expect(sn, rho_ss); return [m, p_mat_m]. Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:22767,rout,routine,22767,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['rout'],['routine']
Integrability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:14254,depend,dependent,14254,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.95s. Est. time left: 00:00:00:08; 20.0%. Run time: 1.81s. Est. time left: 00:00:00:07; 30.0%. Run time: 2.67s. Est. time left: 00:00:00:06; 40.0%. Run time: 3.59s. Est. time left: 00:00:00:05; 50.0%. Run time: 4.42s. Est. time left: 00:00:00:04; 60.0%. Run time: 5.27s. Est. time left: 00:00:00:03; 70.0%. Run time: 6.10s. Est. time left: 00:00:00:02; 80.0%. Run time: 6.91s. Est. time left: 00:00:00:01; 90.0%. Run time: 7.74s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:13794,depend,dependent,13794,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops];",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:31610,depend,dependent,31610,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['depend'],['dependent']
Integrability," = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = list(e_ops.values()); else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:31967,depend,dependent,31967,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['depend'],['dependent']
Integrability," = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # ---------------------------------------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:22563,integrat,integrate,22563,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:18267,depend,dependent,18267,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value ""; ""with the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/solver.html:24935,message,messages,24935,docs/4.5/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/solver.html,5,['message'],['messages']
Integrability," = int(value); except:; raise TypeError(""value is expected to be an integer""). if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value. def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value. def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:24894,message,messages,24894,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['message'],['messages']
Integrability," = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))).data; else:; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))).data; else:; new_args = args.data; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args); return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args); return L * rho. # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among the various ODE solver; # -----------------------------------------------------------------------------. def _generic_ode_solve(r, rho0, tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:23666,integrat,integrate,23666,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we can evaluate it at time t by using the qutip.eseries.esval function:; In [8]: esval(es2, 0.0) # equivalent to es2.value(0.0); Out[8]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. or for a list of times [0.0, 1.0 * pi, 2.0 * pi]:; In [9]: times = [0.0, 1.0 * pi, 2.0 * pi]. In [10]: esval(es2, times) # equivalent to es2.value(times); Out[10]: ; array([ Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. -1.]; [-1. 0.]],; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 1.]; [ 1. 0.]]], dtype=object). To calculate the expectation value of an time-dependent operator represented by an qutip.eseries, we use the qutip.expect function. For example, consider the operator \(\sigma_x \cos(\omega t) + \sigma_z\sin(\omega t)\), and say we would like to know the expectation value of this operator for a spin in its excited state (rho = fock_dm(2,1) produce this state):; In [11]: es3 = (eseries([0.5*sigmaz(), 0.5*sigmaz()], [1j, -1j]) +; ....: eseries([-0.5j*sigmax(), 0.5j*sigmax()], [1j, -1j])); ....: . In [12]: rho = fock_dm(2, 1). In [13]: es3_expect = expect(rho, es3). In [14]: es3_expect; Out[14]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[1, 1]]; Exponent #0 = -1j; (-0.5+0j); Exponent #1 = 1j; (-0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:4686,depend,dependent,4686,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability," =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; c = create(5). print(c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; print(c * c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; print(c ** 2 * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; print(c * a * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; print(c * a * (c * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; print(c * a * (c**2 * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; print(c * a * (c**2 * vac).unit()). Output:; Quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:3772,depend,dependence,3772,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['depend'],['dependence']
Integrability," >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr,; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # TODO cythonize this?; def _ode_oper_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; oper_evo = False; elif psi0.isunitary:; oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct dynamics generator; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h; Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:12660,depend,dependent,12660,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability," @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). def add_control_noise(self, qobj, targets, tlist=None, coeff=None):; self.add_coherent_noise(qobj, targets, tlist=tlist, coeff=coeff). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:8082,depend,dependent,8082,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,4,['depend'],['dependent']
Integrability," @property; def qobj(self):; """"""; See parameter `qobj`.; """"""; return self.ideal_pulse.qobj. @qobj.setter; def qobj(self, x):; self.ideal_pulse.qobj = x. @property; def targets(self):; """"""; See parameter `targets`.; """"""; return self.ideal_pulse.targets. @targets.setter; def targets(self, x):; self.ideal_pulse.targets = x. @property; def tlist(self):; """"""; See parameter `tlist`; """"""; return self.ideal_pulse.tlist. @tlist.setter; def tlist(self, x):; self.ideal_pulse.tlist = x. @property; def coeff(self):; """"""; See parameter `coeff`.; """"""; return self.ideal_pulse.coeff. @coeff.setter; def coeff(self, x):; self.ideal_pulse.coeff = x. [docs] def add_coherent_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:7992,depend,dependent,7992,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['depend'],['dependent']
Integrability," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); nrows = A.shape[0]; if not sym:; A = A + A.transpose(); return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/graph.html:5682,rout,routine,5682,docs/4.6/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html,8,['rout'],"['routine', 'routines']"
Integrability," A = sp.csc_matrix(A); count = np.diff(A.indptr); perm = np.argsort(count); return perm. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; ; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'). nrows = A.shape[0]. if not sym:; A = A + A.transpose(). return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if; necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/graph.html:5455,rout,routine,5455,docs/4.2/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/graph.html,12,['rout'],"['routine', 'routines']"
Integrability," A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the list-string; # and list-function formats that are used by the time-dependent solvers.; # Although not used directly in by those solvers, it can for test purposes be; # conventient to be able to evaluate the expressions passed to the solver for; # arbitrary value of time. This function provides this functionality.; #; def qobj_list_evaluate(qobj_list, t, args):; """"""; Depracated: See Qobj.evaluate; """"""; warnings.warn(""Deprecated: Use Qobj.evaluate"", DeprecationWarning); return Qobj.evaluate(qobj_list, t, args). # -----------------------------------------------------------------------------; #; # A collection of tests used to determine the type of quantum objects, and some; # functions for increased compatibility with quantum optics toolbox.; #. def dag(A):; """"""Adjont operator (dagger) of a quantum object. Parameters; ----------; A : qobj; Input quantum object. Returns; -------; oper : qobj; Adjoint of input operator. Notes; -----; This function is for legac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:47601,depend,dependent,47601,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,8,['depend'],['dependent']
Integrability," ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/heom.html:2453,integrat,integrate,2453,docs/4.4/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/heom.html,4,['integrat'],['integrate']
Integrability," Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:3141,depend,dependent,3141,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,3,['depend'],['dependent']
Integrability," Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when input",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:25617,depend,dependent,25617,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['depend'],['dependent']
Integrability," Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Note; Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectiv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:7917,depend,dependent,7917,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['depend'],['dependent']
Integrability," Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:1034,depend,dependent,1034,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['depend'],['dependent']
Integrability," Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The time-evolutions solvers qutip.mesolve, qutip.mcsolve, qutip.sesolve, and qutip.brmesolve are all capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamilt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:1424,depend,dependent,1424,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~qutip.Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~qutip.QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~qutip.mesolve` takes.; If this is a list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:6775,depend,dependent,6775,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,4,['depend'],['dependent']
Integrability," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target nod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html:1106,depend,dependency,1106,docs/4.7/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html,2,['depend'],['dependency']
Integrability," Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Stochastic Schrödinger Equation and Master Equation¶. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:77792,depend,depend,77792,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['depend']
Integrability," H, T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; r""""""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\alpha c_\alpha \psi_\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:12599,depend,dependent,12599,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability," H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state: must be a density ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9459,integrat,integrate,9459,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavef",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:3259,depend,dependent,3259,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,3,['depend'],['dependent']
Integrability," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2937,depend,dependent,2937,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) on the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:2712,depend,dependent,2712,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,8,['depend'],['dependent']
Integrability," Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 Axes>. In [52]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:14166,depend,dependent,14166,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 Axes>. In [52]: plt.plot(t, func(t)); Out[52]: [<matplotlib.lines.Line2D at 0x1a26e45ef0>]. In [53]: plt.plot(t, noisy_data, 'o'); Out[53]: [<matplotlib.lines.Line2D at 0x1a26e56828>]. In [54]: plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:14191,depend,dependent,14191,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """""". [docs]class StochasticSolverOptions:; """"""Class of options for stochastic solvers such as; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc. The stochastic solvers :func:`qutip.stochastic.general_stochastic`,; :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`,; :func:`qutip.stochastic.photocurrent_sesolve` and; :func:`qutip.stochastic.photocurrent_mesolve`; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Within the attribute list, a ``time_dependent_object`` is either. - :class:`~Qobj`: a constant term; - 2-element list of ``[Qobj, time_dependence]``: a time-dependent term; where the ``Qobj`` will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for :class:`~QobjEvo`. Attributes; ----------; H : time_dependent_object or list of time_dependent_object; System Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) :func:`~mesolve` takes. If this is a; list of elements, they are summed. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : array_like of float; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:8628,depend,dependent,8628,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['depend'],['dependent']
Integrability," IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import pickle; import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. try:; import cython; use_cython = [True]; except:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:2325,wrap,wraps,2325,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['wrap'],['wraps']
Integrability," If analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.solver.ResultIf analytical is False, an instance of the class; qutip.solver.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:140280,depend,dependent,140280,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['depend'],['dependent']
Integrability," If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:39654,depend,depend,39654,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,2,['depend'],['depend']
Integrability," If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coheren",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:12720,depend,dependent,12720,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:244780,rout,routine,244780,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,8,['rout'],"['routine', 'routines']"
Integrability," L = L_List[0][0] * L_List[0][1](t, y, args); for n in range(1, len(L_List)):; L = L + L_List[n][0] * L_List[n][1](t, y, args). return _ode_oper_func(t, y, L). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). #; # setup integrator.; #. if psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; elif psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). L = -1.0j * H; if oper_evo:; r = scipy.integrate.ode(_ode_oper_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr,; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # TODO cythonize this?; def _ode_oper_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:11764,integrat,integrate,11764,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability," L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. H_S¶; qutip.Qobj – System Hamiltonian (can also be a Liouvillian). L1¶; qutip.Qobj / list of qutip.Qobj – System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2¶; qutip.Qobj / list of qutip.Qobj – System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix¶; array – S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov¶; qutip.Qobj / list of qutip.Qobj – Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator¶; str {‘propagator’, ‘mesolve’} – Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallel¶; bool – Run integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. options¶; qutip.solver.Options – Generic solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters:; rho0 (qutip.Qobj) – initial density matrix or state vector (ket).; blist (array_like) – List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger; tlist (array_like) – list of corresponding times t1,..,tn at which to evaluate the field; operators; tau (float) – time-delay; c1 (qutip.Qobj) – system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has mor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:31455,integrat,integrator,31455,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['integrat'],['integrator']
Integrability," LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instruction`.; The graph is represented by attributes `predecessors` and; `successors`, each a set of indices; pointing to the position of the target nod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:2841,depend,dependency,2841,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,2,['depend'],['dependency']
Integrability," LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td, spmvpy_csr; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:2303,integrat,integrate,2303,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['integrat'],['integrate']
Integrability," LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings; import qutip.settings as qset; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/mesolve.html:2303,integrat,integrate,2303,docs/4.1/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats:; start_louvillian = timeit.default_timer(). H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/heom.html:13387,integrat,integrate,13387,docs/4.4/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/heom.html,6,['integrat'],['integrate']
Integrability," LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:3084,depend,dependency,3084,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['depend'],['dependency']
Integrability," Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.propcomp. Source code for qutip.control.propcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html:1171,message,message,1171,docs/4.7/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html,4,['message'],['message']
Integrability," Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config, use_openmp=opt.use_openmp,; omp_components=omp_components,; omp_threads=opt.openmp_threads); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). ; # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname); ; #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:12687,integrat,integrate,12687,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,2,['integrat'],['integrate']
Integrability," List of times for \(t\). Must be uniformly spaced.; c_ops (list of qutip.Qobj) – Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. Todo; Add checks for commuting jump operators in Milstein method. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:; H (qutip.Qobj) – System Hamiltonian.; psi0 (qutip.Qobj) – Initial state vector (ket).; times (list / array) – List of times for \(t\). Must be uniformly spaced.; sc_ops (list of qutip.Qobj) – List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined.; e_ops (list of qutip.Qobj) – Single operator or list of operators for which to evaluate; expectation values.; kwargs (dictionary) – Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output – An instance of the class qutip.solver.SolverResult. Return type:qutip.solver.SolverResult. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters:; H (qutip.Qobj) – System Hamiltonian.; rho0 (qutip.Qobj) – Initi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:77469,depend,depending,77469,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['depending']
Integrability," M_i\); projection operators if ops correspond to; projectors (s.t. \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply; the measurement using qutip.qip.operations.gates.expand_operator; to expand ops into full dimension. Returns. collapsed_stateslist of QobjThe collapsed states obtained after measuring the qubits and obtaining; the qubit specified by the target in the state specified by the index. probabilitieslist of floatsThe probability of measuring a state in a the state specified by the; index. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of; Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians. List format; and options can be found in QobjEvo’s description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opsNone / list / callback function, optionalA list of operators as Qobj and/or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:79109,integrat,integrating,79109,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['integrat'],['integrating']
Integrability," Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:12868,integrat,integration,12868,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,2,['integrat'],['integration']
Integrability," N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if (not isinstance(dims, list)) or (not isinstance(dims[0], list)):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/random_objects.html:18886,depend,depends,18886,docs/4.2/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/random_objects.html,1,['depend'],['depends']
Integrability," N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if (not isinstance(dims, list)) or (not isinstance(dims[0], list)):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/random_objects.html:18886,depend,depends,18886,docs/4.1/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/random_objects.html,1,['depend'],['depends']
Integrability," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:2303,integrat,integrate,2303,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:3560,integrat,integrate,3560,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`Qobj.eigenstates` to get the eigenstates and -values, and use; :obj:`~QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/essolve.html:5434,depend,dependence,5434,docs/4.6/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html,2,['depend'],['dependence']
Integrability," Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:2742,message,message,2742,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['message'],['message']
Integrability," OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/essolve.html:2745,message,message,2745,docs/4.6/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html,2,['message'],['message']
Integrability," Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:2358,depend,dependent,2358,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : array. An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj. Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. c_op : Qobj. operator C. d_op : Qobj. operator D. solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:92491,depend,dependent,92491,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability," PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:2206,integrat,integrate,2206,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability," Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html:2000,depend,dependent,2000,docs/3.0.0/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability," PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:29041,depend,dependent,29041,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,5,['depend'],['dependent']
Integrability," Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:1869,depend,dependent,1869,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2576,depend,dependent,2576,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2429,depend,dependent,2429,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,1,['depend'],['dependent']
Integrability," Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector.¶. For the destruction operator above:; In [18]: q.type; Out[18]: 'oper'. In [19]: q.isherm; Out[19]: False. In [20]: q.data; Out[20]: ; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [21]: q = destroy(4). In [22]: x = sigmax(). In [23]: q + 5; Out[23]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. In [24]: x * x; Out[24]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. In [25]: q ** 3; Out[25]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. In [26]: x / np.sqrt(2); Out[26]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:8581,message,message,8581,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['message'],['message']
Integrability," Returns. objqobjA composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:42240,contract,contracted,42240,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['contract'],['contracted']
Integrability," Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:1910,depend,dependent,1910,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,5,['depend'],['dependent']
Integrability," Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.brmesolve; qutip.ssesolve, qutip.photocurrent_sesolve, qutip.smesolve, and qutip.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:1878,depend,dependence,1878,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,4,['depend'],"['depend', 'dependence']"
Integrability," Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Optimal control; Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/apidoc.html:2538,depend,dependent,2538,docs/3.1.0/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability," Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/changelog.html:2691,depend,dependence,2691,docs/4.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.2/changelog.html,4,['depend'],['dependence']
Integrability," Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{2} -\frac{e_n}{2} C_n; + \frac{e_n^2}{8} \right) \psi \delta t; + \sum_n \left( C_n - \frac{e_n}{2} \right) \psi \delta \omega\]; with. \[ \begin{align}\begin{aligned}:label: jump_rate\\e_n = \left<\psi(t)|C_n + C_n^{+}|\psi(t)\right>\end{aligned}\end{align} \]; Here \(\delta \omega\) is a Wiener increment.; In QuTiP, this is available with the function ssesolve.; In [1]: times = np.linspace(0.0, 10.0, 201). In [2]: p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:1440,depend,depends,1440,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['depend'],['depends']
Integrability," T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/floquet.html:12583,depend,dependent,12583,docs/4.5/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/floquet.html,1,['depend'],['dependent']
Integrability," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['rhs_generate', 'rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of gen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:2480,depend,dependent,2480,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['depend'],['dependent']
Integrability," THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:2960,depend,depending,2960,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['depend'],['depending']
Integrability," Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:1299,depend,dependent,1299,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," The new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:key : string. key for the section.timings dictionary; reusing a key will result in numerical addition of value. value : int. Initial value of the timing, or added to an existing timing. section: string or `class` : _StatsSection. Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output : stream. file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:value : float. Time in seconds to complete the solver section. section : string or class. Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=[], m_ops=None, args=None, ntraj=1, nsubsteps=1, d1=None, d2=None, d2_len=1, dW_factors=None, rhs=None, generate_A_ops=None, generate_noise=None, homogeneous=True, solver=None, method=None, distribution='normal', store_measurement=False, noise=None, norma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:39379,message,messages,39379,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['message'],['messages']
Integrability," The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. args : dict; Dictionary of arguments to be passed to solver. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:100486,depend,dependent,100486,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5578,integrat,integration,5578,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['integrat'],['integration']
Integrability," To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem:; from qutip import *; from scipy import *; # Define atomic states. Use ordering from paper; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). # Set where to truncate Fock state for cavity; N = 2. # Create the atomic operators needed for the Hamiltonian; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. # Create the photon operator; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). # Define collapse operators; c_ops = []; # Cavity decay rate; kappa = 1.5; c_ops.append(sqrt(kappa) * a). # Atomic decay rate; gamma = 6 # decay rate; # Use Rb branching ratio of 5/9 e->u, 4/9 e->g; c_ops.append(sqrt(5*gamma/9) * sigma_ue); c_ops.append(sqrt(4*gamma/9) * sigma_ge). # Define time vector; t = linspace(-15, 15, 100). # Define initial state; p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:6353,depend,dependent,6353,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,4,['depend'],['dependent']
Integrability," To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [1]: ustate = basis(3, 0). In [2]: excited = basis(3, 1). In [3]: ground = basis(3, 2). In [4]: N = 2 # Set where to truncate Fock state for cavity. In [5]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:6291,depend,dependent,6291,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,8,['depend'],['dependent']
Integrability," To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The follow code sets up the problem; In [3]: ustate = basis(3, 0). In [4]: excited = basis(3, 1). In [5]: ground = basis(3, 2). In [6]: N = 2 # Set where to truncate Fock state for cavity. In [7]: sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|. In [8]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [9]: a = tensor(destroy(N), qeye(3)). In [10]: ada = tensor(num(N), qeye(3)). In [11]: c_ops = [] # Build collapse operators. In [12]: kappa = 1.5 # Cavity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:6912,depend,dependent,6912,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,6,['depend'],['dependent']
Integrability," Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:1010,message,message,1010,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,2,['message'],['message']
Integrability," U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:74292,depend,dependent,74292,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability," U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2b11f5a5c950>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:74352,depend,dependent,74352,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability," WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Original Code by Arne Grimsmo (2012): github.com/arnelg/qutipf90mc; ###############################################################################. import numpy as np. from qutip.fortran import qutraj_run as qtf90; from qutip.qobj import Qobj; from qutip.mcsolve import _mc_data_config; from qutip.solver import Options, Result, config; from qutip.settings import debug; import qutip.settings. if debug:; import inspect; import os. # Working precision; wpr = np.dtype(np.float64); wpc = np.dtype(np.complex128). [docs]def mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None,; options=Options(), sparse_dms=True, serial=False,; ptrace_sel=[], calc_entropy=False):; """"""; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters; ----------; H : qobj; System Hamiltonian.; psi0 : qobj; Initial state vector; tlist : array_like; Times at which results are recorded.; ntraj : int; Number of trajectories to run.; c_ops : array_like; ``list`` or ``array`` of collapse operators.; e_ops : array_like; ``list`` or ``array`` of operators for calculating expectation values.; options : Options; Instance of solver options.; sparse_dms : boolean; If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems.; serial : boolean; If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial.; ptrace_sel: list; This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html:4060,depend,dependence,4060,docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fortran/mcsolve_f90.html,1,['depend'],['dependence']
Integrability," [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 * vac).unit(); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:3753,depend,dependence,3753,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,3,['depend'],['dependence']
Integrability," [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); Out[30]: [<matplotlib.lines.Line2D at 0x1a251955c0>]. In [31]: plt.plot(tlist, actual_answer); Out[31]: [<matplotlib.lines.Line2D at 0x1a254cc860>]. In [32]: plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. In [43]: e_ops = [a.dag() * a, a + a.dag()]. In [44]: res_brme = brmesolve(H, psi0, times, a_ops, e_ops). In [45]: plt.figure(); Out[45]: <Figure size 640x480 with 0 Axes>. In [46]: plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'); Out[46]: [<matplotlib.lines.Line2D at 0x1a24dff668>]. In [47]: plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'); Out[47]: [<matplotlib.lines.Line2D at 0x1a24dffc50>]. In [48]: plt.legend(); Out[48]: <matplotlib.legend.Le",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:18397,depend,dependence,18397,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,1,['depend'],['dependence']
Integrability," [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.25s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.48s. Est. time left: 00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:8265,depend,dependent,8265,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.28s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.53s. Est. time left: 00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:7732,depend,dependent,7732,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.44s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.88s. Est. time left: 00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:8290,depend,dependent,8290,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [6]: sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. In [7]: a = tensor(destroy(N), qeye(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7758,depend,dependent,7758,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [<matplotlib.lines.Line2D at 0x2b226c4f55c0>]. In [60]: plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and coll",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:17090,depend,dependent,17090,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [<matplotlib.lines.Line2D at 0x2b4e807cd588>]. In [60]: plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Es",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16627,depend,dependent,16627,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," [<matplotlib.lines.Line2D at 0x2b65bb8c1940>]. In [60]: plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Es",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16461,depend,dependent,16461,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_td_ode_rhs_super); code = compile('r.set_f_params([' + parameter_string + '])',; '<string>', 'exec'); else:; r = scipy.integrate.ode(config.tdfunc); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). def _td_ode_rhs_super(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:20800,integrat,integrate,20800,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:8599,integrat,integrator,8599,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,6,['integrat'],['integrator']
Integrability," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; r""""""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; Lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:8629,integrat,integrator,8629,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,4,['integrat'],['integrator']
Integrability," \(\psi(t_0)\). n_emissionsintNumber of photon emissions to calculate. c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest. system_zero_state:class: qutip.QobjState representing zero excitations in the system. Defaults to; \(\psi(t_0)\). construct_effective_hamiltonianboolWhether an effective Hamiltonian should be constructed from H and c_ops:; \(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\); Default: True. Returns. phi_n:class: qutip.QobjThe scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:114477,integrat,integrated,114477,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['integrat'],['integrated']
Integrability," _safe_mode=True):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated ; spectrum functions, as well as possible Lindblad collapse operators.; ; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable.; ; *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]] ; ; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the ; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:; ; *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]; ; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; ; *Example*; ; a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; ; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; ; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ; *Example*; ; a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:4429,depend,dependence,4429,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['depend'],['dependence']
Integrability," a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tenso",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6789,depend,dependent,6789,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:154145,depend,dependent,154145,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). (png, hires.png, pdf)¶. (png, hires.png, pdf)¶. Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:4824,depend,dependent,4824,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,2,['depend'],['dependent']
Integrability," a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:142707,integrat,integrated,142707,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['integrat'],['integrated']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tensor.html:11018,contract,contracted,11018,docs/4.6/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html,2,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Bui",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/tensor.html:10983,contract,contracted,10983,docs/4.5/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Bui",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/tensor.html:10968,contract,contracted,10968,docs/4.4/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html:10974,contract,contracted,10974,docs/4.0.2/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/tensor.html:10974,contract,contracted,10974,docs/4.2/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/tensor.html:10974,contract,contracted,10974,docs/4.1/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.product, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/tensor.html:10974,contract,contracted,10974,docs/4.3/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/tensor.html,1,['contract'],['contracted']
Integrability," a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:3140,depend,dependence,3140,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['depend'],['dependence']
Integrability," add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change type>. Running this will create a file in the doc/changes directory with a filename corresponding to the argument you passed to towncrier create.; In this file, you should add a short description of the changes that the PR introduces. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend y",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/contributing.html:10274,depend,dependencies,10274,docs/4.7/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html,2,['depend'],['dependencies']
Integrability," add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:50928,message,message,50928,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['message'],['message']
Integrability," ado_state = HierarchyADOsState(; rho, self.ados, solver.y.reshape(hierarchy_shape); ); if ado_return:; output.ado_states.append(ado_state); for e_key, e_op in e_ops.items():; if isinstance(e_op, Qobj):; e_result = (rho * e_op).tr(); else:; e_result = e_op(t, ado_state); output.expect[e_key].append(e_result). self.progress_bar.finished(); return output. [docs]class HSolverDL(HEOMSolver):; """"""; A helper class for creating an :class:`HEOMSolver` that is backwards; compatible with the ``HSolverDL`` provided in ``qutip.nonmarkov.heom``; in QuTiP 4.6 and below. See :class:`HEOMSolver` and :class:`DrudeLorentzBath` for more; descriptions of the underlying solver and bath construction. An exact copy of the QuTiP 4.6 HSolverDL is provided in; ``qutip.nonmarkov.dlheom_solver`` for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. .. note::. Unlike the version of ``HSolverDL`` in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian ``H_sys``. .. note::. For compatibility with ``HSolverDL`` in QuTiP 4.6 and below, the; parameter ``N_exp`` specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent ``Nk`` used in the :class:`DrudeLorentzBath`. I.e.,; ``Nk = N_exp - 1``. The ``Nk`` parameter in the; :class:`DrudeLorentzBath` does not count the zeroeth exponent in; order to better match common usage in the literature. .. note::. The ``stats`` and ``renorm`` arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters; ----------; H_sys : Qobj or QobjEvo or list; The system Hamiltonian or Liouvillian. See :class:`HEOMSolver` for; a complete description. coup_op : Qobj; Operator describing the coupling between system and bath.; See parameter ``Q`` in :class:`BosonicBath` for a complete description. coup_strength : float; Coupling strength. Referred to as ``lam`` in :class:`DrudeLorentzBath`. temperature : fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:28627,depend,dependent,28627,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['depend'],['dependent']
Integrability," also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:9939,depend,dependencies,9939,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['depend'],['dependencies']
Integrability," also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important depe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:9847,depend,dependencies,9847,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['depend'],['dependencies']
Integrability," an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:14619,depend,dependent,14619,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,4,['depend'],['dependent']
Integrability," and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (August 29, 2019)¶. Improvements¶. QobjEvo do not need to start from 0 anymore (by Eric Giguère).; Add a quantum object purity function (by Nathan Shammah and Shahnawaz Ahmed).; Add step function interpolation for array time-coefficient (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:5108,depend,dependant,5108,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['depend'],['dependant']
Integrability," and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-dynamics.html:2062,depend,dependent,2062,docs/3.0.1/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability," and how to use it. Object Model; The Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface (as in the notebook examples) then skip to the section on ‘Using the pulseoptim functions’.; ![qtrl-code_obj_model](./images/qtrl-code_object_model.png “Qtrl code object model”). The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfig; The OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file.; Optimizer; This acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm.; Dynamics; This is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators.; PulseGen; There are many subclasses that of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-control.html:15142,wrap,wrapper,15142,docs/4.0.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-control.html,2,['wrap'],['wrapper']
Integrability," and t[-1], respectively, as well as the entire array of data points:; In [55]: S = Cubic_Spline(t[0], t[-1], noisy_data). In [56]: plt.figure(); Out[56]: <matplotlib.figure.Figure at 0x2b4e8029b7f0>. In [57]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:15912,depend,dependent,15912,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa58>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa90>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:99621,depend,dependent,99621,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability," are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self, name); Add another section with the given name. add_count(self, key, value[, section]); Add value to count. add_timing(self, key, value[, section]); Add value to timing. add_message(self, key, value[, section, sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will res",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:43336,message,message,43336,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['message'],['message']
Integrability," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath deca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:4754,depend,depends,4754,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,8,['depend'],['depends']
Integrability," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the ba",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:4980,depend,depends,4980,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['depends']
Integrability," args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add whi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:24119,depend,dependent,24119,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability," args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args). if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c_ops",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:24088,depend,dependent,24088,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['depend'],['dependent']
Integrability," args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if T is None:; T = max(tlist). if len(spectra_cb) == 0:; # add white noise callbacks if absent; spectra_cb = [lambda w: 1.0] * len(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:23863,depend,dependent,23863,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,4,['depend'],['dependent']
Integrability," array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1, :1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100,; options_modes=None):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. options_modes : :class:`qutip.solver.Options`; options for the ODE solver. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. if options_modes is None:; options_modes_table = Options(); else:; options_modes_table = options_modes. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args,; options=options_modes). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:11840,depend,dependence,11840,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability," as a `qutip.Qobj`.; """"""; cythonized_dicke = _Dicke(int(self.N),; float(self.emission),; float(self.dephasing),; float(self.pumping),; float(self.collective_emission),; float(self.collective_dephasing),; float(self.collective_pumping)); return cythonized_dicke.lindbladian(). [docs] def liouvillian(self):; """"""Build the total Liouvillian using the Dicke basis. Returns; -------; liouv: :class: qutip.Qobj; The Liouvillian matrix for the system.; """"""; lindblad = self.lindbladian(); if self.hamiltonian is None:; liouv = lindblad. else:; hamiltonian = self.hamiltonian; hamiltonian_superoperator = - 1j * \; spre(hamiltonian) + 1j * spost(hamiltonian); liouv = lindblad + hamiltonian_superoperator; return liouv. [docs] def pisolve(self, initial_state, tlist, options=None):; """"""; Solve for diagonal Hamiltonians and initial states faster. Parameters; ==========; initial_state: :class: qutip.Qobj; An initial state specified as a density matrix of; `qutip.Qbj` type. tlist: ndarray; A 1D numpy array of list of timesteps to integrate. options: :class: qutip.solver.Options; The options for the solver. Returns; =======; result: list; A dictionary of the type `qutip.solver.Result` which holds the; results of the evolution.; """"""; if isdiagonal(initial_state) == False:; msg = ""`pisolve` requires a diagonal initial density matrix. ""; msg += ""In general construct the Liouvillian using ""; msg += ""`piqs.liouvillian` and use qutip.mesolve.""; raise ValueError(msg). if self.hamiltonian and isdiagonal(self.hamiltonian) == False:; msg = ""`pisolve` should only be used for diagonal Hamiltonians. ""; msg += ""Construct the Liouvillian using `piqs.liouvillian` and""; msg += "" use `qutip.mesolve`.""; raise ValueError(msg). if initial_state.full().shape != self.dshape:; msg = ""Initial density matrix should be diagonal.""; raise ValueError(msg). pim = Pim(self.N, self.emission, self.dephasing, self.pumping,; self.collective_emission, self.collective_pumping,; self.collective_dephasing); result = pim.solve(i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:8960,integrat,integrate,8960,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,1,['integrat'],['integrate']
Integrability," as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:80166,wrap,wrapper,80166,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['wrap'],['wrapper']
Integrability," as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2850,depend,dependence,2850,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['depend'],['dependence']
Integrability," attributes. The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions. For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters; ----------; circuit: QubitCircuit or list; For gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute `duration`; that indicates the execution time of this instruction.; gates_schedule: bool, optional; `True`, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input `circuit` is a `QubitCircuit`,; it will be assigned to `True` automatically.; Otherwise, the default is `False`.; return_cycles_list: bool, optional; If `True`, the method returns the `cycles_list`,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule.; random_shuffle: bool, optional;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:14870,depend,dependency,14870,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependency']
Integrability," axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:26570,depend,dependent,26570,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability," be set:; k=0 main diagonal; k>0 kth upper diagonal; k<0 kth lower diagonal. dimslist, optionalDimensions for operator. shapelist, tuple, optionalShape of operator. If omitted, a square operator large enough; to contain the diagonals is generated. See also. scipy.sparse.diagsfor usage information. Notes; This function requires SciPy 0.11+.; Examples; >>> qdiags(sqrt(range(1, 4)), 1); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> sigmam(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]. sigmap()[source]¶; Creation operator for Pauli spins.; Examples; >>> sigmap(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 0. 0.]]. sigmax()[source]¶; Pauli spin 1/2 sigma-x operator; Examples; >>> sigmax(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. sigmay()[source]¶; Pauli spin 1/2 sigma-y operator.; Examples; >>> sigmay(); Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-1.j]; [ 0.+1.j 0.+0.j]]. sigmaz()[source]¶; Pauli spin 1/2 sigma-z operator.; Examples; >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = [2, 2], type =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:28336,depend,depending,28336,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['depending']
Integrability," be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:93675,depend,dependent,93675,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability," be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-cal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:70668,depend,dependent,70668,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependent']
Integrability," between [0,1] of output density matrix.; kind : str (Default = 'left'); Generate 'left' or 'right' stochastic matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; Quantum operator form of stochastic matrix.; """"""; if seed is not None:; np.random.seed(seed=seed); if dims:; _check_dims(dims, N, N); num_elems = max([np.int(np.ceil(N*(N+1)*density)/2), N]); data = np.random.rand(num_elems); # Ensure an element on every row and column; row_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); col_idx = np.hstack([np.random.permutation(N),; np.random.choice(N, num_elems-N)]); M = sp.coo_matrix((data, (row_idx, col_idx)),; dtype=float, shape=(N,N)).tocsr(); M = 0.5 * (M + M.conj().transpose()); num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if kind=='left':; M = M.transpose(); if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/random_objects.html:20243,depend,depends,20243,docs/4.5/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/random_objects.html,1,['depend'],['depends']
Integrability," boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters:; options (qutip.solver.Options) – Generic solver options.; If set to None the default options will be used; progress_bar (BaseProgressBar) – Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar; stats (qutip.solver.Stats) – Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). cut_freq¶; float – Bath spectral density cutoff frequency. renorm¶; bool – Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx¶; bool – Use boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, pl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:28878,integrat,integrate,28878,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['integrat'],['integrate']
Integrability," by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). QuTiP: Quantum Toolbox in Python; Copyright (c) 2011 and later.; Paul D. Nation & Robert J. Johansson. QuTiP Version: 3.1.0; Numpy Version: 1.9.1; Scipy Version: 0.14.0; Cython Version: 0.21.1; Matplotlib Version: 1.4.2; Fortran mcsolver: True; scikits.umfpack: False; Python Version: 2.7.9; Platform Info: Darwin (x86_64); Installation path: /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/qutip. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:12991,depend,dependencies,12991,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability," by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:65599,depend,dependence,65599,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependence']
Integrability," c_list:; if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; n_not_const_terms +=1; c = c_spec[0]; c_coeff = c_spec[1]; ; if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); if isinstance(c_coeff, Cubic_Spline):; me_cops_obj.append(c_coeff.coeffs); me_cops_obj_flags.append(n_not_const_terms); me_cops_coeff.append(c_coeff); else:; c_coeff = ""("" + c_coeff + "")**2""; Lcoeff.append(c_coeff); elif issuper(c):; L = c; if isinstance(c_coeff, Cubic_Spline):; me_cops_obj.append(c_coeff.coeffs); me_cops_obj_flags.append(-n_not_const_terms); me_cops_coeff.append(c_coeff); else:; Lcoeff.append(c_coeff); else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); #Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""); ; ; #prepend the constant part of the liouvillian; if Lconst != 0:; Ldata = [Lconst.data.data]+Ldata; Linds = [Lconst.data.indices]+Linds; Lptrs = [Lconst.data.indptr]+Lptrs; Lcoeff = [""1.0""]+Lcoeff; ; else:; me_cops_obj_flags = [kk-1 for kk in me_cops_obj_flags]; # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); n_td_cops = len(me_cops_obj); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:20201,depend,dependent,20201,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," c_ops : list; List of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; :math:`\\sigma = \\sqrt \\gamma \\cdot a`.; tlist : array_like; List of times for :math:`\\tau_i`. tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced.; system_zero_state : :class: qutip.Qobj; State representing zero excitations in the system. Defaults to; `basis(systemDims, 0)`.; construct_effective_hamiltonian : bool; Whether an effective Hamiltonian should be constructed from H and c_ops:; :math:`H_{eff} = H - \\frac{i}{2} \\sum_n \\sigma_n^\\dagger \\sigma_n`; Default: True. Returns; -------; scattering_prob : float; The probability of scattering n photons from the system over the time; range specified.; """"""; phi_n = temporal_scattered_state(H, psi0, n_emissions, c_ops, tlist,; system_zero_state,; construct_effective_hamiltonian); T = len(tlist); W = len(c_ops). # Compute <omega_tau> for all combinations of tau; all_emission_indices = combinations_with_replacement(range(T), n_emissions); probs = np.zeros([T] * n_emissions). # Project scattered state onto temporal basis; for emit_indices in all_emission_indices:; # Consider unique emission time partitionings; partition = tuple(set(set_partition(emit_indices, W))); # wg_indices_list = list(set_partition(indices, W)); for wg_indices in partition:; projector = temporal_basis_vector(wg_indices, T); amplitude = (projector.dag() * phi_n).full().item(); probs[emit_indices] += np.real(amplitude.conjugate() * amplitude). # Iteratively integrate to obtain single value; while probs.shape != ():; probs = np.trapz(probs, x = tlist); return np.abs(probs). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/scattering.html:13357,integrat,integrate,13357,docs/4.6/modules/qutip/scattering.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/scattering.html,2,['integrat'],['integrate']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.25s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.48s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.75s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.97s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.46s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.70s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.95s. Est. time left: 00:00:00:00; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:8591,depend,dependents,8591,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.28s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.53s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.03s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.28s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.53s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.79s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.03s. Est. time left: 00:00:00:00; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:8058,depend,dependents,8058,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.44s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.88s. Est. time left: 00:00:00:03; 30.0%. Run time: 1.55s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.28s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.84s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.54s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.23s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.94s. Est. time left: 00:00:00:01; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:8616,depend,dependents,8616,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:8084,depend,dependents,8084,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.30s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.54s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.79s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.05s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.30s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.57s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.09s. Est. time left: 00:00:00:00; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:8318,depend,dependents,8318,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.56s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.08s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.64s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.31s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.90s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.49s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.10s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.65s. Est. time left: 00:00:00:01; 90",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:8681,depend,dependents,8681,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 3.78s. Est. time left: 00:00:00:33; 20.0%. Run time: 7.55s. Est. time left: 00:00:00:30; 30.0%. Run time: 11.12s. Est. time left: 00:00:00:25; 40.0%. Run time: 14.82s. Est. time left: 00:00:00:22; 50.0%. Run time: 18.42s. Est. time left: 00:00:00:18; 60.0%. Run time: 22.19s. Est. time left: 00:00:00:14; 70.0%. Run time: 25.87s. Est. time left: 00:00:00:11; 80.0%. Run time: 29.56s. Est. time left: 00:00:00:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:8212,depend,dependents,8212,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependents']
Integrability," callable functions as e_ops to mesolve and sesolve, and faster state number enumeration and Husimi Q functions.; Import bugfixes include some bugs affecting plotting with matplotlib 3.5 and fixing support for qutrits (and other non-qubit) quantum circuits.; The many other small improvements, bug fixes, documentation enhancements, and behind the scenese development changes are included in the list below.; QuTiP 4.7.X will be the last series of releases for QuTiP 4. Patch releases will continue for the 4.7.X series but the main development effort will move to QuTiP 5.; The many, many contributors who filed issues, submitted or reviewed pull requests, and improved the documentation for this release are listed next to their contributions below. Thank you to all of you. Improvements¶. MAJOR Added krylovsolve as a new solver based on krylov subspace approximation. (#1739 by Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (#1275 and #1802 by NS2 Group at LPS and Simon Cross); Added a color_style option to the hinton plotting function. (#1595 by Cassandra Granade); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#12",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:8408,wrap,wrapper,8408,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['wrap'],['wrapper']
Integrability," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:11974,depend,dependent,11974,docs/4.7/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html,4,['depend'],['dependent']
Integrability," check for unused entires in; # arrays; return order[order != -1], levels[levels != -1]. [docs]def reverse_cuthill_mckee(A, sym=False):; """"""; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default). It is assumed by default (*sym=False*) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set *sym=True*. Parameters; ----------; A : csc_matrix, csr_matrix; Input sparse CSC or CSR sparse matrix format.; sym : bool {False, True}; Flag to set whether input matrix is symmetric. Returns; -------; perm : array; Array of permuted row and column indices. Notes; -----; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; ----------; E. Cuthill and J. McKee, ""Reducing the Bandwidth of Sparse Symmetric; Matrices"", ACM '69 Proceedings of the 1969 24th national conference,; (1969).; """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'). nrows = A.shape[0]. if not sym:; A = A + A.transpose(). return _reverse_cuthill_mckee(A.indices, A.indptr, nrows). [docs]def maximum_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only. The input matrix will be converted to CSC matrix format if; necessary. Parameters; ----------; A : sparse matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/graph.html:6141,rout,routine,6141,docs/3.1.0/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html,2,['rout'],"['routine', 'routines']"
Integrability," check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))).data; else:; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); else:; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; if isoper(args):; new_args = (-1j * (spre(args) - spost(args))).data; else:; new_args = args.data; else:; new_args = args. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_rho_func_td); else:; r = scipy.integrate.ode(_ode_rho_func_td_with_state); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_data, L_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td(t, rho, L0, L_func, args):; L = L0 + L_func(t, args); return L * rho. #; # evaluate drho(t)/dt according to the master equation; #; def _ode_rho_func_td_with_state(t, rho, L0, L_func, args):; L = L0 + L_func(t, rho, args); return L * rho. # -----------------------------------------------------------------------------; # Generic ODE solver: shared code among t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:23514,integrat,integrator,23514,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Integrability," choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 – The normalized and unnormalized second-order coherence function. Return type:tuple. Steady-state Solvers¶; Mod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:99807,depend,dependent,99807,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20756,depend,dependent,20756,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,4,['depend'],['dependent']
Integrability," class : _StatsSection) – Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:42283,message,messages,42283,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['message'],['messages']
Integrability," class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; In [55]: S = Cubic_Spline(t[0], t[-1], noisy_data). In [56]: plt.figure(); Out[56]: <Figure size 640x480 with 0 Axes>. In [57]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:15843,depend,dependent,15843,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," coeff type. compile(code=False, matched=False, dense=False, omp=0):; Create the associated cython object for faster usage.; code: return the code generated for compilation of the strings.; matched: the compiled object use sparse matrix with matching indices.; (experimental, no real advantage); dense: the compiled object use dense matrix.; omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t.; *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat.; *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi.; More generaly, return the product of the object at t with psi.; *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator,; no check) and state psi.; Return only the real part if herm.; *Faster after compilation. to_list():; Return the time-dependent quantum object as a list; """""". def __init__(self, Q_object=[], args={}, copy=True,; tlist=None, state0=None, e_ops=[]):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); for i, dargs in enumerate(self.dynamics_args):; e_int = dargs[1] == ""expect"" and isinstance(dargs[2], int); if e_ops and e_int:; self.dynamics_args[i] = (dargs[0], ""expect"",; e_ops[dargs[2]]); if state0 is not None:; self._dynamics_args_update(0., state0); return. self.const = False; self.dummy_cte = False; self.args = args.copy(); self.dynamics_args = []; self.cte = None; self.tlist = tlist; self.compiled = """"; self.compiled_qobjevo = None; self.coeff_get = None; self.type = ""none""; self.omp = 0; self.coeff_files = []; self.use_cython = use_cython[0]; self.safePickle = safePickle[0]. if isinstance(Q_object, list) and len(Q_object) == 2:; if isinstance(Q_object[0], Qobj) and not isinstance(Q_object[1],; (Qobj, list))",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:12810,depend,dependent,12810,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability," coeff type. compile(code=False, matched=False, dense=False, omp=0):; Create the associated cython object for faster usage.; code: return the code generated for compilation of the strings.; matched: the compiled object use sparse matrix with matching indices.; (experimental, no real advantage); dense: the compiled object use dense matrix.; omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t.; *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat.; *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi.; More generaly, return the product of the object at t with psi.; *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator,; no check) and state psi.; Return only the real part if herm.; *Faster after compilation. to_list():; Return the time-dependent quantum object as a list; """""". def __init__(self, Q_object=[], args={}, tlist=None, copy=True):; if isinstance(Q_object, QobjEvo):; if copy:; self._inplace_copy(Q_object); else:; self.__dict__ = Q_object.__dict__; if args:; self.arguments(args); return. self.const = False; self.dummy_cte = False; self.args = args.copy() if copy else args; self.dynamics_args = []; self.cte = None; self.tlist = tlist; self.compiled = """"; self.compiled_qobjevo = None; self.compiled_ptr = None; self.coeff_get = None; self.type = ""none""; self.omp = 0. if isinstance(Q_object, list) and len(Q_object) == 2:; if isinstance(Q_object[0], Qobj) and not isinstance(Q_object[1],; (Qobj, list)):; # The format is [Qobj, f/str]; Q_object = [Q_object]. op_type = self._td_format_check_single(Q_object, tlist); self.ops = []. if isinstance(op_type, int):; if op_type == 0:; self.cte = Q_object; self.const = True; self.type = ""cte""; elif op_type == 1:; raise Exception(""The Qobj must not already be a function""); elif op_ty",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:11732,depend,dependent,11732,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability," coeff=None):; """"""; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the pulse.; targets: list; target qubits of the pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.coherent_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None):; """"""; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters; ----------; qobj: :class:'qutip.Qobj'; The collapse operator of the lindblad noise.; targets: list; target qubits of the collapse operator; (or subquantum system of other dimensions).; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied.; `tlist` does not have to be equidistant, but must have the same; length; or one element shorter compared to `coeff`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; coeff: array-like or bool, optional; Time-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for; the parameter `spline_kind` of :class:`qutip.qip.Pulse`.; If a bool, the coefficient is a constant 1 or 0.; """"""; self.lindblad_noise.append(_EvoElement(qobj, targets, tlist, coeff)). [docs] def get_ideal_qobj(self, dims):; """"""; Get the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:8704,depend,dependent,8704,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['depend'],['dependent']
Integrability," complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(name); Add another section with the given name. add_count(key, value[, section]); Add value to count. add_timing(key, value[, section]); Add value to timing. add_message(key, value[, section, sep]); Add value to message. report:; Output the statistics report to console or file. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters:; key : string; key for the section.counts dictionary; reusing a key will result in numerical addition of value. value : int; Initial value of the count, or added to an existing count. section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters:; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value. value : int; Initial value of the message, or added to an existing message. sep : string; Message will be prefixed with this string when concatenating. section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters:; name : string; will be used as key for sections dict; will also be the header for the section. Returns:; section : class; The new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:38650,message,message,38650,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['message'],['message']
Integrability," complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4055,depend,dependent,4055,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," config.n_ops_data = np.array(config.n_ops_data); config.n_ops_ind = np.array(config.n_ops_ind); config.n_ops_ptr = np.array(config.n_ops_ptr). if config.tflag == 0:; # CONSTANT H & C_OPS CODE; # -----------------------. if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op # combine Hamiltonian and collapse terms into one; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:33309,depend,dependent,33309,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability," constraints upon quantum control speed limits"", ; New J. Phys. 19, 103015 (2017). 287. Leroux et al., ""Simple variational ground state and pure-cat-state generation in the quantum Rabi model"", ; Phys. Rev. A 96, 043834 (2017). 286. Laflamme et al., ""Continuous measurement of an atomic current"", ; Phys. Rev. A 95, 043843 (2017). 285. de Assis et al., ""Negative response with an optical cavity and traveling wave fields"", ; Phys. Rev. A 96, 013821 (2017). 284. Gough, ""The Tyranny of Qubits - Quantum Technology's Scalability Bottleneck"", ; arXiv:1703.05342. 283. Hamsen et al., ""Two-Photon Blockade in an Atom-Driven Cavity QED System"", ; Phys. Rev. Lett. 118, 133604 (2017). 282. Hu et al., ""Accessing dark states optically through excitation-ferrying states"", ; arXiv:1703.09614. 281. Escobedo, ""Effective Field Theories for heavy probes in a hot QCD plasma and in the early universe"", ; EPJ Web of Conferences 137, 01008 (2017). 280. Hu, ""Photonic transistor and router using a single quantum-dot-confined spin in a single-sided optical microcavity"", ; Sci. Rep. 7, 45582 (2017). 279. Robertson et al., ""Tailored Codes for Small Quantum Memories"", ; Phys. Rev. Applied 8, 064004 (2017). 278. Raghunandan et al., ""High-density quantum sensing with dissipative first order transitions"", ; arXiv:1703.07358. 277. Gilmore et al., ""Amplitude Sensing below the Zero-Point Fluctuations with a Two-Dimensional Trapped-Ion Mechanical Oscillator"", ; Phys. Rev. Lett. 118, 263602 (2017). 276. Friedman et al., ""The Wigner Flow for Open Quantum Systems"", ; arXiv:1703.04844. 275. Lörch et al., ""Quantum Synchronization Blockade: Energy Quantization Hinders Synchronization of Identical Oscillators"", ; Phys. Rev. Lett. 118, 243602 (2017). 274. Manenti et al., ""Circuit quantum acoustodynamics with surface acoustic waves"", ; Nat. Commun. 8, 975 (2017). 273. Amitai et al., ""Synchronization of an optomechanical system to an external drive"", ; Phys. Rev. A 95, 053858 (2017). 272. Cesa et al., ""Two-qubit ent",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:12023,rout,router,12023,users.html,https://qutip.org,https://qutip.org/users.html,1,['rout'],['router']
Integrability," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: family package qutip-qip. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:6838,integrat,integrated,6838,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['integrat'],['integrated']
Integrability," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:6963,integrat,integrated,6963,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['integrat'],['integrated']
Integrability," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a438>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:109088,depend,dependent,109088,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eab38>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:91129,depend,dependent,91129,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:123290,depend,dependent,123290,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:91338,depend,dependent,91338,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:5172,depend,dependency,5172,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['depend'],['dependency']
Integrability," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:5115,depend,dependency,5115,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['depend'],['dependency']
Integrability," cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:9018,integrat,integrated,9018,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['integrat'],['integrated']
Integrability," cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23428,integrat,integrate,23428,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrate']
Integrability," def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expect[m][t_idx] = (e_ops_data[m] * cdata).trace(); else:; for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops_data[m], cdata,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); if opt.normalize_output:; cdata /= la_norm(cdata, axis=0); # cdata *= norm_dim_factor / la_norm(cdata); output.final_state = Qobj(cdata, dims=dims). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/sesolve.html:12105,integrat,integrate,12105,docs/4.4/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability," defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = []",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:14052,depend,dependent,14052,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['depend'],['dependent']
Integrability," density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map at 0xd1fd21a60>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:69782,depend,dependent,69782,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,3,['depend'],['dependent']
Integrability," density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]¶; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[“w1”]). def f2_t(t, args):return np.cos(t * args[“w2”]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={“w1”:1., “w2”:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, ‘exp(-1j*w1*t)’], [H2, ‘cos(w2*t)’]],args={“w1”:1.,”w2”:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:16727,depend,dependent,16727,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['depend'],['dependent']
Integrability," dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:79090,depend,depend,79090,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['depend']
Integrability," do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:7060,depend,dependencies,7060,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['depend'],['dependencies']
Integrability," do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated. As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:16657,depend,dependent,16657,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return L * rho. def drho_list_td_with_state(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, rho, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, rho, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, rho, args). return L * rho. #; # evaluate dE(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API, where E is a superoperator; #; def dsuper_list_td(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return _ode_super_func(t, y, L). def dsuper_list_td_with_state(t, y, L_list, args):. L = L_list[0][0] * L_list[0][1](t, y, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, y, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, y, args). return _ode_super_func(t, y, L). # -----------------------------------------------------------------------------; # A time-dependent dissipative mast",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:15985,depend,dependence,15985,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,2,['depend'],['dependence']
Integrability," dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:169153,depend,dependent,169153,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability," dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:3798,message,message,3798,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['message'],['message']
Integrability," e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options instance at 0x105963290>, floquet_basis=True, kmax=5)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:58008,depend,dependent,58008,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability," e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters:H : qutip.qobj. system Hamiltonian. rho0 / psi0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.qobj. list of collapse operators. e_ops : list of qutip.qobj / callback function. list of operators for which to evaluate expectation values. spectra_cb : list callback functions. List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:69068,depend,dependent,69068,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability," elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = c_td; c_ops_new.append([c_op, c_td_str]); n += 1; else:; c_ops_new.append(ck). if not args_new:; args_new = args; elif isinstance(args, dict):; args_new.update(args); else:; raise ValueError(""Time-dependent array format requires args to "" +; ""be a dictionary""). return H_new, c_ops_new, args_new. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/rhs_generate.html:11373,depend,dependent,11373,docs/4.3/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/rhs_generate.html,1,['depend'],['dependent']
Integrability," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'breadth_first_search', 'reverse_cuthill_mckee',; 'maximum_bipartite_matching', 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return _node_degrees(A.indices, A.indptr, A.shape[0]). [docs]def breadth_first_search(A, start):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/graph.html:3360,rout,routines,3360,docs/3.1.0/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html,1,['rout'],['routines']
Integrability," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search', ; 'reverse_cuthill_mckee', 'maximum_bipartite_matching', ; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return _node_degrees(A.indices, A.indptr, A.shape[0]). [docs]def breadth_f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/graph.html:2101,rout,routines,2101,docs/4.0.2/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/graph.html,1,['rout'],['routines']
Integrability," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search', ; 'reverse_cuthill_mckee', 'maximum_bipartite_matching', ; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/graph.html:2101,rout,routines,2101,docs/4.2/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/graph.html,4,['rout'],['routines']
Integrability," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]def",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/graph.html:2097,rout,routines,2097,docs/4.4/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/graph.html,1,['rout'],['routines']
Integrability," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching); import warnings. def _deprecate():; warnings.warn((""qutip graph functions are deprecated.""; "" Consider using scipy.sparse.csgraph instead.""),; DeprecationWarning). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row).; """"""; _deprecate(); if not (sp.is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/graph.html:2130,rout,routines,2130,docs/4.6/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/graph.html,2,['rout'],['routines']
Integrability," equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate dec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:15363,depend,dependent,15363,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability," error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:245713,wrap,wrapper,245713,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['wrap'],['wrapper']
Integrability," even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list / callback function, optionalA list of operators as Qobj and/or callable functions (can be mixed); or a single callable function. For operators, the result’s expect will; be computed by qutip.expect. For callable functions, they are; called as f(t, state) and return the expectation value.; A single callback’s expectation value can be any type, but a callback; part of a list must return a number as the expectation value. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.solver.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:85164,depend,dependent,85164,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability," even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:80540,depend,dependent,80540,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability," example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). In [28]: actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). In [29]: plt.figure(); Out[29]: <Figure size 640x480 with 0 Axes>. In [30]: plt.plot(tlist, out.expect[0]); Out[30]: [<matplotlib.lines.Line2D at 0x1a251955c0>]. In [31]: plt.plot(tlist, actual_answer); Out[31]: [<matplotlib.lines.Line2D at 0x1a254cc860>]. In [32]: plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; In [33]: a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; In [34]: N = 10. In [35]: w0 = 1.0 * 2 * np.pi. In [36]: g = 0.05 * w0. In [37]: kappa = 0.15. In [38]: times = np.linspace(0, 25, 1000). In [39]: a = destroy(N). In [40]: H = w0 * a.dag() * a + g * (a + a.dag()). In [41]: psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). In [42]: a_ops = [[ (a, a.dag()), ('{0} * (w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:17883,depend,dependence,17883,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,1,['depend'],['dependence']
Integrability," executed at the same time.; A dependency arrow between Instruction 1 and instruction 2; means that they do not commute.; However, the converse does not hold because we do not need; gate1->gate3 if we already have gate1->gate2->gate3. Parameters; ----------; commuting: function; A Python function that determines if two gates commute,; given that their used qubits overlap.; """"""; # initialize the graph; for node in self.nodes:; node.predecessors = set(); node.successors = set(). num_qubits = max(set().union(; *[instruction.used_qubits for instruction in self.nodes])) + 1; qubits_instructions_dependency = [[set()] for i in range(num_qubits)]; # qubits_instructions_dependency:; # instruction dependency for each qubits, a nested list of level 3.; # E.g. [; # [{1, }],; # [{0, 1}, {2, }],; # [{0, }]; # ]; # means that; # Gate0 acts on qubit 1 and 2, gate1 act on qubit0 and qubit1,; # but gate0 and gate1 cummute with each other.; # Therefore, there is not dependency between gate0 and gate1;; # Gate 2 acts on qubit1 and must be executed after gate0 and gate1.; # Hence, gate2 will depends on gate0 and gate1. # Generate instruction dependency for each qubit; for current_ind, instruction in enumerate(self.nodes):; for qubit in instruction.used_qubits:; # For each used qubit, find the last dependency gate set.; # If the current gate commute with all of them,; # add it to the list.; # Otherwise,; # append a new set with the current gate to the list.; dependent = False; for dependent_ind in qubits_instructions_dependency[qubit][-1]:; if not commuting(current_ind, dependent_ind, self.nodes):; dependent = True; if not dependent:; qubits_instructions_dependency[qubit][-1].add(current_ind); else:; qubits_instructions_dependency[qubit].append({current_ind}). # Generate the dependency graph; for instructions_cycles in qubits_instructions_dependency:; for cycle_ind1 in range(len(instructions_cycles) - 1):; for instruction_ind1 in instructions_cycles[cycle_ind1]:; for instruction_ind2 in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:5192,depend,dependency,5192,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependency']
Integrability," fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html:17637,integrat,integrate,17637,docs/4.5/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/bloch_redfield.html,1,['integrat'],['integrate']
Integrability," fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:6540,integrat,integrated,6540,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['integrat'],['integrated']
Integrability," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4888,depend,dependent,4888,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['depend'],['dependent']
Integrability," float(len(tlist)),; [config.psi0_dims[0],; config.psi0_dims[0]],; [config.psi0_shape[0],; config.psi0_shape[0]],; fast='mc-dm')]). return (states_out, expect_out,; np.array(collapse_times, dtype=float),; np.array(which_oper, dtype=int)). def _mc_func_load(config):; """"""Load cython functions"""""". global _cy_rhs_func; global _cy_col_spmv_func, _cy_col_expect_func; global _cy_col_spmv_call_func, _cy_col_expect_call_func. if debug:; print(inspect.stack()[0][3] + "" in "" + str(os.getpid())). if config.tflag in [1, 10, 11]:; # compile time-depdendent RHS code; if config.tflag in [1, 11]:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs, col_spmv, col_expect',; '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs; _cy_col_spmv_func = col_spmv; _cy_col_expect_func = col_expect; else:; code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()); _cy_rhs_func = cy_td_ode_rhs. # compile wrapper functions for calling cython spmv and expect; if config.col_spmv_code:; _cy_col_spmv_call_func = compile(; config.col_spmv_code, '<string>', 'exec'). if config.col_expect_code:; _cy_col_expect_call_func = compile(; config.col_expect_code, '<string>', 'exec'). elif config.tflag == 0:; _cy_rhs_func = cy_ode_rhs. def _mc_data_config(H, psi0, h_stuff, c_ops, c_stuff, args, e_ops,; options, config):; """"""Creates the appropriate data structures for the monte carlo solver; based on the given time-dependent, or indepdendent, format.; """""". if debug:; print(inspect.stack()[0][3]). config.soft_reset(). # take care of expectation values, if any; if any(e_ops):; config.e_num = len(e_ops); for op in e_ops:; if isinstance(op, list):; op = op[0]; config.e_ops_data.append(op.data.data); config.e_ops_ind.append(op.data.indices); config.e_ops_ptr.append(op.data.indptr); config.e_ops_isherm.append(op.isherm). config.e_ops_data = np.array(config.e_ops_data); config.e_ops_ind = np.array(config.e_ops_ind); config.e_ops_ptr = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:29585,wrap,wrapper,29585,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['wrap'],['wrapper']
Integrability," for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. options_modesqutip.solver.Optionsoptions for the ODE solver. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:110502,depend,depending,110502,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['depending']
Integrability," for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opsl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:89331,depend,depend,89331,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['depend']
Integrability," for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None; ; class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values; ; The method parameter descriptions are the same as for those the parent ; with the same method name; ; Parameters; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:21105,message,messages,21105,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['messages']
Integrability," for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:11445,integrat,integrated,11445,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['integrat'],['integrated']
Integrability," format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:218253,depend,dependent,218253,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure.; Use A+trans(A) if original matrix is not symmetric or not sure. Parameters:; A (csc_matrix, csr_matrix) – Input graph in CSC or CSR matrix format; start (int) – Staring node for BFS traversal. Returns:; order (array) – Order in which nodes are traversed from starting node.; levels (array) – Level of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters:A (qobj, csr_matrix, csc_matrix) – Input quantum object or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A (csc_matrix, csr_matrix) – Input sparse CSC or CSR sparse matrix format.; sym (bool {False, True}) – Flag to set whether input matrix is symmetric. Returns:perm – Array of permuted row and column indices. Return type:array. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:189726,rout,routine,189726,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['rout'],['routine']
Integrability," from qutip import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:4122,message,message,4122,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['message'],['message']
Integrability," from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:3818,integrat,integrating,3818,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['integrat'],['integrating']
Integrability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.12s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.20s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.28s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.36s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.44s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.52s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.60s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.68s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:16844,depend,dependent,16844,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.13s. Est. time left: 00:00:00:01; 20.0%. Run time: 0.22s. Est. time left: 00:00:00:00; 30.0%. Run time: 0.31s. Est. time left: 00:00:00:00; 40.0%. Run time: 0.40s. Est. time left: 00:00:00:00; 50.0%. Run time: 0.49s. Est. time left: 00:00:00:00; 60.0%. Run time: 0.58s. Est. time left: 00:00:00:00; 70.0%. Run time: 0.67s. Est. time left: 00:00:00:00; 80.0%. Run time: 0.76s. Est. time left: 00:00:00:00; 90.0%. Run time: 0.86s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:16678,depend,dependent,16678,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [61]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [62]: args = {'A': 9, 'sig': 5}. In [63]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.24s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.44s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.62s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.80s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.00s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.23s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.42s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.62s. Est. time left: 00:00:00:00; 90.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:16775,depend,dependent,16775,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:14266,integrat,integrator,14266,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Integrability," function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; if opt.rhs_with_state:; r = scipy.integrate.ode(dsuper_list_td_with_state); else:; r = scipy.integrate.ode(dsuper_list_td); else:; if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):; out = np.zeros(rho.shape[0],dtype=complex); L = L_list[0][0]; L_td = L_list[0][1]; spmvpy_csr(L.data, L.indices, L.indptr,; rho, L_td(t, args), out); for n in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:14522,integrat,integrator,14522,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['integrat'],['integrator']
Integrability," function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:15019,integrat,integrator,15019,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrator']
Integrability," function, *args, **kw_args):; """"""; Apply the linear function ``function`` to every ``Qobj`` included in; this time-dependent object, and return a new ``QobjEvo`` with the; result. Any additional arguments or keyword arguments will be appended to every; function call.; """"""; self.compiled = """"; res = self.copy(); cte_res = function(res.cte, *args, **kw_args); if not isinstance(cte_res, Qobj):; raise TypeError(""The function must return a Qobj""); res.cte = cte_res; for op in res.ops:; op.qobj = function(op.qobj, *args, **kw_args); return res. [docs] def apply_decorator(self, function, *args,; str_mod=None, inplace_np=False, **kw_args):; """"""; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result. Any additional arguments and keyword arguments will be appended to the; function calls. Parameters; ----------; function : callable; ``(time_dependence, *args, **kwargs) -> time_dependence``. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_mod : list; A 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string ``x`` will; become ``str_mod[0] + x + str_mod[1]``. inplace_np : bool, default False; Whether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations ``f'(t) = f(g(t))`` create a; mismatch between the array and the associated time list.; """"""; res = self.copy(); for op in res.ops:; op.get_coeff = function(op.get_coeff, *args, **kw_args); if op.type == [""func"", ""spline""]:; op.coeff = op.get_coeff; op.type = ""func""; elif op.type == ""string"":; if str_mod is None:; op.coeff = op.get_coeff; op.type = ""func""; else:; op.coeff = str_mod[0] + op.coeff + str_mod[1]; elif op.type == ""array"":; if inplace_np:; # keep the original function, change t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html:34889,depend,dependent,34889,docs/4.6/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobjevo.html,4,['depend'],['dependent']
Integrability," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:8003,integrat,integrator,8003,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,10,['integrat'],['integrator']
Integrability," guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:68411,message,message,68411,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['message'],['message']
Integrability," guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params). lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub. if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action. if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]. else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__); return optim. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:68983,message,message,68983,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['message'],['message']
Integrability," guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:209572,depend,dependent,209572,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:183640,depend,dependent,183640,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependent']
Integrability," handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:; H : qutip.Qobj; System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj; initial density matrix or state vector (ket). tlist : list / array; list of times for \(t\). c_ops : list of qutip.Qobj; single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single; single operator or list of operators for which to evaluate; expectation values. args : dictionary; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options; with options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calcu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:59279,depend,dependent,59279,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability," if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:10173,depend,dependent,10173,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, phase_option='PSU', amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj. Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:136944,wrap,wrapper,136944,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['wrap'],['wrapper']
Integrability," implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18809,depend,dependent,18809,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability," implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_modes_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); py",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:17351,depend,dependent,17351,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability," in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Installation on MS Windows¶; We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work.; QuTiP uses dynamic compilation of C for some of its time-dependant dynamics solvers. For MS Windows users the additional challenge is the need for a ANSI C99 compliant C compiler. Unlike other platforms, no C compiler is provided with Windows by default.; It is possible to install a Windows SDK that includes a C compiler, but ANSI C99 compliance is not 100%.; The mingw-w64 project lo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:6319,depend,dependencies,6319,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['depend'],['dependencies']
Integrability," in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:39605,depend,dependent,39605,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['depend'],['dependent']
Integrability," index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:117906,depend,dependent,117906,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," initial Floquet modes Phi_alpha(0). Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : list of kets; The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:; f_modes_0 : list of qutip.qobj (kets); Floquet modes at \(t\). f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : qutip.qobj; system Hamiltonian, time-dependent with period T. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; dictionary with variables required to evaluate H. Returns:; output : nested list; A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:; f_modes_table_t : nested list of qutip.qobj (kets); A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns:; output : nested list; A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:; f_modes_t : list of qutip.qo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:72700,depend,dependence,72700,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependence']
Integrability," initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t : nested list of qutip.qobj (kets). A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. t : float. The time for which to evaluate the Floquet modes. T : float. The period of the time-dependence of the hamiltonian. Returns:output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters:f_modes_t : list of qutip.qobj (kets). A ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:71990,depend,dependence,71990,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependence']
Integrability," instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:188279,message,message,188279,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['message'],['message']
Integrability," instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:124989,depend,dependent,124989,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:18722,depend,dependent,18722,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components sh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:19340,depend,dependent,19340,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['depend'],['dependent']
Integrability," it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; self.rates = np.array([]); self.ampl = np.array([]); for ur_key in unique_rates.keys():; total_ampl = np.sum(np.asarray(ampl_dict[ur_key], dtype=object)). if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl, total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; self.rates = np.append(self.rates, unique_rates[ur_key]); self.ampl = np.append(self.ampl,; np.asarray([total_ampl],; dtype=object)). return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/eseries.html:10300,wrap,wrapper,10300,docs/4.5/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/eseries.html,1,['wrap'],['wrapper']
Integrability," list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; By default, a cubic spline interpolation will be used for the coefficient; at time t.; If the coefficients are to be treated as step function, use the arguments; args = {""_step_func_coeff"": True}; *Examples*; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:; state can be obtained with:; ""state_vec"":psi0, args[""state_vec""] = state as 1D np.ndarray; ""state_mat"":psi0, args[""state_mat""] = state as 2D np.ndarray; ""state"":psi0, args[""state""] = state as Qobj. This Qobj is the initial value. expectation values:; ""expect_op_n"":0, args[""expect_op_n""] = expect(e_ops[int(n)], state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:; ""collapse"":list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters; ----------; QobjEvo(Q_object=[], args={}, tlist=None). Q_object : array_like; Data for vector/matrix representation of the quantum object. args : dictionary that contain the arguments for. tlist : array_like; List of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes; ----------; cte : Qobj; Constant part of the QobjEvo. ops : list of EvoElement; List of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,; type, local arguments ), ... ]; type :; 1: function; 2: string; 3: np.array; 4: Cubic_Spline. args : map; arguments of the coefficients. dynamics_args : li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:8510,depend,depending,8510,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['depend'],['depending']
Integrability," local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:236946,depend,dependent,236946,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability," local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:249064,depend,dependent,249064,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability," mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat : array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. c_op : Qobj. operator C. d_op : Qobj. operator D. solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : array. An array of correlation values ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:90800,depend,dependent,90800,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability," mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:82684,depend,dependent,82684,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," must be a density matrix; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian; #; Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec. if isoper(h):; Lconst += -1j * (spre(h) - spost(h)); elif issuper(h):; Lconst += h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if isoper(h):; L = -1j * (spre(h) - spost(h)); elif issuper(h):; L = h; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:17913,depend,dependent,17913,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(msg + ""expected string format""). # loop over all collapse operators; for c_spec in c_ops:; if isinstance(c_spec, Qobj):; c = c_spec. if not isinstance(c, Qobj):; raise TypeError(msg + ""expected Qobj""). if c.isoper:; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:4059,depend,dependence,4059,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,8,['depend'],['dependence']
Integrability," new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, dims=None):; """"""; Internal function for solving ODEs.; """"""; if opt.normalize_output:; state_norm_func = norm; else:; state_norm_func = None; ; ; #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; ou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17655,depend,dependent,17655,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,3,['depend'],['dependent']
Integrability," not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBU",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5549,message,message,5549,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,2,['message'],['message']
Integrability," obj : qobj; A composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:; pairs : tuple; One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:; cqobj : Qobj; The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho : qutip.qobj; A density matrix. mask : list / array; A mask that selects which subsystems should be transposed. method : str; choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:; rho_pr: :class:`qutip.qobj`; A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:43185,contract,contracted,43185,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['contract'],['contracted']
Integrability," object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:16524,depend,dependent,16524,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r). if opt.store_states:; if issuper(rho0):; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims, fast=""mc-dm"")). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mesolve.html:15883,integrat,integration,15883,docs/4.4/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mesolve.html,2,['integrat'],['integration']
Integrability," of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; return [(f_states[i].dag() * psi).data[0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0, f_energies = floquet_modes(H, T, args). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = floquet_modes_table(f_modes_0, f_energies,; np.linspace(0, T, Tsteps + 1),; H, T, args). # setup Result for storing the results; output = Result(); output.times = tlist; output.solver = ""fsesolve"". if isinstance(e_ops, FunctionType",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:12826,depend,dependence,12826,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['depend'],['dependence']
Integrability," of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:92885,depend,dependence,92885,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependence']
Integrability," of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x10569e200>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:96853,depend,dependent,96853,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2340,depend,dependent,2340,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); H_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_cons",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:34373,depend,dependent,34373,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability," of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_inds); # extract time-dependent coefficients (strings or functions); config.h_tdterms = [H[k][1] for k in H_td_inds]; # combine time-INDEPENDENT terms into one.; H = np.array([np.sum(H[k] for k in H_const_inds)] +; [H[k][0] for k in H_td_inds], dtype=object); len_h = len(H); H_inds = np.arange(len_h); # store indicies of time-dependent Hamiltonian terms; config.h_td_inds = np.arange(1, len_h); # if there are any collapse operators; if config.c_num > 0:; if config.tflag == 10:; # constant collapse operators; config.c_const_inds = np.arange(config.c_num); for k in config.c_const_inds:; H[0] -= 0.5j * (c_ops[k].dag() * c_ops[k]); C_inds = np.arange(config.c_num); C_tdterms = np.array([]); else:; # some time-dependent collapse terms; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:33364,depend,dependent,33364,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['depend'],['dependent']
Integrability," of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:102310,depend,depend,102310,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['depend']
Integrability," of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’). Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}. Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:108902,depend,dependent,108902,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability," of qutip.qobj collapse operators.; e_ops (list of qutip.qobj) – list of qutip.qobj operators for which to evaluate; expectation values. Returns:expt_array – Expectation values of wavefunctions/density matrices for the; times specified in tlist. Return type:array. Note; This solver does not support time-dependent Hamiltonians. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters:; L (qobj) – Liouvillian of the system.; rho0 (qobj) – Initial state vector or density matrix. Returns:eseries – eseries represention of the system dynamics. Return type:qutip.eseries. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[], args={}, options=<qutip.solver.Options object>, _safe_mode=True)[source]¶; Solve the dynamics for a system using the Bloch-Redfield master equation. Note; This solver does not currently support time-dependent Hamiltonians. Parameters:; H (qutip.Qobj) – System Hamiltonian.; / psi0 (rho0) – Initial density matrix or state vector (ket).; tlist (list / array) – List of times for \(t\).; a_ops (list of qutip.qobj) – List of system operators that couple to bath degrees of freedom.; e_ops (list of qutip.qobj / callback function) – List of operators for which to evaluate expectation values.; c_ops (list of qutip.qobj) – List of system collapse operators.; args (dictionary) – Placeholder for future implementation, kept for API consistency.; options (qutip.solver.Options) – Options for the solver. Returns:result – An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Return type:qutip.solver.Result. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=[], use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of oper",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:65408,depend,dependent,65408,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); qo = destroy(N, offset=offset) # create operator using destroy function; return qo.dag(). def _implicit_tensor_dimensions(dimensions):; """"""; Total flattened size and operator dimensions for operator creation routines; that automatically perform tensor products. Parameters; ----------; dimensions : (int) or (list of int) or (list of list of int); First dimension of an operator which can create an implicit tensor; product. If the type is `int`, it is promoted first to `[dimensions]`.; From there, it should be one of the two-elements `dims` parameter of a; `qutip.Qobj` representing an `oper` or `super`, with possible tensor; products. Returns; -------; size : int; Dimension of backing matrix required to represent operator.; dimensions : list; Dimension list in the form required by ``Qobj`` creation.; """"""; if not isinstance(dimensions, list):; dimensions = [dimensions]; flat = flatten(dimensions); if not all(isinstance(x, numbers.Integral) and x >= 0 for x in flat):; raise ValueError(""All dimensions must be integers >= 0""); return np.prod(flat), [dimensions, dimensions]. [docs]def qzero(dimensions):; """"""; Zero operator. Parameters; ----------; dimensions : (int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/operators.html:10029,rout,routines,10029,docs/4.5/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/operators.html,1,['rout'],['routines']
Integrability," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:6016,protocol,protocols,6016,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['protocol'],['protocols']
Integrability," on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:6271,protocol,protocols,6271,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['protocol'],['protocols']
Integrability," on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-eseries.html:1696,depend,dependent,1696,docs/3.0.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability," one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options is None:; options = Options(). if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # prin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html:5275,depend,dependent,5275,docs/4.5/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html,5,['depend'],['dependent']
Integrability," one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`, ``list``; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : :class:`qutip.Qobj`, ``list``; single collapse operator or a ``list`` of collapse operators. e_ops : :class:`qutip.Qobj`, ``list``; single operator as Qobj or ``list`` or equivalent of Qobj operators; for calculating expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """"""; if isinstance(c_ops, (Qobj, QobjEvo)):; c_ops = [c_ops]. if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""mcsolve"" in solver_safe:; # print("" ""); H = solver_safe[""mcsolve""]; else:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:5280,depend,dependent,5280,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability," op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11188,integrat,integration,11188,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,2,['integrat'],['integration']
Integrability," operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; n_not_const_terms +=1; c = c_spec[0]; c_coeff = c_spec[1]; ; if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); if isinstance(c_coeff, Cubic_Spline):; me_cops_obj.append(c_coeff.coeffs); me_cops_obj_flags.append(n_not_const_terms); me_cops_coeff.append(c_coeff); else:; c_coeff = ""("" + c_coeff + "")**2""; Lcoeff.append(c_coeff); elif issuper(c):; L = c; if isinstance(c_coeff, Cubic_Spline):; me_cops_obj.append(c_coeff.coeffs); me_cops_obj_flags.append(-n_not_const_terms); me_cops_coeff.append(c_coeff); else:; Lcoeff.append(c_coeff); else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); #Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""); ; ; #prepend the constant part of the liouvillian; if Lconst != 0:; Ldata = [Lconst.data.data]+Ldata; Linds = [Lconst.data.indices]+Linds; Lptrs = [Lconst.data.indptr]+Lptrs; Lcoeff = [""1.0""]+Lcoeff; ; else:; me_cops_obj_flags = [kk-1 for kk in me_cops_obj_flags]; # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); n_td_cops = len(me_cops_obj); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); ; # Add H object terms to ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; # Add cop object terms to end of ode args string; for k in range(len(me_cops_obj)):; stri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/mesolve.html:20442,depend,dependent,20442,docs/4.3/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def _tensor_contract_single(arr, i, j):; """"""; Contracts a dense tensor along a single index pair.; """"""; if arr.shape[i] != arr.shape[j]:; raise ValueError(""Cannot contract over indices of different length.""); idxs = np.arange(arr.shape[i]); sl = tuple(slice(None, None, None); if idx not in (i, j) else idxs for idx in range(arr.ndim)); contract_at = i if j == i + 1 else 0; return np.sum(arr[sl], axis=contract_at). def _tensor_contract_dense(arr, *pairs):; """"""; Contracts a dense tensor along one or more index pairs,; keeping track of how the indices are relabeled by the removal; of other indices.; """"""; axis_idxs = list(range(arr.ndim)); for pair in pairs:; # axis_idxs.index effectively evaluates the mapping from; # original index labels to the labels after contraction.; arr = _tensor_contract_single(arr, *map(axis_idxs.index, pair)); list(map(axis_idxs.remove, pair)); return arr. def tensor_swap(q_oper, *pairs):; """"""Transposes one or more pairs of indices of a Qobj.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be swapped. Returns; -------. sqobj : Qobj; The original Qobj with all named index pairs swapped with each other; """"""; dims = q_oper.dims; tensor_pairs = dims_idxs_to_tensor_idxs(dims, pairs). data = q_oper.data.toarray(). # Reshape into tensor indices; data = data.reshape(dims_to_tensor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/tensor.html:8371,Contract,Contracts,8371,docs/4.6/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/tensor.html,2,['Contract'],['Contracts']
Integrability," operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/changelog.html:3913,depend,dependent,3913,docs/4.3/changelog.html,https://qutip.org,https://qutip.org/docs/4.3/changelog.html,3,['depend'],['dependent']
Integrability," operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # norm collapse op data; self.n_ops_ind = [] # norm collapse op indices; self.n_ops_ptr = [] # norm collapse op indptrs. # holds executable strings for time-dependent collapse evaluation; self.col_expect_code = None; self.col_spmv_code = None. # hold stuff for function list based time dependence; self.h_td_inds = []; self.h_td_data = []; self.h_td_ind = []; self.h_td_ptr = []; self.h_funcs = None; self.h_func_args = None; self.c_funcs = None; self.c_func_args = None; ; # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver; . def _format_time(t, tt=None, ttt=None):; time_str = str(datetime.timedelta(seconds=t)); if tt is not None and t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:12595,depend,dependent,12595,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['depend'],['dependent']
Integrability," opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (data*ym).ravel('F'). # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; if issuper(rho0):; L_data = sp.csr_matrix((n, m), dtype=complex); else:; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))); else:; new_args[key] = args[key]; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:24713,depend,dependence,24713,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['depend'],['dependence']
Integrability," opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:16016,depend,dependent,16016,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,2,['depend'],['dependent']
Integrability," options=<qutip.solver.Options object at 0x2b22624eab00>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624eaac8>)[source]¶; Ca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:82748,depend,dependent,82748,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability," options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:86609,depend,dependent,86609,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability," or a subclass thereof, for; showing the progress of the simulation. Returns:; result: :class:`qutip.Result`; An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:60397,depend,dependent,60397,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['depend'],['dependent']
Integrability," or csr_matrix. Returns:degree – Array of integers giving the degree for each node (row). Return type:array. reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix; in Reverse-Cuthill McKee ordering. Since the input matrix must be; symmetric, this routine works on the matrix A+Trans(A) if the sym flag is; set to False (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters:; A (csc_matrix, csr_matrix) – Input sparse CSC or CSR sparse matrix format.; sym (bool {False, True}) – Flag to set whether input matrix is symmetric. Returns:perm – Array of permuted row and column indices. Return type:array. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines. References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row or column permutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if; necessary. Parameters:; A (sparse matrix) – Input matrix; perm_type (str {'row', 'column'}) – Type of permutation to generate. Returns:perm – Array of row or column permutations. Return type:array. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_. References; I. S. Duff, K. Kaya,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:190367,rout,routine,190367,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['rout'],"['routine', 'routines']"
Integrability," other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that su",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:1965,depend,dependence,1965,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['depend'],['dependence']
Integrability," packaging.version import parse as _parse_version; import numpy as np; from numpy.linalg import svd; import scipy; import scipy.sparse as sp; import scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger('qutip.steadystate'); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. def _rename_kwargs(function, names_pairs):; """"""; Return a wrapped version of `function` that rename any keyword; arguments from the first value of the pair, to the second.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for old, new in names_pairs:; if old in kwargs:; kwargs[new] = kwargs.pop(old); return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:1673,wrap,wrapped,1673,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['wrap'],['wrapped']
Integrability," parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:179438,depend,dependent,179438,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); ; for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compile new cython code if necessary; #; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + parameter_string + ')',; '<string>', 'exec'). exec(code, locals(), args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # configure time-dependent terms and setup ODE so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:11638,integrat,integrate,11638,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability," parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:26290,message,messages,26290,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['message'],['messages']
Integrability," period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:2619,depend,dependent,2619,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability," period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html:2720,depend,dependent,2720,docs/3.1.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability," processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-eseries.html:1798,depend,dependent,1798,docs/3.1.0/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html,2,['depend'],['dependent']
Integrability," progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:H : Qobj / list. System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj. Initial density matrix or state vector (ket). tlist : array_like. List of times for evaluating evolution. a_ops : list. Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list. List of operators for which to eva",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:64327,depend,dependence,64327,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependence']
Integrability," propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:111692,depend,dependent,111692,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability," provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:2586,integrat,integrated,2586,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['integrat'],['integrated']
Integrability," provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/roadmap.html:7662,wrap,wrapper,7662,docs/4.6/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html,2,['wrap'],['wrapper']
Integrability," psi, H_td(t, args), out). return out. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0]; H_td = H_list[0][1]; out = np.zeros(psi.shape[0],dtype=complex); spmvpy_csr(H.data, H.indices, H.indptr,; psi, H_td(t, args), out); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H_list[n][0]; H_td = H_list[n][1]; spmvpy_csr(H.data, H.indices, H.indptr, psi, H_td(t, args), out). return out. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); L = -1.0j * H; ; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:9188,integrat,integrator,9188,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability," psi0.full().ravel('F'); oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. if oper_evo:; initial_vector = psi0.full().ravel('F'); if not opt.rhs_with_state:; r = scipy.integrate.ode(_ode_oper_func_td); else:; r = scipy.integrate.ode(_ode_oper_func_td_with_state). else:; initial_vector = psi0.full().ravel(); if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; # TODO remove?: Looks like these are no longer in use; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi); #; # evaluate dU(t)/dt according to the master equation using the; #; # TODO cythonize these?; def _ode_oper_func_td(t, y, H_func, args):; H = H_func(t, args); return -1j * _ode_oper_func(t, y, H.data). def _ode_oper_func_td_with_state(t, y, H_func, args):; H = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:20881,integrat,integrate,20881,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability," qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; Sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2173,depend,dependent,2173,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,4,['depend'],['dependent']
Integrability," qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components; if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:4013,integrat,integrating,4013,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrating']
Integrability," qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.sparse import sp_reshape; from qutip.cy.sparse_utils import unit_row_norm; from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options, _solver_safety_check, config; from qutip.parallel import parallel_map, _default_kwargs; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list=[], args={}, options=None,; unitary_mode='batch', parallel=False,; progress_bar=None, _safe_mode=True,; **kwargs):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. unitary_mode = str ('batch', 'single'); Solve all basis vectors simulaneously ('batch') or individually; ('single'). parallel : bool {False, True}; Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """"",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/propagator.html:3449,depend,dependent,3449,docs/4.4/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/propagator.html,2,['depend'],['dependent']
Integrability," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; norm, dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:15316,integrat,integrator,15316,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state or oper; #; if psi0.isket:; initial_vector = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:18808,integrat,integrator,18808,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrator']
Integrability," range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; #; # setup integrator; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar; , dims=psi0.dims). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:15573,integrat,integrator,15573,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,3,['integrat'],['integrator']
Integrability," removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:1866,integrat,integration,1866,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,2,['integrat'],['integration']
Integrability," report to console or file. add_count(self, key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:44370,message,message,44370,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['message'],['message']
Integrability," required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of kets. The Floquet modes as kets at time \(t\). floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. tlist : array. The list of times at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. T : float. The period of the time-dependence of the hamiltonian. args : dictionary. dictionary with variables required to evaluate H. Returns:output : nested list. A nested list of Floquet modes as kets for each time in tlist. floquet_modes_t_lookup(f_modes_table_t, t, T)¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters:f_modes_table_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:50163,depend,dependence,50163,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['depend'],['dependence']
Integrability," reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Running String-Based Time-Dependent Problems using Parfor¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In this section we discuss running string-based time-dependent problems using the qutip.parfor function. As the qutip.mcsolve function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the qutip.mesolve function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the rhs_filename property of the qutip.Options class. Because the qutip.parfor function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash. To get around this problem you can call the qutip.rhs_generate function to compile simulation into C code before calling parfor. You must then set the qutip.Odedata object rhs_reuse=True for all solver calls inside the parfor loop that indicates that a valid C code file already exists",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:19306,depend,dependent,19306,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:119714,depend,dependent,119714,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj. Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: qutip.solver.SolverResult. An instance of the class qutip.solver.SolverResult. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, **kwargs)[source]¶; Solve the stochastic Schrödinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters:H : qutip.Qobj. System Hamiltonian. psi0 : qutip.Qobj. Initial state vector (ket). times : list / array. List of times for \(t\). Must be uniformly spaced. sc_ops : list of qutip.Qobj. List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj. Single operator or list of operators for which to evaluate; expectation values. kwargs : dictionary. Optional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns:output: qutip.solver.SolverResult. An instance of the class qutip.solver.SolverResult. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters:H : qutip.Qobj. System Hamiltonian. rho0 : qutip.Qobj. Initial density matrix. times : list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:77204,depend,depending,77204,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['depending']
Integrability," scipy.linalg as la; from scipy.sparse.linalg import (; use_solver, splu, spilu, eigs, LinearOperator, gmres, lgmres, bicgstab,; ); from qutip.qobj import Qobj, issuper, isoper. from qutip.superoperator import liouvillian, vec2mat, spre; from qutip.sparse import sp_permute, sp_bandwidth, sp_profile; from qutip.cy.spmath import zcsr_kron; from qutip.graph import weighted_bipartite_matching; from qutip import (mat2vec, tensor, identity, operator_to_vector); import qutip.settings as settings; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode. import qutip.logging_utils; logger = qutip.logging_utils.get_logger(); logger.setLevel('DEBUG'). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import (mkl_splu, mkl_spsolve). def _eat_kwargs(function, names):; """"""; Return a wrapped version of `function` that simply removes any keyword; arguments with one of the given names.; """"""; @functools.wraps(function); def out(*args, **kwargs):; for name in names:; if name in kwargs:; del kwargs[name]; return function(*args, **kwargs); return out. # From SciPy 1.4 onwards we need to pass the `callback_type='legacy'` argument; # to gmres to maintain the same behaviour we used to have. Since this should; # be the default behaviour, we use that in the main code and just ""eat"" the; # argument if passed to a lower version of SciPy that doesn't know about it.; # Similarly, SciPy < 1.1 does not recognise the `atol` keyword.; #; # Respective checks can be removed when SciPy version requirements are raised. if _parse_version(scipy.__version__) < _parse_version(""1.1""):; gmres = _eat_kwargs(gmres, ['atol', 'callback_type']); lgmres = _eat_kwargs(lgmres, ['atol']); bicgstab = _eat_kwargs(bicgstab, ['atol']); elif _parse_version(scipy.__version__) < _parse_version(""1.4""):; gmres = _eat_kwargs(gmres, ['callback_type']). def _empty_info_dict():; def_info = {'perm': [], 'solution_time': None,; 'residual_norm': None,; 'solver': None, 'method': None}. return def_info. def _",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:3485,wrap,wraps,3485,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['wrap'],['wraps']
Integrability," scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gates.; Functions for quantum process tomography.; Window icons are now set for Ubuntu application launcher.; The propagator function can now take a list of times as argument, and returns a list of corresponding propagators. Bug Fixes:¶. mesolver now correctly uses the user defined rhs_filename in Odeoptions().; rhs_generate() now handles user defined filenames properly.; Density matrix returned by propagator_steadystate is now Hermitian.; eseries_value returns real list if all imag parts are zero.; mcsolver now gives correct results for strong damping rates.; Odeoptions now prints mc_avg correctly",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:9696,depend,dependent,9696,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['depend'],['dependent']
Integrability," simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2247,integrat,integrate,2247,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,2,['integrat'],['integrate']
Integrability," single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:99741,depend,dependent,99741,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability," solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursive",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:122619,depend,dependent,122619,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=Options(),; progress_bar=BaseProgressBar(), _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the `H` or `c_ops`; elements. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be callback; functions that takes two arguments, time and `args`, and returns the; Ham",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mesolve.html:3505,integrat,integrating,3505,docs/4.4/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mesolve.html,1,['integrat'],['integrating']
Integrability," standard package management system. In addition to the required dependencies, it is also strongly recommended that you install the texlive-latex-extra package:; sudo apt-get install texlive-latex-extra. Manual installation of dependencies¶; First install the required dependencies using:; sudo apt-get install python-dev cython python-setuptools python-nose; sudo apt-get install python-numpy python-scipy python-matplotlib. Then install QuTiP from source following the instructions given above.; Alternatively (or additionally), to install a Python 3 environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipyth",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:6163,depend,dependencies,6163,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['depend'],['dependencies']
Integrability," states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj inst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:8460,depend,dependent,8460,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['depend'],['dependent']
Integrability," stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:102188,depend,dependent,102188,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability," string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]¶; Clear counts, timings and messages from all sections. report(self, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(self, value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:45466,message,messages,45466,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['message'],['messages']
Integrability," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html:2442,integrat,integrates,2442,docs/4.4/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html,4,['integrat'],['integrates']
Integrability," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2573,integrat,integrates,2573,docs/4.7/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html,2,['integrat'],['integrates']
Integrability," t)']. In [78]: H_td = [H0, H1]. In [79]: Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; In [80]: opts = Options(rhs_reuse=True). In [81]: rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; In [82]: def task(args):; ....: m, eps = args; ....: p_mat_m = np.zeros(len(A_list)); ....: for n, A in enumerate(A_list):; ....: # change args sent to solver, w is really a constant though.; ....: Hargs = {'w': w, 'eps': eps,'A': A}; ....: U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; ....: rho_ss = propagator_steadystate(U); ....: p_mat_m[n] = expect(sn, rho_ss); ....: return [m, p_mat_m]; ....: . Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:23966,rout,routine,23966,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['rout'],['routine']
Integrability," take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend y",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:9417,depend,dependencies,9417,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['depend'],['dependencies']
Integrability," that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(self, file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check(self)[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(self, new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:100912,message,message,100912,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['message'],['message']
Integrability," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:51122,message,message,51122,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,8,['message'],['message']
Integrability," the Hamiltonian; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|. # Create the photon operator; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). # Define collapse operators; c_ops = []; # Cavity decay rate; kappa = 1.5; c_ops.append(sqrt(kappa) * a). # Atomic decay rate; gamma = 6 # decay rate; # Use Rb branching ratio of 5/9 e->u, 4/9 e->g; c_ops.append(sqrt(5*gamma/9) * sigma_ue); c_ops.append(sqrt(4*gamma/9) * sigma_ge). # Define time vector; t = linspace(-15, 15, 100). # Define initial state; psi0 = tensor(basis(N, 0), ustate). # Define states onto which to project; state_GG = tensor(basis(N, 1), ground); sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). # Set up the time varying Hamiltonian; g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do:; def H1_coeff(t, args):; return 9 * exp(-(t / 5.) ** 2). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve):; H = [H0,[H1,H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; >>> output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:7824,depend,dependent,7824,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:12043,depend,dependent,12043,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,4,['depend'],['dependent']
Integrability," the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [42]: args = {'A': 9, 'sigma': 5}. In [43]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:12666,depend,dependent,12666,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['depend'],['dependent']
Integrability," the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; In [55]: S = Cubic_Spline(t[0], t[-1], noisy_data). In [56]: plt.figure(); Out[56]: <Figure size 640x480 with 0 Axes>. In [57]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:16375,depend,dependent,16375,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:24057,message,messages,24057,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,1,['message'],['messages']
Integrability," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type; elif isinstance(H[ii], list):; _temp_dims = H[ii][0].dims; _temp_type = H[ii][0].type; else:; raise Exception('Inv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23549,message,messages,23549,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['message'],['messages']
Integrability," the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/solver.html:24057,message,messages,24057,docs/4.3/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/solver.html,1,['message'],['messages']
Integrability," the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:94984,depend,dependence,94984,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependence']
Integrability," the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the solver. progress_bar : BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result: qutip.Result. An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:58554,depend,dependent,58554,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability," the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the solver. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result: qutip.Result. An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:47850,depend,dependent,47850,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability," the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters:H : qutip.Qobj. System Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0 : qutip.Qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). c_ops : list of qutip.Qobj. single collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_ops : list of qutip.Qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the solver. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns:result: qutip.Result. An instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=None, args={}, options=None, progress_bar=True, map_func=None, map_kwargs=None, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation va",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:58554,depend,dependent,58554,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability," the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-tensor.html:11698,contract,contracting,11698,docs/4.4/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-tensor.html,2,['contract'],"['contracting', 'contraction']"
Integrability," the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` or the Qobj elements in `c_ops` are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form. **Time-dependent operators**. For time-dependent problems, `H` and `c_ops` can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (:class:`qutip.qobj`) at the first element and where; the second element is either a string (*list string format*), a callback; function (*list callback format*) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (*list; array format*) which specifies the value of the coefficient to the; corresponding operator for each value of t in `tlist`. Alternatively, `H` (but not `c_ops`) can be a callback function with the; signature `f(t, args) -> Qobj` (*callback format*), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used. *Examples*. H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]. H = [[H0, f0_t], [H1, f1_t]]. where f0_t and f1_t are python functions with signature f_t(t, args). H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:4195,depend,dependent,4195,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,4,['depend'],['dependent']
Integrability," the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time-dependent scalar:. - Python function; - string; - array. For function format, the function signature must be; ``f(t: float, args: dict) -> complex``, for example. .. code-block:: python. def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:5067,depend,dependence,5067,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependence']
Integrability," then renormalizing to obtain a valid density; operator. Parameters:; method : str; Algorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns:; oper : qobj; A valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:; inplace : bool; Do an in-place normalization. norm : str; Requested norm for states / operators. sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms. tol : float; Tolerance used by sparse eigensolver. maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns:; oper : qobj; Normalized quantum object if not in-place,; else None. eseries¶. class eseries(q=array([], dtype=object), s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes:; ampl : ndarray; Array of amplitudes for exponential series. rates : ndarray; Array of rates for exponential series. dims : list; Dimensions of exponential series components. shape : list; Shape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters:; wlist : array_like; Array/list of frequenies. Returns:; val_list : ndarray; Values of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters:; tlist : ndarray; Tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:16525,depend,dependent,16525,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['depend'],['dependent']
Integrability," these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimizatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:81715,wrap,wrapper,81715,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['wrap'],['wrapper']
Integrability," this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be paste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14536,depend,dependent,14536,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k); for name, value in args.items():; if is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:19083,depend,dependent,19083,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['depend'],['dependent']
Integrability," time-dependent "" +; ""Hamiltonian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). # loop over all collapse operators; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec. if isoper(c):; cdc = c.dag() * c; Lconst += spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); elif issuper(c):; Lconst += c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). elif isinstance(c_spec, list):; c = c_spec[0]; c_coeff = c_spec[1]. if isoper(c):; cdc = c.dag() * c; L = spre(c) * spost(c.dag()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif issuper(c):; L = c; else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Liouvillian (expected operator or "" +; ""superoperator)""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected string format)""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms +; # collapse operators); n_L_terms = len(Ldata); ; # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:19701,depend,dependent,19701,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,2,['depend'],['dependent']
Integrability," time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; ""superoperator)""). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); if opt.rhs_with_state:; r = scipy.integrate.ode(drho_list_td_with_state); else:; r = scipy.integrate.ode(drho_list_td); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(L_list, args). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master equation using the; # [Qobj, function] style time dependence API; #; def drho_list_td(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, args). return L * rho. def drho_list_td_with_state(t, rho, L_list, args):. L = L_list[0][0] * L_list[0][1](t, rho, args); for n in range(1, len(L_list)):; #; # L_args[n][0] = the sparse data for a Qobj in super-operator form; # L_args[n][1] = function callback giving the coefficient; #; if L_list[n][2]:; L = L + L_list[n][0] * (L_list[n][1](t, rho, args)) ** 2; else:; L = L + L_list[n][0] * L_list[n][1](t, rho, args). return L * rho. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-string format for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:15665,depend,dependence,15665,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependence']
Integrability," times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptionsPhoto(True, H=H, state0=rho0, times=times,; c_ops=c_ops, sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.m_ops is None:; sso.m_ops = [op * 0 for op in sso.sc_ops]; if not isinstance(sso.dW_factors, list):; sso.dW_factors = [1] * len(sso.sc_ops); elif len(sso.dW_factors) != len(sso.sc_ops):; raise Exception(""The len of dW_factors is not the same as sc_ops""). sso.solver_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:29012,depend,depend,29012,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,6,['depend'],['depend']
Integrability," tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31737,depend,dependent,31737,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['depend'],['dependent']
Integrability," to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:12067,depend,dependent,12067,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['depend'],['dependent']
Integrability," to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log).; You will need to use the commit message to do this; the hashes that GitHub reports will probably not be the same as how they appear locally.; Find the first 7 characters of each of the hashes.; Cherry-pick these all in one go by git cherry-pick <hash1> <hash2> ... <hash10>, where <hash1> is the oldest. If any of the cherry-picks have merge conflicts, first verify that you are cherry-picking in order from oldest to newest.; If you still have merge conflicts, you will either need to manually fix them (if it is a very simple fix), or else you will need to find which additional PR this patch depends on, and restart the bug fix process including this additional patch.; This generally should not happen if you are sticking to very small bug fixes; if the fixes had far-reaching changes, a new minor release may be more appropriate. Change the VERSION file by bumping the last number up by one (double-digit numbers are fine, so 4.6.10 comes after 4.6.9), and commit the change.; Push this branch to your fork, and make a pull request against the release branch.; On ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:9160,message,message,9160,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['message'],['message']
Integrability," to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import quti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:3913,wrap,wrapper,3913,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['wrap'],['wrapper']
Integrability," to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:62474,depend,dependent,62474,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependent']
Integrability," to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:255494,depend,dependencies,255494,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependencies']
Integrability," user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:7361,depend,dependent,7361,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['depend'],['dependent']
Integrability," user.; # type : flag for the type of coeff; class EvoElement:; def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; """"""self.qobj = list_[0]; self.get_coeff = list_[1]; self.coeff = list_[2]; self.type = list_[3]""""""; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; *Examples*; tlist = np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:6008,depend,dependent,6008,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability," value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all operato",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:23931,message,messages,23931,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,1,['message'],['messages']
Integrability," value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; else:; raise Exception('Invalid td-list element.'); # Check all operators in list; for ii in range(len(H)):; if isinstance(H[ii], Qobj):; _temp_dims = H[ii].dims; _temp_type = H[ii].type;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:23423,message,messages,23423,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['message'],['messages']
Integrability," value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ; output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt), ; self.name)); ; # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l); ; # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l); . def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None; . def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type ; else:; raise Exception('Invalid td-list element.'); # Check all op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/solver.html:23931,message,messages,23931,docs/4.3/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/solver.html,1,['message'],['messages']
Integrability," value; ; value : int; Initial value of the count, or added to an existing count; ; section: string or `class` : _StatsSection; Section which to add the count to.; If None given, the default (first) section will be used; """"""; ; self._get_section(section).add_count(key, value); ; [docs] def add_timing(self, key, value, section=None):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; ; Parameters; ----------; key : string; key for the section.timings dictionary; reusing a key will result in numerical addition of value; ; value : int; Initial value of the timing, or added to an existing timing; ; section: string or `class` : _StatsSection; Section which to add the timing to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_timing(key, value); ; [docs] def add_message(self, key, value, section=None, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; ; Parameters; ----------; key : string; key for the section.messages dictionary; reusing a key will result in concatenation of value; ; value : int; Initial value of the message, or added to an existing message; ; sep : string; Message will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solve",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:17730,message,message,17730,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['message']
Integrability," values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:; H : qutip.Qobj; System Hamiltonian. psi0 : qutip.Qobj; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or list or array of collapse; operators. e_ops : array_like; single operator or list or array of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns:; results : qutip.solver.Result; Object storing all results from the simulation. .. note::; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:61873,depend,dependent,61873,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:5170,depend,dependent,5170,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,4,['depend'],"['depend', 'dependent']"
Integrability," values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:7733,depend,dependent,7733,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,18,['depend'],"['depend', 'dependent']"
Integrability," vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. composite(*args)[source]¶; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:42165,contract,contracted,42165,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['contract'],['contracted']
Integrability," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:9890,depend,dependent,9890,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,10,['depend'],"['dependence', 'dependent']"
Integrability," was given in place of; operators for which to calculate the expectation values. """"""; # check whether c_ops or e_ops is is a single operator; # if so convert it to a list containing only that operator; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if _safe_mode:; _solver_safety_check(H, rho0, c_ops, e_ops, args); ; if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). # check if rho0 is a superoperator, in which case e_ops argument should; # be empty, i.e., e_ops = []; if issuper(rho0) and not e_ops == []:; raise TypeError(""Must have e_ops = [] when initial condition rho0 is"" +; "" a superoperator.""). # convert array based time-dependence to string format; H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, c_ops). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(); ; #check if should use OPENMP; check_use_openmp(options); ; ; res = None. #; # dispatch the appropriate solver; #; if ((c_ops and len(c_ops) > 0); or (not isket(rho0)); or (isinstance(H, Qobj) and issuper(H)); or (isinstance(H, list) and; isinstance(H[0], Qobj) and issuper(H[0]))):. #; # we have collapse operators, or rho0 is not a ket,; # or H is a Liouvillian; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:9697,depend,dependent,9697,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['depend'],['dependent']
Integrability," which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILU : str, optional, default = ‘smilu_2’. Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns:lu : object. Returns a SuperLU object representing iLU preconditioner. info : dict, optional. Dictionary containing solver-specific information. Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters:H : qobj or list. Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). t : float or array-like. Time or list of times for which to evaluate the propagator. c_op_list : list. List of qobj collapse operators. args : list/array/dictionary. Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : qutip.Options. with options for the ODE solver. unitary_mode = str (‘batch’, ‘single’). Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallel : bool {False, True}. Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the stead",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:107743,depend,dependent,107743,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability," will be prefixed with this string when concatenating; ; section: string or `class` : _StatsSection; Section which to add the message to.; If None given, the default (first) section will be used; """""" ; self._get_section(section).add_message(key, value, sep=sep); ; [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds; ; Parameters; ----------; value : float; Time in seconds to complete the solver section; ; section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value; ; [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format; ; Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """"""; ; if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""); ; if self.header:; output.write(""{}\n{}\n"".format(self.header, ; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output); ; if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))); ; [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:19161,message,messages,19161,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['messages']
Integrability," with 0 Axes>. In [57]: plt.plot(t, func(t)); Out[57]: [<matplotlib.lines.Line2D at 0x1a2391b8d0>]. In [58]: plt.plot(t, noisy_data, 'o'); Out[58]: [<matplotlib.lines.Line2D at 0x1a2391b3c8>]. In [59]: plt.plot(t, S(t), lw=2); Out[59]: [<matplotlib.lines.Line2D at 0x1a26afe7b8>]. In [60]: plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:16387,depend,dependent,16387,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability," with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:3918,depend,dependent,3918,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability," with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:60924,depend,dependent,60924,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,6,['depend'],['dependent']
Integrability," you wrote in the first step is visible.; Find the branch of the release that you will be modifying.; This should already exist on the qutip/qutip repository, and be called qutip-<major>.<minor>.X (e.g. qutip-4.6.X).; If you cannot see it, run git fetch upstream to update all the branch references from the main repository.; Checkout a new private branch, starting from the head of the release branch (git checkout -b prepare-qutip-4.6.1 upstream/qutip-4.6.X).; You can call this branch whatever you like (in the example it is prepare-qutip-4.6.1), because it will only be used to make a pull request.; Cherry-pick all the commits that will be added to this release in order, including your PR that wrote the new changelog entries (this will be the last one you cherry-pick).; You will want to use git log to find the relevant commits, going from oldest to newest (their “age” is when they were merged into master, not when the PR was first opened).; The command is slightly different depending on which merge strategy was used for a particular PR:. “merge”: you only need to find one commit though the log will have included several; there will be an entry in git log with a title such as “Merge pull request #1000 from <…>”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick --mainline 1 <hash>.; “squash and merge”: there will only be a single commit for the entire PR.; Its name will be “<Name of the pull request> (#1000)”.; Note the first 7 characters of its hash.; Cherry-pick this by git cherry-pick <hash>.; “rebase and merge”: this is the most difficult, because there will be many commits that you will have to find manually, and cherry-pick all of them.; Go to the GitHub page for this PR, and go to the “Commits” tab.; Using your local git log (you may find git log --oneline useful), find the hash for every single commit that is listed on the GitHub page, in order from oldest to newest (top-to-bottom in the GitHub view, which is bottom-to-top in git log",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:8110,depend,depending,8110,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['depend'],['depending']
Integrability,""" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, randint; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; from qutip.fastsparse import csr2fast; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:2256,integrat,integrate,2256,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['integrat'],['integrate']
Integrability,"""""; self._get_section(section).add_message(key, value, sep=sep). [docs] def set_total_time(self, value, section=None):; """"""; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters; ----------; value : float; Time in seconds to complete the solver section. section : string or `class` : _StatsSection; Section which to set the total_time for; If None given, the total_time for complete solve is set; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""). if section is None:; self.total_time = value; else:; sect = self._get_section(section); sect.total_time = value. [docs] def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters; ----------; output : stream; file or console stream - anything that support write - where; the output will be written; """""". if not hasattr(output, 'write'):; raise TypeError(""output must have a write method""). if self.header:; output.write(""{}\n{}\n"".format(self.header,; (""=""*len(self.header)))); for name, sect in self.sections.items():; sect.report(output). if self.total_time is not None:; output.write(""\nSummary\n-------\n""); output.write(""{}\t solver total time\n"".format(; _format_time(self.total_time))). [docs] def clear(self):; """"""; Clear counts, timings and messages from all sections; """"""; for sect in self.sections.values():; sect.clear(); self.total_time = None. class _StatsSection(object):; """"""; Not intended to be directly instantiated; This is the type for the SolverStats.sections values. The method p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:21512,message,messages,21512,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['message'],['messages']
Integrability,"""""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don't need to check for tensor idxs versus dims idxs here,; # as column- versus row-stacking will never move an index for the; # vectorized operator spaces all the way from the left to the right.; l_mtx_dims, r_mtx_dims = map(np.prod, map(flatten, contracted_dims)). # Reshape back into a 2D matrix.; qmtx = qtens.reshape((l_mtx_dims, r_mtx_dims)). # Return back as a qobj.; return Qobj(qmtx, dims=contracted_dims, superrep=qobj.superrep). import qutip.states. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/tensor.html:9283,contract,contracted,9283,docs/4.7/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html,2,['contract'],['contracted']
Integrability,"""""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:56726,depend,dependencies,56726,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['depend'],['dependencies']
Integrability,""". name = ""rhs"" + str(os.getpid()) + str(config.cgen_num); config.tdname = name; cgen = Codegen(H_inds, H_tdterms, config.h_td_inds, args,; C_inds, C_tdterms, config.c_td_inds, type='mc',; config=config); cgen.generate(name + "".pyx""). elif config.tflag in [2, 20, 22]:; # PYTHON LIST-FUNCTION BASED TIME-DEPENDENCE; # ------------------------------------------. # take care of Hamiltonian; if config.tflag == 2:; # constant Hamiltonian, at least one function based collapse; # operators; H_inds = np.array([0]); H_tdterms = 0; len_h = 1; else:; # function based Hamiltonian; H_inds = np.arange(len(H)); H_td_inds = np.array(h_stuff[1]); H_const_inds = np.setdiff1d(H_inds, H_td_inds); config.h_funcs = np.array([H[k][1] for k in H_td_inds]); config.h_func_args = args; Htd = np.array([H[k][0] for k in H_td_inds], dtype=object); config.h_td_inds = np.arange(len(Htd)); H = np.sum(H[k] for k in H_const_inds). # take care of collapse operators; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[1]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds; config.c_funcs = np.zeros(config.c_num, dtype=FunctionType); for k in config.c_td_inds:; config.c_funcs[k] = c_ops[k][1]; config.c_func_args = args. # combine constant collapse terms with constant H and construct data; for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); Htd = np.array([Htd[j].tidyup(options.atol); for j in config.h_td_inds], dtype=object); # setup constant H terms data; config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. # setup td H terms data; config.h_td_data = np.array(; [-1.0j * Htd[k].data.data for k in config.h_td_inds]); config.h_td_ind = np.array(; [Htd[k].data.indi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:38640,depend,dependent,38640,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability,"""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:26019,message,messages,26019,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['message'],['messages']
Integrability,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:53920,depend,dependencies,53920,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['depend'],['dependencies']
Integrability,"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPORTS; # We do a few imports here to avoid circular dependencies.; from qutip.eseries import eseries; import qutip.superop_reps as sr; import qutip.tensor as tensor; import qutip.operators as ops; import qutip.metrics as mts; import qutip.states; import qutip.superoperator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/qobj.html:53840,depend,dependencies,53840,docs/4.1/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/qobj.html,1,['depend'],['dependencies']
Integrability,"""version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:9746,depend,dependent,9746,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,2,['depend'],"['dependence', 'dependent']"
Integrability,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.superoperator import vec2mat; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, psi0, tlist, e_ops=[], args={}, options=None,; progress_bar=None,; _safe_mode=True):; """"""; Schrodinger eq",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:2242,integrat,integrate,2242,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:2242,integrat,integrate,2242,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a call",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:3499,integrat,integrate,3499,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/sesolve.html:2242,integrat,integrate,2242,docs/4.1/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm; import qutip.settings as qset; from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config, _solver_safety_check; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state,; spmvpy_csr); from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup. from qutip.ui.progressbar import BaseProgressBar; from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. if qset.has_openmp:; from qutip.cy.openmp.parfuncs import cy_ode_rhs_openmp. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops=[], args={}, options=None,; progress_bar=BaseProgressBar(),; _safe_mode=True):; """"""; Schrodinger equation evolution of a state vector for a given Hami",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:2242,integrat,integrate,2242,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2870,message,message,2870,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,6,['message'],['message']
Integrability,"# args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html:8627,integrat,integrate,8627,docs/4.0.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, args). return H * psi. def psi_list_td_with_state(t, psi, H_list_and_args):. H_list = H_list_and_args[0]; args = H_list_and_args[1]. H = H_list[0][0] * H_list[0][1](t, psi, args); for n in range(1, len(H_list)):; #; # args[n][0] = the sparse data for a Qobj in operator form; # args[n][1] = function callback giving the coefficient; #; H = H + H_list[n][0] * H_list[n][1](t, psi, args). return H * psi. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution) using; # a constant Hamiltonian.; #; def _sesolve_const(H, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver; """"""; if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator.; #; initial_vector = psi0.full().ravel(); r = scipy.integrate.ode(cy_ode_rhs); L = -1.0j * H; r.set_f_params(L.data.data, L.data.indices, L.data.indptr) # cython RHS; r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step). r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt,; progress_bar, norm, dims=psi0.dims). #; # evaluate dpsi(t)/dt [not used. using cython function is being used instead]; #; def _ode_psi_func(t, psi, H):; return H * psi. # -----------------------------------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:9720,integrat,integrate,9720,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"# constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regressio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:39711,depend,dependence,39711,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['depend'],['dependence']
Integrability,"# first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/correlation.html:14702,depend,dependent,14702,docs/4.3/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/correlation.html,3,['depend'],['dependent']
Integrability,"# first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order cohe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:14702,depend,dependent,14702,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,3,['depend'],['dependent']
Integrability,"# qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe.; *Examples*; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:6622,depend,dependent,6622,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability,"##########################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """""". __all__ = ['version_table', 'parfor', 'plot_animation', 'parallel_map']. from qutip.ui.progressbar import BaseProgressBar. from IPython.parallel import Client; from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = {""QuTiP"": qutip.__version__,; ""Numpy"": numpy.__version__,; ""SciPy"": scipy.__version__,; ""matplotlib"": matplotlib.__version__,; ""Cython"": Cython.__version__,; ""Python"": sys.version,; ""IPython"": IPython.__version__,; ""OS"": ""%s [%s]"" % (os.name, sys.platform); }. for name in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, packages[name]). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgress",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:4307,depend,dependencies,4307,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['depend'],['dependencies']
Integrability,"################################################. __all__ = ['brmesolve', 'bloch_redfield_solve', 'bloch_redfield_tensor']. import numpy as np; import scipy.integrate; import scipy.sparse as sp; from qutip.qobj import Qobj, isket; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.solver import Result; from qutip.superoperator import liouvillian; from qutip.cy.spconvert import arr_coo2fast. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=[],; args={}, options=Options(),; _safe_mode=True):; """"""; Solve the dynamics for a system using the Bloch-Redfield master equation. .. note::. This solver does not currently support time-dependent Hamiltonians. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to bath degrees of freedom. e_ops : list of :class:`qutip.qobj` / callback function; List of operators for which to evaluate expectation values. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. args : *dictionary*; Placeholder for future implementation, kept for API consistency. options : :class:`qutip.solver.Options`; Options for the solver. Returns; -------. result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safety_check(H, psi0, a_ops, e_ops, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html:3034,depend,dependent,3034,docs/4.0.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/bloch_redfield.html,2,['depend'],['dependent']
Integrability,"################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; import warnings; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If eithe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:3053,depend,depending,3053,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['depend'],['depending']
Integrability,"################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; import warnings; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_cmode, dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.settings import debug; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=Options(),; progress_bar=BaseProgressBar(), _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mesolve.html:3040,depend,depending,3040,docs/4.4/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mesolve.html,1,['depend'],['depending']
Integrability,"##########################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:4270,integrat,integrating,4270,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrating']
Integrability,"##########################################; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['CavityQEDCompiler']. [docs]class CavityQEDCompiler(GateCompiler):; """"""; Decompose a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.DispersiveCavityQED.set_up_params` for the definition. global_phase: float, optional; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate.; """"""; def __init__(self, N, params, pulse_dict, global_phase=0.):; super(CavityQEDCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.wq = np.sqrt(self.params[""eps""]**2 + self.params[""delta""]**2); self.Delta = self.wq - self.params[""w0""]; self.global_phase = global_phase. [docs] def rz_compiler(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html:3120,rout,routine,3120,docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/cavityqedcompiler.html,2,['rout'],['routine']
Integrability,"###############################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:3032,message,message,3032,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,5,['message'],['message']
Integrability,"##########################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:3046,message,message,3046,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,3,['message'],['message']
Integrability,"####################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools. from qutip.qobj import Qobj; from qutip.rhs_generate import rhs_clear; from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list, args=None, options=None, sparse=False,; progress_bar=None):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """""". if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html:4351,depend,dependent,4351,docs/3.1.0/modules/qutip/propagator.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html,1,['depend'],['dependent']
Integrability,"######; import numpy as np. from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.compiler import GateCompiler, Instruction. __all__ = ['SpinChainCompiler']. [docs]class SpinChainCompiler(GateCompiler):; """"""; Compile a :class:`.QubitCircuit` into; the pulse sequence for the processor. Parameters; ----------; N: int; The number of qubits in the system. params: dict; A Python dictionary contains the name and the value of the parameters.; See :meth:`.SpinChain.set_up_params` for the definition. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; N: int; The number of the component systems. params: dict; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dict; A map between the pulse label and its index in the pulse list. gate_compiler: dict; The Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string; ""linear"" or ""circular"" for two sub-classes. global_phase: bool; Record of the global phase change and will be returned.; """"""; def __init__(self, N, params, pulse_dict, setup=""linear"", global_phase=0.):; super(SpinChainCompiler, self).__init__(; N=N, params=params, pulse_dict=pulse_dict); self.gate_compiler.update({; ""ISWAP"": self.iswap_compiler,; ""SQRTISWAP"": self.sqrtiswap_compiler,; ""RZ"": self.rz_compiler,; ""RX"": self.rx_compiler,; ""GLOBALPHASE"": self.globalphase_compiler; }); self.global_phase ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html:3156,rout,routine,3156,docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/spinchaincompiler.html,2,['rout'],['routine']
Integrability,"%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """"""; def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array. For function format, the function signature must be f(t, args).; *Examples*; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html:6251,depend,dependent,6251,docs/4.5/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability,"', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pai",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:4595,depend,dependence,4595,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependence']
Integrability,"', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:5161,depend,dependent,5161,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:201140,depend,dependent,201140,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['dependent']
Integrability,"',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'tau', 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any ord",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:5452,depend,dependent,5452,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'tau', 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:4841,depend,dependent,4841,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html:5071,depend,dependent,5071,docs/3.0.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html,4,['depend'],['dependent']
Integrability,"'wbm'); ss_args['info']['wbm_time'] = _wbm_end-_wbm_start; if settings.debug:; wbm_band = sp_bandwidth(L)[0]; logger.debug('WBM bandwidth: %i' % wbm_band). if ss_args['use_rcm']:; if settings.debug:; logger.debug('Calculating Reverse Cuthill-Mckee ordering...'); _rcm_start = time.time(); perm2 = reverse_cuthill_mckee(L); _rcm_end = time.time(); rev_perm = np.argsort(perm2); L = sp_permute(L, perm2, perm2, form); ss_args['info']['perm'].append('rcm'); ss_args['info']['rcm_time'] = _rcm_end-_rcm_start; if settings.debug:; rcm_band = sp_bandwidth(L)[0]; rcm_pro = sp_profile(L)[0]; logger.debug('RCM bandwidth: %i' % rcm_band); logger.debug('Bandwidth reduction factor: %f' %; (old_band/rcm_band)); logger.debug('Profile reduction factor: %f' %; (old_pro/rcm_pro)); L.sort_indices(); return L, perm, perm2, rev_perm, ss_args. def steady(L, maxiter=10, tol=1e-12, itertol=1e-15, method='solve',; use_precond=False):; """"""; Deprecated. See steadystate instead.; """"""; message = ""steady has been deprecated, use steadystate instead""; warnings.warn(message, DeprecationWarning); return steadystate(L, [], maxiter=maxiter, tol=tol,; use_precond=use_precond). def _steadystate_direct_sparse(L, ss_args):; """"""; Direct solver that uses scipy sparse matrices; """"""; if settings.debug:; logger.debug('Starting direct LU solver.'). dims = L.dims[0]; n = int(np.sqrt(L.shape[0])); b = np.zeros(n ** 2, dtype=complex); b[0] = ss_args['weight']. if ss_args['solver'] == 'mkl':; has_mkl = 1; else:; has_mkl = 0. ss_lu_liouv_list = _steadystate_LU_liouvillian(L, ss_args, has_mkl); L, perm, perm2, rev_perm, ss_args = ss_lu_liouv_list; if np.any(perm):; b = b[np.ix_(perm,)]; if np.any(perm2):; b = b[np.ix_(perm2,)]. if ss_args['solver'] == 'scipy':; ss_args['info']['permc_spec'] = ss_args['permc_spec']; ss_args['info']['drop_tol'] = ss_args['drop_tol']; ss_args['info']['diag_pivot_thresh'] = ss_args['diag_pivot_thresh']; ss_args['info']['fill_factor'] = ss_args['fill_factor']; ss_args['info']['ILU_MILU'] = ss_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:13996,message,message,13996,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['message'],['message']
Integrability,"() * a], args={'A': 9, 'sigma': 5}). (png, hires.png, pdf). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). (png, hires.png, pdf). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:12139,depend,dependent,12139,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"() for op in sso.preops]; [op.compile() for op in sso.postops]; [op.compile() for op in sso.preops2]; [op.compile() for op in sso.postops2]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. sso.solver_obj = PmSMESolver; sso.solver_name = ""smesolve_"" + sso.solver; res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isket(rho0):; rho0 = ket2dm(rho0). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:28810,depend,dependent,28810,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,5,['depend'],['dependent']
Integrability,"()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif hasattr(H_k[1], '__call__'):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html:6654,depend,dependent,6654,docs/4.5/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/rhs_generate.html,3,['depend'],['dependent']
Integrability,"()) - 0.5 * spre(cdc) \; - 0.5 * spost(cdc); c_coeff = ""("" + c_coeff + "")**2""; elif c.issuper:; L = c; else:; raise TypeError(msg + ""expected operator or superoperator""). Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); Lcoeff.append(c_coeff). else:; raise TypeError(msg + ""expected string format""). # add the constant part of the lagrangian; if Lconst != 0:; Ldata.append(Lconst.data.data); Linds.append(Lconst.data.indices); Lptrs.append(Lconst.data.indptr); Lcoeff.append(""1.0""). # the total number of liouvillian terms (hamiltonian terms + collapse; # operators); n_L_terms = len(Ldata). cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname +; ' import cy_td_ode_rhs', '<string>', 'exec'); exec(code, globals()). config.tdfunc = cy_td_ode_rhs. if cleanup:; try:; os.remove(config.tdname + "".pyx""); except:; pass. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(H_k[1], (FunctionType,; BuiltinFunctionType, partial)):; h_func.append(k); elif isinstance(H_k[1], str):; h_str.append(k); elif isinstance(H_k[1], Cubic_Spline):; h_obj.append(k); elif isinstance(H_k[1], np.ndarray):; h_str.append(k); else:; raise TypeError(""Incorrect hamiltonian specification""); else:; raise TypeError(""Incorrect hamiltonian specification""). # the the whole thing again for c_ops; c_const = []; c_func = []; c_str = []; c_obj = []; if isinstance(c_ops, list):; for k in ra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:6458,depend,dependent,6458,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,5,['depend'],['dependent']
Integrability,"())]; for idx, c in enumerate(sso.sc_ops)]. elif sso.method == 'photocurrent':; sso.d1 = d1_psi_photocurrent; sso.d2 = d2_psi_photocurrent; sso.d2_len = 1; sso.homogeneous = False; sso.distribution = 'poisson'. if ""dW_factors"" not in kwargs:; sso.dW_factors = np.array([1]); if ""m_ops"" not in kwargs:; sso.m_ops = [[None] for c in sso.sc_ops]. else:; raise Exception(""Unrecognized method '%s'."" % sso.method). if sso.distribution == 'poisson':; sso.homogeneous = False. if sso.solver == 'euler-maruyama' or sso.solver is None:; sso.rhs = _rhs_psi_euler_maruyama. elif sso.solver == 'platen':; sso.rhs = _rhs_psi_platen. else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _ssesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def smesolve(H, rho0, times, c_ops, sc_ops, e_ops, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.SolverResult`. An instance of the class :class:`",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html:13279,depend,depending,13279,docs/3.1.0/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/stochastic.html,1,['depend'],['depending']
Integrability,"(), sigmaz()]. In [10]: expt_list = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops). In [11]: sphere = Bloch(). In [12]: sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). In [13]: sphere.vector_color = ['r']. In [14]: sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). In [15]: sphere.make_sphere(). In [16]: plt.show(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:14003,depend,dependent,14003,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * np.random.rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; import numpy as np; from matplotlib import pyplot. import qutip. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.5 * 2*np.pi; omega = 1.0 * 2*np.pi; T = (2*np.pi)/omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2, 0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = qutip.floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). (png, hires.png, pdf). Pre-computing the Floquet modes for one period¶; When eval",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:11105,depend,dependent,11105,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,"(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * np.random.rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; import numpy as np; from matplotlib import pyplot. import qutip. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.5 * 2*np.pi; omega = 1.0 * 2*np.pi; T = (2*np.pi)/omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2, 0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = qutip.floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet stat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:11095,depend,dependent,11095,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,"(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12524,depend,dependent,12524,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['depend'],['dependent']
Integrability,"(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.25s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.48s. Est. time left: 00:00:00:01; 30.0%. Run time: 0.75s. Est. time left: 00:00:00:01; 40.0%. Run time: 0.97s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:8314,depend,dependent,8314,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.28s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.53s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.78s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.03s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:7781,depend,dependent,7781,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.44s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.88s. Est. time left: 00:00:00:03; 30.0%. Run time: 1.55s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.28s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:8339,depend,dependent,8339,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"(3)). In [8]: ada = tensor(num(N), qeye(3)). In [9]: c_ops = [] # Build collapse operators. In [10]: kappa = 1.5 # Cavity decay rate. In [11]: c_ops.append(np.sqrt(kappa) * a). In [12]: gamma = 6 # Atomic decay rate. In [13]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [14]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [15]: t = np.linspace(-15, 15, 100) # Define time vector. In [16]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [17]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [18]: sigma_GG = state_GG * state_GG.dag(). In [19]: state_UU = tensor(basis(N, 0), ustate). In [20]: sigma_UU = state_UU * state_UU.dag(). In [21]: g = 5 # coupling strength. In [22]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [23]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [24]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [25]: H = [H0,[H1,H1_coeff]]. In [26]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [27]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.55s. Est. time left: 00:00:00:04; 20.0%. Run time: 1.07s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.60s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.13s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:7807,depend,dependent,7807,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2dm(rho0). #; # construct liouvillian; #; new_args = None. if len(c_op_list) > 0:; L_data = liouvillian(None, c_op_list).data; else:; n, m = rho0.shape; L_data = sp.csr_matrix((n ** 2, m ** 2), dtype=complex). if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; if isoper(args[key]):; new_args[key] = (; -1j * (spre(args[key]) - spost(args[key]))).data; else:; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; if isoper(arg):; new_args.append((-1j * (spre(arg) - spost(arg))).data); e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:22290,depend,dependence,22290,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['depend'],['dependence']
Integrability,"(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_func > 0:; res = _sesolve_list_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, psi0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, Qobj):; res = _sesolve_const(H, psi0, tlist, e_ops, args, options,; progress_bar); else:; raise TypeError(""Invalid Hamiltonian specification""). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_list_func_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state or oper; #; if psi0.isket:; initial_vector = psi0.full().ravel(); oper_evo = False; elif psi0.isunitary:; initial_vector = psi0.full().ravel('F'); oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct liouvillian in list-function format; #; L_list = []; if not opt.rhs_with_state:; constant_func = lambda x, y: 1.0; else:; constant_func = lambda x, y, z: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hami",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:7044,depend,dependent,7044,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; res = _sesolve_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); else:; res = _sesolve_const(H, rho0, tlist,; e_ops, args, options, progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-function format; #; def _mesolve_list_func_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian in list-function format; #; L_list = []; if opt.rhs_with_state:; constant_func = lambda x, y, z: 1.0; else:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:12667,depend,dependent,12667,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['depend'],['dependent']
Integrability,"(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True, options_modes=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solver.Optionsoptions for the ODE solver. For solving the master equation. floquet_basisboolWill return results in Floquet basis or computational basis; (optional). k_maxintThe truncation of the number of sidebands (default 5). options_modesqutip.solver.Optionsoptions for the ODE solver. For computing Floquet modes. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values for the times specified; by tlist. fsesolve(H, psi0, tlist, e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:108241,depend,dependent,108241,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"(J)]. progress_bar.finished(). # return U_f_list[-1], H_td_func, u; return GRAPEResult(u=u, U_f=U_f_list[-1], H_t=H_td_func). def cy_grape_unitary(U, H0, H_ops, R, times, eps=None, u_start=None,; u_limits=None, interp_kind='linear', use_interp=False,; alpha=None, beta=None, phase_sensitive=True,; progress_bar=BaseProgressBar()):; """"""; Calculate control pulses for the Hamitonian operators in H_ops so that the; unitary U is realized. Experimental: Work in progress. Parameters; ----------; U : Qobj; Target unitary evolution operator. H0 : Qobj; Static Hamiltonian (that cannot be tuned by the control fields). H_ops: list of Qobj; A list of operators that can be tuned in the Hamiltonian via the; control fields. R : int; Number of GRAPE iterations. time : array / list; Array of time coordinates for control pulse evalutation. u_start : array; Optional array with initial control pulse values. Returns; -------; Instance of GRAPEResult, which contains the control pulses calculated; with GRAPE, a time-dependent Hamiltonian that is defined by the; control pulses, as well as the resulting propagator.; """""". if eps is None:; eps = 0.1 * (2 * np.pi) / (times[-1]). M = len(times); J = len(H_ops). u = np.zeros((R, J, M)). H_ops_data = [H_op.data for H_op in H_ops]. if u_limits and len(u_limits) != 2:; raise ValueError(""u_limits must be a list with two values""). if u_limits:; warnings.warn(""Causion: Using experimental feature u_limits""). if u_limits and u_start:; # make sure that no values in u0 violates the u_limits conditions; u_start = np.array(u_start); u_start[u_start < u_limits[0]] = u_limits[0]; u_start[u_start > u_limits[1]] = u_limits[1]. if u_limits:; use_u_limits = 1; u_min = u_limits[0]; u_max = u_limits[1]; else:; use_u_limits = 0; u_min = 0.0; u_max = 0.0. if u_start is not None:; for idx, u0 in enumerate(u_start):; u[0, idx, :] = u0. if beta:; warnings.warn(""Causion: Using experimental feature time-penalty""). alpha_val = alpha if alpha else 0.0; beta_val = beta if beta e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html:9844,depend,dependent,9844,docs/3.1.0/modules/qutip/control/grape.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/grape.html,1,['depend'],['dependent']
Integrability,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [77]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [78]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [79]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [80]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [81]: chi = qpt(U_rho, op_basis). In [82]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [83]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-visualization.html:16473,depend,dependent,16473,docs/3.1.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html,1,['depend'],['dependent']
Integrability,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-visualization.html:16382,depend,dependent,16382,docs/3.0.1/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html,1,['depend'],['dependent']
Integrability,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-visualization.html:16320,depend,dependent,16320,docs/3.0.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html,1,['depend'],['dependent']
Integrability,"(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23334,integrat,integrator,23334,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrator']
Integrability,"(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:state : qobj. A state vector or density matrix for a spin-j quantum system. theta : array_like. theta-coordinates at which to calculate the Q function. phi : array_like. phi-coordinates at which to calculate the Q function. Returns:Q, T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:109654,depend,dependent,109654,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,"(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)); ; elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:10170,depend,dependence,10170,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['depend'],['dependence']
Integrability,"(eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """""". # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T. f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)). else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:5639,depend,dependence,5639,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['depend'],['dependence']
Integrability,"(eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : list of kets. The Floquet modes as kets at time :math:`t`. """"""; # find t in [0,T] such that t_orig = t + n * T for integer n; t = t - int(t / T) * T; f_modes_t = []. # get the unitary propagator from 0 to t; if t > 0.0:; U = propagator(H, t, [], args). for n in np.arange(len(f_modes_0)):; f_modes_t.append(U * f_modes_0[n] * exp(1j * f_energies[n] * t)); else:; f_modes_t = f_modes_0. return f_modes_t. [docs]def floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None):; """"""; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. tlist : array; The list of times at which to evaluate the floquet modes. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. T : float",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:5713,depend,dependence,5713,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:5528,integrat,integrator,5528,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,5,['integrat'],['integrator']
Integrability,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; r""""""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html:5557,integrat,integrator,5557,docs/4.6/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/nonmarkov/memorycascade.html,4,['integrat'],['integrator']
Integrability,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html:5524,integrat,integrator,5524,docs/4.4/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/nonmarkov/memorycascade.html,1,['integrat'],['integrator']
Integrability,"(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem[1]); if elem != td_consts[-1]:; string += ("",""). # run code generator; if not opt.rhs_reuse or config.tdfunc is None:; if opt.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; cgen = Codegen(h_terms=n_L_terms, h_tdterms=Lcoeff, args=args,; config=config); cgen.generate(config.tdname + "".pyx""). code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs. #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(config.tdfunc); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); code = compile('r.set_f_params(' + string + ')', '<string>', 'exec'); exec(code). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; def odesolve(H, rho0, tlist, c_op_list, e_ops, args=None, options=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian. Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; integratin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:32658,integrat,integrator,32658,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['integrat'],['integrator']
Integrability,"(list, tuple)):; ctrls = np.array(ctrls, dtype=object); except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:5123,message,message,5123,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,4,['message'],['message']
Integrability,"(me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:89603,depend,dependent,89603,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"(nds, nds). c_ops(self)[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix(self)[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian(self)[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian(self)[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(self, initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:54174,integrat,integrate,54174,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['integrat'],['integrate']
Integrability,"(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:5034,depend,dependent,5034,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[“w1”]). def f2_t(t, args):return np.cos(t * args[“w2”]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={“w1”:1., “w2”:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, ‘exp(-1j*w1*t)’], [H2, ‘cos(w2*t)’]],args={“w1”:1.,”w2”:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:17257,depend,dependent,17257,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,"(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:8668,depend,dependent,8668,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,"(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:93996,depend,dependent,93996,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"(t\). (3)\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:5319,depend,dependent,5319,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,3,['depend'],['dependent']
Integrability,") . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:170688,depend,dependent,170688,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['depend'],['dependent']
Integrability,") L. Parameters:L : qobj. Liouvillian of the system. rho0 : qobj. Initial state vector or density matrix. Returns:eseries : qutip.eseries. eseries represention of the system dynamics. Bloch-Redfield Master Equation¶. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]; For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]; It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]; where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]; where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters:H : Qobj / list. System Hamiltonian giv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:63871,depend,dependent,63871,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,") and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_ep",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:23355,depend,dependent,23355,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['depend'],['dependent']
Integrability,") are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html:5139,depend,depends,5139,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,3,['depend'],['depends']
Integrability,") instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : ndarray. An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool {False, True}. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:85118,depend,dependent,85118,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,")'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <Figure size 640x480 with 0 Axes>. In [52]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:13652,depend,dependent,13652,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,")'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [47]: t = np.linspace(-15, 15, 100). In [48]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [49]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [50]: noisy_data = noisy_func(t). In [51]: plt.figure(); Out[51]: <matplotlib.figure.Figure at 0x2b4e8082ebe0>. In [52]: plt.plot(t, func(t)); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:13626,depend,dependent,13626,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,")'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶. Note; New in QuTiP 4.1. Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes it own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; In [49]: t = np.linspace(-15, 15, 100). In [50]: func = lambda t: 9*np.exp(-(t / 5)** 2). In [51]: noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]). In [52]: noisy_data = noisy_func(t). In [53]: plt.plot(t, func(t)); Out[53]: [<matplotlib.lines.Line2D at 0x2b65d0755a90>]. In [54]: plt.plot(t, noisy_data, 'o'); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:13886,depend,dependent,13886,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,")']. In [78]: H_td = [H0, H1]. In [79]: Hargs = {'w': w, 'eps': eps_list[0], 'A': A_list[0]}. where the last code block sets up the problem using a string-based Hamiltonian, and Hargs is a dictionary of arguments to be passed into the Hamiltonian. In this example, we are going to use the qutip.propagator and qutip.propagator.propagator_steadystate to find expectation; values for different values of \(\epsilon\) and \(A\) in the; Hamiltonian \(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\).; We must now tell the qutip.mesolve function, that is called by qutip.propagator to reuse a; pre-generated Hamiltonian constructed using the qutip.rhs_generate command:; In [80]: opts = Options(rhs_reuse=True). In [81]: rhs_generate(H_td, c_ops, Hargs, name='lz_func'). Here, we have given the generated file a custom name lz_func, however this is not necessary as a generic name will automatically be given. Now we define the function task that is called by qutip.parallel.parfor with the m-index parallelized in loop over the elements of p_mat[m,n]:; In [82]: def task(args):; ....: m, eps = args; ....: p_mat_m = np.zeros(len(A_list)); ....: for n, A in enumerate(A_list):; ....: # change args sent to solver, w is really a constant though.; ....: Hargs = {'w': w, 'eps': eps,'A': A}; ....: U = propagator(H_td, T, c_ops, Hargs, opts) #<- IMPORTANT LINE; ....: rho_ss = propagator_steadystate(U); ....: p_mat_m[n] = expect(sn, rho_ss); ....: return [m, p_mat_m]; ....: . Notice the Options opts in the call to the qutip.propagator function. This is tells the qutip.mesolve function used in the propagator to call the pre-generated file lz_func. If this were missing then the routine would fail. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:23546,rout,routine,23546,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['rout'],['routine']
Integrability,")). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:38656,depend,dependent,38656,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['depend'],['dependent']
Integrability,")). In [10]: ada = tensor(num(N), qeye(3)). In [11]: c_ops = [] # Build collapse operators. In [12]: kappa = 1.5 # Cavity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.30s. Est. time left: 00:00:00:02; 20.0%. Run time: 0.54s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.79s. Est. time left: 00:00:00:01; 40.0%. Run time: 1.05s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:8041,depend,dependent,8041,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,")). In [10]: ada = tensor(num(N), qeye(3)). In [11]: c_ops = [] # Build collapse operators. In [12]: kappa = 1.5 # Cavity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.56s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.08s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.64s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.31s. Est. time left: 00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:8404,depend,dependent,8404,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,")). In [10]: ada = tensor(num(N), qeye(3)). In [11]: c_ops = [] # Build collapse operators. In [12]: kappa = 1.5 # Cavity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 3.78s. Est. time left: 00:00:00:33; 20.0%. Run time: 7.55s. Est. time left: 00:00:00:30; 30.0%. Run time: 11.12s. Est. time left: 00:00:00:25; 40.0%. Run time: 14.82s. Est. time left: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:7935,depend,dependent,7935,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,"). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). # -----------------------------------------------------------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list). #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel(); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. # -----------------------------------------------------------------------------; # Master equation solver for python-function time-dependence.; #; def _mesolve_func_td(L_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = ket2d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:21579,integrat,integrate,21579,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability,"). 155. Joo et al., ""Deterministic amplification of Schrödinger cat states in circuit quantum electrodynamics"", ; New J. Phys. 18, 023028 (2016). 154. Hofer et al., ""Quantum heat engine based on photon-assisted Cooper pair tunneling"", ; Phys. Rev. B 93, 041418(R) (2016). 153. Hwang et al., ""Recurrent Delocalization and Quasiequilibration of Photons in Coupled Systems in Circuit Quantum Electrodynamics"", ; Phys. Rev. Lett. 116, 153601 (2016). 152. Gharavi et al., ""Readout of Majorana parity states using a quantum dot"", ; Phys. Rev. B 94, 155417 (2016). 151. Ofek et al., ""Extending the lifetime of a quantum bit with error correction in superconducting circuits"", ; Nature 536, 441 (2016). 150. Nunes et al., ""A Simple Scheme for Quantum Non Demolition of Phonons Number of the Nanoelectromechanics Systems"", ; arXiv:1601.03750. 149. Escobedo, ""Heavy quarkonium suppression in a fireball"", ; AIP Conf. Proc. 1701, 060009 (2016). 148. Straubel et al., ""Efficient mode conversion in an optical nanoantenna mediated by quantum emitters"", ; Opt. Lett. 41, 2294 (2016). 147. Ramos et al., ""Non-Markovian dynamics in chiral quantum networks with spins and photons"", ; Phys. Rev. A 93, 062104 (2016). 146. Souquet et al., ""Fock-state stabilization and emission in superconducting circuits using dc-biased Josephson junctions"", ; Phys. Rev. A 93, 060301(R) (2016). 145. Müller et al., ""Self-homodyne-enabled generation of indistinguishable photons"", ; Optica 3, 931 (2016). 144. Morrison et al., ""Low-Scaling Quantum Chemistry Approach to Excited-State Properties via an ab Initio Exciton Model: Application to Excitation Energy Transfer in a Self-Assembled Nanotube"", ; J. Phys. Chem. Lett. 6, 4390 (2015). 143. Yamamoto et al., ""Parametric Amplifier and Oscillator Based on Josephson Junction Circuitry"", ; Lecture Notes in Physics 911, 495 (2016). 142. Dory et al., ""Complete Coherent Control of a Quantum Dot Strongly Coupled to a Nanocavity"", ; Sci. Rep. 6, 25172 (2016). 141. Kaczmarczyk et al., """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:29698,mediat,mediated,29698,users.html,https://qutip.org,https://qutip.org/users.html,1,['mediat'],['mediated']
Integrability,"). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is constructed from a set; of constant:obj:`~qutip.Qobj` :math:`\\{Q_k\\}` and time-dependent scalars; :math:`f_k(t)` by. .. math::. Q(t) = \\sum_k f_k(t) Q_k. If a scalar :math:`f_k(t)` is not passed with a given :obj:`~qutip.Qobj`,; then that term is assumed to be constant. The next section contains more; detail on the allowed forms of the constants, and gives several examples; for how to build instances of this class. **Time-dependence formats**. There are three major formats for specifying a time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:4700,depend,dependent,4700,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependent']
Integrability,"). if options is None:; options = Options(); if options.rhs_reuse and not isinstance(H, SolverSystem):; # TODO: deprecate when going to class based solver.; if ""sesolve"" in solver_safe:; H = solver_safe[""sesolve""]. if args is None:; args = {}. check_use_openmp(options). if isinstance(H, SolverSystem):; ss = H; elif isinstance(H, (list, Qobj, QobjEvo)):; ss = _sesolve_QobjEvo(H, tlist, args, options); elif callable(H):; ss = _sesolve_func_td(H, args, options); else:; raise Exception(""Invalid H type""). func, ode_args = ss.makefunc(ss, psi0, args, e_ops, options). if _safe_mode:; v = psi0.full().ravel('F'); func(0., v, *ode_args) + v. res = _generic_ode_solve(func, ode_args, psi0, tlist, e_ops, options,; progress_bar, dims=psi0.dims); if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; res.SolverSystem = ss; return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:6593,depend,dependent,6593,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,2,['depend'],['dependent']
Integrability,"). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_bins : int; Number of time bins; the range over which each index c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:111421,depend,dependent,111421,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi. In [2]: H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: H1 = A/2.0 * sigmaz(). In [4]: args = {'w': omega}. In [5]: H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; In [6]: T = 2*pi / omega. In [7]: f_modes_0, f_energies = floquet_modes(H, T, args). In [8]: f_energies; Out[8]: array([-2.83131212, 2.83131212]). In [9]: f_modes_0; Out[9]: ; [Quantum objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html:6999,depend,dependent,6999,docs/3.1.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows; >>> delta = 0.2 * 2*pi; eps0 = 1.0 * 2*pi; A = 2.5 * 2*pi; omega = 1.0 * 2*pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*pi / omega; >>> f_modes, f_energies = floquet_modes(H, T, args); >>> f_energies; array([ 2.83131211, -2.83131211]); >>> f_modes0; [Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.3",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html:6898,depend,dependent,6898,docs/3.0.0/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. (png, hires.png, pdf). The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*np.pi / omega; >>> f_modes_0, f_energies = floquet_modes(H, T, args); >>> f_energies ; array([-2.83131212, 2.83131212]); >>> f_modes_0 ; [Quantum object: dims = [[2",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html:6493,depend,dependent,6493,docs/4.6/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*np.pi / omega; >>> f_modes_0, f_energies = floquet_modes(H, T, args); >>> f_energies ; array([-2.83131212, 2.83131212]); >>> f_modes_0 ; [Quantum object: dims = [[2], [1]], shape = (2, 1)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:6580,depend,dependent,6580,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi. In [2]: H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: H1 = A/2.0 * sigmaz(). In [4]: args = {'w': omega}. In [5]: H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; In [6]: T = 2*pi / omega. In [7]: f_modes_0, f_energies = floquet_modes(H, T, args). In [8]: f_energies; Out[8]: array([-2.83131211, 2.83131211]). In [9]: f_modes_0; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html:6355,depend,dependent,6355,docs/4.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-floquet.html,4,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi. In [2]: H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: H1 = A/2.0 * sigmaz(). In [4]: args = {'w': omega}. In [5]: H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; In [6]: T = 2*pi / omega. In [7]: f_modes_0, f_energies = floquet_modes(H, T, args). In [8]: f_energies; Out[8]: array([-2.83131212, 2.83131212]). In [9]: f_modes_0; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html:6450,depend,dependent,6450,docs/4.4/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; In [1]: delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 2.5 * 2*np.pi; omega = 1.0 * 2*np.pi. In [2]: H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). In [3]: H1 = A/2.0 * sigmaz(). In [4]: args = {'w': omega}. In [5]: H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; In [6]: T = 2*pi / omega. In [7]: f_modes_0, f_energies = floquet_modes(H, T, args). In [8]: f_energies; Out[8]: array([-2.83131212, 2.83131212]). In [9]: f_modes_0; Out[9]: ; [Quantum obje",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html:6475,depend,dependent,6475,docs/4.5/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,"):; """"""; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the ``drift + ctrl_amp[j]*ctrls[j]``. The control pulse is an ``[n_ts, n_ctrls]`` array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; The underlying dynamics generator of the system can provide list (of; length ``num_tslots``) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bound",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:7257,depend,dependent,7257,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['depend'],['dependent']
Integrability,"):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`qutip.Qobj.eigenstates` to get the eigenstates and -values,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:3723,depend,dependence,3723,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,2,['depend'],['dependence']
Integrability,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html:7517,depend,dependence,7517,docs/4.4/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/bloch_redfield.html,3,['depend'],['dependence']
Integrability,"); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.outp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52613,depend,dependency,52613,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,2,['depend'],['dependency']
Integrability,"); if full_tlist is None:; full_tlist = self.get_full_tlist(); coeffs_list = []; for pulse in self.pulses:; if pulse.tlist is None and pulse.coeff is None:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if not isinstance(pulse.coeff, (bool, np.ndarray)):; raise ValueError(; ""get_full_coeffs only works for ""; ""NumPy array or bool coeff.""); if isinstance(pulse.coeff, bool):; if pulse.coeff:; coeffs_list.append(np.ones(len(full_tlist))); else:; coeffs_list.append(np.zeros(len(full_tlist))); continue; if self.spline_kind == ""step_func"":; arg = {""_step_func_coeff"": True}; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, arg)); elif self.spline_kind == ""cubic"":; coeffs_list.append(; _fill_coeff(pulse.coeff, pulse.tlist, full_tlist, {})); else:; raise ValueError(""Unknown spline kind.""); return np.array(coeffs_list). [docs] def set_all_tlist(self, tlist):; """"""; Set the same `tlist` for all the pulses. Parameters; ----------; tlist: array-like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; """"""; if isinstance(tlist, list) and len(tlist) == len(self.pulses):; for i, pulse in enumerate(self.pulses):; pulse.tlist = tlist[i]; else:; for pulse in self.pulses:; pulse.tlist = tlist. [docs] def add_pulse(self, pulse):; """"""; Add a new pulse to the device. Parameters; ----------; pulse: :class:`.Pulse`; `Pulse` object to be added.; """"""; if isinstance(pulse, Pulse):; if pulse.spline_kind is None:; pulse.spline_kind = self.spline_kind; self.pulses.append(pulse); else:; raise ValueError(""Invalid input, pulse must be a Pulse object""). [docs] def remove_pulse(self, indices=None, label=None):; """"""; Remove the control pulse with given indices. Parameters; ----------; indices: int or list of int; The indices of the control Hamiltonians to be removed.; label: str; The label of the pulse; """"""; if indices is not None:; if not isinstance(indices, Iterable):; indices = [indices]; indices",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:11430,depend,dependent,11430,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,4,['depend'],['dependent']
Integrability,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:16995,integrat,integration,16995,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['integrat'],['integration']
Integrability,"); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"""; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string; """"""; value = str(value). if key in self.messages:; if sep is not None:; try:; value = sep + value; except:; TypeError(""It is not possible to concatenate the value with ""; ""the given seperator""); self.messages[key] += value; else:; self.messages[key] = value; ; def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header, ; (""-""*len(self.header)))); ; # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty; ; # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None; ; tt = self.total_time; ;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:22498,message,message,22498,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['message']
Integrability,")\) for the frequencies; specified in wlist. Return type:array. spectrum_correlation_fft(taulist, y)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters:; tlist (array_like) – list/array of times \(t\) which the correlation function is given.; y (array_like) – list/array of correlations corresponding to time delays \(t\). Returns:w, S – Returns an array of angular frequencies ‘w’ and the corresponding; one-sided power spectrum ‘S(w)’. Return type:tuple. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:98336,depend,dependent,98336,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,")\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:75052,depend,dependent,75052,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['depend'],['dependent']
Integrability,")\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2b11f5a5c950>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:75112,depend,dependent,75112,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,"* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Qdeoptions`; with options for the ODE solver. Returns; -------. output: :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`, or; an *array* or state vectors or density matrices corresponding to the; times in `tlist` [if `e_ops` is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. """""". if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. # convert array based time-dependence to string format; H, _, args = _td_wrap_array_str(H, [], args, tlist). # check for type (if any) of time-dependent inputs; n_const, n_func, n_str = _td_format_check(H, []). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config time-dependence flags to default values; config.reset(). if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist, e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType,; partial)):; res = _sesolve_func_td(H, rho0, tlist, e_ops, args, options,; progress_bar). else:; res = _sesolve_const(H, rho0, tlist, e_ops, args, options,; progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent unitary wavefunction equation on the l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:5840,depend,dependence,5840,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['depend'],['dependence']
Integrability,"* np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [39]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the abov",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:11811,depend,dependent,11811,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,4,['depend'],['dependent']
Integrability,"* np.exp(-(t / sig) ** 2); ....: . where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [42]: args = {'A': 9, 'sigma': 5}. In [43]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the abov",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:12434,depend,dependent,12434,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['depend'],['dependent']
Integrability,"+ 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this solver only works for time-independent systems. Second, you can not pass a lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:12579,depend,dependent,12579,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['depend'],['dependent']
Integrability,"+ p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37909,wrap,wrapper,37909,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['wrap'],['wrapper']
Integrability,"+ sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, c_ops=c_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.solver_code == 120:; raise Exception(""rouchon only wor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:22824,depend,depend,22824,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,4,['depend'],['depend']
Integrability,"+ sso.solver. res = _sesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}; return res. [docs]def ssesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; State vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if ""method"" in kwargs and kwargs[""method""] == ""photocurrent"":; print(""stochastic solver with photocurrent method has been moved to ""; ""it's own function: photocurrent_sesolve""); return photocurrent_sesolve(H, psi0, times, sc_ops=sc_ops,; e_ops=e_ops, _safe_mode=_safe_mode,; args=args, **kwargs). if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = StochasticSolverOptions(False, H=H, state0=psi0, times=times,; sc_ops=sc_ops, e_ops=e_ops,; args=args, **kwargs). if _safe_mode:; _safety_checks(sso). if sso.solver_code == 120:; raise Exception(""rouchon only w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/stochastic.html:21932,depend,depend,21932,docs/4.7/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/stochastic.html,2,['depend'],['depend']
Integrability,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/nonmarkov/memorycascade.html:12210,integrat,integrator,12210,docs/4.0.2/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/nonmarkov/memorycascade.html,5,['integrat'],['integrator']
Integrability,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html:12210,integrat,integrator,12210,docs/4.2/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/nonmarkov/memorycascade.html,5,['integrat'],['integrator']
Integrability,"+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html:12210,integrat,integrator,12210,docs/4.1/modules/qutip/nonmarkov/memorycascade.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/memorycascade.html,5,['integrat'],['integrator']
Integrability,"+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent Hamiltonians; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; Note: Deprecated method; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; pass; elif psi0.isunitary:; raise TypeError(""The unitary operator evolution is not supported""; "" in the list td method.""); else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'); tflag = 1; if opt.rhs_reuse and config.tdfunc is None:; print(""No previous time-dependent RHS found.""); print(""Generating one for you...""); rhs_generate(H_func, args); lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; # create data arrays for time-dependent RHS function; Hdata = [-1.0j * H_func[0][k].data.data for k in range(lenh)]; Hinds = [H_func[0][k].data.indices for k in range(lenh)]; Hptrs = [H_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Hdata["" + str(k) + ""], Hinds["" + str(k) +; ""], Hptrs["" + str(k) + ""],""). if args:; td_consts = args.items(); for elem in td_consts:; string += str(elem",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:17256,depend,dependent,17256,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,", 'explicit1.5', 'taylor2.0',; ]; raise ValueError(""The solver should be one of {!r}"".format(known)). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:18871,depend,dependent,18871,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['depend'],['dependent']
Integrability,", 'milstein-imp', ""; ""'rouchon', ""; ""'taylor1.5', 'taylor1.5-imp', 'explicit1.5' ""; ""'taylor2.0']"")). class StochasticSolverOptionsPhoto(StochasticSolverOptions):; """"""; Attributes; ----------. solver : string; Name of the solver method to use for solving the evolution; of the system.*; order 1 algorithms: 'euler'; order 2 algorithms: 'pred-corr'; In photocurrent evolution; """"""; def set_solver(self):; if self.solver in [None, 'euler', 1, 60]:; self.solver_code = 60; self.solver = 'euler'; elif self.solver in ['pred-corr', 'predictor-corrector', 110, 2]:; self.solver_code = 110; self.solver = 'pred-corr'; else:; raise Exception(""The solver should be one of "" +; ""[None, 'euler', 'predictor-corrector']""). [docs]def smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the `solver` keyword argument. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj`; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:18518,depend,dependent,18518,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['depend'],['dependent']
Integrability,", 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:4735,depend,dependent,4735,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = dense2D_to_fastcsr_cmode(np.reshape(out_psi,; (out_psi.shape[0], 1)),; out_psi.shape[0], 1); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.H,; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.H)). else:; states_out[k] = Qobj(out_psi_csr, config.psi0_dims,; conf",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:27240,depend,dependent,27240,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['depend'],['dependent']
Integrability,", 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators.; n_dp = np.array(; [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in range(config.c_num)]). # determine which operator does collapse and store it; kk = np.cumsum(n_dp / np.sum(n_dp)); j = cinds[kk >= rand_vals[1]][0]; which_oper.append(j); if j in config.c_const_inds:; state = spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); else:; if config.tflag in [1, 11]:; _locals = locals(); # calculates the state vector for collapse by a; # time-dependent collapse operator; exec(_cy_col_spmv_call_func, globals(), _locals); state = _locals['state']; else:; state = \; config.c_funcs[j](ODE.t,; config.c_func_args) * \; spmv_csr(config.c_ops_data[j],; config.c_ops_ind[j],; config.c_ops_ptr[j], ODE._y); state = state / dznrm2(state); ODE._y = state; ODE._integrator.call_args[3] = 1; rand_vals = prng.rand(2). # after while loop; # ----------------; out_psi = ODE._y / dznrm2(ODE._y); if config.e_num == 0 or config.options.store_states:; out_psi_csr = sp.csr_matrix(np.reshape(out_psi,; (out_psi.shape[0], 1)),; dtype=complex); if (config.options.average_states and; not config.options.steady_state_average):; states_out[k] = Qobj(; out_psi_csr * out_psi_csr.conj().transpose(),; [config.psi0_dims[0], config.psi0_dims[0]],; [config.psi0_shape[0], config.psi0_shape[0]],; fast='mc-dm'). elif config.options.steady_state_average:; states_out[0] = (; states_out[0] +; (out_psi_csr * out_psi_csr.conj().transpose())). else:; states_out[k] = Qobj(out_psi_csr, config",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html:28243,depend,dependent,28243,docs/3.1.0/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html,1,['depend'],['dependent']
Integrability,", Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:91779,depend,dependent,91779,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,", N); num_elems = np.int(np.ceil(N*(N+1)*density)/2); data = np.random.rand(num_elems); row_idx = np.random.choice(N, num_elems); col_idx = np.random.choice(N, num_elems); if kind=='left':; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsc(); else:; M = sp.coo_matrix((data, (row_idx,col_idx)), dtype=float, shape=(N,N)).tocsr(); M = 0.5*(M+M.conj().transpose()); if kind=='left':; num_cols = M.indptr.shape[0]-1; for col in range(num_cols):; col_start = M.indptr[col]; col_end = M.indptr[col+1]; col_sum = np.sum(M.data[col_start:col_end]); M.data[col_start:col_end] /= col_sum; M = M.tocsr(); else:; num_rows = M.indptr.shape[0]-1; for row in range(num_rows):; row_start = M.indptr[row]; row_end = M.indptr[row+1]; row_sum = np.sum(M.data[row_start:row_end]); M.data[row_start:row_end] /= row_sum; if dims:; return Qobj(M, dims=dims, shape=[N, N]); else:; return Qobj(M). def _check_ket_dims(dims, N1):; if (not isinstance(dims, list)) or (not isinstance(dims[0], list)):; raise TypeError(""Left and right Qobj dimensions must be lists of ints. E.g.: [2, 3].""); if np.prod(dims) != N1:; raise ValueError(""Qobj dimensions must match matrix shape.""). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/random_objects.html:18886,depend,depends,18886,docs/4.3/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/random_objects.html,1,['depend'],['depends']
Integrability,", OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolev` will be removed in QuTiP 5. Please use :obj:`~sesolve`; or :obj:`~mesolve` for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; :obj:`~essolve` for you. Parameters; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/essolve.html:2694,wrap,wraps,2694,docs/4.6/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html,2,['wrap'],['wraps']
Integrability,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point valu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/piqs.html:2652,integrat,integrate,2652,docs/4.6/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/piqs.html,2,['integrat'],['integrate']
Integrability,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.sparse.linalg import eigsh; from scipy.special import entr; from scipy import constants; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; vector_to_operator,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip import entropy_vn; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; m_vals,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/piqs.html:2632,integrat,integrate,2632,docs/4.5/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/piqs.html,1,['integrat'],['integrate']
Integrability,", Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes; ----------; log_level : integer; level of messaging output ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:5373,message,message,5373,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,4,['message'],['message']
Integrability,", QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5551,depend,dependent,5551,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html:3664,depend,dependent,3664,docs/4.5/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mcsolve.html,2,['depend'],['dependent']
Integrability,", SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; terms ``H0`` and ``H1``, where ``H1`` is time-dependent with coefficient; ``sin(w*t)``, and collapse operators ``C0`` and ``C1``, where ``C1`` is; time-dependent with coeffcient ``exp(-a*t)``. Here, w and a are constant; arguments with values ``W`` and ``A``. Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as::. def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:3684,depend,dependent,3684,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,8,['depend'],['dependent']
Integrability,", T, args); return sum([f_states_t[i] * f_coeff[i]; for i in np.arange(len(f_energies))]). [docs]def floquet_state_decomposition(f_states, f_energies, psi):; """"""; Decompose the wavefunction `psi` (typically an initial state) in terms of; the Floquet states, :math:`\psi = \sum_\\alpha c_\\alpha \psi_\\alpha(0)`. Parameters; ----------. f_states : list of :class:`qutip.qobj` (kets); A list of Floquet modes. f_energies : array; The Floquet energies. psi : :class:`qutip.qobj`; The wavefunction to decompose in the Floquet state basis. Returns; -------. output : array. The coefficients :math:`c_\\alpha` in the Floquet state decomposition. """"""; # [:1,:1][0, 0] patch around scipy 1.3.0 bug; return [(f_states[i].dag() * psi).data[:1,:1][0, 0]; for i in np.arange(len(f_energies))]. [docs]def fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100):; """"""; Solve the Schrodinger equation using the Floquet formalism. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; System Hamiltonian, time-dependent with period `T`. psi0 : :class:`qutip.qobj`; Initial state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in `tlist` will be; returned instead of expectation values. T : float; The period of the time-dependence of the hamiltonian. args : dictionary; Dictionary with variables required to evaluate H. Tsteps : integer; The number of time steps in one driving period for which to; precalculate the Floquet modes. `Tsteps` should be an even number. Returns; -------. output : :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which; contains either an *array* of expectation values or an array of; state vectors, for the times specified by `tlist`.; """""". if not T:; # assume that tlist span exactly one period of the driving; T = tlist[-1]. # find the floquet ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:12569,depend,dependent,12569,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,1,['depend'],['dependent']
Integrability,", THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline; from functools import partial, wraps; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import _compile_str_single, _compiled_coeffs; from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi, spmv, cy_spmm_tr); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff); import pickle; import sys; import scipy; import os. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = False; if sys.platform == 'win32':; safePickle = True. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf+0j. str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:2302,wrap,wraps,2302,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['wrap'],['wraps']
Integrability,", [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-tensor.html:12509,contract,contracting,12509,docs/4.6/guide/guide-tensor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-tensor.html,4,['contract'],"['contracting', 'contraction']"
Integrability,", alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar val",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:175208,depend,dependent,175208,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['depend'],['dependent']
Integrability,", c_ops=sso.c_ops) * sso.dt. def _prespostdag(op):; return spre(op) * spost(op.dag()). sso.sops = [[spre(op._cdc()) + spost(op._cdc()),; spre(op._cdc()),; op.apply(_prespostdag)._f_norm2()] for op in sso.sc_ops]; sso.ce_ops = [QobjEvo(spre(op)) for op in sso.e_ops]; sso.cm_ops = [QobjEvo(spre(op)) for op in sso.m_ops]. sso.LH.compile(); [[op.compile() for op in ops] for ops in sso.sops]; [op.compile() for op in sso.cm_ops]; [op.compile() for op in sso.ce_ops]. res = _sesolve_generic(sso, sso.options, sso.progress_bar); res.num_collapse = [np.count_nonzero(noise) for noise in res.noise]. if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. def photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[],; _safe_mode=True, args={}, **kwargs):; """"""; Solve stochastic schrodinger equation using the photocurrent method. Parameters; ----------. H : :class:`qutip.Qobj`, or time dependent system.; System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. sc_ops : list of :class:`qutip.Qobj`, or time dependent Qobjs.; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operators for which to evaluate; expectation values. kwargs : *dictionary*; Optional keyword arguments. See; :class:`qutip.stochastic.StochasticSolverOptions`. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`.; """"""; if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. sso = Sto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:31098,depend,depend,31098,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['depend'],['depend']
Integrability,", mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea978>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea9b0>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:85693,depend,dependent,85693,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,", phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:162168,depend,dependent,162168,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,", psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:12358,depend,dependent,12358,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,", psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [40]: args = {'A': 9, 'sigma': 5}. In [41]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [42]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [43]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [44]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [45]: args = {'A': 9, 'sig': 5}. In [46]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:12891,depend,dependent,12891,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,", psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; In [42]: args = {'A': 9, 'sigma': 5}. In [43]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; In [44]: H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:12981,depend,dependent,12981,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,3,['depend'],['dependent']
Integrability,", the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian.; lindblad_noise: list of :class:`._EvoElement`; The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation.; spline_kind: str; See parameter `spline_kind`.; label: str; See parameter `label`. Examples; --------; Create a pulse that is turned off. >>> Pulse(sigmaz(), 0) # doctest: +SKIP; >>> Pulse(sigmaz(), 0, None, None) # doctest: +SKIP. Create a time dependent pulse. >>> tlist = np.array([0., 1., 2., 4.]) # doctest: +SKIP; >>> coeff = np.array([0.5, 1.2, 0.8]) # doctest: +SKIP; >>> spline_kind = ""step_func"" # doctest: +SKIP; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") # doctest: +SKIP. Create a time independent pulse. >>> Pulse(sigmaz(), 0, coeff=True) # doctest: +SKIP. Create a constant pulse with time range. >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) # doctest: +SKIP. Create an dummy Pulse (H=0). >>> Pulse(None, None) # doctest: +SKIP. """"""; def __init__(self, qobj, targets, tlist=None, coeff=None,; spline_kind=None, label=""""):; self.spline_kind = spline_kind; self.ideal_pulse = _EvoElement(qobj, target",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:5977,depend,dependent,5977,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,4,['depend'],['dependent']
Integrability,", then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> sigmam() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]. sigmap()[source]¶; Creation operator for Pauli spins.; Examples; >>> sigmap() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 0. 0.]]. sigmax()[source]¶; Pauli spin 1/2 sigma-x operator; Examples; >>> sigmax() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. sigmay()[source]¶; Pauli spin 1/2 sigma-y operator.; Examples; >>> sigmay() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-1.j]; [ 0.+1.j 0.+0.j]]. sigmaz()[source]¶; Pauli spin 1/2 sigma-z operator.; Examples; >>> sigmaz() ; Quantum object: dims = [[2], [2]], shape = [2, 2], t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:29255,depend,depending,29255,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['depend'],['depending']
Integrability,", vec2mat; #from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.rhs_generate import rhs_clear; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs +",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:3711,depend,dependent,3711,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,4,['depend'],['dependent']
Integrability,"-----------------------------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops, e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if T is None:; T = max(tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html:24894,depend,dependence,24894,docs/3.1.0/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html,1,['depend'],['dependence']
Integrability,"-----------------------------------------------------; # A time-dependent disipative master equation on the list-string format for; # cython compilation; #; def _sesolve_list_str_td(H_list, psi0, tlist, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; oper_evo = False; elif psi0.isunitary:; oper_evo = True; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # construct dynamics generator; #; Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix representation to h_coeff; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = ""1.0"". elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected string format)""). L = -1j * h; Ldata.append(L.data.data); Linds.append(L.data.indices); Lptrs.append(L.data.indptr); if isinstance(h_coeff, Cubic_Spline):; Lobj.append(h_coeff.coeffs); Lcoeff.append(h_coeff). # the total number of Hamiltonian terms; n_L_terms = len(Ldata). # Check which components should use OPENMP; omp_components = None; if qset.has_openmp:; if opt.use_openmp:; omp_components = openmp_components(Lptrs). #; # setup ode args string: we expand the list Ldata, Linds and Lptrs into; # and explicit list of parameters; #; string_list = []; for k in range(n_L_terms):; string_list.append(""Ldata[%d], Linds[%d], Lptrs[%d]"" % (k, k, k)); # Add object terms to end of ode args string; for k in range(len(Lobj)):; string_list.append(""Lobj[%d]"" % k). for name, value in args.items():; if isinstance(value, np.ndarray):; string_list.append(name); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). #; # generate and compi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:13597,depend,dependent,13597,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"--------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/floquet.html:23942,depend,dependence,23942,docs/4.6/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"--------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """""". if _safe_mode:; _solver_safe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/floquet.html:23911,depend,dependence,23911,docs/4.4/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"--------------------------------------------; # Solve the Floquet-Markov master equation; #; #; [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : :class:`qutip.solver`; options for the ODE solver. k_max : int; The truncation of the number of sidebands (default 5). Returns; -------. output : :class:`qutip.solver`. An instance of the class :class:`qutip.solver`, which contains either; an *array* of expectation values for the times specified by `tlist`.; """"""; ; if _safe_mode:; _solver_sa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:23686,depend,dependence,23686,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,4,['depend'],['dependence']
Integrability,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar, norm,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html:16885,integrat,integrate,16885,docs/3.1.0/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html,1,['integrat'],['integrate']
Integrability,"--------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians; #; def _sesolve_func_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""!; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). if not isket(psi0):; raise TypeError(""psi0 must be a ket""). #; # setup integrator; #; new_args = None. if type(args) is dict:; new_args = {}; for key in args:; if isinstance(args[key], Qobj):; new_args[key] = args[key].data; else:; new_args[key] = args[key]. elif type(args) is list or type(args) is tuple:; new_args = []; for arg in args:; if isinstance(arg, Qobj):; new_args.append(arg.data); else:; new_args.append(arg). if type(args) is tuple:; new_args = tuple(new_args); else:; if isinstance(args, Qobj):; new_args = args.data; else:; new_args = args. initial_vector = psi0.full().ravel(). if not opt.rhs_with_state:; r = scipy.integrate.ode(cy_ode_psi_func_td); else:; r = scipy.integrate.ode(cy_ode_psi_func_td_with_state). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]); r.set_f_params(H_func, new_args). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). #; # evaluate dpsi(t)/dt for time-dependent hamiltonian; #; def _ode_psi_func_td(t, psi, H_func, args):; H = H_func(t, args); return -1j * (H * psi). def _ode_psi_func_td_with_state(t, psi, H_func, args):; H = H_func(t, psi, args); return -1j * (H * psi). # -----------------------------------------------------------------------------; # Solve an ODE which solver parameters already setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/sesolve.html:17137,integrat,integrate,17137,docs/4.2/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/sesolve.html,3,['integrat'],['integrate']
Integrability,"--------------------------------; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.arguments(args); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, args, opt):; """"""; Prepare the system for the solver, H is a function.; """"""; ss = SolverSystem(); ss.H = H_func; ss.makefunc = _Hfunc_set; solver_safe[""sesolve""] = ss; return ss. def _Hfunc_set(HS, psi, args, opt):; """"""; From the system, get the ode function and args; """"""; H_func = HS.H; if psi.isunitary:; if not opt.rhs_with_state:; print(""_ode_oper_func_td""); func = _ode_oper_func_td; else:; print(""_ode_oper_func_td_with_state""); func = _ode_oper_func_td_with_state; else:; if not opt.rhs_with_state:; print(""cy_ode_psi_func_td""); func = cy_ode_psi_func_td; else:; print(""cy_ode_psi_func_td_with_state""); func = cy_ode_psi_func_td_with_state. return func, (H_func, args). # -----------------------------------------------------------------------------; # evaluate dU(t)/dt according to the schrodinger equation; #; def _ode_oper_func_td(t, y, H_func, args):; H = H_f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/sesolve.html:7475,depend,dependent,7475,docs/4.4/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/sesolve.html,1,['depend'],['dependent']
Integrability,"----------------------------; # Master equation solver; #; def _mesolve_const(H, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver, for constant hamiltonian; and collapse operators.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0 and isoper(H):; return _sesolve_const(H, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if opt.tidy:; H = H.tidyup(opt.atol). L = liouvillian(H, c_op_list); . #; # setup integrator; #; initial_vector = mat2vec(rho0.full()).ravel('F'); if issuper(rho0):; r = scipy.integrate.ode(_ode_super_func); r.set_f_params(L.data); else:; if opt.use_openmp and L.data.nnz >= qset.openmp_thresh:; r = scipy.integrate.ode(cy_ode_rhs_openmp); r.set_f_params(L.data.data, L.data.indices, L.data.indptr, ; opt.openmp_threads); else:; r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(L.data.data, L.data.indices, L.data.indptr); # r = scipy.integrate.ode(_ode_rho_test); # r.set_f_params(L.data); r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # call generic ODE code; #; return _generic_ode_solve(r, rho0, tlist, e_ops, opt, progress_bar). #; # evaluate drho(t)/dt according to the master eqaution; # [no longer used, replaced by cython function]; #; def _ode_rho_func(t, rho, L):; return L * rho. def _ode_rho_test(t, rho, data):; # for performance comparison of cython code; return data*(np.transpose(rho)); #; # Evaluate d E(t)/dt for E a super-operator; #. def _ode_super_func(t, y, data):; ym = vec2mat(y); return (da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:23558,integrat,integrate,23558,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,3,['integrat'],['integrate']
Integrability,"----------------------------; # single-trajectory for monte carlo; # --------------------------------------------------------------------------; def _single_traj(self, nt):; """"""; Monte Carlo algorithm returning state-vector or expectation values; at times tlist for a single trajectory.; """"""; # SEED AND RNG AND GENERATE; prng = RandomState(self.seeds[nt]); opt = self.options. # set initial conditions; ss = self.ss; tlist = self.tlist; e_ops = self.e_ops.copy(); opt = self.options; rhs, ode_args = self.ss.makefunc(ss); ODE = self._build_integration_func(rhs, ode_args, opt); ODE.set_initial_value(self.initial_vector, tlist[0]); e_ops.init(tlist). cymc = CyMcOde(ss, opt); states_out, ss_out, collapses = cymc.run_ode(ODE, tlist, e_ops, prng). # Run at end of mc_alg function; # -----------------------------; if opt.steady_state_average:; ss_out /= float(len(tlist)). return (states_out, ss_out, e_ops, collapses). def _build_integration_func(self, rhs, ode_args, opt):; """"""; Create the integration function while fixing the parameters; """"""; ODE = ode(rhs); if ode_args:; ODE.set_f_params(ode_args); # initialize ODE solver for RHS; ODE.set_integrator('zvode', method=""adams""); ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step); return ODE. # --------------------------------------------------------------------------; # In development diagonalize the Hamiltonian before solving; # Same seeds give same evolution; # 3~5 time faster; # constant system only.; # --------------------------------------------------------------------------; def make_diag_system(self, H, c_ops):; ss = SolverSystem(); ss.td_c_ops = []; ss.td_n_ops = []. H_ = H.copy(); H_ *= -1j; for c in c_ops:; H_ += -0.5 * c.dag() * c. w, v = np.linalg.eig(H_.full()); arg = np.argsort(np.abs(w)); eig = w[arg]; U = v.T[arg].T; Ud = U.T.conj(). for c in c_ops:; c_diag = Qobj(Ud @ c.full(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html:18183,integrat,integration,18183,docs/4.4/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mcsolve.html,6,['integrat'],['integration']
Integrability,"------------------------; # Solve the Floquet-Markov master equation; #; #. [docs]def fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None,; args={}, options=Options(), floquet_basis=True, kmax=5,; _safe_mode=True, options_modes=None):; """"""; Solve the dynamics for the system using the Floquet-Markov master equation. .. note::. This solver currently does not support multiple collapse operators. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. rho0 / psi0 : :class:`qutip.qobj`; initial density matrix or state vector (ket). tlist : *list* / *array*; list of times for :math:`t`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. e_ops : list of :class:`qutip.qobj` / callback function; list of operators for which to evaluate expectation values. spectra_cb : list callback functions; List of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in `c_ops`. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. args : *dictionary*; dictionary of parameters for time-dependent Hamiltonians and; collapse operators. This dictionary should also contain an entry 'w_th', which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion. >>> temperature = 25e-3 # unit K # doctest: +SKIP; >>> h = 6.626e-34 # doctest: +SKIP; >>> kB = 1.38e-23 # doctest: +SKIP; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 \; #doctest: +SKIP. options : :class:`qutip.solver.Options`; options for the ODE solver. For solving the master equation. floquet_basis : bool; Will return results in Floquet basis or computational basis; (optional). k_max : int; The truncation of the number of sidebands (default 5). options_modes : :c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/floquet.html:25395,depend,dependence,25395,docs/4.7/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/floquet.html,2,['depend'],['dependence']
Integrability,"----------------------; if config.cflag:; config.c_const_inds = np.arange(len(c_ops)); # combine Hamiltonian and constant collapse terms into one; for c_op in c_ops:; n_op = c_op.dag() * c_op; H -= 0.5j * \; n_op ; # construct Hamiltonian data structures; if options.tidy:; H = H.tidyup(options.atol); config.h_data = -1.0j * H.data.data; config.h_ind = H.data.indices; config.h_ptr = H.data.indptr. elif config.tflag in [1, 10, 11]:; # STRING BASED TIME-DEPENDENCE; # ----------------------------. # take care of arguments for collapse operators, if any; if any(args):; for item in args.items():; config.c_args.append(item[1]); # constant Hamiltonian / string-type collapse operators; if config.tflag == 1:; H_inds = np.arange(1); H_tdterms = 0; len_h = 1; C_inds = np.arange(config.c_num); # find inds of time-dependent terms; C_td_inds = np.array(c_stuff[2]); # find inds of constant terms; C_const_inds = np.setdiff1d(C_inds, C_td_inds); # extract time-dependent coefficients (strings); C_tdterms = [c_ops[k][1] for k in C_td_inds]; # store indicies of constant collapse terms; config.c_const_inds = C_const_inds; # store indicies of time-dependent collapse terms; config.c_td_inds = C_td_inds. for k in config.c_const_inds:; H -= 0.5j * (c_ops[k].dag() * c_ops[k]); if options.tidy:; H = H.tidyup(options.atol); config.h_data = [H.data.data]; config.h_ind = [H.data.indices]; config.h_ptr = [H.data.indptr]; for k in config.c_td_inds:; op = c_ops[k][0].dag() * c_ops[k][0]; config.h_data.append(-0.5j * op.data.data); config.h_ind.append(op.data.indices); config.h_ptr.append(op.data.indptr); config.h_data = -1.0j * np.array(config.h_data); config.h_ind = np.array(config.h_ind); config.h_ptr = np.array(config.h_ptr). else:; # string-type Hamiltonian & at least one string-type; # collapse operator; # -----------------. H_inds = np.arange(len(H)); # find inds of time-dependent terms; H_td_inds = np.array(h_stuff[2]); # find inds of constant terms; H_const_inds = np.setdiff1d(H_inds, H_td_in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:32445,depend,dependent,32445,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,4,['depend'],['dependent']
Integrability,"-------------------; # Old style API below.; # -----------------------------------------------------------------------------. # -----------------------------------------------------------------------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # set",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:30950,depend,dependent,30950,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['depend'],['dependent']
Integrability,"-----------------; # Master equation solver: deprecated in 2.0.0. No support for time-dependent; # collapse operators. Only used by the deprecated odesolve function.; #; def _mesolve_list_td(H_func, rho0, tlist, c_op_list, e_ops, args, opt,; progress_bar):; """"""; Evolve the density matrix using an ODE solver with time dependent; Hamiltonian.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; # if initial state is a ket and no collapse operator where given,; # fall back on the unitary schrodinger equation solver; if len(c_op_list) == 0:; return _sesolve_list_td(H_func, rho0, tlist, e_ops, args, opt,; progress_bar). # Got a wave function as initial state: convert to density matrix.; rho0 = ket2dm(rho0). #; # construct liouvillian; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if not isinstance(H_func[0], (list, np.ndarray)) or len(H_func[0]) <= 1:; raise TypeError('Time-dependent Hamiltonians must be a list ' +; 'with two or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be list with ' +; 'length N-1 where N is the number of ' +; 'Hamiltonian terms.'). if opt.rhs_reuse and config.tdfunc is None:; rhs_generate(H_func, args). lenh = len(H_func[0]); if opt.tidy:; H_func[0] = [(H_func[0][k]).tidyup() for k in range(lenh)]; L_func = [[liouvillian(H_func[0][0], c_op_list)], H_func[1]]; for m in range(1, lenh):; L_func[0].append(liouvillian(H_func[0][m], [])). # create data arrays for time-dependent RHS function; Ldata = [L_func[0][k].data.data for k in range(lenh)]; Linds = [L_func[0][k].data.indices for k in range(lenh)]; Lptrs = [L_func[0][k].data.indptr for k in range(lenh)]; # setup ode args string; string = """"; for k in range(lenh):; string += (""Ldata[%d], Linds[%d], Lptrs[%d],"" % (k, k, k)). if args:; td_consts = args.items(); for elem in td_consts:; string += st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:31097,depend,dependent,31097,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['depend'],['dependent']
Integrability,"-------; N: int; The number of the component systems. params: dict, optional; A Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optional; A map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; ``(pulse_label, coeff)``, instead of ``(pulse_index, coeff)``.; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer ``pulse_index`` needs to be used; in the compiling routine saved under the attributes ``gate_compiler``. Attributes; ----------; gate_compiler: dict; The Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dict; Arguments for individual compiling routines.; It adds more flexibility in customizing compiler.; """"""; def __init__(self, N, params=None, pulse_dict=None):; self.gate_compiler = {}; self.N = N; self.params = params if params is not None else {}; self.pulse_dict = pulse_dict if pulse_dict is not None else {}; self.gate_compiler = {""GLOBALPHASE"": self.globalphase_compiler}; self.args = {""params"": self.params}; self.global_phase = 0. [docs] def globalphase_compiler(self, gate, args):; """"""; Compiler for the GLOBALPHASE gate; """"""; pass. [docs] def compile(self, circuit, schedule_mode=None, args=None):; """"""; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters; ----------; circuit: :class:`.QubitCircuit` or list of; :class:`.Gate`; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in `gate_compiler`. schedule_mode: str, optional; ``""ASAP""`` for ""as soon as possibl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html:3581,rout,routines,3581,docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/gatecompiler.html,4,['rout'],['routines']
Integrability,"-----; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; Attributes; ----------; name : string; key for the parent sections dictionary; will also be used as the header; ; parent : `class` : SolverStats; The container for all the sections; ; header : string; Used as heading for section in report; ; counts : OrderedDict; The integer type statistics for the stats section; ; timings : OrderedDict; The timing type statistics for the stats section; Expected to contain float values representing values in seconds; ; messages : OrderedDict; Text type output to be reported; ; total_time : float; Total time for processing in the section; Can be None, meaning that section timing percentages will be reported; """"""; def __init__(self, name, parent):; self.parent = parent; self.header = str(name); self.name = name; self.counts = OrderedDict(); self.timings = OrderedDict(); self.messages = OrderedDict(); self.total_time = None. def add_count(self, key, value):; """"""; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the given value; value is expected to be an integer; """"""; if not isinstance(value, int):; try:; value = int(value); except:; raise TypeError(""value is expected to be an integer""); ; if key in self.counts:; self.counts[key] += value; else:; self.counts[key] = value; ; def add_timing(self, key, value):; """"""; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds.; """"""; if not isinstance(value, float):; try:; value = float(value); except:; raise TypeError(""value is expected to be a float""); ; if key in self.timings:; self.timings[key] += value; else:; self.timings[key] = value; ; def add_message(self, key, value, sep="";""):; """"",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:21466,message,messages,21466,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,4,['message'],['messages']
Integrability,"--. output : nested list. A nested list of Floquet modes as kets for each time in `tlist`. """""". # truncate tlist to the driving period; tlist_period = tlist[np.where(tlist <= T)]. f_modes_table_t = [[] for t in tlist_period]. opt = Options(); opt.rhs_reuse = True. for n, f_mode in enumerate(f_modes_0):; output = mesolve(H, f_mode, tlist_period, [], [], args, opt); for t_idx, f_state_t in enumerate(output.states):; f_modes_table_t[t_idx].append(; f_state_t * exp(1j * f_energies[n] * tlist_period[t_idx])). return f_modes_table_t. [docs]def floquet_modes_t_lookup(f_modes_table_t, t, T):; """"""; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters; ----------. f_modes_table_t : nested list of :class:`qutip.qobj` (kets); A lookup-table of Floquet modes at times precalculated by; :func:`qutip.floquet.floquet_modes_table`. t : float; The time for which to evaluate the Floquet modes. T : float; The period of the time-dependence of the hamiltonian. Returns; -------. output : nested list. A list of Floquet modes as kets for the time that most closely matching; the time `t` in the supplied table of Floquet modes.; """""". # find t_wrap in [0,T] such that t = t_wrap + n * T for integer n; t_wrap = t - int(t / T) * T. # find the index in the table that corresponds to t_wrap (= tlist[t_idx]); t_idx = int(t_wrap / T * len(f_modes_table_t)). # XXX: might want to give a warning if the cast of t_idx to int discard; # a significant fraction in t_idx, which would happen if the list of time; # values isn't perfect matching the driving period; # if debug: print ""t = %f -> t_wrap = %f @ %d of %d"" % (t, t_wrap, t_idx,; # N). return f_modes_table_t[t_idx]. def floquet_states(f_modes_t, f_energies, t):; """"""; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters; ----------. f_modes_t : list of :class:`qutip.qobj` (kets); A list of Floquet modes for time :math:`t`. f_energies : array; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/floquet.html:7779,depend,dependence,7779,docs/4.2/modules/qutip/floquet.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/floquet.html,5,['depend'],['dependence']
Integrability,"-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. options : qutip.solver. options for the ODE solver. k_max : int. The truncation of the number of sidebands (default 5). Returns:output : qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters:H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. U : qutip.qobj. The propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns:output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters:f_modes_0 : list of qutip.qobj (kets). Floquet modes at \(t\). f_energies : list. Floquet energies. t : float. The time at which to evaluate the floquet modes. H : qutip.qobj. system Hamiltonian, time-dependent with period T. args : dictionary. dictionary with variables required to evaluate H. T : float. The period of the time-dependence of the hamiltonian. Returns:output : list of k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:70424,depend,dependence,70424,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,3,['depend'],['dependence']
Integrability,"-; # A time-dependent unitary wavefunction equation on the list-function format; #; def _sesolve_QobjEvo(H, tlist, args, opt):; """"""; Prepare the system for the solver, H can be an QobjEvo.; """"""; H_td = -1.0j * QobjEvo(H, args, tlist=tlist); if opt.rhs_with_state:; H_td._check_old_with_state(); nthread = opt.openmp_threads if opt.use_openmp else 0; H_td.compile(omp=nthread). ss = SolverSystem(); ss.H = H_td; ss.makefunc = _qobjevo_set; solver_safe[""sesolve""] = ss; return ss. def _qobjevo_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_td = HS.H; H_td.solver_set_args(args, psi, e_ops); if psi.isunitary:; func = H_td.compiled_qobjevo.ode_mul_mat_f_vec; elif psi.isket:; func = H_td.compiled_qobjevo.mul_vec; else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""); return func, (). # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent hamiltonians.; #; def _sesolve_func_td(H_func, args, opt):; """"""; Prepare the system for the solver, H is a function.; """"""; ss = SolverSystem(); ss.H = H_func; ss.makefunc = _Hfunc_set; solver_safe[""sesolve""] = ss; return ss. def _Hfunc_set(HS, psi, args, e_ops, opt):; """"""; From the system, get the ode function and args; """"""; H_func = HS.H; if psi.isunitary:; if not opt.rhs_with_state:; func = _ode_oper_func_td; else:; func = _ode_oper_func_td_with_state; else:; if not opt.rhs_with_state:; func = cy_ode_psi_func_td; else:; func = cy_ode_psi_func_td_with_state. return func, (H_func, args). # -----------------------------------------------------------------------------; # evaluate dU(t)/dt according to the schrodinger equation; #; def _ode_oper_func_td(t, y, H_func, args):; H = H_func(t, args).data * -1j; ym = vec2mat(y); return (H * ym).ravel(""F""). def _ode_oper_func_td_with_state(t, y, H_func, args):; H = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/sesolve.html:7673,depend,dependent,7673,docs/4.5/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/sesolve.html,5,['depend'],['dependent']
Integrability,"-Based Time-Dependent Problems using Parfor. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:1607,depend,dependence,1607,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,4,['depend'],"['depend', 'dependence']"
Integrability,"-Phonon Interaction through Mode Field Coupling in Hybrid Optomechanical Systems"", ; Phys. Rev. Lett. 118, 133603 (2017). 224. Jonsson et al., ""Efficient determination of the Markovian time-evolution towards a steady-state of a complex open quantum system"", ; Comput. Phys. Commun. 220, 81 (2017). 223. Lahoz-Beltra, ""Quantum Genetic Algorithms for Computer Scientists"", ; Computers 5, 24 (2016). 222. Davis-Tilley et al., ""Synchronization of micromasers"", ; Phys. Rev. A 94, 063819 (2016). 221. Weinberg et al., ""QuSpin: a Python package for dynamics and exact diagonalisation of quantum many body systems part I: spin chains"", ; SciPost Phys. 2, 003 (2017). 220. Dory et al., ""Tuning the photon statistics of a strongly coupled nanophotonic system"", ; Phys. Rev. A 95, 023804 (2017). 219. Lachance-Quirion et al., ""Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet"", ; Science Advances 3, (2017). 218. Doyeux et al., ""Excitation injector in an atomic chain: Long-range transport and efficiency amplification"", ; Phys. Rev. A 95, 012138 (2017). 217. Roulet et al., ""Autonomous Rotor Heat Engine"", ; Phys. Rev. E 95, 062131 (2017). 216. Nigg et al., ""Robust quantum optimizer with full connectivity"", ; Science Advances 3, 1602273 (2017). 215. Puri et al., ""Quantum annealing with all-to-all connected nonlinear oscillators"", ; Nat. Commun. 8, 15785 (2017).>. 214. Shi et al., ""Model reduction of cavity nonlinear optics for photonic logic: a quasi-principal components approach"", ; J. Phys. D: Appl. Phys. 49, 465501 (2016). 213. McNally et al., ""Performance of 1D quantum cellular automata in the presence of error"", ; AIP Advances 6, 095115 (2016). 212. Zhong et al., ""Towards quantum entanglement of micromirrors via a two-level atom and radiation pressure"", ; arXiv:1609.00590. 211. Roth et al., ""Synchronization of active atomic clocks via quantum and classical channels"", ; Phys. Rev. A 94, 043841 (2016). 210. Jarlov et al., ""Effect of Pure Dephasing and Phono",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:20177,inject,injector,20177,users.html,https://qutip.org,https://qutip.org/users.html,1,['inject'],['injector']
Integrability,"-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator U. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None, options=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. optionsqutip.solver.Optionsoptions for the ODE solver. For the propagator. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None, options=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:102970,depend,dependence,102970,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependence']
Integrability,"-dependent Qobj as a list*; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`, :class:`qutip.QobjEvo` or [Qobj, coeff*]; List of deterministic collapse operators. sc_ops : list of :class:`qutip.Qobj`, :class:`qutip.QobjEvo` or [Qobj, coeff*]; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; order 2 algorithms: 'taylor2.0'; call help of :func:`qutip.stochastic.stochastic_solvers`; for a description of the solvers.; Implicit methods can adjust tolerance via the kw 'tol'; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:9015,depend,dependent,9015,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,2,['depend'],['dependent']
Integrability,"-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:15581,depend,dependent,15581,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,"-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; In [20]: N = 10 # number of basis states to consider. In [21]: a = destroy(N). In [22]: H = a.dag() * a. In [23]: psi0 = basis(N, 9) # initial state. In [24]: kappa = 0.2 # coupling to oscillator. In [25]: a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. In [26]: tlist = np.linspace(0, 10, 100). In [27]: out = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:16207,depend,dependent,16207,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,"-level systems. Returns; -------; nds: int; The number of Dicke states.; """"""; return _num_dicke_states(N). [docs]def num_dicke_ladders(N):; """"""Calculate the total number of ladders in the Dicke space. For a collection of N two-level systems it counts how many different; ""j"" exist or the number of blocks in the block-diagonal matrix. Parameters; ----------; N: int; The number of two-level systems. Returns; -------; Nj: int; The number of Dicke ladders.; """"""; return _num_dicke_ladders(N). [docs]def num_tls(nds):; """"""Calculate the number of two-level systems. Parameters; ----------; nds: int; The number of Dicke states. Returns; -------; N: int; The number of two-level systems.; """"""; if np.sqrt(nds).is_integer():; # N is even; N = 2*(np.sqrt(nds)-1); else:; # N is odd; N = 2*(np.sqrt(nds + 1/4)-1); return int(N). [docs]def isdiagonal(mat):; """"""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""; if isinstance(mat, Qobj):; mat = mat.full(). return np.all(mat == np.diag(np.diagonal(mat))). [docs]class Dicke(object):; """"""The Dicke class which builds the Lindbladian and Liouvillian matrix. Example; -------; >>> from piqs import Dicke, jspin; >>> N = 2; >>> jx, jy, jz = jspin(N); >>> jp = jspin(N, ""+""); >>> jm = jspin(N, ""-""); >>> ensemble = Dicke(N, emission=1.); >>> L = ensemble.liouvillian(). Parameters; ----------; N: int; The number of two-level systems. hamiltonian : :class:`qutip.Qobj`; A Hamiltonian in the Dicke basis. The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the `jspin` functions. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/piqs.html:4161,depend,depending,4161,docs/4.4/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/piqs.html,1,['depend'],['depending']
Integrability,"-level systems. Returns; -------; nds: int; The number of Dicke states.; """"""; return _num_dicke_states(N). [docs]def num_dicke_ladders(N):; """"""Calculate the total number of ladders in the Dicke space. For a collection of N two-level systems it counts how many different; ""j"" exist or the number of blocks in the block-diagonal matrix. Parameters; ----------; N: int; The number of two-level systems. Returns; -------; Nj: int; The number of Dicke ladders.; """"""; return _num_dicke_ladders(N). [docs]def num_tls(nds):; """"""Calculate the number of two-level systems. Parameters; ----------; nds: int; The number of Dicke states. Returns; -------; N: int; The number of two-level systems.; """"""; if np.sqrt(nds).is_integer():; # N is even; N = 2*(np.sqrt(nds)-1); else:; # N is odd; N = 2*(np.sqrt(nds + 1/4)-1); return int(N). [docs]def isdiagonal(mat):; """"""; Check if the input matrix is diagonal. Parameters; ==========; mat: ndarray/Qobj; A 2D numpy array. Returns; =======; diag: bool; True/False depending on whether the input matrix is diagonal.; """"""; if isinstance(mat, Qobj):; mat = mat.full(). return np.all(mat == np.diag(np.diagonal(mat))). [docs]class Dicke(object):; """"""The Dicke class which builds the Lindbladian and Liouvillian matrix. Example; -------; >>> from piqs import Dicke, jspin; >>> N = 2; >>> jx, jy, jz = jspin(N); >>> jp = jspin(N, ""+""); >>> jm = jspin(N, ""-""); >>> ensemble = Dicke(N, emission=1.); >>> L = ensemble.liouvillian(). Parameters; ----------; N: int; The number of two-level systems. hamiltonian: :class: qutip.Qobj; A Hamiltonian in the Dicke basis. The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the `jspin` functions. emission: float; Incoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: float; Local dephasing coefficient.; default: 0.0. pumping: float; Incoherent pumping coefficient.; default: 0.0. collective_emission: float; C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/piqs.html:4165,depend,depending,4165,docs/4.3/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/piqs.html,1,['depend'],['depending']
Integrability,"-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compatible with the HSolverDL provided in qutip.nonmarkov.heom; in QuTiP 4.6 and below.; See HEOMSolver and DrudeLorentzBath for more; descriptions of the underlying solver and bath construction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be completely; removed in QuTiP 5. Note; Unlike the version of HSolverDL in QuTiP 4.6, this solver; supports supplying a time-dependent or Liouvillian H_sys. Note; For compatibility with HSolverDL in QuTiP 4.6 and below, the; parameter N_exp specifying the number of exponents to keep in; the expansion of the bath correlation function is one more than; the equivalent Nk used in the DrudeLorentzBath. I.e.,; Nk = N_exp - 1. The Nk parameter in the; DrudeLorentzBath does not count the zeroeth exponent in; order to better match common usage in the literature. Note; The stats and renorm arguments accepted in QuTiP 4.6 and below; are no longer supported. Parameters. H_sysQobj or QobjEvo or listThe system Hamiltonian or Liouvillian. See HEOMSolver for; a complete description. coup_opQobjOperator describing the coupling between system and bath.; See parameter Q in BosonicBath for a complete description. coup_strengthfloatCoupling strength. Referred to as lam in DrudeLorentzBath. temperaturefloatBath temperature. Referred to as T in DrudeLorentzBath. N_cutintThe maximum depth of the hierarchy. See max_depth in; HE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:47522,depend,dependent,47522,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['depend'],['dependent']
Integrability,". """"""; def __init__(self, optimconfig, params=None):; self.config = optimconfig; self.params = params; self.reset(). def reset(self):; # Link to optimiser object if self is linked to one; self.parent = None; # Main functional attributes; self.time = None; self.initial = None; self.target = None; self.ctrl_amps = None; self.initial_ctrl_scaling = 1.0; self.initial_ctrl_offset = 0.0; self.drift_dyn_gen = None; self.ctrl_dyn_gen = None; self._tau = None; self._evo_time = None; self._num_ctrls = None; self._num_tslots = None; # attributes used for processing evolution; self.memory_optimization = 0; self.oper_dtype = None; self.cache_phased_dyn_gen = None; self.cache_prop_grad = None; self.cache_dyn_gen_eigenvectors_adj = None; self.sparse_eigen_decomp = None; self.dyn_dims = None; self.dyn_shape = None; self.sys_dims = None; self.sys_shape = None; self.time_depend_drift = False; self.time_depend_ctrl_dyn_gen = False; # These internal attributes will be of the internal operator data type; # used to compute the evolution; # Note this maybe ndarray, Qobj or some other depending on oper_dtype; self._drift_dyn_gen = None; self._ctrl_dyn_gen = None; self._phased_ctrl_dyn_gen = None; self._dyn_gen_phase = None; self._phase_application = None; self._initial = None; self._target = None; self._onto_evo_target = None; self._dyn_gen = None; self._phased_dyn_gen = None; self._prop = None; self._prop_grad = None; self._fwd_evo = None; self._onwd_evo = None; self._onto_evo = None; # The _qobj attribs are Qobj representations of the equivalent; # internal attribute. They are only set when the extenal accessors; # are used; self._onto_evo_target_qobj = None; self._dyn_gen_qobj = None; self._prop_qobj = None; self._prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:14844,depend,depending,14844,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,2,['depend'],['depending']
Integrability,". #; # we have collapse operators; #. #; # find out if we are dealing with all-constant hamiltonian and; # collapse operators or if we have at least one time-dependent; # operator. Then delegate to appropriate solver...; #. if isinstance(H, Qobj):; # constant hamiltonian; if n_func == 0 and n_str == 0:; # constant collapse operators; res = _mesolve_const(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_str > 0:; # constant hamiltonian but time-dependent collapse; # operators in list string format; res = _mesolve_list_str_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); elif n_func > 0:; # constant hamiltonian but time-dependent collapse; # operators in list function format; res = _mesolve_list_func_td([H], rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, (types.FunctionType,; types.BuiltinFunctionType, partial)):; # function-callback style time-dependence: must have constant; # collapse operators; if n_str > 0: # or n_func > 0:; raise TypeError(""Incorrect format: function-format "" +; ""Hamiltonian cannot be mixed with "" +; ""time-dependent collapse operators.""); else:; res = _mesolve_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). elif isinstance(H, list):; # determine if we are dealing with list of [Qobj, string] or; # [Qobj, function] style time-dependencies (for pure python and; # cython, respectively); if n_func > 0:; res = _mesolve_list_func_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar); else:; res = _mesolve_list_str_td(H, rho0, tlist, c_ops,; e_ops, args, options,; progress_bar). else:; raise TypeError(""Incorrect specification of Hamiltonian "" +; ""or collapse operators.""). else:; #; # no collapse operators: unitary dynamics; #; if n_func > 0:; res = _sesolve_list_func_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif n_str > 0:; res = _sesolve_list_str_td(H, rho0, tlist,; e_ops, args, options, progress_bar); elif isinstance(H, (types.FunctionTy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html:11692,depend,dependence,11692,docs/3.1.0/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html,2,['depend'],"['dependence', 'dependent']"
Integrability,". . API documentation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/apidoc.html:1261,depend,dependent,1261,docs/4.0.2/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability,". . API documentation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/apidoc.html:1275,depend,dependent,1275,docs/4.1/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability,". . API documentation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/apidoc.html:1275,depend,dependent,1275,docs/4.2/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability,". . API documentation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation. API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/apidoc.html:1302,depend,dependent,1302,docs/4.3/apidoc/apidoc.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/apidoc.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-eseries.html:437,depend,dependent,437,docs/4.0.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-eseries.html:437,depend,dependent,437,docs/4.1/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-eseries.html:437,depend,dependent,437,docs/4.2/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-eseries.html:437,depend,dependent,437,docs/4.3/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-eseries.html:433,depend,dependent,433,docs/4.4/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . An Overview of the Eseries Class — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; An Overview of the Eseries Class. An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-eseries.html:437,depend,dependent,437,docs/4.5/guide/guide-eseries.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-eseries.html,1,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that cou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html:553,depend,dependent,553,docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-bloch-redfield.html,1,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that cou",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-bloch-redfield.html:553,depend,dependent,553,docs/4.1/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-bloch-redfield.html,1,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying en",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:432,depend,dependent,432,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for examp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html:432,depend,dependent,432,docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html:501,depend,dependent,501,docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,". . Bloch-Redfield master equation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html:485,depend,dependent,485,docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-bloch-redfield.html,2,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-data.html:544,depend,dependent,544,docs/4.0.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-data.html:544,depend,dependent,544,docs/4.1/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html:512,depend,dependent,512,docs/4.2/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html:512,depend,dependent,512,docs/4.3/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-data.html:581,depend,dependent,581,docs/4.4/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Dynamics Simulation Results — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-data.html:565,depend,dependent,565,docs/4.5/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-data.html,1,['depend'],['dependent']
Integrability,". . Floquet Formalism — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-floquet.html:451,depend,dependent,451,docs/4.0.2/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-floquet.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:; N (int) – Number of Fock states in Hilbert space.; n (int) – Integer corresponding to desired number state, defaults; to 0 if omitted.; offset (int (default 0)) – The lowest number state that is included in the finite number state; representation of the state. Returns:state – Qobj representing the requested number state |n>. Return type:qobj. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. Notes; A",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:828,depend,dependent,828,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:828,depend,dependent,828,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:828,depend,dependent,828,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:; N : int; Number of Fock states in Hilbert space. n : int; Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the state. Returns:; state : qobj; Qobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:829,depend,dependent,829,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters. NintNumber of Fock states in Hilbert space. nintInteger corresponding to desired number state, defaults; to 0 if omitted. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the state. Returns. statequtip.QobjQobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:825,depend,dependent,825,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Functions — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Noisy Devices. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)Integer corresponding to desired number state, defaults to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:895,depend,dependent,895,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['depend'],['dependent']
Integrability,". . Installation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Verifying the Installation; Checking Version Information using the About Function; Installation on MS Windows. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:565,depend,depends,565,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,2,['depend'],"['dependent', 'depends']"
Integrability,". . Installation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:589,depend,depends,589,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,1,['depend'],['depends']
Integrability,". . Installation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/installation.html:589,depend,depends,589,docs/4.2/installation.html,https://qutip.org,https://qutip.org/docs/4.2/installation.html,1,['depend'],['depends']
Integrability,". . Installation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/installation.html:589,depend,depends,589,docs/4.3/installation.html,https://qutip.org,https://qutip.org/docs/4.3/installation.html,1,['depend'],['depends']
Integrability,". . Installation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when usin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:585,depend,depends,585,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,1,['depend'],['depends']
Integrability,". . Installation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:598,depend,depends,598,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['depend'],['depends']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in princ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-master.html:537,depend,dependent,537,docs/4.0.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in princ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-master.html:537,depend,dependent,537,docs/4.1/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in princ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html:505,depend,dependent,505,docs/4.2/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This mat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html:505,depend,dependent,505,docs/4.3/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html:574,depend,dependent,574,docs/4.4/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Lindblad Master Equation Solver — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\ri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html:558,depend,dependent,558,docs/4.5/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-master.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:488,depend,dependent,488,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:488,depend,dependent,488,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:456,depend,dependent,456,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:456,depend,dependent,456,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:561,depend,dependent,561,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,". . Monte Carlo Solver — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corres",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:509,depend,dependent,509,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Def,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-options.html:474,depend,dependent,474,docs/4.0.2/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Def,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-options.html:474,depend,dependent,474,docs/4.1/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Def,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html:442,depend,dependent,442,docs/4.2/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options =,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html:442,depend,dependent,442,docs/4.3/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. The,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html:511,depend,dependent,511,docs/4.4/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,. . Setting Options for the Dynamics Solvers — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; stor,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html:495,depend,dependent,495,docs/4.5/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html,1,['depend'],['dependent']
Integrability,". . Stochastic Solver - Photocurrent — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html:531,depend,dependent,531,docs/4.4/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-photocurrent.html,1,['depend'],['dependent']
Integrability,". . Stochastic Solver - Photocurrent — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a pro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html:515,depend,dependent,515,docs/4.5/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-photocurrent.html,1,['depend'],['dependent']
Integrability,". . Stochastic Solver — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \left( \frac{C_n^{+} C_n}{",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html:508,depend,dependent,508,docs/4.4/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-stochastic.html,1,['depend'],['dependent']
Integrability,". . Stochastic Solver — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶. Homodyne detection¶; Homodyne detection is an extension of the photocurrent method where the output; is mixed with a strong external source allowing to get information about the; phase of the system. With this method, the resulting detection rate depends is. \[ \begin{align}\begin{aligned}:label: jump_rate\\\tau = tr \left((\gamma^2 + \gamma (C+C^\dag) + C^\dag C)\rho \right)\end{aligned}\end{align} \]; With \(\gamma\), the strength of the external beam and \(C\) the collapse; operator. When the beam is very strong \((\gamma >> C^\dag C)\),; the rate becomes a constant term plus a term proportional to the quadrature of; the system. Closed system¶; In closed systems, the resulting stochastic differential equation is. (1)¶\[\delta \psi(t) = - i H \psi(t) \delta t; - \sum_n \",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html:492,depend,dependent,492,docs/4.5/guide/dynamics/dynamics-stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-stochastic.html,1,['depend'],['dependent']
Integrability,". . Time Evolution and Quantum System Dynamics — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-dynamics.html:476,depend,dependent,476,docs/4.0.2/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,. . Time Evolution and Quantum System Dynamics — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solv,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/guide-dynamics.html:476,depend,dependent,476,docs/4.1/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,. . Time Evolution and Quantum System Dynamics — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolutio,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-dynamics.html:444,depend,dependent,444,docs/4.2/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,. . Time Evolution and Quantum System Dynamics — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theor,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-dynamics.html:444,depend,dependent,444,docs/4.3/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,. . Time Evolution and Quantum System Dynamics — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems u,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-dynamics.html:513,depend,dependent,513,docs/4.4/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,. . Time Evolution and Quantum System Dynamics — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing. Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Homodyne detection. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Bloch-Redfield mas,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-dynamics.html:497,depend,dependent,497,docs/4.5/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-dynamics.html,1,['depend'],['dependent']
Integrability,". ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monito",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/development.html:1064,integrat,integration,1064,docs/4.6/development/development.html,https://qutip.org,https://qutip.org/docs/4.6/development/development.html,2,['integrat'],['integration']
Integrability,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:512,depend,dependent,512,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,". Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2ac6866d3b90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:33727,integrat,integrating,33727,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['integrat'],['integrating']
Integrability,". Density matrix for which to calculate the covariance matrix. Returns:cov_mat: *array* :. A 2-dimensional array of covariance values. logarithmic_negativity(V)¶; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters:V : 2d array. The covariance matrix. Returns:N: *float*, the logarithmic negativity for the two-mode Gaussian state :; that is described by the the Wigner covariance matrix V. :. Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, rho0, tlist, e_ops, args={}, options=None, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3a90>)¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; an ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:33789,integrat,integrating,33789,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['integrat'],['integrating']
Integrability,". Dynamics Simulation Results — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. resu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html:563,depend,dependent,563,docs/4.6/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-data.html,2,['depend'],['dependent']
Integrability,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:592,depend,dependent,592,docs/4.7/guide/dynamics/dynamics-data.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html,2,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:01; 50.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.46s. Est. time left: 00:00:00:00; 70.0%. Run time: 1.70s. Est. time left: 00:00:00:00; 80.0%. Run time: 1.95s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.21s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.46s. Est. time left: 00:00:00:00; Total run time: 2.47s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:10351,depend,dependent,10351,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:01; 50.0%. Run time: 1.28s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.53s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.79s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.03s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.28s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.57s. Est. time left: 00:00:00:00; Total run time: 2.63s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:9818,depend,dependent,9818,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:01; 50.0%. Run time: 1.30s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.57s. Est. time left: 00:00:00:01; 70.0%. Run time: 1.82s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.09s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.35s. Est. time left: 00:00:00:00; 100.0%. Run time: 2.60s. Est. time left: 00:00:00:00; Total run time: 2.63s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [30]: kappa = 0.5. In [31]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:10078,depend,dependent,10078,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:03; 50.0%. Run time: 2.69s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.24s. Est. time left: 00:00:00:02; 70.0%. Run time: 3.79s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.38s. Est. time left: 00:00:00:01; 90.0%. Run time: 4.93s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.46s. Est. time left: 00:00:00:00; Total run time: 5.46s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html:9844,depend,dependent,9844,docs/4.3/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:03; 50.0%. Run time: 2.84s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.54s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.23s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.94s. Est. time left: 00:00:00:01; 90.0%. Run time: 6.06s. Est. time left: 00:00:00:00; 100.0%. Run time: 6.80s. Est. time left: 00:00:00:00; Total run time: 6.90s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [28]: kappa = 0.5. In [29]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [30]: N = 10 # number of basis states. In [31]: a = destroy(N). In [32]: H = a.dag() * a # simple HO. In [33]: psi0 = basis(N, 9) # initial state. In [34]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [35]: times = np.linspace(0, 10, 100). In [36]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [37]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [38]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html:10376,depend,dependent,10376,docs/4.5/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Est. time left: 00:00:00:03; 50.0%. Run time: 2.90s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.49s. Est. time left: 00:00:00:02; 70.0%. Run time: 4.10s. Est. time left: 00:00:00:01; 80.0%. Run time: 4.65s. Est. time left: 00:00:00:01; 90.0%. Run time: 5.22s. Est. time left: 00:00:00:00; 100.0%. Run time: 5.80s. Est. time left: 00:00:00:00; Total run time: 5.92s. The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; In [30]: kappa = 0.5. In [31]: def col_coeff(t, args): # coefficient function; ....: return np.sqrt(kappa * np.exp(-t)); ....: . In [32]: N = 10 # number of basis states. In [33]: a = destroy(N). In [34]: H = a.dag() * a # simple HO. In [35]: psi0 = basis(N, 9) # initial state. In [36]: c_ops = [[a, col_coeff]] # time-dependent collapse term. In [37]: times = np.linspace(0, 10, 100). In [38]: output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable; In [39]: def H1_coeff(t, args):; ....: return args['A'] * np.exp(-(t/args['sigma'])**2); ....: . or equivalently,; In [40]: def H1_coeff(t, args):; ....: A = args['A']; ....:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html:10441,depend,dependent,10441,docs/3.1.0/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html,1,['depend'],['dependent']
Integrability,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:499,depend,dependent,499,docs/4.7/guide/dynamics/dynamics-floquet.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html,2,['depend'],['dependent']
Integrability,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:937,depend,dependent,937,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['depend'],['dependent']
Integrability,". Functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Krylov Subspace Solver; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:961,depend,dependent,961,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['depend'],['dependent']
Integrability,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:494,depend,dependent,494,docs/4.7/guide/dynamics/dynamics-intro.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html,2,['depend'],['dependent']
Integrability,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:533,depend,dependent,533,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,2,['depend'],['dependent']
Integrability,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:585,depend,dependent,585,docs/4.7/guide/dynamics/dynamics-master.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html,2,['depend'],['dependent']
Integrability,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:536,depend,dependent,536,docs/4.7/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html,2,['depend'],['dependent']
Integrability,. Setting Options for the Dynamics Solvers — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:493,depend,dependent,493,docs/4.6/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html,2,['depend'],['dependent']
Integrability,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:522,depend,dependent,522,docs/4.7/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html,2,['depend'],['dependent']
Integrability,". Stochastic Solver - Photocurrent — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html:513,depend,dependent,513,docs/4.6/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-photocurrent.html,2,['depend'],['dependent']
Integrability,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:542,depend,dependent,542,docs/4.7/guide/dynamics/dynamics-photocurrent.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html,2,['depend'],['dependent']
Integrability,. Time Evolution and Quantum System Dynamics — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data; Running String-Bas,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-dynamics.html:495,depend,dependent,495,docs/4.6/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-dynamics.html,2,['depend'],['dependent']
Integrability,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-dynamics.html:524,depend,dependent,524,docs/4.7/guide/guide-dynamics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html,2,['depend'],['dependent']
Integrability,". add_section(name)[source]¶; Add another section with the given name. Parameters:name (string) – will be used as key for sections dict; will also be the header for the section. Returns:section – The new section. Return type:class : _StatsSection. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters:; key (string) – key for the section.timings dictionary; reusing a key will result in numerical addition of value; value (int) – Initial value of the timing, or added to an existing timing; section (string or class : _StatsSection) – Section which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters:output (stream) – file or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters:; value (float) – Time in seconds to complete the solver section; section (string or class : _StatsSection) – Section which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(H=None, state0=None, times=None, c_ops=[], sc_ops=[], e_ops=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:42429,message,messages,42429,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['message'],['messages']
Integrability,". before the function name in the string, i.e 'np.sin(t)'. This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...]. where H0 is a time-independent Hamiltonian, while H1,``H2``, are time dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...]. Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any ord",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html:5194,depend,dependent,5194,docs/4.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-time.html,2,['depend'],['dependent']
Integrability,". def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_forma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:39000,depend,dependence,39000,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['depend'],['dependence']
Integrability,". e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r). if opt.store_states:; if issuper(rho0):; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims, fast=""mc-dm"")). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/mesolve.html:16678,integrat,integrate,16678,docs/4.5/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/mesolve.html,1,['integrat'],['integrate']
Integrability,". from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.interpolate import Cubic_Spline; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`) and an [optional] set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. If either `H` ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html:3371,depend,depending,3371,docs/4.0.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/mesolve.html,1,['depend'],['depending']
Integrability,". property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:174639,rout,routine,174639,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,4,['rout'],['routine']
Integrability,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/about.html:393,depend,dependencies,393,docs/4.7/modules/qutip/about.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html,2,['depend'],['dependencies']
Integrability,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:504,integrat,integrate,504,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability,". qutip.control.pulseoptim — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:579,Wrap,Wrapper,579,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['Wrap'],['Wrapper']
Integrability,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/eseries.html:585,depend,dependent,585,docs/4.7/modules/qutip/eseries.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html,4,['depend'],"['dependence', 'dependent']"
Integrability,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:843,message,message,843,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,4,"['message', 'wrap']","['message', 'wraps']"
Integrability,". qutip.graph — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.graph. Source code for qutip.graph; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'column_permutation', 'breadth_first_search',; 'reverse_cuthill_mckee', 'maximum_bipartite_matching',; 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching); import warnings. def _deprecate():; warnings.warn((""qutip graph functions are deprecated.""; "" Consider using scipy.sparse.csgraph instead.""),; DeprecationWarning). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row).; """"""; _deprecate(); if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return np.asarray(_node_degrees(A.indices, A.indptr, A.shape[0])). [docs]def breadth_first_search(A, start):; """"""; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs. This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters; ----------; A : csc_matrix, csr_matrix; Input graph in CSC or CSR matrix format; start : int; Staring node for BFS traversal. Returns; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/graph.html:395,rout,routines,395,docs/4.7/modules/qutip/graph.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/graph.html,2,['rout'],['routines']
Integrability,". qutip.ipynbtools — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.ipynbtools. Source code for qutip.ipynbtools; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """"""; from qutip.ui.progressbar import BaseProgressBar; from qutip.utilities import _blas_info, available_cpu_count; import IPython. #IPython parallel routines moved to ipyparallel in V4; #IPython parallel routines not in Anaconda by default; if IPython.version_info[0] >= 4:; try:; from ipyparallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']; else:; try:; from IPython.parallel import Client; __all__ = ['version_table', 'parfor', 'plot_animation',; 'parallel_map', 'HTMLProgressBar']; except:; __all__ = ['version_table', 'plot_animation', 'HTMLProgressBar']. from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation; from base64 import b64encode. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html:590,rout,routines,590,docs/4.7/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/ipynbtools.html,4,['rout'],['routines']
Integrability,". qutip.mcsolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mcsolve. Source code for qutip.mcsolve; __all__ = ['mcsolve']. import os; import numpy as np; from numpy.random import RandomState, randint; import scipy.sparse as sp; from scipy.integrate import ode; from scipy.integrate._ode import zvode. from types import FunctionType, BuiltinFunctionType; from functools import partial; from qutip.fastsparse import csr2fast; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.mcsolve import CyMcOde, CyMcOdeDiag; from qutip.cy.spconvert import dense1D_to_fastcsr_ket; from qutip.sesolve import sesolve; from qutip.solver import (Options, Result, ExpectOps,; solver_safe, SolverSystem); from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions. # Todo: use real warning; def warn(text):; print(text). class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0,; args={}, options=None, progress_bar=True,; map_func=parallel_map, map_kwargs={}, _safe_mode=True):; r""""""Monte Carlo evolution of a state vector :math:`|\psi \rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html:485,integrat,integrate,485,docs/4.7/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mcsolve.html,4,['integrat'],['integrate']
Integrability,". qutip.mesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.mesolve. Source code for qutip.mesolve; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve']. import numpy as np; import scipy.integrate; from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, vec2mat, lindblad_dissipator; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, solver_safe, SolverSystem; from qutip.cy.spmatfuncs import spmv; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.states import ket2dm; from qutip.sesolve import sesolve; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.qobjevo import QobjEvo. from qutip.cy.openmp.utilities import check_use_openmp. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian or Liouvillian (`H`) and an optional set of collapse operators; (`c_ops`), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mesolve.html:502,integrat,integrate,502,docs/4.7/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html,2,['integrat'],['integrate']
Integrability,". qutip.nonmarkov.bofin_solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.bofin_solvers. Source code for qutip.nonmarkov.bofin_solvers; """"""; This module provides solvers for system-bath evoluation using the; HEOM (hierarchy equations of motion). See https://en.wikipedia.org/wiki/Hierarchical_equations_of_motion for a very; basic introduction to the technique. The implementation is derived from the BoFiN library (see; https://github.com/tehruhn/bofin) which was itself derived from an earlier; implementation in QuTiP itself.; """""". from copy import deepcopy. import numpy as np; import scipy.sparse as sp; import scipy.integrate; from scipy.sparse.linalg import spsolve. from qutip import settings; from qutip import state_number_enumerate; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.superoperator import liouvillian, spre, spost, vec2mat; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.fastsparse import fast_identity, fast_csr_matrix; from qutip.nonmarkov.bofin_baths import (; BathExponent, DrudeLorentzBath,; ). # Load MKL spsolve if avaiable; if settings.has_mkl:; from qutip._mkl.spsolve import mkl_spsolve; else:; mkl_spsolve = None. [docs]class HierarchyADOs:; """"""; A description of ADOs (auxilliary density operators) with the; hierarchical equations of motion. The list of ADOs is constructed from a list of bath exponents; (corresponding to one or more baths). Each ADO is referred to by a label; that lists the number of ""excitations"" of each bath exponent. The; level of a label within the hierarchy is the sum of the ""ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:880,integrat,integrate,880,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['integrat'],['integrate']
Integrability,". qutip.nonmarkov.dlheom_solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.nonmarkov.dlheom_solver. Source code for qutip.nonmarkov.dlheom_solver; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.special import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html:722,integrat,integrate,722,docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,2,['integrat'],['integrate']
Integrability,". qutip.piqs — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.piqs. Source code for qutip.piqs; """"""Permutational Invariant Quantum Solver (PIQS). This module calculates the Liouvillian for the dynamics of ensembles of; identical two-level systems (TLS) in the presence of local and collective; processes by exploiting permutational symmetry and using the Dicke basis.; It also allows to characterize nonlinear functions of the density matrix.; """""". # Authors: Nathan Shammah, Shahnawaz Ahmed; # Contact: nathan.shammah@gmail.com, shahnawaz.ahmed95@gmail.com. from math import factorial; from decimal import Decimal. import numpy as np; from scipy.integrate import odeint; from scipy.linalg import eigvalsh; from scipy.special import entr; from scipy.sparse import dok_matrix, block_diag, lil_matrix; from qutip.solver import Options, Result; from qutip import (; Qobj,; spre,; spost,; tensor,; identity,; ket2dm,; ); from qutip import sigmax, sigmay, sigmaz, sigmap, sigmam; from qutip.cy.piqs import Dicke as _Dicke; from qutip.cy.piqs import (; jmm1_dictionary,; _num_dicke_states,; _num_dicke_ladders,; get_blocks,; j_min,; j_vals,; ). __all__ = [; ""num_dicke_states"",; ""num_dicke_ladders"",; ""num_tls"",; ""isdiagonal"",; ""dicke_blocks"",; ""dicke_blocks_full"",; ""dicke_function_trace"",; ""purity_dicke"",; ""entropy_vn_dicke"",; ""Dicke"",; ""state_degeneracy"",; ""m_degeneracy"",; ""energy_degeneracy"",; ""ap"",; ""am"",; ""spin_algebra"",; ""jspin"",; ""collapse_uncoupled"",; ""dicke_basis"",; ""dicke"",; ""excited"",; ""superradiant"",; ""css"",; ""ghz"",; ""ground"",; ""identity_uncoupled"",; ""block_matrix"",; ""tau_column"",; ""Pim"",; ]. def _ensure_int(x):; """"""; Ensure that a floating-point value `x` is exactly an integer, and return it; as an int.; """"""; out = int(x); if out != x:; raise ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/piqs.html:888,integrat,integrate,888,docs/4.7/modules/qutip/piqs.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/piqs.html,2,['integrat'],['integrate']
Integrability,". qutip.qip.compiler.instruction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.instruction. Source code for qutip.qip.compiler.instruction; from copy import deepcopy; import numpy as np. __all__ = ['Instruction']. [docs]class Instruction():; """"""; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters; ----------; gate: :class:`.Gate`; The quantum gate.; duration: list, optional; The execution time needed for the instruction.; tlist: array_like, optional; A list of time at which the time-dependent coefficients are; applied. See :class:`.Pulse` for detailed information`; pulse_info: list, optional; A list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes; ----------; targets: list, optional; The target qubits.; controls: list, optional; The control qubits.; used_qubits: set; Union of the control and target qubits.; """"""; def __init__(; self, gate, tlist=None,; pulse_info=(), duration=1):; self.gate = deepcopy(gate); self.used_qubits = set(); if self.targets is not None:; self.targets.sort() # Used when comparing the instructions; self.used_qubits |= set(self.targets); if self.controls is not None:; self.controls.sort(); self.used_qubits |= set(self.controls); self.tlist = tlist; if self.tlist is not None:; if np.isscalar(self.tlist):; self.duration = self.tlist; elif abs(self.tlist[0]) > 1.e-8:; raise ValueError(""Pulse time sequence must start from 0""); else:; self.duration = self.tlist[-1]; else:; self.duration = duration; self.pulse_info = pulse_info. @property; def name(self):; return self.gate.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/instruction.html:848,depend,dependent,848,docs/4.7/modules/qutip/qip/compiler/instruction.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/instruction.html,2,['depend'],['dependent']
Integrability,". qutip.qip.compiler.scheduler — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.compiler.scheduler. Source code for qutip.qip.compiler.scheduler; from collections import deque; from copy import deepcopy; from functools import cmp_to_key; from random import shuffle. from ..circuit import QubitCircuit, Gate; from .instruction import Instruction. class InstructionsGraph():; """"""; A directed acyclic graph (DAG) representation; of the quantum instruction dependency.; An example is Fig3(b) in https://doi.org/10.1117/12.666419.; It contains methods of generating the instruction dependency graph,; a list-schedule algorithm to find the topological order; and the computation of the distance in the weighted graph; (circuit latency). It uses the `Instruction` object as a representation of node; and adds the following attributes to it:. predecessors, successors: dependency arrow of the DAG; distance_to_start, distance_to_end: longest distance to the start and end. Parameters; ----------; instructions: list; A list of instructions. Attributes; ----------; nodes: list; The input list of instruction with additional graph information.; start, end: list; List of indices of nodes connected to the start or end nodes.; """"""; def __init__(self, instructions):; instructions = deepcopy(instructions); self.nodes = []; for instruction in instructions:; if isinstance(instruction, Gate):; self.nodes.append(Instruction(instruction)); else:; self.nodes.append(instruction); for node in self.nodes:; if node.duration is None:; node.duration = 1; self.start = None; self.end = None. def generate_dependency_graph(self, commuting):; """"""; Generate the instruction dependency graph.; It modifies the class attribute `nodes`, where each element (node); is an `Instructio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html:698,depend,dependency,698,docs/4.7/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/compiler/scheduler.html,4,['depend'],['dependency']
Integrability,". qutip.qobjevo — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qobjevo. Source code for qutip.qobjevo; """"""Time-dependent Quantum Object (Qobj) class.; """"""; __all__ = ['QobjEvo']. from qutip.qobj import Qobj; import qutip.settings as qset; from qutip.interpolate import Cubic_Spline; from scipy.interpolate import CubicSpline, interp1d; from functools import partial; from types import FunctionType, BuiltinFunctionType; import numpy as np; from numbers import Number; from qutip.qobjevo_codegen import (_compile_str_single, _compiled_coeffs,; _compiled_coeffs_python); from qutip.cy.spmatfuncs import (cy_expect_rho_vec, cy_expect_psi,; spmv); from qutip.cy.cqobjevo import (CQobjCte, CQobjCteDense, CQobjEvoTd,; CQobjEvoTdMatched, CQobjEvoTdDense); from qutip.cy.cqobjevo_factor import (InterCoeffT, InterCoeffCte,; InterpolateCoeff, StrCoeff,; StepCoeffCte, StepCoeffT); import sys; import scipy; import os; from re import sub. if qset.has_openmp:; from qutip.cy.openmp.cqobjevo_omp import (CQobjCteOmp, CQobjEvoTdOmp,; CQobjEvoTdMatchedOmp). safePickle = [False]; if sys.platform == 'win32':; safePickle[0] = True. if qset.has_cython:; import cython; use_cython = [True]; else:; use_cython = [False]. def proj(x):; if np.isfinite(x):; return (x); else:; return np.inf + 0j * np.imag(x). str_env = {; ""sin"": np.sin,; ""cos"": np.cos,; ""tan"": np.tan,; ""asin"": np.arcsin,; ""acos"": np.arccos,; ""atan"": np.arctan,; ""pi"": np.pi,; ""sinh"": np.sinh,; ""cosh"": np.cosh,; ""tanh"": np.tanh,; ""asinh"": np.arcsinh,; ""acosh"": np.arccosh,; ""atanh"": np.arctanh,; ""exp"": np.exp,; ""log"": np.log,; ""log10"": np.log10,; ""erf"": scipy.special.erf,; ""zerf"": scipy.special.erf,; ""sqrt"": np.sqrt,; ""real"": np.real,; ""imag"": np.imag,; ""conj"": np.conj,; ""abs"": np.abs,; ""norm"": lambda x: ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:354,depend,dependent,354,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,2,['depend'],['dependent']
Integrability,". qutip.rhs_generate — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.rhs_generate. Source code for qutip.rhs_generate; __all__ = ['rhs_clear']. import os; import numpy as np; from types import FunctionType, BuiltinFunctionType; from functools import partial. from qutip.cy.codegen import Codegen; from qutip.solver import Options, config, solver_safe; from qutip.qobj import Qobj; from qutip.superoperator import spre, spost; from qutip.interpolate import Cubic_Spline. [docs]def rhs_clear():; """"""; Resets the string-format time-dependent Hamiltonian parameters. Parameters; ----------. Returns; -------; Nothing, just clears data from internal config module. """"""; # time-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. def _td_format_check(H, c_ops, solver='me'):; """"""; Checks on time-dependent format.; """"""; h_const = []; h_func = []; h_str = []; h_obj = []; # check H for incorrect format; if isinstance(H, Qobj):; pass; elif isinstance(H, (FunctionType, BuiltinFunctionType, partial)):; pass # n_func += 1; elif isinstance(H, list):; for k, H_k in enumerate(H):; if isinstance(H_k, Qobj):; h_const.append(k); elif isinstance(H_k, list):; if len(H_k) != 2 or not isinstance(H_k[0], Qobj):; raise TypeError(""Incorrect hamiltonian specification""); else:; if isinstance(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html:771,depend,dependent,771,docs/4.7/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/rhs_generate.html,4,['depend'],['dependent']
Integrability,". qutip.sesolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.sesolve. Source code for qutip.sesolve; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; import numpy as np; import scipy.integrate; from scipy.linalg import norm as la_norm; from qutip.cy.stochastic import normalize_inplace; import qutip.settings as qset; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.cy.spconvert import dense1D_to_fastcsr_ket, dense2D_to_fastcsr_fmode; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.solver import Result, Options, config, solver_safe, SolverSystem; from qutip.superoperator import vec2mat; from qutip.ui.progressbar import (BaseProgressBar, TextProgressBar); from qutip.cy.openmp.utilities import check_use_openmp, openmp_components. [docs]def sesolve(H, psi0, tlist, e_ops=None, args=None, options=None,; progress_bar=None, _safe_mode=True):; """"""; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian. Evolve the state vector (``psi0``) using a given Hamiltonian (``H``), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation. The output is either the state vector or unitary matrix at arbitrary points; in time (``tlist``), or the expectation values of the supplied operators; (``e_ops``). If ``e_ops`` is a callback function, it is invoked for each; time in ``tlist`` with time and the state as arguments, and the function; does not use any return values. ``e_ops`` cannot be used in conjunction; with solving the Schrodinger opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/sesolve.html:505,integrat,integrate,505,docs/4.7/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/sesolve.html,2,['integrat'],['integrate']
Integrability,". qutip.tensor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.tensor. Source code for qutip.tensor; """"""; Module for the creation of composite quantum objects via the tensor product.; """""". __all__ = [; 'tensor', 'super_tensor', 'composite', 'tensor_swap', 'tensor_contract'; ]. import numpy as np; import scipy.sparse as sp; from qutip.cy.spmath import zcsr_kron; from qutip.qobj import Qobj; from qutip.permute import reshuffle; from qutip.superoperator import operator_to_vector; from qutip.dimensions import (; flatten, enumerate_flat, unflatten, deep_remove,; dims_to_tensor_shape, dims_idxs_to_tensor_idxs; ). import qutip.settings; import qutip.superop_reps # Avoid circular dependency here. [docs]def tensor(*args):; """"""Calculates the tensor product of input operators. Parameters; ----------; args : array_like; ``list`` or ``array`` of quantum objects for tensor product. Returns; -------; obj : qobj; A composite quantum object. Examples; --------; >>> tensor([sigmax(), sigmax()]) # doctest: +SKIP; Quantum object: dims = [[2, 2], [2, 2]], \; shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]; """""". if not args:; raise TypeError(""Requires at least one input argument""). if len(args) == 1 and isinstance(args[0], (list, np.ndarray)):; # this is the case when tensor is called on the form:; # tensor([q1, q2, q3, ...]); qlist = args[0]. elif len(args) == 1 and isinstance(args[0], Qobj):; # tensor is called with a single Qobj as an argument, do nothing; return args[0]. else:; # this is the case when tensor is called on the form:; # tensor(q1, q2, q3, ...); qlist = args. if not all([isinstance(q, Qobj) for q in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/tensor.html:923,depend,dependency,923,docs/4.7/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/tensor.html,2,['depend'],['dependency']
Integrability,". qutip.three_level_atom — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.three_level_atom. Source code for qutip.three_level_atom; r'''; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations::. Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; ----------; The naming of qutip operators follows the convention in [1]_ . .. [1] Shore, B. W., ""The Theory of Coherent Atomic Excitation"",; Wiley, 1990. Notes; -----; Contributed by Markus Baden, Oct. 07, 2011. '''. __all__ = ['three_level_basis', 'three_level_ops']. import numpy as np; from qutip.states import qutrit_basis. [docs]def three_level_basis():; ''' Basis states for a three level atom. Returns; -------; states : array; `array` of three level atom basis vectors. '''; # A three level atom has the same representation as a qutrit, i.e.; # three states; return qutrit_basis(). [docs]def three_level_ops():; ''' Operators for a three level system (qutrit). Returns; --------; ops : array; `array` of three level operators. '''; out = np.empty((5,), dtype=object); one, two, three = qutrit_basis(); # Note that the three level operators are different; # from the qutrit operators. A three level atom only; # has transitions 1 <-> 2 <-> 3, so we define the; # operators seperately from ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html:585,Depend,Depending,585,docs/4.7/modules/qutip/three_level_atom.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/three_level_atom.html,1,['Depend'],['Depending']
Integrability,". return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:15185,depend,dependent,15185,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['depend'],['dependent']
Integrability,". state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). [docs]def charge(Nmax, Nmin=None, frac = 1):; """"""; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters; ----------; Nmax : int; Maximum charge state to consider. Nmin : int (default = -Nmax); Lowest charge state to consider. frac : float (default = 1); Specify fractional charge if needed. Returns; -------; C : Qobj; Charge operator over [Nmin,Nmax]. Notes; -----; .. versionadded:: 3.2. """"""; if Nmin is None:; Nmin = -Nmax; diag = np.arange(Nmin, Nmax+1, dtype=float); if frac != 1:; diag *= frac; C = sp.diags(diag, 0, format='csr', dtype=complex); return Qobj(C, isherm=True). [docs]def tunneling(N, m=1):; """"""; Tunneling operator with elements of the form; :math:`\sum |N><N+m| + |N+m><N|`. Parameters; ----------; N : int; Number of basis states in Hilbert space.; m : int (default = 1); Number of excitations in tunneling event. Returns; -------; T : Qobj; Tunneling operator. Notes; -----; .. versionadded:: 3.2. """"""; diags = [np.ones(N-m,dtype=int),np.ones(N-m,dtype=int)]; T = sp.diags(diags,[m,-m],format='csr', dtype=complex); return Qobj(T, isherm=True). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from qutip.tensor import tensor. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/operators.html:23370,depend,dependencies,23370,docs/4.5/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/operators.html,1,['depend'],['dependencies']
Integrability,". tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_L_t_shift(H, c_ops, args={}):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". # while this list doesn't seem exhaustive, mesolve has already been called; # and has hence called _td_format_check from qutip.rhs_generate. important; # to keep in mind is that mesolve already requires the types of; # time-dependence to be the same for the hamiltonian as for the collapse; # operators. if isinstance(H, Qobj):; # constant hamiltonian; H_shifted = H # not shifted!. c_ops_is_td = False; if isinstance(c_ops, list):; for i in range(len(c_ops)):; # test is collapse operators are time-dependent; if isinstance(c_ops[i], list):; c_ops_is_td = True. if not c_ops_is_td:; # constant collapse operators; c_ops_shifted = c_ops # not shifted!. if isinstance(H, Qobj) and not c_ops_is_td:; # constant hamiltonian and collapse operators; _args = args # not shifted!. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:38380,depend,dependence,38380,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['depend'],['dependence']
Integrability,". tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_H_t_shift(H, args=None):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". if isinstance(H, Qobj):; # constant hamiltonian; return H, args. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""); return H_shifted, _args. if isinstance(H, list):; # string/function-list based time-dependence; H_shifted = []; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. for i in range(len(H)):; if isinstance(H[i], list):; # modify hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t+args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Note: other functions already raise errors for mixed; # td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:38699,depend,dependence,38699,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['depend'],['dependence']
Integrability,"., 4.]); >>> coeff = np.array([0.5, 1.2, 0.8]); >>> spline_kind = ""step_func""; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func""). Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True). Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True). Create an dummy Pulse (H=0); >>> Pulse(None, None). Attributes. ideal_pulse: :class:`qutip.qip.pulse._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`qutip.qip.pulse._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(self, qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of qutip.qip.Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of qutip.qip.Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(self, qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindbla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:140060,depend,dependent,140060,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['depend'],['dependent']
Integrability,".7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:8766,depend,dependencies,8766,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,3,"['depend', 'message']","['dependencies', 'message']"
Integrability,".; Odeoptions now prints mc_avg correctly.; Do not check for PyObj in mcsolve when gui=False.; Eseries now correctly handles purely complex rates.; thermal_dm() function now uses truncated operator method.; Cython based time-dependence now Python 3 compatible.; Removed call to NSAutoPool on mac systems.; Progress bar now displays the correct number of CPU’s used.; Qobj.diag() returns reals if operator is Hermitian.; Text for progress bar on Linux systems is no longer cutoff. Version 2.0.0 (June 01, 2012):¶; The second version of QuTiP has seen many improvements in the performance of the original code base, as well as the addition of several new routines supporting a wide range of functionality. Some of the highlights of this release include:. New Features¶. QuTiP now includes solvers for both Floquet and Bloch-Redfield master equations.; The Lindblad master equation and Monte Carlo solvers allow for time-dependent collapse operators.; It is possible to automatically compile time-dependent problems into c-code using Cython (if installed).; Python functions can be used to create arbitrary time-dependent Hamiltonians and collapse operators.; Solvers now return Odedata objects containing all simulation results and parameters, simplifying the saving of simulation results. Important; This breaks compatibility with QuTiP version 1.x. mesolve and mcsolve can reuse Hamiltonian data when only the initial state, or time-dependent arguments, need to be changed.; QuTiP includes functions for creating random quantum states and operators.; The generation and manipulation of quantum objects is now more efficient.; Quantum objects have basis transformation and matrix element calculations as built-in methods.; The quantum object eigensolver can use sparse solvers.; The partial-trace (ptrace) function is up to 20x faster.; The Bloch sphere can now be used with the Matplotlib animation function, and embedded as a subplot in a figure.; QuTiP has built-in functions for saving quantum obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:9099,depend,dependent,9099,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,9,['depend'],['dependent']
Integrability,".BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:; H (qutip.qobj) – system Hamiltonian, or a callback function for time-dependent; Hamiltonians.; rho0 (qutip.qobj) – initial density matrix or state vector (ket).; tlist (list / array) – list of times for \(t\).; e_ops (list of qutip.qobj / callback function single) – single operator or list of operators for which to evaluate; expectation values.; args (dictionary) – dictionary of parameters for time-dependent Hamiltonians and; collapse operators.; options (qutip.Qdeoptions) – with options for the ODE solver. Returns:output – An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Return type:qutip.solver. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:55551,depend,dependent,55551,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,".BaseProgressBar object>, _safe_mode=True)[source]¶; Schrodinger equation evolution of a state vector for a given Hamiltonian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. Parameters:H : qutip.qobj. system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : qutip.qobj. initial density matrix or state vector (ket). tlist : list / array. list of times for \(t\). e_ops : list of qutip.qobj / callback function single. single operator or list of operators for which to evaluate; expectation values. args : dictionary. dictionary of parameters for time-dependent Hamiltonians and; collapse operators. options : qutip.Qdeoptions. with options for the ODE solver. Returns:output: qutip.solver. An instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors or density matrices corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:53683,depend,dependent,53683,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['depend'],['dependent']
Integrability,".]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:3788,depend,dependence,3788,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['depend'],['dependence']
Integrability,".]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:4504,depend,dependence,4504,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['depend'],['dependence']
Integrability,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:162325,integrat,integrated,162325,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['integrat'],['integrated']
Integrability,".data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []. if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else:; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:9476,integrat,integrate,9476,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,2,['integrat'],['integrate']
Integrability,.eot; glyphicons-halflings-regular.svg; glyphicons-halflings-regular.ttf; glyphicons-halflings-regular.woff. /js; ; jquery-1.11.0.min.js; jquery-fix.js. basic.css; bootstrap-sphinx.css; bootstrap-sphinx.js; doctools.js; favicon.ico; jquery.js; pygments.css; searchtools.js; site.css; underscore.js. /4.0.2; . /apidoc; ; API documentation — QuTiP 4.0 Documentation; Classes — QuTiP 4.0 Documentation; Functions — QuTiP 4.0 Documentation. Bibliography — QuTiP 4.0 Documentation; Change Log — QuTiP 4.0 Documentation; Developers — QuTiP 4.0 Documentation; Frontmatter — QuTiP 4.0 Documentation; Index — QuTiP 4.0 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.0 Documentation; Dynamics Simulation Results — QuTiP 4.0 Documentation; Floquet Formalism — QuTiP 4.0 Documentation; Lindblad Master Equation Solver — QuTiP 4.0 Documentation; Monte Carlo Solver — QuTiP 4.0 Documentation; Setting Options for the Dynamics Solvers — QuTiP 4.0 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 4.0 Documentation. Users Guide — QuTiP 4.0 Documentation; Basic Operations on Quantum Objects — QuTiP 4.0 Documentation; Plotting on the Bloch Sphere — QuTiP 4.0 Documentation; Quantum Optimal Control — QuTiP 4.0 Documentation; Two-time correlation functions — QuTiP 4.0 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 4.0 Documentation; An Overview of the Eseries Class — QuTiP 4.0 Documentation; Guide Overview — QuTiP 4.0 Documentation; Parallel computation — QuTiP 4.0 Documentation; Generating Random Quantum States & Operators — QuTiP 4.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.0 Documentation; Manipulating States and Operators — QuTiP 4.0 Documentation; Solving for Steady-State Solutions — QuTiP 4.0 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.0 Documentation; Visualization of quantum states and processes — QuTiP 4.0 Documentation.,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:11563,depend,dependent,11563,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['depend'],['dependent']
Integrability,".expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. # -----------------------------------------------------------------------------; # A time-dependent dissipative master equation on the list-function format; #; def _mesolve_list_func_td(H_list, rho0, tlist, c_list, e_ops, args, opt,; progress_bar):; """"""; Internal function for solving the master equation. See mesolve for usage.; """""". if debug:; print(inspect.stack()[0][3]). #; # check initial state; #; if isket(rho0):; rho0 = rho0 * rho0.dag(). #; # construct liouvillian in list-function format; #; L_list = []; if opt.rhs_with_state:; constant_func = lambda x, y, z: 1.0; else:; constant_func = lambda x, y: 1.0. # add all hamitonian terms to the lagrangian list; for h_spec in H_list:. if isinstance(h_spec, Qobj):; h = h_spec; h_coeff = constant_func. elif isinstance(h_spec, list) and isinstance(h_spec[0], Qobj):; h = h_spec[0]; h_coeff = h_spec[1]. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected callback function)""). if isoper(h):; L_list.append([(-1j * (spre(h) - spost(h))).data, h_coeff, False]). elif issuper(h):; L_list.append([h.data, h_coeff, False]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""Hamiltonian (expected operator or superoperator)""). # add all collapse operators to the liouvillian list; for c_spec in c_list:. if isinstance(c_spec, Qobj):; c = c_spec; c_coeff = constant_func; c_square = False. elif isinstance(c_spec, list) and isinstance(c_spec[0], Qobj):; c = c_spec[0]; c_coeff = c_spec[1]; c_square = True. else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected callback function)""). if isoper(c):; L_list.append([liouvillian(None, [c], data_only=True),; c_coeff, c_square]). elif issuper(c):; L_list.append([c.data, c_coeff, c_square]). else:; raise TypeError(""Incorrect specification of time-dependent "" +; ""collapse operators (expected operator or "" +; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mesolve.html:13492,depend,dependent,13492,docs/4.2/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mesolve.html,5,['depend'],['dependent']
Integrability,".isfile(file_):; # Don't exist anymore; del self.files[i]. def __del__(self):; self.clean(). coeff_files = _file_list(). class _StrWrapper:; def __init__(self, code):; self.code = ""_out = "" + code. def __call__(self, t, args={}):; env = {""t"": t}; env.update(args); exec(self.code, str_env, env); return env[""_out""]. class _CubicSplineWrapper:; # Using scipy's CubicSpline since Qutip's one; # only accept linearly distributed tlist; def __init__(self, tlist, coeff):; self.coeff = coeff; self.tlist = tlist; self.func = CubicSpline(self.tlist, self.coeff). def __call__(self, t, args={}):; return self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; """"""self.qobj = list_[0]; self.get_coeff = list_[1]; self.coeff = list_[2]; self.type = list_[3]""""""; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""A class for representing time-dependent quantum objects,; such as quantum operators and states. The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :; +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number; and some common linear operator/state opera",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html:4815,depend,dependent,4815,docs/4.4/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobjevo.html,1,['depend'],['dependent']
Integrability,".mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; In [17]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Note; New in QuTiP 4.2. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; In [18]: ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). In [19]: output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:14520,depend,dependent,14520,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,4,['depend'],['dependent']
Integrability,".messages[key] = value. def report(self, output=sys.stdout):; """"""; Report the counts, timings and messages for this section.; Note the percentage of the section and solver total times will be; given if the parent and or section total_time is set; """"""; if self.header:; output.write(""\n{}\n{}\n"".format(self.header,; (""-""*len(self.header)))). # TODO: Make the timings and counts ouput in a table format; # Generally make more pretty. # Report timings; try:; ttt = self.parent.total_time; except:; ttt = None. tt = self.total_time. output.write(""### Timings:\n""); for key, value in self.timings.items():; l = "" - {}\t{}\n"".format(_format_time(value, tt, ttt), key); output.write(l); if tt is not None:; output.write("" - {}\t{} total time\n"".format(_format_time(tt),; self.name)). # Report counts; output.write(""### Counts:\n""); for key, value in self.counts.items():; l = "" - {}\t{}\n"".format(value, key); output.write(l). # Report messages; output.write(""### Messages:\n""); for key, value in self.messages.items():; l = "" - {}:\t{}\n"".format(key, value); output.write(l). def clear(self):; """"""; Clear counts, timings and messages from this section; """"""; self.counts.clear(); self.timings.clear(); self.messages.clear(); self.total_time = None. def _solver_safety_check(H, state=None, c_ops=[], e_ops=[], args={}):; # Input is std Qobj (Hamiltonian or Liouvillian); if isinstance(H, Qobj):; Hdims = H.dims; Htype = H.type; _structure_check(Hdims, Htype, state); # Input H is function; elif isinstance(H, (FunctionType, BuiltinFunctionType)):; Hdims = H(0,args).dims; Htype = H(0,args).type; _structure_check(Hdims, Htype, state); # Input is td-list; elif isinstance(H, list):; if isinstance(H[0], Qobj):; Hdims = H[0].dims; Htype = H[0].type; elif isinstance(H[0], list):; Hdims = H[0][0].dims; Htype = H[0][0].type; elif isinstance(H[0], (FunctionType, BuiltinFunctionType)):; Hdims = H[0](0,args).dims; Htype = H[0](0,args).type; else:; raise Exception('Invalid td-list element.'); # Check all operato",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:26085,message,messages,26085,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['message'],['messages']
Integrability,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20117,depend,dependent,20117,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,4,['depend'],['dependent']
Integrability,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. @staticmethod; [docs] def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:46668,depend,dependent,46668,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['depend'],['dependent']
Integrability,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : :class:`qutip.Qobj`; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:50555,depend,dependent,50555,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,6,['depend'],['dependent']
Integrability,".prod(self.dims[1])]); else:; return tuple(self.data.shape). @property; def isbra(self):; return self.type == 'bra'. @property; def isket(self):; return self.type == 'ket'. @property; def isoperbra(self):; return self.type == 'operator-bra'. @property; def isoperket(self):; return self.type == 'operator-ket'. @property; def isoper(self):; return self.type == 'oper'. @property; def issuper(self):; return self.type == 'super'. [docs] @staticmethod; def evaluate(qobj_list, t, args):; """"""Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, 'sin(w * t)']]. is evaluated to. Qobj(t) = H0 + H1 * sin(args['w'] * t). Parameters; ----------; qobj_list : list; A nested list of Qobj instances and corresponding time-dependent; coefficients.; t : float; The time for which to evaluate the time-dependent Qobj instance.; args : dictionary; A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns; -------; output : Qobj; A Qobj instance that represents the value of qobj_list at time t. """""". q_sum = 0; if isinstance(qobj_list, Qobj):; q_sum = qobj_list; elif isinstance(qobj_list, list):; for q in qobj_list:; if isinstance(q, Qobj):; q_sum += q; elif (isinstance(q, list) and len(q) == 2 and; isinstance(q[0], Qobj)):; if isinstance(q[1], types.FunctionType):; q_sum += q[0] * q[1](t, args); elif isinstance(q[1], str):; args['t'] = t; q_sum += q[0] * float(eval(q[1], globals(), args)); else:; raise TypeError('Unrecognized format for ' +; 'specification of time-dependent Qobj'); else:; raise TypeError('Unrecognized format for specification ' +; 'of time-dependent Qobj'); else:; raise TypeError(; 'Unrecongized format for specification of time-dependent Qobj'). return q_sum. # -----------------------------------------------------------------------------; # This functions evaluates a time-dependent quantum object on the lis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:49474,depend,dependent,49474,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['depend'],['dependent']
Integrability,".qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – A list of Floquet states for the time \(t\). Return type:list. floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters:; f_modes_t (list of qutip.qobj (kets)) – A list of initial Floquet modes (for time \(t=0\)).; f_energies (array) – The Floquet energies.; f_coeff (array) – The coefficients for Floquet decomposition of the initial wavefunction.; t (float) – The time for which to evaluate the Floquet states.; H (qutip.qobj) – System Hamiltonian, time-dependent with period T.; T (float) – The period of the time-dependence of the hamiltonian.; args (dictionary) – Dictionary with variables required to evaluate H. Returns:output – The wavefunction for the time \(t\). Return type:qutip.qobj. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters:; f_states (list of qutip.qobj (kets)) – A list of Floquet modes.; f_energies (array) – The Floquet energies.; psi (qutip.qobj) – The wavefunction to decompose in the Floquet state basis. Returns:output – The coefficients \(c_\alpha\) in the Floquet state decomposition. Return type:array. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters:; H (qutip.qobj.Qobj) – System Hamiltonian, time-dependent with period T.; psi0 (qutip.qobj) – Initial ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:74056,depend,dependent,74056,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['depend'],['dependent']
Integrability,".qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`._EvoElement`; The coherent noise caused by the control pulse. Each dynamic element is;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:4779,depend,dependent,4779,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,4,['depend'],['dependent']
Integrability,".qobj,; ""targets"": self.targets,; ""tlist"": self.tlist,; ""coeff"": self.coeff; }). [docs]class Pulse():; """"""; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; `qobj`, `targets`, `tlist` and `coeff`. See examples for different construction behavior. Parameters; ----------; qobj: :class:'qutip.Qobj'; The Hamiltonian of the ideal pulse.; targets: list; target qubits of the ideal pulse; (or subquantum system of other dimensions).; tlist: array-like, optional; `tlist` of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; `tlist` does not have to be equidistant, but must have the same length; or one element shorter compared to `coeff`. See documentation for; the parameter `spline_kind`.; coeff: array-like or bool, optional; Time-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to `tlist`.; See documentation for the parameter `spline_kind`.; If a bool, the coefficient is a constant 1 or 0.; spline_kind: str, optional; Type of the coefficient interpolation:; ""step_func"" or ""cubic"". -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; ``len(coeff)=len(tlist)-1`` or ``len(coeff)=len(tlist)``, but; in the second case the last element of `coeff` has no effect. -""cubic"":; Use cubic interpolation for the coefficient. It requires; ``len(coeff)=len(tlist)``; label: str; The label (name) of the pulse. Attributes; ----------; ideal_pulse: :class:`qutip.qip.pulse._EvoElement`; The ideal dynamic of the control pulse.; coherent_noise: list of :class:`qutip.qip.pulse._EvoElement`; The coherent noise caused by the control p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html:4795,depend,dependent,4795,docs/4.5/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/pulse.html,1,['depend'],['dependent']
Integrability,".reshape(dims_to_tensor_shape(dims)). # Now permute the dims list so we know how to get back.; flat_dims = flatten(dims); perm = list(range(len(flat_dims))); for i, j in pairs:; flat_dims[i], flat_dims[j] = flat_dims[j], flat_dims[i]; for i, j in tensor_pairs:; perm[i], perm[j] = perm[j], perm[i]; dims = unflatten(flat_dims, enumerate_flat(dims)). # Next, permute the actual indices of the dense tensor.; data = data.transpose(perm). # Reshape back, using the left and right of dims.; data = data.reshape(list(map(np.prod, dims))). return Qobj(inpt=data, dims=dims, superrep=q_oper.superrep). [docs]def tensor_contract(qobj, *pairs):; """"""Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should *not* be used for very large Qobjs. Parameters; ----------. pairs : tuple; One or more tuples ``(i, j)`` indicating that the; ``i`` and ``j`` dimensions of the original qobj; should be contracted. Returns; -------. cqobj : Qobj; The original Qobj with all named index pairs contracted; away. """"""; # Record and label the original dims.; dims = qobj.dims; dims_idxs = enumerate_flat(dims); tensor_dims = dims_to_tensor_shape(dims). # Convert to dense first, since sparse won't support the reshaping we need.; qtens = qobj.data.toarray(). # Reshape by the flattened dims.; qtens = qtens.reshape(tensor_dims). # Contract out the indices from the flattened object.; # Note that we need to feed pairs through dims_idxs_to_tensor_idxs; # to ensure that we are contracting the right indices.; qtens = _tensor_contract_dense(qtens, *dims_idxs_to_tensor_idxs(dims, pairs)). # Remove the contracted indexes from dims so we know how to; # reshape back.; # This concerns dims, and not the tensor indices, so we need; # to make sure to use the original dims indices and not the ones; # generated by dims_to_* functions.; contracted_idxs = deep_remove(dims_idxs, *flatten(list(map(list, pairs)))); contracted_dims = unflatten(flatten(dims), contracted_idxs). # We don'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/tensor.html:10371,contract,contracted,10371,docs/4.1/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/tensor.html,10,['contract'],['contracted']
Integrability,".set_f_params(' + parameter_string + ')',; '<string>', 'exec'). r.set_integrator('zvode', method=opt.method, order=opt.order,; atol=opt.atol, rtol=opt.rtol, nsteps=opt.nsteps,; first_step=opt.first_step, min_step=opt.min_step,; max_step=opt.max_step); r.set_initial_value(initial_vector, tlist[0]). exec(code, locals(), args). # Remove RHS cython file if necessary; if not opt.rhs_reuse and config.tdname:; _cython_build_cleanup(config.tdname). #; # call generic ODE code; #; return _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; dims=psi0.dims). # TODO cythonize this?; def _td_ode_rhs_oper(t, y, arglist):; N = int(np.sqrt(len(y))); out = np.zeros(N, dtype=complex); y2 = np.zeros(len(y), dtype=complex); for i in range(N):; out = cy_td_ode_rhs(t, y[i*N:(i+1)*N], *arglist); y2[i*N:(i+1)*N] = out; return y2. # -----------------------------------------------------------------------------; # Wave function evolution using a ODE solver (unitary quantum evolution), for; # time dependent Hamiltonians; def _sesolve_list_td(H_func, psi0, tlist, e_ops, args, opt, progress_bar):; """"""; Evolve the wave function using an ODE solver with time-dependent; Hamiltonian.; Note: Deprecated method; """""". if debug:; print(inspect.stack()[0][3]). if psi0.isket:; pass; elif psi0.isunitary:; raise TypeError(""The unitary operator evolution is not supported""; "" in the list td method.""); else:; raise TypeError(""The unitary solver requires psi0 to be""; "" a ket as initial state""; "" or a unitary as initial operator.""). #; # configure time-dependent terms and setup ODE solver; #; if len(H_func) != 2:; raise TypeError('Time-dependent Hamiltonian list must have two terms.'); if (not isinstance(H_func[0], (list, np.ndarray))) or \; (len(H_func[0]) <= 1):; raise TypeError('Time-dependent Hamiltonians must be a list with two '; + 'or more terms'); if (not isinstance(H_func[1], (list, np.ndarray))) or \; (len(H_func[1]) != (len(H_func[0]) - 1)):; raise TypeError('Time-dependent coefficients must be ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:16471,depend,dependent,16471,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,2,['depend'],['dependent']
Integrability,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); if not r.successful():; raise RuntimeError(; ""HSolverDL ODE integration error. Try increasing""; "" the nsteps given in the HSolverDL options""; "" (which increases the allowed substeps in each""; "" step between times given in tlist).""); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html:13734,integrat,integrate,13734,docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/dlheom_solver.html,2,['integrat'],['integrate']
Integrability,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html:15432,integrat,integrate,15432,docs/4.1/modules/qutip/nonmarkov/heom.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/nonmarkov/heom.html,8,['integrat'],['integrate']
Integrability,".transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); for t_idx, _ in enumerate(tlist):. if not r.successful():; break. rho_eb.data = vec2mat(r.y). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for calculting the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html:7955,integrat,integrate,7955,docs/3.1.0/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html,1,['integrat'],['integrate']
