quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"ciently comprehensive; library of serializers and deserializers will emerge over time. For more details, consult the tutorial [rf515_hfJSON](https://root.cern/doc/v626/rf515__hfJSON_8py.html). ### Creating RooFit datasets from RDataFrame; RooFit now contains two RDataFrame action helpers, `RooDataSetHelper` and `RooDataHistHelper`, which allow for creating RooFit datasets by booking an action:; ```c++; RooRealVar x(""x"", ""x"", -5., 5.);; RooRealVar y(""y"", ""y"", -50., 50.);; auto myDataSet = rdataframe.Book<double, double>(; RooDataSetHelper{""dataset"", // Name (directly forwarded to RooDataSet::RooDataSet()); ""Title of dataset"", // Title ( ~ "" ~ ); RooArgSet(x, y) }, // Variables to create in dataset; {""x"", ""y""} // Column names from RDataFrame; );; ```; For more details, consult the tutorial [rf408_RDataFrameToRooFit](https://root.cern/doc/v626/rf408__RDataFrameToRooFit_8C.html). ### Storing global observables in RooFit datasets. RooFit groups model variables into *observables* and *parameters*, depending on if their values are stored in the dataset.; For fits with parameter constraints, there is a third kind of variables, called *global observables*.; These represent the results of auxiliary measurements that constrain the nuisance parameters.; In the RooFit implementation, a likelihood is generally the sum of two terms:; * the likelihood of the data given the parameters, where the normalization set is the set of observables (implemented by `RooNLLVar`); * the constraint term, where the normalization set is the set of *global observables* (implemented by `RooConstraintSum`). Before this release, the global observable values were always taken from the model/pdf.; With this release, a mechanism is added to store a snapshot of global observables in any `RooDataSet` or `RooDataHist`.; For toy studies where the global observables assume a different values for each toy, the bookkeeping of the set of global observables and in particular their values is much easier with this ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:26819,variab,variables,26819,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['variab'],['variables']
Modifiability,"cified. Memory Operations; -----------------. G_LOAD, G_SEXTLOAD, G_ZEXTLOAD; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Generic load. Expects a MachineMemOperand in addition to explicit; operands. If the result size is larger than the memory size, the; high bits are undefined, sign-extended, or zero-extended respectively. Only G_LOAD is valid if the result is a vector type. If the result is larger; than the memory size, the high elements are undefined (i.e. this is not a; per-element, vector anyextload). Unlike in SelectionDAG, atomic loads are expressed with the same; opcodes as regular loads. G_LOAD, G_SEXTLOAD and G_ZEXTLOAD may all; have atomic memory operands. G_INDEXED_LOAD; ^^^^^^^^^^^^^^. Generic indexed load. Combines a GEP with a load. $newaddr is set to $base + $offset.; If $am is 0 (post-indexed), then the value is loaded from $base; if $am is 1 (pre-indexed); then the value is loaded from $newaddr. G_INDEXED_SEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is sign-extending, as with G_SEXTLOAD. G_INDEXED_ZEXTLOAD; ^^^^^^^^^^^^^^^^^^. Same as G_INDEXED_LOAD except that the load performed is zero-extending, as with G_ZEXTLOAD. G_STORE; ^^^^^^^. Generic store. Expects a MachineMemOperand in addition to explicit; operands. If the stored value size is greater than the memory size,; the high bits are implicitly truncated. If this is a vector store, the; high elements are discarded (i.e. this does not function as a per-lane; vector, truncating store). G_INDEXED_STORE; ^^^^^^^^^^^^^^^. Combines a store with a GEP. See description of G_INDEXED_LOAD for indexing behaviour. G_ATOMIC_CMPXCHG_WITH_SUCCESS; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Generic atomic cmpxchg with internal success check. Expects a; MachineMemOperand in addition to explicit operands. G_ATOMIC_CMPXCHG; ^^^^^^^^^^^^^^^^. Generic atomic cmpxchg. Expects a MachineMemOperand in addition to explicit; operands. G_ATOMICRMW_XCHG, G_ATOMICRMW_ADD, G_ATOMICRMW_SUB, G_ATOMICRMW_AND,; G_A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:16407,extend,extending,16407,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extending']
Modifiability,cified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit mem,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144602,variab,variables,144602,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"citly specify the generator with the command line option ``-G ""Name of the; generator""``. To see a list of the available generators on your system, execute. .. code-block:: console. $ cmake --help. This will list the generator names at the end of the help text. Generators' names are case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5481,variab,variables,5481,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"ck String Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is often useful to match a pattern and then verify that it occurs again; later in the file. For codegen tests, this can be useful to allow any; register, but verify that that register is used consistently later. To do; this, :program:`FileCheck` supports string substitution blocks that allow; string variables to be defined and substituted into patterns. Here is a simple; example:. .. code-block:: llvm. ; CHECK: test5:; ; CHECK: notw	[[REGISTER:%[a-z]+]]; ; CHECK: andw	{{.*}}[[REGISTER]]. The first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27045,variab,variable,27045,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"ck that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:8745,variab,variable,8745,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"ck was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. Insure that the TTreeCloner (fast merging) is able to also copy 'uninitialized' TStreamerInfo describing abstract classes.; Repair several use case of splitting collection of pointers (especially when their split level is 1).; Several run-time performance improvements.; In TTree::Fill use fZipBytes instead of fTotBytes for deciding when to flush or autosave.; Properly handle TTree aliases containing array indices.; Fix the default sorting order of baskets when the TTree is an older in-memory TTree.; Enhance the sort order to use the 'entry number' when the seek position are equal.; Consequently the default sort order for an older in-memory TTree is now; essentially kSortBasketsByEntry rather than kSortBasketsByBranch (old 'correct' sort; order) or 'random' (the 'broken' sort order prior to this release). IMPORTANT enhancement in TTree::Fill:; Slides from a recent seminar describing the main features of ROOT IO and Trees and the recent; improvements described below are available at; http://root.cern/files/brun_lcgapp09.pptx ; or; http://root.cern/files/brun_lcgapp09.pdf .; The baskets are flushed and the Tree header saved at regular intervals (See AutoFlush and OptimizeBaskets); When the amount of data written so far (fTotBytes) is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region.; When the first call to flush the baskets happens, we also take this opportunity to optimize the baskets buffers.; We also check if the number of bytes written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point in case the program writing the Tree crashes.; Note that the user can also decide to call FlushBaskets and AutoSave in her event loop on the base of the numb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html:3151,enhance,enhancement,3151,tree/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v526/index.html,1,['enhance'],['enhancement']
Modifiability,"ck. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:2939,variab,variables,2939,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"ck:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Linux`` (in configuration: ``Linux``); Like ``Attach``, but break before braces on function, namespace and; class definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:47733,config,configuration,47733,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ck:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }. static const bool flow = true;; }. Flow mappings are subject to line wrapping according to the Output object; configuration. Sequence; ========. To be translated to or from a YAML sequence for your type T you must specialize; llvm::yaml::SequenceTraits on T and implement two methods:; ``size_t size(IO &io, T&)`` and; ``T::value_type& element(IO &io, T&, size_t indx)``. For example:. .. code-block:: c++. template <>; struct SequenceTraits<MySeq> {; static size_t size(IO &io, MySeq &list) { ... }; static MySeqEl &element(IO &io, MySeq &list, size_t index) { ... }; };. The size() method returns how many elements are currently in your sequence.; The element() method returns a reference to the i'th element in the sequence.; When parsing YAML, the element() method may be called with an index one bigger; than the current size. Your element() method should allocate space for one; more element (using default constructor if element is a C++ object) and returns; a reference to that new allocated space. Flow Sequence; -------------; A YAML ""flow sequence"" is a sequence that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:24844,config,configuration,24844,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['config'],['configuration']
Modifiability,"ck:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58275,variab,variables,58275,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,"ck_copy_assign(&dst->captured_voidBlock, src->captured_voidBlock, 0);; _Block_object_assign(&dst->captured_voidBlock, src->captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);; }. void _block_byref_dispose_helper(struct _block_byref_voidBlock *param) {; //_Block_destroy(param->captured_voidBlock, 0);; _Block_object_dispose(param->captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER)}. and:. .. code-block:: c. struct _block_byref_voidBlock voidBlock = {( .forwarding=&voidBlock, .flags=(1<<25), .size=sizeof(struct _block_byref_voidBlock *),; .byref_keep=_block_byref_keep_helper, .byref_dispose=_block_byref_dispose_helper,; .captured_voidBlock=blockA )};. voidBlock.forwarding->captured_voidBlock = blockB;. Importing ``__block`` variables into ``Blocks``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``Block`` that uses a ``__block`` variable in its compound statement body must; import the variable and emit ``copy_helper`` and ``dispose_helper`` helper; functions that, in turn, call back into the runtime to actually copy or release; the ``byref`` data block using the functions ``_Block_object_assign`` and; ``_Block_object_dispose``. For example:. .. code-block:: c. int __block i = 2;; functioncall(^{ i = 10; });. would translate to:. .. code-block:: c. struct _block_byref_i {; void *isa; // set to NULL; struct _block_byref_voidBlock *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);; void (*byref_dispose)(struct _block_byref_i *);; int captured_i;; };. struct __block_literal_5 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_5 *);; struct __block_descriptor_5 *descriptor;; struct _block_byref_i *i_holder;; };. void __block_invoke_5(struct __block_literal_5 *_block) {; _block->forwarding->captured_i = 10;; }. void __block_copy_5(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; //_Block_byref_assign_copy(&dst->captured_i, src->ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:15290,variab,variable,15290,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variable']
Modifiability,"ckground,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). VolumeRangeMode No Adaptive Unscaled, MinMax, RMS, Adaptive, kNN Method to determine volume size. KernelEstimator No Box Box, Sphere, Teepee, Gauss, Sinc3, Sinc5, Sinc7, Sinc9, Sinc11, Lanczos2, Lanczos3, Lanczos5, Lanczos8, Trim Kernel estimation function. DeltaFrac No 3 − nEventsMin/Max for minmax and rms volume range. NEventsMin No 100 − nEventsMin for adaptive volume range. NEventsMax No 200 − nEventsMax for adaptive volume range. MaxVIterations No 150 − MaxVIterations for adaptive volume range. InitialScale No 0.99 − InitialScale for adaptive volume range. GaussSigma No 0.1 − Width (wrt volume size) of Gaussian kernel estimator. NormTree No False − Normalize binary search tree. Configuration options for MVA method :. Configuration options reference for MVA method: FDA. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:4849,adapt,adaptive,4849,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['adapt'],['adaptive']
Modifiability,"ckle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll al",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:11288,variab,variables,11288,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,2,['variab'],['variables']
Modifiability,"cks automatically and displays useful suggestions too; specific to your platform.; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```; or; ```sh; cd tools/packaging/; ./cpt.py -c; ```; Regardless of the platform and operating system, make sure to call the cpt script; with Python 3.; CPT uses some features and modules which are not a part of older versions of Python.; The same holds true for the versions of GCC/Clang you have on your machine. Older; compilers do not support c++11 features and thus you can expect a build error if you; choose not to update them. All pre-compiled binaries of Python ship with built-in support for SSL. However if; the Python on your system was compiled by you manually, chances are that it doesn't; have SSL support. This is very likely if you had performed a minimal installation; of Scientific Linux CERN which doesn't include OpenSSL development package. In such; a case, you should install ```openssl-devel```, re-compile Python and ```configure```; will automatically link against the required libraries and produce a binary with SSL; support. #### Ubuntu/Debian; On Debian, Ubuntu, Linux Mint, CrunchBang, or any other distro based on Debian; which supports APT package manager, you can install all the required packages by:; ```sh; sudo apt-get update; sudo apt-get install git g++ debhelper devscripts gnupg python; ```; You are not required to do this manually since CPT can do this for you automatically. ###### Setting up:; Make sure GnuPG is properly set up with your correct fingerprint. These; credentials are needed to sign the Debian package and create Debian changelogs.; On a build machine (Electric Commander), make sure the fingerprint is of the; user who is supposed to sign the official uploads. You might also want to; configure GnuPG to not ask for the passphrase while signing the Debian package. The [Ubuntu Packaging Guide] contains a quick guide on creating a GPG key on an; Ubuntu system. To test if you have successfully se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:2269,config,configure,2269,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['config'],['configure']
Modifiability,"cks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr;; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; static TClonesArray *fgTracks;; static TH1F *fgHist;; // ... list of methods; ClassDef(Event,1) //Event structure; };; ```. ### The EventHeader Class. The `EventHeader` class (also defined in `Event.h`) does not inherit; from **`TObject`**. Beginning with ROOT 3.0, an object can be placed on; a branch even though it does not inherit from **`TObject`**. In previous; releases branches were restricted to objects inheriting from the; **`TObject`**. However, it has always been possible to write a class not; inheriting from **`TObject`** to a tree by encapsulating it in a; **`TObject`** descending class as is the case in `EventHeader` and; `Event`. ``` {.cpp}; class EventHeader {; private:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;; // ... list of methods; ClassDef(EventHeader,1) //Event Header; };; ```. ### The Track Class. The `Track` class descends from **`TObject`** since tracks are in a; **`TClonesArray`** (i.e. a ROOT collection class) and contains a; selection of basic types and an array of vertices. Its **`TObject`**; inheritance enables `Track` to be in a collection and in `Event` is a; **`TClonesArray`** of `Tracks`. ``` {.cpp}; class Track : public TObject {; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge depositio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:60440,inherit,inheriting,60440,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inheriting']
Modifiability,"clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.; Then split into groups based on category priority. See; ``IncludeCategories``. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h>; #include ""a.h"" #include <lib/main.h>. .. _IncludeCategories:. **IncludeCategories** (``List of IncludeCategories``) :versionbadge:`clang-format 3.8` :ref:`¶ <IncludeCategories>`; Regular expressions denoting the different ``#include`` categories; used for ordering ``#includes``. `POSIX extended; <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html>`_; regular expressions are supported. These regular expressions are matched against the filename of an include; (including the <> or """") in order. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:65593,config,configuration,65593,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,clangd/benchmarks/CompletionModel; - `1`; - `0`; - `1`; - :none:`0%`; * - clang-tools-extra/clangd/fuzzer; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index; - `39`; - `36`; - `3`; - :part:`92%`; * - clang-tools-extra/clangd/index/dex; - `9`; - `7`; - `2`; - :part:`77%`; * - clang-tools-extra/clangd/index/dex/dexp; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/marshalling; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/monitor; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/server; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/index/remote/unimplemented; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/indexer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/refactor; - `6`; - `5`; - `1`; - :part:`83%`; * - clang-tools-extra/clangd/refactor/tweaks; - `14`; - `10`; - `4`; - :part:`71%`; * - clang-tools-extra/clangd/support; - `25`; - `24`; - `1`; - :part:`96%`; * - clang-tools-extra/clangd/tool; - `2`; - `2`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests; - `79`; - `66`; - `13`; - :part:`83%`; * - clang-tools-extra/clangd/unittests/decision_forest_model; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/remote; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/support; - `11`; - `11`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/unittests/tweaks; - `20`; - `19`; - `1`; - :part:`95%`; * - clang-tools-extra/clangd/unittests/xpc; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc; - `3`; - `3`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/framework; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/clangd/xpc/test-client; - `1`; - `1`; - `0`; - :good:`100%`; * - clang-tools-extra/modularize; - `9`; - `1`; - `8,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:19846,refactor,refactor,19846,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['refactor'],['refactor']
Modifiability,"class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32191,variab,variables,32191,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variables']
Modifiability,"class extensions.; Misc. bug fixes to improve analyzer precision.; . checker-256; built: April 13, 2011; highlights:. Lots of bug fixes and improvements to analyzer precision (fewer false positives, possibly more bugs found).; Introductory analysis support for C++ and Objective-C++. This build contains basic support for C++ and Objective-C++ that is ready to be tried out; by general users. It is still in its infancy, but establishes a baseline for things to come. The main hope is that it can find some; issues and have a reasonable false positive rate.; Please file bugs when you see issues of any kind so we can assess; where development on C++ analysis support needs to be focused.; To try out C++ analysis support, it should work out of the box using scan-build. If you are using this checker build; as a replacement to the analyzer bundled with Xcode, first use the set-xcode-analyzer script to change Xcode to use; your version of the analyzer. You will then need to modify one configuration file in Xcode to enable C++ analysis support. This can; be done with the following steps:. Find the clang .xcspec file:; $ cd /Developer/Library; $ find . | grep xcspec | grep Clang; ./Xcode/<SNIP>/Clang LLVM 1.0.xcplugin/Contents/Resources/Clang LLVM 1.0.xcspec. The exact location of the file may vary depending on your installation of Xcode. Edit that file, and look for the string ""--analyze"":. SourceFileOption = ""--analyze"";; FileTypes = (; ""sourcecode.c.c"",; ""sourcecode.c.objc"",; );; ... Change the ""FileTypes"" entry to:. FileTypes = (; ""sourcecode.c.c"",; ""sourcecode.c.objc"",; ""sourcecode.cpp.cpp"",; ""sourcecode.cpp.objcpp"",; );. Restart Xcode. checker-255; built: February 11, 2011; highlights:. Mac OS X builds are now Intel i386 and x86_64 only (no ppc support); Turns on new -init method checker by default; Reduces memory usage of analyzer by 10%; Misc. fixes to reduce false positives on dead stores and idempotent operations. checker-254; built: January 27, 2011; highlights:. Introd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:12064,config,configuration,12064,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['config'],['configuration']
Modifiability,"class-order. Displays classes in the specified order. .. code-block:: text. =none - Undefined / no particular sort order (default); =name - Sort classes by name; =size - Sort classes by size; =padding - Sort classes by amount of padding; =padding-pct - Sort classes by percentage of space consumed by padding; =padding-imm - Sort classes by amount of immediate padding; =padding-pct-imm - Sort classes by percentage of space consumed by immediate padding. .. option:: -class-recurse-depth=<uint>. When dumping class definitions, stop after recursing the specified number of times. The; default is 0, which is no limit. .. option:: -classes. Display classes. .. option:: -compilands. Display compilands (e.g. object files). .. option:: -enums. Display enums. .. option:: -externals. Dump external (e.g. exported) symbols. .. option:: -globals. Dump global symbols. .. option:: -lines. Dump the mappings between source lines and code addresses. .. option:: -module-syms. Display symbols (variables, functions, etc) for each compiland. .. option:: -sym-types=<types>. Type of symbols to dump when -globals, -externals, or -module-syms is; specified. (default all). .. code-block:: text. =thunks - Display thunk symbols; =data - Display data symbols; =funcs - Display function symbols; =all - Display all symbols (default). .. option:: -symbol-order=<order>. For symbols dumped via the -module-syms, -globals, or -externals options, sort; the results in specified order. .. code-block:: text. =none - Undefined / no particular sort order; =name - Sort symbols by name; =size - Sort symbols by size. .. option:: -typedefs. Display typedef types. .. option:: -types. Display all types (implies -classes, -enums, -typedefs). Other Options; +++++++++++++. .. option:: -color-output. Force color output on or off. By default, color if used if outputting to a; terminal. .. option:: -load-address=<uint>. When displaying relative virtual addresses, assume the process is loaded at the; given address and displa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:5922,variab,variables,5922,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['variab'],['variables']
Modifiability,"classification by training of one discriminator foam for each; variable.; The cell tree can now be plotted from the macro test/PlotFoams. This makes; it easyer to compare the PDEFoam structure to a decision tree.; Variable importance ranking by counting the number of cuts made in each; dimension. The variable, for which the most cuts were done is ranked highest. Fixed the size of the sampling box in PDEFoam:; In TMVA 4.1.0 the size of the PDEFoam sampling box in each dimension was; 2*VolFrac times the foam size. This was contrary to the intention and the; documentation in the UserGuide and is now corrected: In TMVA 4.1.1 the size; of the PDEFoam sampling box in each dimension is now VolFrac times the foam; size. This implies that in TMVA 4.1.1 the VolFrac value for training a PDEFoam; must be doubled in order to give the same results as in TMVA 4.1.0. The default; VolFrac value was also changed from 0.0333 to 0.0666.; New configuration variable ""NbinsMVAoutput"" defining the bins of the MVA output; variables in the TMVA training plots produced via the GUI. As always, Config; settings can be modified in the training script via, eg, the command. (TMVA::gConfig().GetVariablePlotting()).fNbinsMVAoutput = 50;. to be called AFTER initialising the TMVA Factory object. Bug fixes. Requested number of training and testing events was not; correct when pre-selection cuts were applied. Now the number of; requested events scales with the preselection efficiency and hence; does not need to be adjusted with the pre-selection. This also; corrects the problems seen in the Category classifierm, where; pre-selection is used to build the categories.; Correct histogram boundaries in PlotVariable.; Correct scanning procedure in OptimizeTuningParameters.; Print the significance formula that is actually used; Small speed improvement for PDEFoam functions.; Fix for MethodBoost which ensures that the method options for the boosted; classifier are handled correctly during boosting.; Fixed proble",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v530/index.html:1299,config,configuration,1299,tmva/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v530/index.html,3,"['config', 'variab']","['configuration', 'variable', 'variables']"
Modifiability,"clicked; t[i].fId = i+1; // button id; t[i].fButton = NULL; // button pointer. if (strlen(xpms[i]) == 0) {; separator = 5;; continue;; }; tb->AddButton(fMain,&t[i],separator);; separator = 0;; }; // adding the tool bar to the main frame; fMain->AddFrame(tb, new TGLayoutHints(kLHintsTop|kLHintsExpandX));. // adding a horizontal line as a separator; TGHorizontal3DLine *lh = new TGHorizontal3DLine(fMain);; fMain->AddFrame(lh, new TGLayoutHints(kLHintsTop|kLHintsExpandX));; ```. To have a tool bar in your application you do not need to do anything; special - only to create objects: a tool bar and its picture buttons.; This sample code creates the following three toolbar buttons:. ![](pictures/03000218.png). First we need to complete a `ToolBarData_t` structure for each tool bar; button before adding it to the tool bar. This structure contains:. - the icon file name ""`filename.xpm`"". - the tool tip text - a short help message explaining the button; purpose. - the Boolean variable defining the button behavior when is clicked. - `kFALSE` - do not stay down. - `kTRUE` - to stay down. - the button ID. - the button pointer (**`TGButton *`**) - should be `NULL`. We create an array `*xpms[]` containing the icon file names that will be; used for a picture button creation. If you write only the file names; here ROOT will search these files in `$ROOTSYS/icons` directory. If the; icon files are not there, you should provide the full path name also.; The array `*tips[] `contains the tool tip texts for buttons. The integer; variable separator is used to set the distance between two groups of; toolbar buttons. It defines the amount of pixels to the left for each; button. We create a tool bar object and add the buttons using the `AddButton`; method. The variable separator helps us to define no space between the; buttons in a group (0), and 5 pixels extra-space before and after. All; buttons added via this method will be deleted by the toolbar. On return; the **`TGButton`** field of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:76283,variab,variable,76283,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['variab'],['variable']
Modifiability,"cling and _cppyy_generator.py. 2019-09-25: 1.5.4; -----------------. * operator+/* now respect C++-side associativity; * Fix potential crash if modules are reloaded; * Fix some portability issues on Mac/Windows of cppyy-cling. 2019-09-15: 1.5.3; -----------------. * Performance improvements; * Support for anonymous/unnamed/nested unions; * Extended documentation. 2019-09-06: 1.5.2; -----------------. * Added a ""low level"" interface (cppyy.ll) for hard-casting and ll types; * Extended support for passing ctypes arguments through ptr, ref, ptr-ptr; * Fixed crash when creating an array of instances of a scoped inner struct; * Extended documentation. 2019-08-26: 1.5.1; -----------------. * Upgrade cppyy-cling to 6.18.2; * Various patches to upstream's pre-compiled header generation and use; * Instantiate templates with larger integer types if argument values require; * Improve cppyy.interactive and partially enable it on PyPy, IPython, etc.; * Let ``__overload__`` be more flexible in signature matching; * Make list filtering of dir(cppyy.gbl) on Windows same as Linux/Mac; * Extended documentation. 2019-08-18: 1.5.0; -----------------. * Upgrade cppyy-cling to 6.18.0; * Allow python-derived classes to be used in templates; * Stricter template resolution and better caching/performance; * Detailed memory management for make_shared and shared_ptr; * Two-way memory management for cross-inherited objects; * Reduced memory footprint of proxy objects in most common cases; * Allow implicit conversion from a tuple of arguments; * Data set on namespaces reflected on C++ even if data not yet bound; * Generalized resolution of binary operators in wrapper generation; * Proper naming of arguments in namespaces for ``std::function<>``; * Cover more cases of STL-liker iterators; * Allow ``std::vector`` initialization with a list of constructor arguments; * Consistent naming of ``__cppname__`` to ``__cpp_name__``; * Added ``__set_lifeline__`` attribute to overloads; * Fixes to the cmake ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:17435,flexible,flexible,17435,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['flexible'],['flexible']
Modifiability,"clude; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x versions suffice and are supported as; well. Versions older than 2.2 are not supported and will not work. Note; that one problem with 2.2 is that the shared library of the `Python`; interpreter core is not build by default and the '--enable-shared' flag; should thus be used when building `Python` from source. If the `Python`; interpreter that is installed on your system is too old, please obtain a; new version from <http://www.python.org>. Once configured, you continue the build process the normal way:. `$ make`. `$ make install`. After some time, a library called `libPyROOT.so` (or `libPyROOT.dll`, on; Windows) will be created in the; `$ROOTSYS/lib `(`$ROOTSYS/bin on Windows`) directory and a top Python; module, `ROOT.py`, will be copied into the same place. The final step is; to setup the shell environment, which is similar to what is described in; the chapter ‘Environment Settings'. Note that the `$ROOTSYS` entries are; probably already there if you followed the standard instructions, and; that the `PYTHONDIR` entries should be replaced as appropriate by your; choice at configuration time, or be left out if you had the; configuration script pick up them up from a default location. ### Using PyROOT. Since it is an extension module, the usage of `PyROOT` probably comes; naturally if you're used to Python. In general, `PyROOT` attempts to; allow working in both Python and ROOT style, and although it is; succeeding, it isn't perfect: there are edges. Th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:8232,config,configured,8232,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['config'],['configured']
Modifiability,"cluded at the beginning of the translation unit. The extensions to the; AST file format required for modules are discussed in the section on; :ref:`modules <pchinternals-modules>`. Clang's AST files are designed with a compact on-disk representation, which; minimizes both creation time and the time required to initially load the AST; file. The AST file itself contains a serialized representation of Clang's; abstract syntax trees and supporting data structures, stored using the same; compressed bitstream as `LLVM's bitcode file format; <https://llvm.org/docs/BitCodeFormat.html>`_. Clang's AST files are loaded ""lazily"" from disk. When an AST file is initially; loaded, Clang reads only a small amount of data from the AST file to establish; where certain important data structures are stored. The amount of data read in; this initial load is independent of the size of the AST file, such that a; larger AST file does not lead to longer AST load times. The actual header data; in the AST file --- macros, functions, variables, types, etc. --- is loaded; only when it is referenced from the user's code, at which point only that; entity (and those entities it depends on) are deserialized from the AST file.; With this approach, the cost of using an AST file for a translation unit is; proportional to the amount of code actually used from the AST file, rather than; being proportional to the size of the AST file itself. When given the `-print-stats` option, Clang produces statistics; describing how much of the AST file was actually loaded from disk. For a; simple ""Hello, World!"" program that includes the Apple ``Cocoa.h`` header; (which is built as a precompiled header), this option illustrates how little of; the actual precompiled header is required:. .. code-block:: none. *** AST File Statistics:; 895/39981 source location entries read (2.238563%); 19/15315 types read (0.124061%); 20/82685 declarations read (0.024188%); 154/58070 identifiers read (0.265197%); 0/7260 selectors read ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:3823,variab,variables,3823,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['variab'],['variables']
Modifiability,"cmake_minimum_required(VERSION 3.20.0). if(NOT DEFINED LLVM_COMMON_CMAKE_UTILS); set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake); endif(); include(${LLVM_COMMON_CMAKE_UTILS}/Modules/CMakePolicy.cmake; NO_POLICY_SCOPE). # If we are not building as a part of LLVM, build Clang as an; # standalone project, using LLVM as an external library:; if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR); project(Clang); set(CLANG_BUILT_STANDALONE TRUE); endif(). # Must go below project(..); include(GNUInstallDirs). if(CLANG_BUILT_STANDALONE); set(CMAKE_CXX_STANDARD 17 CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES); set(CMAKE_CXX_EXTENSIONS NO). if(NOT MSVC_IDE); set(LLVM_ENABLE_ASSERTIONS ${ENABLE_ASSERTIONS}; CACHE BOOL ""Enable assertions""); # Assertions should follow llvm-config's.; mark_as_advanced(LLVM_ENABLE_ASSERTIONS); endif(). find_package(LLVM REQUIRED HINTS ""${LLVM_CMAKE_DIR}""); list(APPEND CMAKE_MODULE_PATH ""${LLVM_DIR}""). # Turn into CACHE PATHs for overwritting; set(LLVM_INCLUDE_DIRS ${LLVM_INCLUDE_DIRS} CACHE PATH ""Path to llvm/include and any other header dirs needed""); set(LLVM_BINARY_DIR ""${LLVM_BINARY_DIR}"" CACHE PATH ""Path to LLVM build tree""); set(LLVM_MAIN_SRC_DIR ""${CMAKE_CURRENT_SOURCE_DIR}/../llvm"" CACHE PATH ""Path to LLVM source tree""); set(LLVM_TOOLS_BINARY_DIR ""${LLVM_TOOLS_BINARY_DIR}"" CACHE PATH ""Path to llvm/bin""); set(LLVM_LIBRARY_DIR ""${LLVM_LIBRARY_DIR}"" CACHE PATH ""Path to llvm/lib""). find_program(LLVM_TABLEGEN_EXE ""llvm-tblgen"" ${LLVM_TOOLS_BINARY_DIR}; NO_DEFAULT_PATH). # They are used as destination of target generators.; set(LLVM_RUNTIME_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin); set(LLVM_LIBRARY_OUTPUT_INTDIR ${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib${LLVM_LIBDIR_SUFFIX}); if(WIN32 OR CYGWIN); # DLL platform -- put DLLs into bin.; set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_RUNTIME_OUTPUT_INTDIR}); else(); set(LLVM_SHLIB_OUTPUT_INTDIR ${LLVM_LIBRARY_OUTPUT_INTDIR}); endif(). opt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:825,config,config,825,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['config']
Modifiability,"co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the number of; parameters, variable or non-variable. Memory allocation is done; dynamically according to the actual needs and ""on demand"". There is no; protection against an upper limit on the number of parameters, however; the ""technological"" limitations of M can be seen around a maximum of 15; free parameters at a time. ## Interfe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:25053,portab,portable,25053,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['portab'],['portable']
Modifiability,"code 2) contains a variable number of values representing; the bytes of the ``target triple`` specification string. MODULE_CODE_DATALAYOUT Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DATALAYOUT, ...string...]``. The ``DATALAYOUT`` record (code 3) contains a variable number of values; representing the bytes of the ``target datalayout`` specification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26392,variab,variable,26392,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"code object. It is; encoded as a map in the Message Pack [MsgPack]_ binary data format. See; :ref:`amdgpu-amdhsa-code-object-metadata-v3`,; :ref:`amdgpu-amdhsa-code-object-metadata-v4` and; :ref:`amdgpu-amdhsa-code-object-metadata-v5` for the map keys defined for the; ``amdhsa`` OS. .. _amdgpu-symbols:. Symbols; -------. Symbols include the following:. .. table:: AMDGPU ELF Symbols; :name: amdgpu-elf-symbols-table. ===================== ================== ================ ==================; Name Type Section Description; ===================== ================== ================ ==================; *link-name* ``STT_OBJECT`` - ``.data`` Global variable; - ``.rodata``; - ``.bss``; *link-name*\ ``.kd`` ``STT_OBJECT`` - ``.rodata`` Kernel descriptor; *link-name* ``STT_FUNC`` - ``.text`` Kernel entry point; *link-name* ``STT_OBJECT`` - SHN_AMDGPU_LDS Global variable in LDS; ===================== ================== ================ ==================. Global variable; Global variables both used and defined by the compilation unit. If the symbol is defined in the compilation unit then it is allocated in the; appropriate section according to if it has initialized data or is readonly. If the symbol is external then its section is ``STN_UNDEF`` and the loader; will resolve relocations using the definition provided by another code object; or explicitly defined by the runtime. If the symbol resides in local/group memory (LDS) then its section is the; special processor specific section name ``SHN_AMDGPU_LDS``, and the; ``st_value`` field describes alignment requirements as it does for common; symbols. .. TODO::. Add description of linked shared object symbols. Seems undefined symbols; are marked as STT_NOTYPE. Kernel descriptor; Every HSA kernel has an associated kernel descriptor. It is the address of the; kernel descriptor that is used in the AQL dispatch packet used to invoke the; kernel, not the kernel entry point. The layout of the HSA kernel descriptor is; defined in :ref:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:78170,variab,variable,78170,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"code refactoring. libanalysis - Source-level dataflow analysis useful for performing analyses; such as computing live variables. It also includes a; path-sensitive ""graph-reachability"" engine for writing; analyses that reason about different possible paths of; execution through source code. This is currently being; employed to write a set of checks for finding bugs in software. libcodegen - Lower the AST to LLVM IR for optimization & codegen. Depends; on libast.; ; clang - An example driver, client of the libraries at various levels.; This depends on all these libraries, and on LLVM VMCore. This front-end has been intentionally built as a DAG of libraries, making it; easy to reuse individual parts or replace pieces if desired. For example, to; build a preprocessor, you take the Basic and Lexer libraries. If you want an; indexer, you take those plus the Parser library and provide some actions for; indexing. If you want a refactoring, static analysis, or source-to-source; compiler tool, it makes sense to take those plus the AST building and semantic; analyzer library. Finally, if you want to use this with the LLVM backend,; you'd take these components plus the AST to LLVM lowering code.; ; In the future I hope this toolkit will grow to include new and interesting; components, including a C++ front-end, ObjC support, and a whole lot of other; things. Finally, it should be pointed out that the goal here is to build something that; is high-quality and industrial-strength: all the obnoxious features of the C; family must be correctly supported (trigraphs, preprocessor arcana, K&R-style; prototypes, GCC/MS extensions, etc). It cannot be used if it is not 'real'. II. Usage of clang driver:. * Basic Command-Line Options:; - Help: clang --help; - Standard GCC options accepted: -E, -I*, -i*, -pedantic, -std=c90, etc.; - To make diagnostics more gcc-like: -fno-caret-diagnostics -fno-show-column; - Enable metric printing: -stats. * -fsyntax-only is currently the default mode. * -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt:3508,refactor,refactoring,3508,interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2007-OriginalClangReadme.txt,1,['refactor'],['refactoring']
Modifiability,"code which is intended to cause an; execution trap with the intention of requesting the attention of a; debugger. '``llvm.ubsantrap``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.ubsantrap(i8 immarg) cold noreturn nounwind. Overview:; """""""""""""""""". The '``llvm.ubsantrap``' intrinsic. Arguments:; """""""""""""""""""". An integer describing the kind of failure detected. Semantics:; """""""""""""""""""". This intrinsic is lowered to code which is intended to cause an execution trap,; embedding the argument into encoding of that trap somehow to discriminate; crashes if possible. Equivalent to ``@llvm.trap`` for targets that do not support this behaviour. '``llvm.stackprotector``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackprotector(ptr <guard>, ptr <slot>). Overview:; """""""""""""""""". The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it; onto the stack at ``slot``. The stack slot is adjusted to ensure that it; is placed on the stack before local variables. Arguments:; """""""""""""""""""". The ``llvm.stackprotector`` intrinsic requires two pointer arguments.; The first argument is the value loaded from the stack guard; ``@__stack_chk_guard``. The second variable is an ``alloca`` that has; enough space to hold the value of the guard. Semantics:; """""""""""""""""""". This intrinsic causes the prologue/epilogue inserter to force the position of; the ``AllocaInst`` stack slot to be before local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:929923,variab,variables,929923,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description; char *raster_description_z; // z axis description; int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_color; // color of channel marks; int chanline_en_dis; // decides whether the channel lines (grid) are shown. // auxiliary variables, transformation coefficients for internal use only; double kx;; double ky;; double mxx;; double mxy;; double myx;; double myy;; double txx;; double txy;; double tyx;; double tyy;; double tyz;; double vx;; double vy;; double nu_sli;. // auxiliary internal variables, working place; double z,zeq,gbezx,gbezy,dxspline,dyspline;; int xt,yt,xs,ys,xe,ye,priamka,z_preset_value;; unsigned short obal[MAXIMUM_XSCREEN_RESOLUTION];; unsigned short obal_cont[MAXIMUM_XSCREEN_RESOLUTION];; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next few Figures. ![Display mode-bars, pen width=2](figures/image226.png). ![Display mode-triangles, log scale](figures/image228.png). ![Display mode-contours](figures/image230.png). ![Display mode surface shading according to height](figures/image232.png). ![Display mode-surface shading according to light point](figures/image234.png). ![Display mode-surface shading according to height+light position with ratio 50:50, CMY color model](figures/image236.png). ![Display mode bars shaded according to height](figures/image238.png). ![Display mode- surface shading according to light position with shadows](figures/image240.png). ![Display mode- surface shading according to height with 10 levels of contours](figures/image242.png). ![Display mode- surface shading according to height, sqrt scale, ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:80561,variab,variables,80561,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variables']
Modifiability,"column names in the RDataFrame object is now also; usable from a node of a distributed computation graph. This makes the generation of said computation graph slightly; less lazy than before. Notably, it used to be the case that a distributed computation graph could be defined with; code that was not yet available on the user's local application, but that would only become available in the; distributed worker. Now a call such as `df.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4374,adapt,adapter,4374,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,1,['adapt'],['adapter']
Modifiability,"com; D: Debug Information. N: Vladimir Prus; W: http://vladimir_prus.blogspot.com; E: ghost@cs.msu.su; D: Made inst_iterator behave like a proper iterator, LowerConstantExprs pass. N: QIU Chaofan; E: qiucofan@cn.ibm.com; D: PowerPC Backend Developer. N: Kalle Raiskila; E: kalle.rasikila@nokia.com; D: Some bugfixes to CellSPU. N: Xerxes Ranby; E: xerxes@zafena.se; D: Cmake dependency chain and various bug fixes. N: Alex Rosenberg; E: alexr@leftfield.org; I: arosenberg; D: ARM calling conventions rewrite, hard float support. N: Chad Rosier; E: mcrosier@codeaurora.org; I: mcrosier; D: AArch64 fast instruction selection pass; D: Fixes and improvements to the ARM fast-isel pass; D: Fixes and improvements to the AArch64 backend. N: Nadav Rotem; E: nadav.rotem@me.com; D: X86 code generation improvements, Loop Vectorizer, SLP Vectorizer. N: Roman Samoilov; E: roman@codedgers.com; D: MSIL backend. N: Duncan Sands; E: baldrick@free.fr; I: baldrick; D: Ada support in llvm-gcc; D: Dragonegg plugin; D: Exception handling improvements; D: Type legalizer rewrite. N: Ruchira Sasanka; E: sasanka@uiuc.edu; D: Graph coloring register allocator for the Sparc64 backend. N: Alina Sbirlea; E: alina.sbirlea@gmail.com; D: MemorySSA, BatchAA, misc loop and new pass manager work. N: Arnold Schwaighofer; E: arnold.schwaighofer@gmail.com; D: Tail call optimization for the x86 backend. N: Shantonu Sen; E: ssen@apple.com; D: Miscellaneous bug fixes. N: Anand Shukla; E: ashukla@cs.uiuc.edu; D: The `paths' pass. N: Michael J. Spencer; E: bigcheesegs@gmail.com; D: Shepherding Windows COFF support into MC.; D: Lots of Windows stuff. N: Reid Spencer; E: rspencer@reidspencer.com; W: http://reidspencer.com/; D: Lots of stuff, see: http://wiki.llvm.org/index.php/User:Reid. N: Abhina Sreeskantharajan; E: Abhina.Sreeskantharajan@ibm.com; D: z/OS support. N: Alp Toker; E: alp@nuanti.com; W: http://atoker.com/; D: C++ frontend next generation standards implementation. N: Craig Topper; E: craig.topper@gmail.c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:11399,plugin,plugin,11399,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,2,"['plugin', 'rewrite']","['plugin', 'rewrite']"
Modifiability,"com; D: Pluggable GC support; D: C interface; D: Ocaml bindings. N: Raul Fernandes Herbster; E: raul@dsc.ufcg.edu.br; D: JIT support for ARM. N: Paolo Invernizzi; E: arathorn@fastwebnet.it; D: Visual C++ compatibility fixes. N: Patrick Jenkins; E: patjenk@wam.umd.edu; D: Nightly Tester. N: Tony(Yanjun) Jiang; E: jtony@ca.ibm.com; D: PowerPC Backend Developer; D: Improvements to the PPC backend and miscellaneous bug fixes. N: Dale Johannesen; E: dalej@apple.com; D: ARM constant islands improvements; D: Tail merging improvements; D: Rewrite X87 back end; D: Use APFloat for floating point constants widely throughout compiler; D: Implement X87 long double. N: Brad Jones; E: kungfoomaster@nondot.org; D: Support for packed types. N: Rod Kay; E: rkay@auroraux.org; D: Author of LLVM Ada bindings. N: Erich Keane; E: erich.keane@intel.com; D: A variety of Clang contributions including function multiversioning, regcall/vectorcall.; I: ErichKeane. N: Eric Kidd; W: http://randomhacks.net/; D: llvm-config script. N: Anton Korobeynikov; E: anton at korobeynikov dot info; D: Mingw32 fixes, cross-compiling support, stdcall/fastcall calling conv.; D: x86/linux PIC codegen, aliases, regparm/visibility attributes; D: Switch lowering refactoring. N: Sumant Kowshik; E: kowshik@uiuc.edu; D: Author of the original C backend. N: Benjamin Kramer; E: benny.kra@gmail.com; D: Miscellaneous bug fixes. N: Michael Kuperstein; E: mkuper@google.com; D: Loop Vectorizer. N: Sundeep Kushwaha; E: sundeepk@codeaurora.org; D: Implemented DFA-based target independent VLIW packetizer. N: Christopher Lamb; E: christopher.lamb@gmail.com; D: aligned load/store support, parts of noalias and restrict support; D: vreg subreg infrastructure, X86 codegen improvements based on subregs; D: address spaces. N: Jim Laskey; E: jlaskey@apple.com; D: Improvements to the PPC backend, instruction scheduling; D: Debug and Dwarf implementation; D: Auto upgrade mangler; D: llvm-gcc4 svn wrangler. N: Chris Lattner; E: sabre@nond",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:6287,config,config,6287,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['config'],['config']
Modifiability,"combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VALUE %1, $noreg, !123, !DIExpression(). And has the following operands:; * The first operand can record the variable location as a register,; a frame index, an immediate, or the base address register if the original; debug intrinsic referred to memory. ``$noreg`` indicates the variable; location is undefined, equivalent to an ``undef`` dbg.value operand.; * The type of the second operand indicates whether the variable location is; directly referred to by the DBG_VALUE, or whether it is indirect. The; ``$noreg`` register signifies the former, an immediate operand (0) the; latter.; * Operand 3 is the Variable field of the original debug intrinsic.; * Operand 4 is the Expression field of the original debug intrinsic. The second form, ``DBG_VALUE_LIST``, appears thus:. .. code-bl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:27052,variab,variable,27052,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"command or by setting it directly in ``ccmake`` or ``cmake-gui``). This file is available in two different locations. * ``<LLVM_INSTALL_PACKAGE_DIR>/LLVMConfig.cmake`` where; ``<LLVM_INSTALL_PACKAGE_DIR>`` is the location where LLVM CMake modules are; installed as part of an installed version of LLVM. This is typically; ``cmake/llvm/`` within the lib directory. On Linux, this is typically; ``/usr/lib/cmake/llvm/LLVMConfig.cmake``. * ``<LLVM_BUILD_ROOT>/lib/cmake/llvm/LLVMConfig.cmake`` where; ``<LLVM_BUILD_ROOT>`` is the root of the LLVM build tree. **Note: this is only; available when building LLVM with CMake.**. If LLVM is installed in your operating system's normal installation prefix (e.g.; on Linux this is usually ``/usr/``) ``find_package(LLVM ...)`` will; automatically find LLVM if it is installed correctly. If LLVM is not installed; or you wish to build directly against the LLVM build tree you can use; ``LLVM_DIR`` as previously mentioned. The ``LLVMConfig.cmake`` file sets various useful variables. Notable variables; include. ``LLVM_CMAKE_DIR``; The path to the LLVM CMake directory (i.e. the directory containing; LLVMConfig.cmake). ``LLVM_DEFINITIONS``; A list of preprocessor defines that should be used when building against LLVM. ``LLVM_ENABLE_ASSERTIONS``; This is set to ON if LLVM was built with assertions, otherwise OFF. ``LLVM_ENABLE_EH``; This is set to ON if LLVM was built with exception handling (EH) enabled,; otherwise OFF. ``LLVM_ENABLE_RTTI``; This is set to ON if LLVM was built with run time type information (RTTI),; otherwise OFF. ``LLVM_INCLUDE_DIRS``; A list of include paths to directories containing LLVM header files. ``LLVM_PACKAGE_VERSION``; The LLVM version. This string can be used with CMake conditionals, e.g., ``if; (${LLVM_PACKAGE_VERSION} VERSION_LESS ""3.5"")``. ``LLVM_TOOLS_BINARY_DIR``; The path to the directory containing the LLVM tools (e.g. ``llvm-as``). Notice that in the above example we link ``simple-tool`` against several LLVM;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:43501,variab,variables,43501,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20970,config,configuration,20970,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"compilation database; from the ``compile_commands.json`` file, generated by CMake. When; invoking clang tools, you can either specify a path to a build directory; using a command line parameter ``-p`` or let Clang Tooling find this; file in your source tree. In either case you need to configure your; build using CMake to use clang tools. Setup Clang Tooling Using CMake and Make; ========================================. If you intend to use make to build LLVM, you should have CMake 2.8.6 or; later installed (can be found `here <https://cmake.org>`_). First, you need to generate Makefiles for LLVM with CMake. You need to; make a build directory and run CMake from it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using make:. .. code-block:: console. $ make check-all. Setup Clang Tooling Using CMake on Windows; ==========================================. For Windows developers, the Visual Studio project generators in CMake do; not support `CMAKE_EXPORT_COMPILE_COMMANDS; <https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html>`_.; However, the Ninja generator does support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:1601,config,configure,1601,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indicate; to the system which argument corresponds to which data member of the; class. ### Executing Events when a Cursor Passes on Top of an Object. This paragraph is for class designers. When a class is designed, it is; often desirable to include drawing methods for it. We will have a more; e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7939,variab,variable,7939,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,2,['variab'],['variable']
Modifiability,"completed.; Painter for drawn object will be provided as first argument (or null in case of error).; 8. Improve cleanup of JSROOT objects. ## Changes in 4.7.1; 1. Workaround for MathJax output - scaling not always works in Firefox; 2. Fix - bin scaling for box draw option for TH2 and TH3 histograms; 3. Fix - increase points limits for contour plots; 4. Fix - position of 3D canvas in WebKit browsers; 5. Fix - use abs bin content in RMS calculations; 6. Fix - support char star* and object arrays in I/O; 7. Fix - correct decoding of TAxis time offset; 8. Fix - checksum reading for foreign classes. ## Changes in 4.7.0; 1. Implement simple TTree::Draw over single leaf (#80); Support basic types, fixed-size arrays and several vector types; 2. Display of TEveTrack(s) and TEvePointSet(s) over drawn geometry (drag and drop); Also browsing, toggling, highlight of tracks and hits are done.; 3. Let set default geo colors as TGeoManager::DefaultColors() does; 4. Let use original ROOT macros to configure visibility of geometry volumes. Like:; &file=files/alice2.root&item=Geometry;1&opt=macro:macros/geomAlice.C; One can set default colors or colors/transparency for selected volumes.; Also volume, selected for drawing in the macro, will be used in the JSROOT; 5. Support drawing of TH2Poly class with 'col' and 'lego' options; 6. Implement 'CONT', 'ARR' and 'SURF' draw options for TH2 class; 7. Support basic drawing of TPolyLine class; 8. Interactive axis zooming in 3D with mouse, very much like to 2D; 9. Zooming and tool buttons via keyboards. ## Changes in 4.6.0; 1. Improvements in TGeo drawings; - support of large (~10M volumes) models, only most significant volumes are shown; - one could activate several clip planes (only with WebGL); - interaction with object browser to change visibility flags or focus on selected volume; - support of floating browser for TGeo objects; - intensive use of HTML Worker to offload computation tasks and keep interactivity; - enable more details when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:51956,config,configure,51956,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11898,config,configuration,11898,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; drafting; Nested brace initialization from same type; Not resolved. 2320; extension; constexpr if and boolean conversions; Extension. 2321; CD5; Conditional operator and cv-qualified class prvalues; Unknown. 2322; CD5; Substitution failure and lexical order; Unknown. 2323; C++20; Expunge POD; Unknown. 2324; drafting; Size of base class subobject; Not resolved. 2325; drafting; std::launder and reuse of character buffers; Not resolved. 2326; dup; Type deduction with initializer list containing ambiguous functions; Unknown. 2327; drafting; Copy elision for direct-initializat,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157854,variab,variables,157854,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"contributors moving from the; legacy configure/make system. If you are really anxious about getting a functional LLVM build, go to the; `Quick start`_ section. If you are a CMake novice, start with `Basic CMake usage`_; and then go back to the `Quick start`_ section once you know what you are doing. The; `Options and variables`_ section is a reference for customizing your build. If; you already have experience with CMake, this is the recommended starting point. This page is geared towards users of the LLVM CMake build. If you're looking for; information about modifying the LLVM CMake build system you may want to see the; :doc:`CMakePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:1499,variab,variable,1499,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"converted to a C++ class by; René Brun. The current implementation in C++ is a straightforward; conversion of the original FORTRAN version. The main changes are:. - The variables in the various `Minuit` labeled common blocks have; been changed to the **`TMinuit`** class data members. - The internal arrays with a maximum dimension depending on the; maximum number of parameters are now data members' arrays with a; dynamic dimension such that one can fit very large problems by; simply initializing the **`TMinuit`** constructor with the maximum; number of parameters. - The include file `Minuit.h` has been commented as much as possible; using existing comments in the code or the printed documentation. - The original `Minuit` subroutines are now member functions. - Constructors and destructor have been added. - Instead of passing the `FCN` function in the argument list, the; addresses of this function is stored as pointer in the data; members of the class. This is by far more elegant and flexible in; an interactive environment. The member function `SetFCN` can be; used to define this pointer. - The ROOT static function `Printf` is provided to replace all; format statements and to print on currently defined output file. - The functions `SetObjectFit/GetObjectFit` can be used inside the; `FCN` function to set/get a referenced object instead of using; global variables. - By default `fGraphicsMode` is true. When calling the `Minuit`; functions such as `mncont`, `mnscan`, or any `Minuit` command; invoking `mnplot`, `TMinuit::mnplot()` produces a **`TGraph`**; object pointed by `fPlot`. One can retrieve this object with; **`TMinuit`**`::GetPlot().` For example:. ``` {.cpp}; h->Fit(""gaus"");; gMinuit->Command(""SCAn 1"");; TGraph *gr = (TGraph*)gMinuit->GetPlot();; gr->SetMarkerStyle(21);; gr->Draw(""alp"");; ```. - To set `Minuit` in no graphics mode, call. ``` {.cpp}; gMinuit->SetGraphicsMode(kFALSE);; ```. ### Basic Concepts of Minuit. The `Minuit` package acts on a multi parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:54096,flexible,flexible,54096,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['flexible'],['flexible']
Modifiability,coped enumeration type to integral type; Clang 2.9. 672; CD2; Sequencing of initialization in new-expressions; Unknown. 673; NAD; Injection of names from elaborated-type-specifiers in friend declarations; Yes. 674; C++11; “matching specialization” for a friend declaration; Clang 8. 675; CD3; Signedness of bit-field with typedef or template parameter type; Duplicate of 739. 676; C++11; static_assert-declarations and general requirements for declarations; N/A. 677; CD1; Deleted operator delete and virtual destructors; No. 678; C++11; Language linkage of member function parameter types and the ODR; Unknown. 679; CD1; Equivalence of template-ids and operator function templates; Yes. 680; CD2; What is a move constructor?; N/A. 681; CD1; Restrictions on declarators with late-specified return types; Partial. 682; CD5; Missing description of lookup of template aliases; Unknown. 683; CD1; Requirements for trivial subobject special functions; Yes. 684; CD1; Constant expressions involving the address of an automatic variable; Superseded by 1454. 685; CD2; Integral promotion of enumeration ignores fixed underlying type; Yes. 686; CD1; Type declarations/definitions in type-specifier-seqs and type-ids; Clang 3.0. 687; NAD; template keyword with unqualified-ids; Unknown. 688; CD1; Constexpr constructors and static initialization; Unknown. 689; CD5; Maximum values of signed and unsigned integers; Unknown. 690; CD2; The dynamic type of an rvalue reference; Unknown. 691; C++11; Template parameter packs in class template partial specializations; Unknown. 692; C++11; Partial ordering of variadic class template partial specializations; Clang 16. 693; CD2; New string types and deprecated conversion; Unknown. 694; C++11; Zero- and value-initialization of union objects; Unknown. 695; CD2; Compile-time calculation errors in constexpr functions; Unknown. 696; C++11; Use of block-scope constants in local classes; Clang 3.1. 697; open; Deduction rules apply to more than functions; Not resolved.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:46913,variab,variable,46913,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"cord being defined. The steps taken to create a new record are somewhat complex. See `How; records are built`_. See `Examples: classes and records`_ for examples. Examples: classes and records; -----------------------------. Here is a simple TableGen file with one class and two record definitions. .. code-block:: text. class C {; bit V = true;; }. def X : C;; def Y : C {; let V = false;; string Greeting = ""Hello!"";; }. First, the abstract class ``C`` is defined. It has one field named ``V``; that is a bit initialized to true. Next, two records are defined, derived from class ``C``; that is, with ``C``; as their parent class. Thus they both inherit the ``V`` field. Record ``Y``; also defines another string field, ``Greeting``, which is initialized to; ``""Hello!""``. In addition, ``Y`` overrides the inherited ``V`` field,; setting it to false. A class is useful for isolating the common features of multiple records in; one place. A class can initialize common fields to default values, but; records inheriting from that class can override the defaults. TableGen supports the definition of parameterized classes as well as; nonparameterized ones. Parameterized classes specify a list of variable; declarations, which may optionally have defaults, that are bound when the; class is specified as a parent class of another class or record. .. code-block:: text. class FPFormat <bits<3> val> {; bits<3> Value = val;; }. def NotFP : FPFormat<0>;; def ZeroArgFP : FPFormat<1>;; def OneArgFP : FPFormat<2>;; def OneArgFPRW : FPFormat<3>;; def TwoArgFP : FPFormat<4>;; def CompareFP : FPFormat<5>;; def CondMovFP : FPFormat<6>;; def SpecialFP : FPFormat<7>;. The purpose of the ``FPFormat`` class is to act as a sort of enumerated; type. It provides a single field, ``Value``, which holds a 3-bit number. Its; template argument, ``val``, is used to set the ``Value`` field. Each of the; eight records is defined with ``FPFormat`` as its parent class. The; enumeration value is passed in angle bracket",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:29894,inherit,inheriting,29894,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inheriting']
Modifiability,"correct type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:53825,polymorphi,polymorphic,53825,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['polymorphi'],['polymorphic']
Modifiability,"correct variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to record every valid variable location in that block. After this pass the DBG_VALUE instruction changes meaning: rather than; corresponding to a source-level assignment where the variable may change value,; it asserts the location of a variable in a block, and loses effect outside the; block. Propagating variable locations through copies and spills is; straightforwards: determining the variable location in every basic block; requires the consideration of control flow. Consider the following IR, which; presents several difficulties:. .. code-block:: text. define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {; entry:; br i1 %cond, label %truebr, label %falsebr. bb1:; %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]; br label %exit, !dbg !26. truebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = add i32 %input, 1; br label %bb1. falsebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 2, metadata !23, metadata !DIExpression()), !dbg !24; %value2 = add i32 %input, 2; br label %bb1. exit:; ret i32 %value, !dbg !30; }. Here the difficulties are:. * The control flow is roughly the opposite of basic block order",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:37053,variab,variable,37053,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that ``buf`` has ``count`` number of elements available. This; relationship must hold even after any of these related variables are updated. To; this end, the model requires that assignments to ``buf`` and ``count`` must be; side by side, with no side effects between them. This prevents ``buf`` and; ``count`` from temporarily falling out of sync due to updates happening at a; distance. The example below shows a function ``alloc_buf`` that initializes a struct that; members that use the ``__counted_by`` annotation. The compiler allows these; assignments because ``sbuf->buf`` and ``sbuf->count`` are updated side by side; without any side effects in between the assignments. Furthermore, the compiler inserts additional run-time checks to ensure the new; ``buf`` has at least as many elements as the new ``count`` indicates as shown in; the transformed pseudo code of function ``alloc_buf()`` in the example below. .. code-block:: c. typedef struct {; int *__counted_by(count) buf;; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:36137,variab,variables,36137,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"corresponding TProcessID; record and an ""fUniqueID"" field uniquely identifying the referenced object among those; written by that process (see \ref tobject). Similarly, every persistent reference to that; object (a TRef Object, see \ref tref) also contains ""pidf"" and ""fUniqueID"" fields with the; same value, thereby uniquely determining the referenced object (which need not even be in the; same file). In the case of an array of references (a TRefArray object, see \ref trefarray),; there is one ""pidf"" value for the entire array, and a separate ""fUniqueID"" value for each; reference. For further information, see the above URL. ## Some useful container classes. ### TObjArray and TClonesArray. The TObjArray class can be used to support an array of objects. The objects need not be of the; same type, but each object must be of a class type that inherits from TObject. We have already; seen a specific example of the use of TObjArray, in the StreamerInfo record, where it is used; to hold an array of TStreamerElement objects, each of which is of a class inheriting from; TStreamerElement, which in turn inherits from TObject. The TClonesArray class is a specialization of the TObjArray class for holding an array; of objects that are all of the same type. The format of a TClonesArray object; is given in \ref tclonesarray. There are two great advantages in the use of TClonesArray over TObjArray when the objects; all will be of the same class:. 1. Memory for the objects will be allocated only once for the entire array, rather; than the per-object allocation for TObjArray. This can be done because all the; objects are the same size.; 2. In the case of TObjArray, the stored objects are written sequentially. However,; in a TClonesArray, by default, each object is split one level deep into its base; class(es) and data members, and each of these members is written sequentially for; all objects in the array before the next member is written. This has two advantages:; 1. Greater compression",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:12232,inherit,inheriting,12232,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,2,['inherit'],"['inheriting', 'inherits']"
Modifiability,cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407297,plugin,plugins,407297,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,create_subdirectory_options(CLANG TOOL). add_clang_subdirectory(diagtool); add_clang_subdirectory(driver); add_clang_subdirectory(apinotes-test); add_clang_subdirectory(clang-diff); add_clang_subdirectory(clang-format); add_clang_subdirectory(clang-format-vs); add_clang_subdirectory(clang-fuzzer); add_clang_subdirectory(clang-import-test); add_clang_subdirectory(clang-linker-wrapper); add_clang_subdirectory(clang-offload-packager); add_clang_subdirectory(clang-offload-bundler); add_clang_subdirectory(clang-scan-deps); if(HAVE_CLANG_REPL_SUPPORT); add_clang_subdirectory(clang-repl); endif(). add_clang_subdirectory(c-index-test). add_clang_subdirectory(clang-rename); add_clang_subdirectory(clang-refactor); # For MinGW we only enable shared library if LLVM_LINK_LLVM_DYLIB=ON.; # Without that option resulting library is too close to 2^16 DLL exports limit.; if(UNIX OR (MINGW AND LLVM_LINK_LLVM_DYLIB)); add_clang_subdirectory(clang-shlib); endif(). if(CLANG_ENABLE_ARCMT); add_clang_subdirectory(arcmt-test); add_clang_subdirectory(c-arcmt-test); endif(). if(CLANG_ENABLE_STATIC_ANALYZER); add_clang_subdirectory(clang-check); add_clang_subdirectory(clang-extdef-mapping); add_clang_subdirectory(scan-build); add_clang_subdirectory(scan-build-py); add_clang_subdirectory(scan-view); endif(). # We support checking out the clang-tools-extra repository into the 'extra'; # subdirectory. It contains tools developed as part of the Clang/LLVM project; # on top of the Clang tooling platform. We keep them in a separate repository; # to keep the primary Clang repository small and focused.; # It also may be included by LLVM_EXTERNAL_CLANG_TOOLS_EXTRA_SOURCE_DIR.; add_llvm_external_project(clang-tools-extra extra). # libclang may require clang-tidy in clang-tools-extra.; add_clang_subdirectory(libclang). add_clang_subdirectory(amdgpu-arch); add_clang_subdirectory(nvptx-arch); ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/CMakeLists.txt:703,refactor,refactor,703,interpreter/llvm-project/clang/tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/CMakeLists.txt,1,['refactor'],['refactor']
Modifiability,"criptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; target-specific issues. The code for the target-independent JIT lives in; ``lib/ExecutionEngine/JIT``. Depending on which part of the code generator you are interested in working on,; different pieces of this will be useful to you. In any case, you should be; familiar with the `target description`_ and `machine code representation`_; classes. If you want to add a backend for a new target, you will need to; `implement the target description`_ classes for your new target and understand; the :doc:`LLVM code representation <LangRef>`. If you are interested in; implementing a new `code generation algorithm`_, it should only depend on the; target-description and machine code representation classes, ensuring that it is; portable. Required components in the code generator; -----------------------------------------. The two pieces of the LLVM code generator are the high-level interface to the; code generator and the set of reusable components that can be used to build; target-specific backends. The two most important interfaces (:raw-html:`<tt>`; `TargetMachine`_ :raw-html:`</tt>` and :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>`) are the only ones that are required to be defined for a; backend to fit into the LLVM system, but the others must be defined if the; reusable code generator components are going to be used. This design has two important implications. The first is that LLVM can support; completely non-traditional code generation targets. For example, the C backend; does not require register allocation, instruction selection, or any of the other; standard components provided by the system. As such, it on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:3248,portab,portable,3248,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['portab'],['portable']
Modifiability,"crosoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``; For variables defined in the executable and only used within it. If no explicit model is given, the ""general dynamic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25625,variab,variable,25625,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"cs; -------------------------------------. Variable argument support is defined in LLVM with the; :ref:`va_arg <i_va_arg>` instruction and these three intrinsic; functions. These functions are related to the similarly named macros; defined in the ``<stdarg.h>`` header file. All of these functions operate on arguments that use a target-specific; value type ""``va_list``"". The LLVM assembly language reference manual; does not define what this type is, so all transformations should be; prepared to handle these functions regardless of the type used. This example shows how the :ref:`va_arg <i_va_arg>` instruction and the; variable argument handling intrinsic functions are used. .. code-block:: llvm. ; This struct is different for every platform. For most platforms,; ; it is merely a ptr.; %struct.va_list = type { ptr }. ; For Unix x86_64 platforms, va_list is the following struct:; ; %struct.va_list = type { i32, i32, ptr, ptr }. define i32 @test(i32 %X, ...) {; ; Initialize variable argument processing; %ap = alloca %struct.va_list; call void @llvm.va_start(ptr %ap). ; Read a single integer argument; %tmp = va_arg ptr %ap, i32. ; Demonstrate usage of llvm.va_copy and llvm.va_end; %aq = alloca ptr; call void @llvm.va_copy(ptr %aq, ptr %ap); call void @llvm.va_end(ptr %aq). ; Stop processing of arguments.; call void @llvm.va_end(ptr %ap); ret i32 %tmp; }. declare void @llvm.va_start(ptr); declare void @llvm.va_copy(ptr, ptr); declare void @llvm.va_end(ptr). .. _int_va_start:. '``llvm.va_start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.va_start(ptr <arglist>). Overview:; """""""""""""""""". The '``llvm.va_start``' intrinsic initializes ``<arglist>`` for; subsequent use by ``va_arg``. Arguments:; """""""""""""""""""". The argument is a pointer to a ``va_list`` element to initialize. Semantics:; """""""""""""""""""". The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro; available in C. In a target-dependent way, it initializes the; ``va_list``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:492580,variab,variable,492580,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ct A {; virtual void f();; };. struct B : A {; virtual void f();; virtual void g();; };. struct C {; virtual void h();; };. struct D : A, C {; virtual void f();; virtual void h();; };. The virtual table objects for A, B, C and D look like this (under the Itanium ABI):. .. csv-table:: Virtual Table Layout for A, B, C, D; :header: Class, 0, 1, 2, 3, 4, 5, 6. A, A::offset-to-top, &A::rtti, &A::f; B, B::offset-to-top, &B::rtti, &B::f, &B::g; C, C::offset-to-top, &C::rtti, &C::h; D, D::offset-to-top, &D::rtti, &D::f, &D::h, D::offset-to-top, &D::rtti, thunk for &D::h. When an object of type A is constructed, the address of ``&A::f`` in A's; virtual table object is stored in the object's vtable pointer. In ABI parlance; this address is known as an `address point`_. Similarly, when an object of type; B is constructed, the address of ``&B::f`` is stored in the vtable pointer. In; this way, the vtable in B's virtual table object is compatible with A's vtable. D is a little more complicated, due to the use of multiple inheritance. Its; virtual table object contains two vtables, one compatible with A's vtable and; the other compatible with C's vtable. Objects of type D contain two virtual; pointers, one belonging to the A subobject and containing the address of; the vtable compatible with A's vtable, and the other belonging to the C; subobject and containing the address of the vtable compatible with C's vtable. The full set of compatibility information for the above class hierarchy is; shown below. The following table shows the name of a class, the offset of an; address point within that class's vtable and the name of one of the classes; with which that address point is compatible. .. csv-table:: Type Offsets for A, B, C, D; :header: VTable for, Offset, Compatible Class. A, 16, A; B, 16, A; , , B; C, 16, C; D, 16, A; , , D; , 48, C. The next step is to encode this compatibility information into the IR. The way; this is done is to create type metadata named after each of the co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:2622,inherit,inheritance,2622,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['inherit'],['inheritance']
Modifiability,"ct or; compare four-vectors:. ``` {.cpp}; v3 = -v1;; v1 = v2+v3;; v1+= v3;; v1 = v2 + v3;; v1-= v3;; if (v1 == v2) {...}; if (v1 != v3) {...}; ```. ### Magnitude/Invariant mass, beta, gamma, scalar product. The scalar product of two four-vectors is calculated with the; `(-,-,-,+) `metric:. **`s = v1*v2 `** `= t1*t2-x1*x2-y1*y2-z1*z2 `. The magnitude squared `mag2` of a four-vector is therefore:. **`mag2 = v*v`** ` = t*t-x*x-y*y-z*z `. If `mag2` is negative: **`mag = -Sqrt(-mag*mag)`**. The methods are:. ``` {.cpp}; Double_t s, s2;; s = v1.Dot(v2);// scalar product; s = v1*v2;// scalar product; s2 = v.Mag2();ors2 = v.M2();; s = v.Mag();s = v.M();; ```. Since in case of momentum and energy the magnitude has the meaning of; invariant mass **`TLorentzVector`** provides the more meaningful aliases; `M2()` and `M()`. The methods `Beta()` and `Gamma()` returns `beta` and; `gamma = 1/Sqrt(1-beta*beta)`. ### Lorentz Boost. A boost in a general direction can be parameterized with three; parameters which can be taken as the components of a three vector; `b=(bx,by,bz)`. With `x=(x,y,z)` and `gamma=1/Sqrt(1-beta*beta)` (beta; being the module of vector b)`,` an arbitrary active Lorentz boost; transformation (from the rod frame to the original frame) can be written; as:. `x = x' + (gamma-1)/(beta*beta)*(b*x')*b + gamma*t'*b `. `t = gamma(t'+ b*x') `. The `Boost()` method performs a boost transformation from the rod frame; to the original frame. `BoostVector()` returns a **`TVector3`** of the; spatial components divided by the time component:. ``` {.cpp}; TVector3 b;; v.Boost(bx,by,bz);; v.Boost(b);; b = v.BoostVector();// b=(x/t,y/t,z/t); ```. ### Rotations. There are four sets of functions to rotate the **`TVector3`** component; of a **`TLorentzVector`**:. Around Axes:. ``` {.cpp}; v.RotateX(TMath::Pi()/2.);; v.RotateY(.5);; v.RotateZ(.99);; ```. Around an arbitrary axis:. ``` {.cpp}; v.Rotate(TMath::Pi()/4., v1); // rotation around v1; ```. Transformation from rotated frame:. ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md:13218,parameteriz,parameterized,13218,documentation/users-guide/PhysicsVectors.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PhysicsVectors.md,1,['parameteriz'],['parameterized']
Modifiability,"ct; if(NOT EXISTS ${COMPILER_RT_SRC_ROOT}); # We don't want to set it if LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR is """"; if(LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR); set(COMPILER_RT_SRC_ROOT ${LLVM_EXTERNAL_COMPILER_RT_SOURCE_DIR}); endif(); endif(). if(LLVM_BUILD_EXTERNAL_COMPILER_RT AND EXISTS ${COMPILER_RT_SRC_ROOT}/). # Add compiler-rt as an external project.; set(COMPILER_RT_PREFIX ${CMAKE_BINARY_DIR}/projects/compiler-rt). set(STAMP_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-stamps/); set(BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/compiler-rt-bins/). add_custom_target(compiler-rt-clear; COMMAND ${CMAKE_COMMAND} -E remove_directory ${BINARY_DIR}; COMMAND ${CMAKE_COMMAND} -E remove_directory ${STAMP_DIR}; COMMENT ""Clobberring compiler-rt build and stamp directories""; ). # Find all variables that start with COMPILER_RT and populate a variable with; # them.; get_cmake_property(variableNames VARIABLES); foreach(variableName ${variableNames}); if(variableName MATCHES ""^COMPILER_RT""); string(REPLACE "";"" ""\;"" value ""${${variableName}}""); list(APPEND COMPILER_RT_PASSTHROUGH_VARIABLES; -D${variableName}=${value}); endif(); endforeach(). set(compiler_rt_configure_deps); if(TARGET cxx-headers); list(APPEND compiler_rt_configure_deps ""cxx-headers""); endif(); if(LLVM_INCLUDE_TESTS); list(APPEND compiler_rt_configure_deps LLVMTestingSupport); endif(). include(GetClangResourceDir); get_clang_resource_dir(output_resource_dir PREFIX ${LLVM_BINARY_DIR}); get_clang_resource_dir(install_resource_dir); ExternalProject_Add(compiler-rt; DEPENDS llvm-config clang ${compiler_rt_configure_deps}; PREFIX ${COMPILER_RT_PREFIX}; SOURCE_DIR ${COMPILER_RT_SRC_ROOT}; STAMP_DIR ${STAMP_DIR}; BINARY_DIR ${BINARY_DIR}; CMAKE_ARGS ${CLANG_COMPILER_RT_CMAKE_ARGS}; -DCMAKE_C_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/clang; -DCMAKE_CXX_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/clang++; -DCMAKE_ASM_COMPILER=${LLVM_RUNTIME_OUTPUT_INTDIR}/clang; -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}; -DCMAKE_MAKE_PROGRAM=${CMAKE_MAKE_P",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt:1738,variab,variableNames,1738,interpreter/llvm-project/clang/runtime/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/runtime/CMakeLists.txt,6,['variab'],"['variableName', 'variableNames']"
Modifiability,"cted. ======================================== ================================================; Syntax Description; ======================================== ================================================; dst_sel:DWORD Use bits 31:0.; dst_sel:BYTE_0 Use bits 7:0.; dst_sel:BYTE_1 Use bits 15:8.; dst_sel:BYTE_2 Use bits 23:16.; dst_sel:BYTE_3 Use bits 31:24.; dst_sel:WORD_0 Use bits 15:0.; dst_sel:WORD_1 Use bits 31:16.; ======================================== ================================================. .. _amdgpu_synid_dst_unused:. dst_unused; ~~~~~~~~~~. Controls what to do with the bits in the destination which are not selected; by :ref:`dst_sel<amdgpu_synid_dst_sel>`.; By default, unused bits are preserved. ======================================== ================================================; Syntax Description; ======================================== ================================================; dst_unused:UNUSED_PAD Pad with zeros.; dst_unused:UNUSED_SEXT Sign-extend upper bits, zero lower bits.; dst_unused:UNUSED_PRESERVE Preserve bits.; ======================================== ================================================. .. _amdgpu_synid_src0_sel:. src0_sel; ~~~~~~~~. Controls which bits in the src0 are used. By default, all bits are used. ======================================== ================================================; Syntax Description; ======================================== ================================================; src0_sel:DWORD Use bits 31:0.; src0_sel:BYTE_0 Use bits 7:0.; src0_sel:BYTE_1 Use bits 15:8.; src0_sel:BYTE_2 Use bits 23:16.; src0_sel:BYTE_3 Use bits 31:24.; src0_sel:WORD_0 Use bits 15:0.; src0_sel:WORD_1 Use bits 31:16.; ======================================== ================================================. .. _amdgpu_synid_src1_sel:. src1_sel; ~~~~~~~~. Controls which bits in the src1 are used. By default, all bits are used. ======================================== ===============================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:48601,extend,extend,48601,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['extend'],['extend']
Modifiability,"ction (for unbinned fits). These standard objective functions can be created with or without gradient functionality. In the first case the minimization will be performed using the gradient provided by the function. These functions can also be used in specialized fitting methods like Fumili or the GSL non-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In Minuit2Minimizer fill the status information according to the minimizer result; Add Scan and Contour methods in the Minuit2Minimizer class; ; GenVector. Change the way the exception are thrown in the package (class GenVector_exception). Now, the GenVector_exception class is created only when the throwing of exception is enabled. This avoids the allocation of an un-needed std::string. This problem was observed in CMS when converting from ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:3324,variab,variables,3324,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,1,['variab'],['variables']
Modifiability,"ction inside of ELF object files. However, LTO with bitcode files; is still supported. .. _`gold linker`: http://sourceware.org/binutils; .. _`GCC LTO`: http://gcc.gnu.org/wiki/LinkTimeOptimization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above confi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:1784,plugin,plugin,1784,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"ction(no-op-function),no-op-module' /tmp/a.ll -S. A more complete example, and ``-debug-pass-manager`` to show the execution; order:. .. code-block:: shell. $ opt -passes='no-op-module,cgscc(no-op-cgscc,function(no-op-function,loop(no-op-loop))),function(no-op-function,loop(no-op-loop))' /tmp/a.ll -S -debug-pass-manager. Improper nesting can lead to error messages such as. .. code-block:: shell. $ opt -passes='no-op-function,no-op-module' /tmp/a.ll -S; opt: unknown function pass 'no-op-module'. The nesting is: module (-> cgscc) -> function -> loop, where the CGSCC nesting is optional. There are a couple of special cases for easier typing:. * If the first pass is not a module pass, a pass manager of the first pass is; implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-function' /tmp/a.ll -S; $ opt -passes='function(no-op-function,no-op-function)' /tmp/a.ll -S. * If there is an adaptor for a pass that lets it fit in the previous pass; manager, that is implicitly created. * For example, the following are equivalent. .. code-block:: shell. $ opt -passes='no-op-function,no-op-loop' /tmp/a.ll -S; $ opt -passes='no-op-function,loop(no-op-loop)' /tmp/a.ll -S. For a list of available passes and analyses, including the IR unit (module,; CGSCC, function, loop) they operate on, run. .. code-block:: shell. $ opt --print-passes. or take a look at ``PassRegistry.def``. To make sure an analysis named ``foo`` is available before a pass, add; ``require<foo>`` to the pass pipeline. This adds a pass that simply requests; that the analysis is run. This pass is also subject to proper nesting. For; example, to make sure some function analysis is already computed for all; functions before a module pass:. .. code-block:: shell. $ opt -passes='function(require<my-function-analysis>),my-module-pass' /tmp/a.ll -S. Status of the New and Legacy Pass Managers; ==========================================. LLVM currently contai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:19654,adapt,adaptor,19654,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['adapt'],['adaptor']
Modifiability,"ctionX(); // ! TH1D, not TH1F; TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F; ```. ### Constant or Variable Bin Width. The histogram classes provide a variety of ways to construct a; histogram, but the most common way is to provide the name and title of; histogram and for each dimension: the number of bins, the minimum x; (lower edge of the first bin) and the maximum x (upper edge of the; last bin). ``` {.cpp}; TH2* h = new TH2D(; /* name */ ""h2"",; /* title */ ""Hist with constant bin width"",; /* X-dimension */ 100, 0.0, 4.0,; /* Y-dimension */ 200, -3.0, 1.5);; ```. When employing this constructor, you will create a histogram with; constant (fixed) bin width on each axis. For the example above, the; interval `[0.0, 4.0]` is divided into 100 bins of the same width `w`; `X = 4.0 - 0.0 100 = 0.04` for the X axis (dimension). Likewise, for; the Y axis (dimension), we have bins of equal width `w`; `Y = 1.5 - (-3.0) 200 = 0.0225`. If you want to create histograms with variable bin widths, ROOT; provides another constructor suited for this purpose. Instead of; passing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:4357,variab,variable,4357,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"ctions, present in; ""/llvm/unittests/tools/llvm-cfi-verify"".; - Integration tests, present in ""/llvm/tools/clang/test/LLVMCFIVerify"". These; integration tests are part of clang as part of a continuous integration; framework, ensuring updates to the compiler that reduce CFI coverage on; indirect control flow instructions are identified. Background; ==========. This tool will continuously validate that CFI directives are properly; implemented around all indirect control flows by analysing the output machine; code. The analysis of machine code is important as it ensures that any bugs; present in linker or compiler do not subvert CFI protections in the final; shipped binary. Unprotected indirect control flow instructions will be flagged for manual; review. These unexpected control flows may simply have not been accounted for in; the compiler implementation of CFI (e.g. indirect jumps to facilitate switch; statements may not be fully protected). It may be possible in the future to extend this tool to flag unnecessary CFI; directives (e.g. CFI directives around a static call to a non-polymorphic base; type). This type of directive has no security implications, but may present; performance impacts. Design Ideas; ============. This tool will disassemble binaries and DSO's from their machine code format and; analyse the disassembled machine code. The tool will inspect virtual calls and; indirect function calls. This tool will also inspect indirect jumps, as inlined; functions and jump tables should also be subject to CFI protections. Non-virtual; calls (``-fsanitize=cfi-nvcall``) and cast checks (``-fsanitize=cfi-*cast*``); are not implemented due to a lack of information provided by the bytecode. The tool would operate by searching for indirect control flow instructions in; the disassembly. A control flow graph would be generated from a small buffer of; the instructions surrounding the 'target' control flow instruction. If the; target instruction is branched-to, the fallthro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst:1975,extend,extend,1975,interpreter/llvm-project/llvm/docs/CFIVerify.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst,1,['extend'],['extend']
Modifiability,"ctly by calling its constructor, you can also pass the global observables in a command argument instead of calling `setGlobalObservables()` later:; ```C++; RooDataSet data{""dataset"", ""dataset"", x, RooFit::GlobalObservables(g1, g2)};; ```. To access the set of global observables stored in a `RooAbsData`, call `RooAbsData::getGlobalObservables()`.; It returns a `nullptr` if no global observable snapshots are stored in the dataset. For more information of global observables and how to attach them to the toy datasets, please take a look at the new; [rf613_global_observables.C](https://root.cern/doc/v626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:29874,extend,extended,29874,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['extend'],['extended']
Modifiability,"cts need retain. Overview; ========. A new derived type is introduced to C and, by extension, Objective-C,; C++, and Objective-C++. The Block Type; ==============. Like function types, the :block-term:`Block type` is a pair consisting; of a result value type and a list of parameter types very similar to a; function type. Blocks are intended to be used much like functions with; the key distinction being that in addition to executable code they; also contain various variable bindings to automatic (stack) or managed; (heap) memory. The abstract declarator,. .. code-block:: c. int (^)(char, float). describes a reference to a Block that, when invoked, takes two; parameters, the first of type char and the second of type float, and; returns a value of type int. The Block referenced is of opaque data; that may reside in automatic (stack) memory, global memory, or heap; memory. Block Variable Declarations; ===========================. A :block-term:`variable with Block type` is declared using function; pointer style notation substituting ``^`` for ``*``. The following are; valid Block variable declarations:. .. code-block:: c. void (^blockReturningVoidWithVoidArgument)(void);; int (^blockReturningIntWithIntAndCharArguments)(int, char);; void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int);. Variadic ``...`` arguments are supported. [variadic.c] A Block that; takes no arguments must specify void in the argument list [voidarg.c].; An empty parameter list does not represent, as K&R provide, an; unspecified argument list. Note: both gcc and clang support K&R style; as a convenience. A Block reference may be cast to a pointer of arbitrary type and vice; versa. [cast.c] A Block reference may not be dereferenced via the; pointer dereference operator ``*``, and thus a Block's size may not be; computed at compile time. [sizeof.c]. Block Literal Expressions; =========================. A :block-term:`Block literal expression` produces a reference to a; Block. It is introduced ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:1416,variab,variable,1416,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"cts that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being hosted as part of the LLVM umbrella; project.; A specification: The specification must be sufficient to understand the; design of the feature as well as interpret the meaning of specific examples.; The specification should be detailed enough that another compiler vendor; could implement the feature.; Representation within the appropriate governing organization: For; extensions to a language governed by a standards committee (C, C++, OpenCL),; the extension itself must have an active proposal and proponent within that; committee and have a reasonable chance of acceptance. Clang should drive the; standard, not diverge from it. This criterion does not apply to all; extensions, since some extensions fall outside of the realm of the standards; bodies.; A long-term support plan: increasingly large or complex extensions to; Clang need matching commitments to supporting them over time, including; improving their implementation and specification as Clang evolves. The; capacity of the contributor to make that commitment is as important as the; commitment itself.; A high-quality implementation: The implementation must fit well into; Clang's architecture, follow LLVM's coding conventions, and meet Clang's; quality standards, including diagnostics and complete AST; representations. This is particularly important for language extensions,; because users will learn how those extensions work through the behavior of the; compiler.; A test suite: Extensive testing is crucial to ensure that the language; extension is not broken by ongoing maintenance in Clang. The test suite; should be complete enough that another compiler vendor could conceivably; validate their implementation of the feature against it. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:3967,evolve,evolves,3967,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['evolve'],['evolves']
Modifiability,"cts to extract or convert the underlying; objects or data to something that matches what C++ expects; overload; resolution based on the unboxed arguments; offset calculations; and finally; the actual dispatch.; As a practical matter, overload resolution is the most costly part, followed; by the unboxing and conversion.; Best performance is achieved by specialization of the paths through the; run-time: recognize early the case at hand and select an optimized path.; For that reason, `PyPy`_ is so fast: JIT-ed traces operate on unboxed objects; and resolved overloads are baked into the trace, incurring no further cost.; Similarly, this is why pybind11 is so slow: its code generation is the C++; compiler's template engine, so complex path selection and specialization is; very hard to do in a performance-portable way. In cppyy, a great deal of attention has gone into built-in specialization; paths, which drives its performance.; For example, basic inheritance sequentially lines up classes, whereas; multiple (virtual) inheritance usually requires thunks.; Thus, when calling base class methods on a derived instance, the latter; requires offset calculations that depend on that instance, whereas the former; has fixed offsets fully determined by the class definitions themselves.; By labeling classes appropriately, single inheritance classes (by far the; most common case) do not incur the overhead in PyPy's JIT-ed traces that is; otherwise unavoidable for multiple virtual inheritance.; As another example, consider that the C++ standard does not allow modifying; a ``std::vector`` while looping over it, whereas Python has no such; restriction, complicating loops.; Thus, cppyy has specialized ``std::vector`` iteration for both PyPy and; CPython, easily outperforming looping over an equivalent numpy array. In CPython, the performance of `non-overloaded` function calls depends; greatly on the Python interpreter's internal specializations; and Python3; has many specializations speci",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:2808,inherit,inheritance,2808,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,2,['inherit'],['inheritance']
Modifiability,"cts).; - Introduced support for type safe range-for-loop for ROOT collection. The typical use is:. ```; for(auto bcl : TRangeDynCast<TBaseClass>( * cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; for(auto bcl : TRangeDynCast<TBaseClass>( cl->GetListOfBases() )) {; if (!bcl) continue;; ... use bcl as a TBaseClass*; }; ```; - ClassDefInline has been enhanced even for some compiled class (without a dictionary). ClassDefInline can still not be used for class template instance using Double32_t or Float16_t as a template parameter or for class or class template that do not have a public default constructor.; - ROOT's backport of `std::string_view` has been updated to follow what's available in C++17, notably its `to_string` member function has been removed. ### Thread safety. Resolved the race conditions inherent to the use of the RecursiveRemove mechanism. - Introduced ```ROOT::TReentrantRWLock```, an implementation of a reentrant read-write lock with a configurable internal mutex/lock and a condition variable to synchronize readers and writers when necessary. The implementation allows a single reader to take the write lock without releasing the reader lock. It also allows the writer to take a read lock. In other word, the lock is re-entrant for both reading and writing. The implementation tries to make faster the scenario when readers come and go but there is no writer. In that case, readers will not pay the price of taking the internal lock.; Moreover, this RW lock tries to be fair with writers, giving them the possibility to claim the lock and wait for only the remaining readers, thus preventing starvation. - Switched the ROOT global to be a ```ROOT::TReentrantRWLock``` and renamed it ROOT::gCoreMutex. The old name ```gROOTMutex``` and ```gInterpreterMutex``` are deprecated and may be removed in future releases.; - Added ```TReadLockGuard```,```TWriteLockGuard```, ```R__READ_LOCKGUARD``` and```R__WRITE_LOCKGUARD``` to take advantage of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:4483,config,configurable,4483,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,2,"['config', 'variab']","['configurable', 'variable']"
Modifiability,"ctually use the LLVM; target-independent code generator, you must perform the steps described in the; :doc:`LLVM Target-Independent Code Generator <CodeGenerator>` document. First, you should create a subdirectory under ``lib/Target`` to hold all the; files related to your target. If your target is called ""Dummy"", create the; directory ``lib/Target/Dummy``. In this new directory, create a ``CMakeLists.txt``. It is easiest to copy a; ``CMakeLists.txt`` of another target and modify it. It should at least contain; the ``LLVM_TARGET_DEFINITIONS`` variable. The library can be named ``LLVMDummy``; (for example, see the MIPS target). Alternatively, you can split the library; into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``, the latter of which; should be implemented in a subdirectory below ``lib/Target/Dummy`` (for example,; see the PowerPC target). Note that these two naming schemes are hardcoded into ``llvm-config``. Using; any other naming scheme will confuse ``llvm-config`` and produce a lot of; (seemingly unrelated) linker errors when linking ``llc``. To make your target actually do something, you need to implement a subclass of; ``TargetMachine``. This implementation should typically be in the file; ``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target``; directory will be built and should work. To use LLVM's target independent code; generator, you should do what all current machine backends do: create a; subclass of ``LLVMTargetMachine``. (To create a target from scratch, create a; subclass of ``TargetMachine``.). To get LLVM to actually build and link your target, you need to run ``cmake``; with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Dummy``. This will build your; target without needing to add it to the list of all the targets. Once your target is stable, you can add it to the ``LLVM_ALL_TARGETS`` variable; located in the main ``CMakeLists.txt``. Target Machine; ==============. ``LLVMTargetMachine`` is designed as a base class for targets imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:7008,config,config,7008,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['config'],['config']
Modifiability,"cument describes the design of Clang's refactoring engine and provides; a couple of examples that show how various primitives in the refactoring API; can be used to implement different refactoring actions. The :doc:`LibTooling`; library provides several other APIs that are used when developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1039,refactor,refactoring,1039,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],['refactoring']
Modifiability,"cument for KDENS "".; . New TSVDUnfold class; TSVDUnfold implements the singular value decomposition based; unfolding method proposed in NIM A372, 469 (1996); [hep-ph/9509307]. The regularisation is implemented as; a discrete minimum curvature condition. This minimal implementation of; TSVDUnfold provides unfolding of one-dimensional histograms with; equal number of, not necessarily equidistant, bins in the measured and; unfolded distributions. In addition to the unfolding itself,; TSVDUnfold provides. Propagation of covariance matrices from the measured to the unfolded; spectrum via GetUnfoldCovMatrix; Evaluation of covariance matrix due to finite statistics in detector; response via GetAdetCovMatrix; Access to distribution of |d_i| useful for determining the proper; regularisation via GetD; Access to singular values via GetSV. A toy example for the use of TSVDUnfold is included in the math; tutorials (TSVDUnfoldExample.C). New TH2Poly class; TH2Poly is a 2D Histogram class, inheriting from TH2,; allowing to define polygonal bins of arbitary shape. Each bin, in a TH2Poly histogram, is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices, stored; as TGraphs and TMultiGraphs, and the content of the polygonal; bin. Bins are defined using one of the AddBin() methods. The bins definition; should be done before filling. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();. Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);. h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can be found in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html:12530,inherit,inheriting,12530,hist/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v528/index.html,1,['inherit'],['inheriting']
Modifiability,"cutable relative to itself for static analysis. One can override this; behavior with this option by using the 'clang' packaged with Xcode (on OS X) or; from the PATH. ; A complete list of options can be obtained by running scan-build; with no arguments.; Output of scan-build. The output of scan-build is a set of HTML files, each one which represents a; separate bug report. A single index.html file is generated for; surveying all of the bugs. You can then just open index.html in a web; browser to view the bug reports. Where the HTML files are generated is specified with a -o option to; scan-build. If -o isn't specified, a directory in /tmp; is created to store the files (scan-build will print a message telling; you where they are). If you want to view the reports immediately after the build; completes, pass -V to scan-build. Recommended Usage Guidelines; This section describes a few recommendations with running the analyzer.; ALWAYS analyze a project in its ""debug"" configuration; Most projects can be built in a ""debug"" mode that enables assertions.; Assertions are picked up by the static analyzer to prune infeasible paths, which; in some cases can greatly reduce the number of false positives (bogus error; reports) emitted by the tool.; Another option is to use --force-analyze-debug-code flag of; scan-build tool which would enable assertions automatically.; Use verbose output when debugging scan-build; scan-build takes a -v option to emit verbose output about; what it's doing; two -v options emit more information. Redirecting the; output of scan-build to a text file (make sure to redirect standard; error) is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:6162,config,configuration,6162,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configuration']
Modifiability,"cutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr()))). Furthermore, we can restrict our matcher to only match if the; incremented variable is an integer:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(varDecl(hasType(isInteger()))))))). And the last step will be to attach an identifier to this variable, so; that we can retrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:12002,variab,variables,12002,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"d *remotely* with your user ID *on the remote node*. > It is worth noting that the remote environment scripts will be sent to; > the remote node using a secure connection (SSH), thus there is no; > concern in placing sensitive user data there. Installing the Virtual Analysis Facility client; -----------------------------------------------. ### Download the client from Git. The Virtual Analysis Facility client is available on; [GitHub](https://github.com/dberzano/virtual-analysis-facility):. ``` {.bash}; git clone git://github.com/dberzano/virtual-analysis-facility.git /dest/dir; ```. The client will be found in `/dest/dir/client/bin/vaf-enter`: it is; convenient to add it to the `$PATH` so that the users might simply start; it by typing `vaf-enter`. ### Install the experiment's configuration files system-wide. A system administrator might find convenient to install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:7565,config,config-samples,7565,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['config-samples']
Modifiability,"d 500 files. Getting Started; ---------------. Patterns in Transformer are expressed with :doc:`clang's AST matchers <LibASTMatchers>`.; Matchers are a language of combinators for describing portions of a clang; Abstract Syntax Tree (AST). Since clang's AST includes complete type information; (within the limits of single `Translation Unit (TU)`_,; these patterns can even encode rich constraints on the type properties of AST; nodes. .. _`Translation Unit (TU)`: https://en.wikipedia.org/wiki/Translation_unit_\(programming\). We assume a familiarity with the clang AST and the corresponding AST matchers; for the purpose of this tutorial. Users who are unfamiliar with either are; encouraged to start with the recommended references in `Related Reading`_. Example: style-checking names; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Assume you have a style-guide rule which forbids functions from being named; ""MkX"" and you want to write a check that catches any violations of this rule. We; can express this a Transformer rewrite rule:. .. code-block:: c++. makeRule(functionDecl(hasName(""MkX"").bind(""fun""),; 	 noopEdit(node(""fun"")),; 	 cat(""The name ``MkX`` is not allowed for functions; please rename""));. ``makeRule`` is our go-to function for generating rewrite rules. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:3220,rewrite,rewrite,3220,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"d Fortran version,; with almost equivalent numerical accuracy and computational performances.; Furthermore, it contains new functionality, like the possibility to set single side parameter limits or; the FUMILI algorithm, which is an optimized method for least square and log likelihood minimizations.; The package has been originally developed by M. Winkler and F. James.; More information on the new C++ version can be found on the; MINUIT Web Site. Minuit2, originally developed in the SEAL project, is now distributed within %ROOT.; The API has been then changed in this new version to follow the %ROOT coding convention (function names starting with capital letters) and the classes have been moved inside the namespace ROOT::Minuit2.; In addition, the %ROOT distribution contains classes needed to integrate Minuit2 in the %ROOT framework. A new class has been introduced, ROOT::Minuit2::Minuit2Minimizer, which implements the interface; ROOT::Math::Minimizer. Within %ROOT, it can be instantiates also using the %ROOT plug-in manager. This class provides a convenient entry point for using Minuit2. An example of using this interface is; the %ROOT tutorial tutorials/fit/NumericalMinimization.C or; the Minuit2 test program testMinimize.cxx. A standalone version of Minuit2 (independent of %ROOT) can be downloaded from here. It does not contain the %ROOT interface and it is therefore totally independent of external packages and can be simply build using the configure script and then make. Example tests are provided in the directory test/MnSim and test/MnTutorial and they can be built with the make check command. The Minuit2 User Guide provides all the information needed for using directly (without add-on packages like %ROOT) Minuit2. References. F. James, Fortran MINUIT Reference Manual (html);; F. James and M. Winkler, C++ MINUIT User's Guide (html and; pdf);; F. James, Minuit Tutorial on Function Minimization (pdf);; F. James, The Interpretation of Errors in Minuit (pdf);. */; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html:1292,plug-in,plug-in,1292,math/minuit2/doc/Minuit2.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/doc/Minuit2.html,2,"['config', 'plug-in']","['configure', 'plug-in']"
Modifiability,"d an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5964,config,configuration,5964,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,"d and interpreted; classes in an interactive ROOT session without having the class derive; from **`TQObject`**. Every signal method declaration is followed by a; comment `""*SIGNAL*"".` Only instances of a class that defines a signal or; instances of its subclasses can emit the signal. The ROOT implementation; of a popular example presenting signals and slots is the next. Let's; have a minimal class declaration:. ``` {.cpp}; class MyClass {; private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; ```. It will become the following as interpreted:. ``` {.cpp}; class MyClass {; RQ_OBJECT(""MyClass""); private:; Int_t fValue;; public:; MyClass() { fValue=0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); // *SIGNAL*; };; ```. Both class declarations have the same data member and public methods to; access the value. By placing the `RQ_OBJECT(""MyClass"")` macro inside the; `MyClass` body (`MyClass` is not inherited from **`TQObject`**) we allow; this class to use the signal/slot communication. Any instance of this; class can tell the outside world that the state of its data member has; changed by emitting a signal `SetValue(Int_t).` A possible; implementation of `MyClass::SetValue()` can be:. ``` {.cpp}; void MyClass::SetValue(Int_t v) {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"",v);; }; }; ```. The line `Emit(""SetValue(Int_t)"",v)` activates the signal; `SetValue(Int_t)` with argument v. You can use any of the methods; **`TQObject::Emit(""full_method_name"",arguments)`** to emit a signal. We; create two instances of `MyClass` and connect them together:. ``` {.cpp}; MyClass *objA = new MyClass();; MyClass *objB = new MyClass();; objA->Connect(""SetValue(Int_t)"",""MyClass"",objB,""SetValue(Int_t)"");; objB->SetValue(11);; objA->SetValue(79);; objB->GetValue(); // the value is 79; ```. By calling the method `objA->Connect()`, `objA` connects its signal; ""`SetValue(Int_t)`"" to the ""`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:44174,inherit,inherited,44174,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherited']
Modifiability,"d applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7487,config,configuration,7487,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"d are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9864,variab,variables,9864,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"d as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk1' instead of 'host' only as; it was so far). These feature can be enabled by defining the rootrc; variable 'Packetizer.Partitions', e.g.;            Packetizer.Partitions  /disk1,/disk2,/disk3; Add to the output list the parameters used by the active packetizer. . In the PrintProgress function used to display a text progress; bar, show also the average reading rate in [k,M,G}bytes/s in addition; to the event processing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6918,extend,extended,6918,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['extend'],['extended']
Modifiability,"d be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is little growth of the global; state, the state is contained within each object, rather than; scattered through the program in the form of global variables. - Objects may come and go, but the basic structure of the program; remains relatively static, increases opportunity for reuse of; design. ## Installing ROOT; \index{install ROOT}. To install ROOT you have the choice to; download the binaries or the source. The source is quicker to transfer; since it is only \~22 MB, but you will need to compile and link it. The; binaries compiled with no debug information range from \~35 MB to \~45; MB depending on the target platform. The installation and building of ROOT is described in Appendix A:; Install and Build ROOT. You can download the binaries, or the sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:8201,inherit,inheritance,8201,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,"['extend', 'inherit']","['extend', 'inheritance']"
Modifiability,"d be treated as ``__null_terminated``.; The same applies to other annotations.; In system headers, the default pointer attribute for ABI-visible pointers is set; to ``__unsafe_indexable`` by default. The ``__ptrcheck_abi_assume_*ATTR*()`` macros are defined as pragmas in the; toolchain header (See `Portability with toolchains that do not support the; extension`_ for more details about the toolchain header):. .. code-block:: C. #define __ptrcheck_abi_assume_single() \; _Pragma(""clang abi_ptr_attr set(single)""). #define __ptrcheck_abi_assume_indexable() \; _Pragma(""clang abi_ptr_attr set(indexable)""). #define __ptrcheck_abi_assume_bidi_indexable() \; _Pragma(""clang abi_ptr_attr set(bidi_indexable)""). #define __ptrcheck_abi_assume_unsafe_indexable() \; _Pragma(""clang abi_ptr_attr set(unsafe_indexable)""). ABI implications of default bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although simply modifying types of a local variable doesn't normally impact the; ABI, taking the address of such a modified type could create a pointer type that; has an ABI mismatch. Looking at the following example, ``int *local`` is; implicitly ``int *__bidi_indexable`` and thus the type of ``&local`` is a; pointer to ``int *__bidi_indexable``. On the other hand, in ``void foo(int; **)``, the parameter type is a pointer to ``int *__single`` (i.e., ``void; foo(int *__single *__single)``) (or a pointer to ``int *__unsafe_indexable`` if; it's from a system header). The compiler reports an error for casts between; pointers whose elements have incompatible pointer attributes. This way,; ``-fbounds-safety`` prevents pointers that are implicitly ``__bidi_indexable``; from silently escaping thereby breaking the ABI. .. code-block:: c. void foo(int **);. void bar(void) {; int *local = 0;; // error: passing 'int *__bidi_indexable*__bidi_indexable' to parameter of; // incompatible nested pointer type 'int *__single*__single'; foo(&local);; }. A local variable may still be exposed to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:23503,variab,variable,23503,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variable']
Modifiability,"d between functions and we can test for it having the high bits set to; detect when it has been marked due to misspeculation. The callsite instruction; sequence looks like (assuming a misspeculated state value of `-1`):; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; ```. This first puts the predicate state into the high bits of `%rsp` before calling; the function and then reads it back out of high bits of `%rsp` afterward. When; correctly executing (speculatively or not), these are all no-ops. When; misspeculating, the stack pointer will end up negative. We arrange for it to; remain a canonical address, but otherwise leave the low bits alone to allow; stack adjustments to proceed normally without disrupting this. Within the; called function, we can extract this predicate state and then reset it on; return:; ```; other_function:; # prolog; callq other_function; movq %rsp, %rax; sarq 63, %rax # Sign extend the high bit to all bits.; # ... .LBB0_N:; cmovneq %r8, %rax # Conditionally update predicate state.; shlq $47, %rax; orq %rax, %rsp; retq; ```. This approach is effective when all code is mitigated in this fashion, and can; even survive very limited reaches into unmitigated code (the state will; round-trip in and back out of an unmitigated function, it just won't be; updated). But it does have some limitations. There is a cost to merging the; state into `%rsp` and it doesn't insulate mitigated code from misspeculation in; an unmitigated caller. There is also an advantage to using this form of interprocedural mitigation: by; forming these invalid stack pointer addresses we can prevent speculative; returns from successfully reading speculatively written values to the actual; stack. This works first by forming a data-dependency between computing the; address of the return address on the stack and our pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:39844,extend,extend,39844,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['extend'],['extend']
Modifiability,"d by the target. The only constants that target extension types may have are ``zeroinitializer``,; ``undef``, and ``poison``. Other possible values for target extension types may; arise from target-specific intrinsics and functions. These types cannot be converted to other types. As such, it is not legal to use; them in :ref:`bitcast <i_bitcast>` instructions (as a source or target type),; nor is it legal to use them in :ref:`ptrtoint <i_ptrtoint>` or; :ref:`inttoptr <i_inttoptr>` instructions. Similarly, they are not legal to use; in an :ref:`icmp <i_icmp>` instruction. Target extension types have a name and optional type or integer parameters. The; meanings of name and parameters are defined by the target. When being defined in; LLVM IR, all of the type parameters must precede all of the integer parameters. Specific target extension types are registered with LLVM as having specific; properties. These properties can be used to restrict the type from appearing in; certain contexts, such as being the type of a global variable or having a; ``zeroinitializer`` constant be valid. A complete list of type properties may be; found in the documentation for ``llvm::TargetExtType::Property`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1TargetExtType.html>`_). :Syntax:. .. code-block:: llvm. target(""label""); target(""label"", void); target(""label"", void, i32); target(""label"", 0, 1, 2); target(""label"", void, i32, 0, 1, 2). .. _t_vector:. Vector Type; """""""""""""""""""""". :Overview:. A vector type is a simple derived type that represents a vector of; elements. Vector types are used when multiple primitive data are; operated in parallel using a single instruction (SIMD). A vector type; requires a size (number of elements), an underlying primitive data type,; and a scalable property to represent vectors where the exact hardware; vector length is unknown at compile time. Vector types are considered; :ref:`first class <t_firstclass>`. :Memory Layout:. In general vector elements are laid o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:173854,variab,variable,173854,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"d can be obtained by an automatic conversion of the TFitResultPtr to an integer. If the fit option *`S`* is instead used, `TFitResultPtr` contains the `TFitResult` and behaves as a smart; pointer to it. This is an example:. ``` {.cpp}; int fitStatus = hist->Fit(myFunction); // TFitResultPtr contains only the fit status. TFitResultPtr r = hist->Fit(myFunction,""S""); // TFitResultPtr contains the TFitResult; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file; ```. ## The Minimization packages. As explained before various minimization packages can be used when fitting in ROOT.; We have seen before how to configure the `Fitter` class to use different minimization packages; and different minimization options.; When using the `Fit` method the minimization package (and its options) can be selected using the; static methods of the `ROOT::Math::MinimizerOptions` class.; For example to select `Minuit2` instead of `Minuit` for fitting an histogram do:. ``` {.cpp}; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; // fit the histogram histo with the gaussian pre-defined function; histo->Fit(""gaus"");; ```. In the following we will give some brief description of the minimization packages.; The packages all implement the `ROOT::Math::Minimizer` interface which can be use for; finding the minimum of a multi-dimensional function.; The interface is documented in the Mathematical Library Chapter. In addition packages like Minuit or Minuit2 provide their own interfaces. ## MINUIT (Old TMInuit Version). This package was originally written in FORTRAN by Fred James and part; of `PACKLIB` (patch D506). It has been converted to a C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:52077,config,configure,52077,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configure']
Modifiability,"d code into the C++ function that needs debugging,; even when such information is available for that C++ function. To enable debugging information in JITed code, set the ``EXTRA_CLING_ARGS``; envar to ``-g`` (and any further compiler options you need, e.g. add ``-O2``; to debug optimized code). On a crash in C++, the backend will attempt to provide a stack trace.; This works quite well on Linux (through ``gdb``) and decently on MacOS; (through ``unwind``), but is currently unreliable on MS Windows.; To prevent printing of this trace, which can be slow to produce, set the; envar ``CPPYY_CRASH_QUIET`` to '1'. It is even more useful to obtain a traceback through the Python code that led; up to the problem in C++.; Many modern debuggers allow mixed-mode C++/Python debugging (for example; `gdb`_ and `MSVC`_), but cppyy can also turn abortive C++ signals (such as a; segmentation violation) into Python exceptions, yielding a normal traceback.; This is particularly useful when working with cross-inheritance and other; cross-language callbacks. To enable the signals to exceptions conversion, import the lowlevel module; ``cppyy.ll`` and use:. .. code-block:: python. import cppyy.ll; cppyy.ll.set_signals_as_exception(True). Call ``set_signals_as_exception(False)`` to disable the conversion again.; It is recommended to only have the conversion enabled around the problematic; code, as it comes with a performance penalty.; If the problem can be localized to a specific function, you can use its; ``__sig2exc__`` flag to only have the conversion active in that function.; Finally, for convenient scoping, you can also use:. .. code-block:: python. with cppyy.ll.signals_as_exception():; # crashing code goes here. The translation of signals to exceptions is as follows (all of the exceptions; are subclasses of ``cppyy.ll.FatalError``):. ======================================== ========================================; C++ signal Python exception; ======================================== ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst:1428,inherit,inheritance,1428,bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/debugging.rst,1,['inherit'],['inheritance']
Modifiability,"d columns in the clusters that were already (partially) filled before the model was extended. Storage Backends; ----------------. Support for storage backends is implemented through derived classes of `RPageSink` and `RPageSource`.; The `RPage{Sink,Source}File` class provides a storage backend for RNTuple data in ROOT files, local or remote.; The `RPage{Sink,Source}Daos` class provides a storage backend for RNTuple data in the DAOS object store. Every new storage backend needs to define; 1) The RNTuple embedding: how are RNTuple data blobs stored, e.g. in keys of ROOT files, or in objects of object stores; 2) The RNTuple anchor: the initial link to the location of the header and footer (cf. format specification); 3) A locator format: how are byte ranges addressed (e.g., through an offset in a file or an object ID). That means that new backends are likely to have implications on the RNTuple format specification. The page sources and sinks are ROOT internal classes.; They are not meant to be extended by users. Multi-Threading; ---------------. The following options exist in RNTuple for multithreaded data processing. ### Implicit Multi-Threading; When `ROOT::EnableImplicitMT()` is used, RNTuple uses ROOT's task arena to compress and decompress pages.; That requires writes to be buffered and reads uses the cluster pool resp.; The RNTuple data source for RDataFrame lets RDataFrame full control of the thread pool.; That means that RDataFrame uses a separate data source for every thread, each of the data sources runs in sequential mode. ### Concurrent Readers; Multiple readers can read the same RNTuple concurrently as long as access to every individual reader is sequential. ### Parallel REntry Preparation; Multiple `REntry` object can be concurrently prepared by multiple threads.; I.e., construction and binding of the objects can happen in parallel.; The actual reading and writing of entries (`RNTupleReader::LoadEntry()`, `RNTupleWriter::Fill()`) needs to be protected by a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:24351,extend,extended,24351,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['extend'],['extended']
Modifiability,d constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and definitions of variable templates; Unknown. 1730; drafting; Can a variable template have an unnamed type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown.,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:117163,variab,variable,117163,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"d directory, all tests within it will be; reported as unsupported. Used by: *ShTest*. **parent** The parent configuration, this is the config object for the directory; containing the test suite, or None. **root** The root configuration. This is the top-most :program:`lit` configuration in; the project. **pipefail** Normally a test using a shell pipe fails if any of the commands; on the pipe fail. If this is not desired, setting this variable to false; makes the test fail only if the last command in the pipe fails. **available_features** A set of features that can be used in `XFAIL`,; `REQUIRES`, and `UNSUPPORTED` directives. TEST DISCOVERY; ~~~~~~~~~~~~~~. Once test suites are located, :program:`lit` recursively traverses the source; directory (following *test_source_root*) looking for tests. When :program:`lit`; enters a sub-directory, it first checks to see if a nested test suite is; defined in that directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:17765,config,config,17765,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['config'],"['config', 'configuration-files']"
Modifiability,"d doesn't match all the regexes; from ``-fprofile-exclude-list``. .. code-block:: console. $ clang --coverage -fprofile-exclude-files=""^/usr/include/.*$"" \; -fprofile-filter-files=""^/usr/.*$"". In that case ``/usr/foo/oof.h`` is instrumented since it matches the filter regex and; doesn't match the exclude regex, but ``/usr/include/foo.h`` doesn't since it matches; the exclude regex. Controlling Debug Information; -----------------------------. Controlling Size of Debug Information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info kind generated by Clang can be set by one of the flags listed; below. If multiple flags are present, the last one is used. .. option:: -g0. Don't generate any debug info (default). .. option:: -gline-tables-only. Generate line number tables only. This kind of debug info allows to obtain stack traces with function names,; file names and line numbers (by such tools as ``gdb`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:124882,variab,variables,124882,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"d first; according to increasing category number and then alphabetically within; each category. If none of the regular expressions match, INT_MAX is assigned as; category. The main header for a source file automatically gets category 0.; so that it is generally kept at the beginning of the ``#includes``; (https://llvm.org/docs/CodingStandards.html#include-style). However, you; can also assign negative priorities if you have certain headers that; always need to be first. There is a third and optional field ``SortPriority`` which can used while; ``IncludeBlocks = IBS_Regroup`` to define the priority in which; ``#includes`` should be ordered. The value of ``Priority`` defines the; order of ``#include blocks`` and also allows the grouping of ``#includes``; of different priority. ``SortPriority`` is set to the value of; ``Priority`` as default if it is not assigned. Each regular expression can be marked as case sensitive with the field; ``CaseSensitive``, per default it is not. To configure this in the .clang-format file, use:. .. code-block:: yaml. IncludeCategories:; - Regex: '^""(llvm|llvm-c|clang|clang-c)/'; Priority: 2; SortPriority: 2; CaseSensitive: true; - Regex: '^((<|"")(gtest|gmock|isl|json)/)'; Priority: 3; - Regex: '<[[:alnum:].]+>'; Priority: 4; - Regex: '.*'; Priority: 1; SortPriority: 0. .. _IncludeIsMainRegex:. **IncludeIsMainRegex** (``String``) :versionbadge:`clang-format 3.9` :ref:`¶ <IncludeIsMainRegex>`; Specify a regular expression of suffixes that are allowed in the; file-to-main-include mapping. When guessing whether a #include is the ""main"" include (to assign; category 0, see above), use this regex of allowed suffixes to the header; stem. A partial match is done, so that:; - """" means ""arbitrary suffix""; - ""$"" means ""no suffix"". For example, if configured to ""(_test)?$"", then a header a.h would be seen; as the ""main"" include in both a.cc and a_test.cc. .. _IncludeIsMainSourceRegex:. **IncludeIsMainSourceRegex** (``String``) :versionbadge:`clang-form",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:67714,config,configure,67714,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configure']
Modifiability,"d has a license (MLP) compatible with LGPL. ## 3D Graphics Libraries. ### REve; * Introduce lightweight visualization of instanced shapes on the level of 100.000 instances. This is integrated in digit visualization of the type REveBoxSet. List of typed instances are boxes, hexagons, and cones. The digit sets support different types of transformation: positioning, rotation, and scaling in different combinations. With the digit set a palette GUI interface has also been added to enable setting digits threshold and value to color mapping. <figure>; <img src=""reve-boxset-cones.png"" >; <figcaption>REveBoxSet screenshot with cone shape type. The set is using value to color map with overflow and underflow mark. The single REveBoxet object has a secondary selection enabled, where one can set a custom tooltip on mouse hover of an individual instance.</figcaption>; </figure>. * Update version of RenderCore to fix tone mapping of transparent objects. ## PROOF Libraries. By default, PROOF is not configured and built any more. It will be deprecated in the future given that its functionality is now provided by the superior RDataFrame and its distributed version, [DistRDF](https://root.cern/doc/master/classROOT_1_1RDataFrame.html#distrdf). ## PyROOT. PyROOT was rebased on the latest version of the [cppyy library](https://cppyy.readthedocs.io/en/latest/).; This means PyROOT benefits from many upstream improvements and fixes, for example related to the conversion of NumPy arrays to vectors, implicit conversion from nested Python tuples to nested initializer lists, and improved overload resolution. Related to this cppyy upgrade, there are some changes in PyROOT behavior. ### Different representation of `std::string`. Calling `repr()` on a `cppyy.gbl.std.string` object now comes with a ""b"" prefix, i.e. a bytes object is returned instead of a Python string.; This is an intentional change for better unicode support. See: https://github.com/root-project/root/issues/15153#issuecomment-2040",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:18982,config,configured,18982,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['configured']
Modifiability,"d in place of ``@GOTPCREL`` to guarantee that; the assembler emits an ``R_X86_64_GOTPCREL`` relocation instead of a relaxable; ``R_X86_64[_REX]_GOTPCRELX`` relocation. Windows on ARM; --------------. Stack Probe Emission; ^^^^^^^^^^^^^^^^^^^^. The reference implementation (Microsoft Visual Studio 2012) emits stack probes; in the following fashion:. .. code-block:: gas. movw r4, #constant; bl __chkstk; sub.w sp, sp, r4. However, this has the limitation of 32 MiB (±16MiB). In order to accommodate; larger binaries, LLVM supports the use of ``-mcmodel=large`` to allow a 4GiB; range via a slight deviation. It will generate an indirect jump as follows:. .. code-block:: gas. movw r4, #constant; movw r12, :lower16:__chkstk; movt r12, :upper16:__chkstk; blx r12; sub.w sp, sp, r4. Variable Length Arrays; ^^^^^^^^^^^^^^^^^^^^^^. The reference implementation (Microsoft Visual Studio 2012) does not permit the; emission of Variable Length Arrays (VLAs). The Windows ARM Itanium ABI extends the base ABI by adding support for emitting; a dynamic stack allocation. When emitting a variable stack allocation, a call; to ``__chkstk`` is emitted unconditionally to ensure that guard pages are setup; properly. The emission of this stack probe emission is handled similar to the; standard stack probe emission. The MSVC environment does not emit code for VLAs currently. Windows on ARM64; ----------------. Stack Probe Emission; ^^^^^^^^^^^^^^^^^^^^. The reference implementation (Microsoft Visual Studio 2017) emits stack probes; in the following fashion:. .. code-block:: gas. mov x15, #constant; bl __chkstk; sub sp, sp, x15, lsl #4. However, this has the limitation of 256 MiB (±128MiB). In order to accommodate; larger binaries, LLVM supports the use of ``-mcmodel=large`` to allow a 8GiB; (±4GiB) range via a slight deviation. It will generate an indirect jump as; follows:. .. code-block:: gas. mov x15, #constant; adrp x16, __chkstk; add x16, x16, :lo12:__chkstk; blr x16; sub sp, sp, x15, lsl #4. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:22582,extend,extends,22582,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,2,"['extend', 'variab']","['extends', 'variable']"
Modifiability,"d in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:72898,variab,variables,72898,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"d llvm; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l # -l avoids fetching ahead of the git mirror. Commits are performed using `svn commit` or with the sequence `git commit` and; `git svn dcommit`. .. _workflow-multicheckout-nocommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. With the monorepo variant, there are a few options, depending on your; constraints. First, you could just clone the full repository:. git clone https://github.com/llvm/llvm-project.git. At this point you have every sub-project (llvm, clang, lld, lldb, ...), which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checkout; git read-tree -mu HEAD. The data for all sub-projects is still in your `.git` directory, but in your; checkout, you only see `compiler-rt`.; Before you push, you'll need to fetch and rebase (`git pull --rebase`) as; usual. Note that when you fetch you'll likely pull in changes to sub-projects you don't; care about. If you are using sparse checkout, the files from other projects; won't appear on your disk. The only effect is that your commit hash changes. You can check whether the changes in the last fetch are relevant to your commit; by running::. git log origin/main@{1}..origin/main -- libcxx. This command can be hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-sv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:14077,config,config,14077,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability,"d on the intermediate representation; directly, without having to do extra analyses on the side before the; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arguments. Variable; argument functions can access their arguments with the :ref:`variable argument; handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type; except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`. :Examples:. +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (i32)`` | function taking an ``i32``, returning an ``i32`` |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (ptr, ...)`` | A vararg function that takes at least one :ref:`pointer <t_pointer>` argument and returns an integer. This is the signature for ``printf`` in LLVM. |; +---------------------------------+---------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:166385,variab,variable,166385,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"d on the target. As an example the following CMake; invocation can generate build files targeting iOS. This will work on macOS; with the latest Xcode:. .. code-block:: console. % cmake -G ""Ninja"" -DCMAKE_OSX_ARCHITECTURES=""armv7;armv7s;arm64""; -DCMAKE_TOOLCHAIN_FILE=<PATH_TO_LLVM>/cmake/platforms/iOS.cmake; -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_RUNTIME=Off -DLLVM_INCLUDE_TESTS=Off; -DLLVM_INCLUDE_EXAMPLES=Off -DLLVM_ENABLE_BACKTRACES=Off [options]; <PATH_TO_LLVM>. Note: There are some additional flags that need to be passed when building for; iOS due to limitations in the iOS SDK. Check :doc:`HowToCrossCompileLLVM` and `Clang docs on how to cross-compile in general; <https://clang.llvm.org/docs/CrossCompilation.html>`_ for more information; about cross-compiling. The Location of LLVM Object Files; ---------------------------------. The LLVM build system is capable of sharing a single LLVM source tree among; several LLVM builds. Hence, it is possible to build LLVM for several different; platforms or configurations using the same source tree. * Change directory to where the LLVM object files should live:. .. code-block:: console. % cd OBJ_ROOT. * Run ``cmake``:. .. code-block:: console. % cmake -G ""Unix Makefiles"" -DCMAKE_BUILD_TYPE=Release SRC_ROOT. The LLVM build will create a structure underneath *OBJ_ROOT* that matches the; LLVM source tree. At each level where source files are present in the source; tree there will be a corresponding ``CMakeFiles`` directory in the *OBJ_ROOT*.; Underneath that directory there is another directory with a name ending in; ``.dir`` under which you'll find object files for each source. For example:. .. code-block:: console. % cd llvm_build_dir; % find lib/Support/ -name APFloat*; lib/Support/CMakeFiles/LLVMSupport.dir/APFloat.cpp.o. Optional Configuration Items; ----------------------------. If you're running on a Linux system that supports the `binfmt_misc; <http://en.wikipedia.org/wiki/binfmt_misc>`_; module, and you have root acce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:32204,config,configurations,32204,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configurations']
Modifiability,"d on; other options. For example if the user specifies ``-fno-exceptions`` then a; toolchain could select libraries built without exception support, thereby; reducing the size of the resulting binary. Design; ======. Clang supports GCC's ``-print-multi-lib`` and ``-print-multi-directory``; options. These are described in; `GCC Developer Options <https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Developer-Options.html>`_. There are two ways to configure multilib in Clang: hard-coded or via a; configuration file. Hard-coded Multilib; ===================. The available libraries can be hard-coded in Clang. Typically this is done; using the ``MultilibBuilder`` interface in; ``clang/include/clang/Driver/MultilibBuilder.h``.; There are many examples of this in ``lib/Driver/ToolChains/Gnu.cpp``.; The remainder of this document will not focus on this type of multilib. EXPERIMENTAL Multilib via configuration file; ============================================. Some Clang toolchains support loading multilib configuration from a; ``multilib.yaml`` configuration file. A ``multilib.yaml`` configuration file specifies which multilib variants are; available, their relative location, what compilation options were used to build; them, and the criteria by which they are selected. Multilib processing; ===================. Clang goes through the following steps to use multilib from a configuration; file:. #. Normalize command line options. Clang can accept the same; information via different options - for example,; ``--target=arm-none-eabi -march=armv7-m`` and; ``--target=armv7m-none-eabi`` are equivalent.; Clang normalizes the command line before passing them to the multilib system.; To see what flags are emitted for a given set of command line options, use; the ``-print-multi-flags-experimental`` command line option; along with the rest of the options you want to use.; #. Load ``multilib.yaml`` from sysroot.; #. Generate additional flags. ``multilib.yaml`` contains a ``Mappings`` section,;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:2033,config,configuration,2033,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"d or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; user certificate and private key you might be interested in installing; sshcertauth. Please refer to the [installation; guide](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth); for further i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3567,config,configurations,3567,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configurations']
Modifiability,"d other statements. When a class ``C`` inherits from another; class ``D``, the fields of ``D`` are effectively merged into the fields of; ``C``. A given class can only be defined once. A ``class`` statement is; considered to define the class if *any* of the following are true (the; :token:`RecordBody` elements are described below). * The :token:`TemplateArgList` is present, or; * The :token:`ParentClassList` in the :token:`RecordBody` is present, or; * The :token:`Body` in the :token:`RecordBody` is present and not empty. You can declare an empty class by specifying an empty :token:`TemplateArgList`; and an empty :token:`RecordBody`. This can serve as a restricted form of; forward declaration. Note that records derived from a forward-declared; class will inherit no fields from it, because those records are built when; their declarations are parsed, and thus before the class is finally defined. .. _NAME:. Every class has an implicit template argument named ``NAME`` (uppercase),; which is bound to the name of the :token:`Def` or :token:`Defm` inheriting; from the class. If the class is inherited by an anonymous record, the name; is unspecified but globally unique. See `Examples: classes and records`_ for examples. Record Bodies; `````````````. Record bodies appear in both class and record definitions. A record body can; include a parent class list, which specifies the classes from which the; current class or record inherits fields. Such classes are called the; parent classes of the class or record. The record body also; includes the main body of the definition, which contains the specification; of the fields of the class or record. .. productionlist::; RecordBody: `ParentClassList` `Body`; ParentClassList: ["":"" `ParentClassListNE`]; ParentClassListNE: `ClassRef` ("","" `ClassRef`)*; ClassRef: (`ClassID` | `MultiClassID`) [""<"" [`ArgValueList`] "">""]; ArgValueList: `PostionalArgValueList` ["",""] `NamedArgValueList`; PostionalArgValueList: [`Value` {"","" `Value`}*]; NamedArgVa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:23956,inherit,inheriting,23956,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inheriting']
Modifiability,"d returns the return type of; the function, or the FunctionType_ of the actual function. * ``SymbolTable *getSymbolTable()``. Return a pointer to the SymbolTable_ for this ``Function``. .. _GlobalVariable:. The ``GlobalVariable`` class; ----------------------------. ``#include ""llvm/IR/GlobalVariable.h""``. header source: `GlobalVariable.h; <https://llvm.org/doxygen/GlobalVariable_8h_source.html>`_. doxygen info: `GlobalVariable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159008,variab,variables,159008,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variables']
Modifiability,"d running for such; interactive use in the most ordinary way, to print or display an; announcement including an appropriate copyright notice and a; notice that there is no warranty (or else, saying that you provide; a warranty) and that users may redistribute the program under; these conditions, and telling the user how to view a copy of this; License. (Exception: if the Program itself is interactive but; does not normally print such an announcement, your work based on; the Program is not required to print an announcement.). These requirements apply to the modified work as a whole. If; identifiable sections of that work are not derived from the Program,; and can be reasonably considered independent and separate works in; themselves, then this License, and its terms, do not apply to those; sections when you distribute them as separate works. But when you; distribute the same sections as part of a whole which is a work based; on the Program, the distribution of the whole must be on the terms of; this License, whose permissions for other licensees extend to the; entire whole, and thus to each and every part regardless of who wrote it. Thus, it is not the intent of this section to claim rights or contest; your rights to work written entirely by you; rather, the intent is to; exercise the right to control the distribution of derivative or; collective works based on the Program. In addition, mere aggregation of another work not based on the Program; with the Program (or with a work based on the Program) on a volume of; a storage or distribution medium does not bring the other work under; the scope of this License. 3. You may copy and distribute the Program (or a work based on it,; under Section 2) in object code or executable form under the terms of; Sections 1 and 2 above provided that you also do one of the following:. a) Accompany it with the complete corresponding machine-readable; source code, which must be distributed under the terms of Sections; 1 and 2 above on a m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt:6297,extend,extend,6297,misc/rootql/LICENSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/rootql/LICENSE.txt,2,['extend'],['extend']
Modifiability,"d set to ""one""), it is equivalent to the ""real-AdaBoost"" (i.e. using the option !UseYesNoLeaf (which uses the leave node purity rather than a signal or background attribute in the leaf node of each individual tree). Unfortunatly, no reasonable performance has been achieved yet when choosing different cost parameters. c) BDT's with little tree depth (as favoured for good performance) do not *like* it if; there are very clean signal and background separation cuts available, which however ; have NOT been applied yet as preselection. Now there is a possibility to choose the option; ""DoPreselection"" that looks for suitable preselection cuts and applies them prior to ; the Decision Tree training. While that works fine, this clearly gives ""sharp"" peaks at +1 (-1); for the MVA output distribution and therefore the ""smoothing"" of this distribution used to; produce the ROC curve and efficiency estimates are somewhat thwarted.; ; --> It's better if you do these preselection cuts YOURSELF when defining training and test; sample!. d) Removed completely the (hopefully never used) option of treating negative events weights; via: PairNegWeightsInNode. e) Renamed option: IgnoreNegEvents --> IgnoreNegEventsInTraining; and removed the IDENTICAL option NoNegeventsInTraining. 6) SVM; All but the Gauss kernel options have been ""removed"" (guess that was done already some; time ago, probably with the introduction of ""regression"", but was not properly announced; so far. 5) minor bug fixes . a) fix calculation of mean values of the MVA distribution; for signal and background samples, which is used to; decide if a cut on the MVA variable selects signal or; background. Due to the bug it sometimes was swapped. b) equalize the interpolation of the PDF-class that is used to; smooth the Gauss-Transformation, between the .xml weights and; the Standalone class. Now they give the same results even for; large data samples where numerical difference previously ; resulted in substantial differences.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt:3868,variab,variable,3868,documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/ReleaseNotes4.2.0.txt,1,['variab'],['variable']
Modifiability,"d should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates its own set of CMake exports, and the target to; install the CMake exports for a particular distribution for a project is named; ``${project}-${distribution}-cmake-exports``, where ``${project}`` is the name; of the project in lowercase and ``${distribution}`` is the name of the; distribution in lowercase, unless the project is LLVM, in which case the target; is just named ``${distribution}-cmake-exports``. These targets need to be; explicitly included in the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS*; variable in order to be included as part of the distribution. Unlike with the single distribution setup, when building multiple distributions,; any components specified in *LLVM_RUNTIME",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:4800,variab,variable,4800,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"d syntax feedback using e.g. colors.; Class names are highlighted blue when typed, indicating that it is known to ROOT.; Matching parenthesis pairs are highlighted green when typed, or when the cursor is moved to a bracket. This works for () {} and [] brackets.; Any mismatched brackets (those without a matching partner) will be highlighted red when typed or when the cursor is moved to the bracket.; Tab completion output is colored magenta to differentiate between tab completion output and user input.; All of the colors are configurable in the .rootrc file.; They can be specified as #rgb or #rrggbb or color names:; black, red, green, yellow, blue, magenta, cyan or white.; They can be followed by an optional bold (alias light) or underlined.; Rint.ReverseColor allows to quickly toggle between the default ""light on dark"" (yes) instead of ""dark on light"" (no), depending on the terminal background.; An example configuration would be:. Rint.TypeColor: blue; Rint.BracketColor: bold green; Rint.BadBracketColor: underlined red; Rint.TabColor: magenta; Rint.PromptColor: black; Rint.ReverseColor: no. The enhanced prompt is available on all platforms with [n]curses, including Linux, Solaris and MacOS; the bold and underline options are available also for black and white terminals. You can export (or setenv) TERM=xterm-256color for nicer colors.; With editline comes also an improved terminal input handler.; It supports e.g. ^O (Ctrl-o) to replay the history: suppose you have entered. ...; root [3] i = func(); root [4] i += 12; root [5] printf(""i is %d\n"", i). You now want to re-run these three lines.; As always, you press the up cursor three times to see. root [6] i = func(). and now press ^O (Ctrl-o) to run the line, and prepare the next line:. root [6] i = func()^O; root [7] i += 12^O; root [8] printf(""i is %d\n"", i)^O; root [9] . allowing you to re-run that part of the history without having to press the up-arrow again and again.; Currently, editline is disabled on Windows.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html:2661,enhance,enhanced,2661,core/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v526/index.html,1,['enhance'],['enhanced']
Modifiability,"d through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <has",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532500,variab,variable,532500,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"d to indicate the address space; of the called function. If it is not specified, the program address space; from the :ref:`datalayout string<langref_datalayout>` will be used.; #. '``ty``': the type of the call instruction itself which is also the; type of the return value. Functions that return no value are marked; ``void``.; #. '``fnty``': shall be the signature of the function being called. The; argument types must match the types implied by this signature. This; type can be omitted if the function is not varargs.; #. '``fnptrval``': An LLVM value containing a pointer to a function to; be called. In most cases, this is a direct function call, but; other ``callbr``'s are just as possible, calling an arbitrary pointer; to function value.; #. '``function args``': argument list whose types match the function; signature argument types and parameter attributes. All arguments must; be of :ref:`first class <t_firstclass>` type. If the function signature; indicates the function accepts a variable number of arguments, the; extra arguments can be specified.; #. '``fallthrough label``': the label reached when the inline assembly's; execution exits the bottom.; #. '``indirect labels``': the labels reached when a callee transfers control; to a location other than the '``fallthrough label``'. Label constraints; refer to these destinations.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". This instruction is designed to operate as a standard '``call``'; instruction in most regards. The primary difference is that it; establishes an association with additional labels to define where control; flow goes after the call. The output values of a '``callbr``' instruction are available only to; the '``fallthrough``' block, not to any '``indirect``' blocks(s). The only use of this today is to implement the ""goto"" feature of gcc inline; assembly where additional labels can be provided as locations fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:368361,variab,variable,368361,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"d to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135492,variab,variable,135492,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"d to the client. Note that the client may not report the; error to the user. #. Otherwise the source range return value will be used to construct the; ``DeleteSelectedRange`` rule. The rule will then be invoked as the initiation; succeeded (all requirements were evaluated successfully). The same series of steps applies to any refactoring rule. Firstly, the engine; will evaluate all of the requirements. Then it will check if these requirements; are satisfied (they should not produce an error). Then it will construct the; rule and invoke it. The separation of requirements, their evaluation and the invocation of the; refactoring action rule allows the refactoring clients to:. - Disable refactoring action rules whose requirements are not supported. - Gather the set of options and define a command-line / visual interface; that allows users to input these options without ever invoking the; action. Selection Requirements; ^^^^^^^^^^^^^^^^^^^^^^. The refactoring rule requirements that require some form of source selection; are listed below:. - ``SourceRangeSelectionRequirement`` evaluates to a source range when the; action is invoked with some sort of selection. This requirement should be; satisfied when a refactoring is initiated in an editor, even when the user; has not selected anything (the range will contain the cursor's location in; that case). .. FIXME: Future selection requirements. .. FIXME: Maybe mention custom selection requirements?. Other Requirements; ^^^^^^^^^^^^^^^^^^. There are several other requirements types that can be used when creating; a refactoring rule:. - The ``RefactoringOptionsRequirement`` requirement is an abstract class that; should be subclassed by requirements working with options. The more; concrete ``OptionRequirement`` requirement is a simple implementation of the; aforementioned class that returns the value of the specified option when; it's evaluated. The next section talks more about refactoring options and; how they can be used when cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:8704,refactor,refactoring,8704,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"d to; generate a Data Layout and the optimization phases will operate; accordingly and introduce target specificity into the IR with respect to; these default specifications. .. _langref_triple:. Target Triple; -------------. A module may specify a target triple string that describes the target; host. The syntax for the target triple is simply:. .. code-block:: llvm. target triple = ""x86_64-apple-macosx10.7.0"". The *target triple* string consists of a series of identifiers delimited; by the minus sign character ('-'). The canonical forms are:. ::. ARCHITECTURE-VENDOR-OPERATING_SYSTEM; ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT. This information is passed along to the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140314,variab,variable,140314,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,d type?; Not resolved. 1731; NAD; is_trivially_X and definitions of special member functions; Unknown. 1732; C++14; Defining types in conditions and range-based for statements; Unknown. 1733; CD6; Return type and value for operator= with ref-qualifier; Unknown. 1734; CD4; Nontrivial deleted copy functions; No. 1735; drafting; Out-of-range literals in user-defined-literals; Not resolved. 1736; CD4; Inheriting constructor templates in a local class; Clang 3.9. 1737; C++14; Type dependence of call to a member of the current instantiation; Unknown. 1738; C++14; Explicit instantiation/specialization of inheriting constructor templates; Unknown. 1739; C++14; Conversion of floating point to enumeration; Unknown. 1740; C++14; Disambiguation of noexcept; Unknown. 1741; C++14; odr-use of class object in lvalue-to-rvalue conversion; Unknown. 1742; CD5; using-declarations and scoped enumerators; Unknown. 1743; NAD; init-captures in nested lambdas; Unknown. 1744; CD4; Unordered initialization for variable template specializations; Unknown. 1745; NAD; thread_local constexpr variable; Unknown. 1746; C++14; Are volatile scalar types trivially copyable?; Unknown. 1747; C++14; Constant initialization of reference to function; Unknown. 1748; CD4; Placement new with a null pointer; Clang 3.7. 1749; NAD; Confusing definition for constant initializer; Unknown. 1750; CD4; “Argument” vs “parameter”; Unknown. 1751; CD4; Non-trivial operations vs non-trivial initialization; Unknown. 1752; CD4; Right-recursion in mem-initializer-list; Unknown. 1753; CD4; decltype-specifier in nested-name-specifier of destructor; Clang 11. 1754; NAD; Declaration of partial specialization of static data member template; Unknown. 1755; drafting; Out-of-class partial specializations of member templates; Not resolved. 1756; CD4; Direct-list-initialization of a non-class object; Clang 3.7. 1757; CD4; Const integral subobjects; Unknown. 1758; CD4; Explicit conversion in copy/move list initialization; Clang 3.7. 1759,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:118245,variab,variable,118245,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"d unbinned datasets; (representation as a RooDataSet with weights). The setWeightVar() method has been deprecated as it is very difficult to support on-the-fly redefinition; of the event weight variable in the new data store scheme. To declare a data set weighed,; use the WeightVar() modifier of the constructor instead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:10777,config,configurate,10777,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['config'],['configurate']
Modifiability,"d use the; command:. .. code-block:: console. % make -j2. There are several special targets which are useful when working with the LLVM; source code:. ``make clean``. Removes all files generated by the build. This includes object files,; generated C/C++ files, libraries, and executables. ``make install``. Installs LLVM header files, libraries, tools, and documentation in a hierarchy; under ``$PREFIX``, specified with ``CMAKE_INSTALL_PREFIX``, which; defaults to ``/usr/local``. ``make docs-llvm-html``. If configured with ``-DLLVM_ENABLE_SPHINX=On``, this will generate a directory; at ``OBJ_ROOT/docs/html`` which contains the HTML formatted documentation. Cross-Compiling LLVM; --------------------. It is possible to cross-compile LLVM itself. That is, you can create LLVM; executables and libraries to be hosted on a platform different from the platform; where they are built (a Canadian Cross build). To generate build files for; cross-compiling CMake provides a variable ``CMAKE_TOOLCHAIN_FILE`` which can; define compiler flags and variables used during the CMake test operations. The result of such a build is executables that are not runnable on the build; host but can be executed on the target. As an example the following CMake; invocation can generate build files targeting iOS. This will work on macOS; with the latest Xcode:. .. code-block:: console. % cmake -G ""Ninja"" -DCMAKE_OSX_ARCHITECTURES=""armv7;armv7s;arm64""; -DCMAKE_TOOLCHAIN_FILE=<PATH_TO_LLVM>/cmake/platforms/iOS.cmake; -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_RUNTIME=Off -DLLVM_INCLUDE_TESTS=Off; -DLLVM_INCLUDE_EXAMPLES=Off -DLLVM_ENABLE_BACKTRACES=Off [options]; <PATH_TO_LLVM>. Note: There are some additional flags that need to be passed when building for; iOS due to limitations in the iOS SDK. Check :doc:`HowToCrossCompileLLVM` and `Clang docs on how to cross-compile in general; <https://clang.llvm.org/docs/CrossCompilation.html>`_ for more information; about cross-compiling. The Location of LLVM Object Fil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:30967,variab,variable,30967,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"d via rootcint but; were not split if the dictionary was generated via genreflex. Classes with a custom Streamer function and classes with an older, non StreamerInfo; based automatic streamer are also no longer split. To force the splitting of those classes, thus by-passing the custom Streamer,; when storing the object in a TTree and in a collection object, use:. ``` {.cpp}; TClass::GetClass(classname)->SetCanSplit(true);; ```. ### I/O Schema Checksum. The algorithm used to calculate a single number giving an indication on whether; the schema layout has changed (i.e. if two StreamerInfo are equivalent) have; been update to. - Use the normalized name for the types (i.e. two different spelling of the same; name will lead to the same checksum); - Take into account the base classes' checksum in the derived class checksum;; this is necessary to properly support base classes during memberwise streaming. The algorithm that checks whether two StreamerInfo are equal even-though their; checksum is different has been significantly enhanced in particular to also; check the base classes. ### TFileMerger. - Added possibility to merge only a list of objects/folders from the; input files, specified by name, \; or to skip them from merging. This is fully integrated with the new; PartialMerge(flags) schema. \; Usage: \; The names of the objects to be merged or skipped have to be; specified using the interface:. ``` {.cpp}; TFileMerger::AddObjectNames(const char *names); ```. This method can be called several times to add object names. Several; names can be added with one call separated by single blancs (no; blanc at the end). Directory names are accepted, applying the; merging selection to all content. Two new options are being; supported for partial merging:. ``` {.cpp}; TFileMerger::PartialMerge(flags | kOnlyListed); ```. This will merge only the objects in the files having the names in; the specified list. If a folder is specified, it whole content will; be merged. ``` {.cpp}; TFil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md:1252,enhance,enhanced,1252,io/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v600/index.md,1,['enhance'],['enhanced']
Modifiability,"d with a '``;``' and go until the end of line.; #. Unnamed temporaries are created when the result of a computation is; not assigned to a named value.; #. By default, unnamed temporaries are numbered sequentially (using a; per-function incrementing counter, starting with 0). However, when explicitly; specifying temporary numbers, it is allowed to skip over numbers. Note that basic blocks and unnamed function parameters are included in this; numbering. For example, if the entry basic block is not given a label name; and all function parameters are named, then it will get number 0. It also shows a convention that we follow in this document. When; demonstrating instructions, we will follow an instruction with a comment; that defines the type and name of value produced. High Level Structure; ====================. Module Structure; ----------------. LLVM programs are composed of ``Module``'s, each of which is a; translation unit of the input programs. Each module consists of; functions, global variables, and symbol table entries. Modules may be; combined together with the LLVM linker, which merges function (and; global variable) definitions, resolves forward declarations, and merges; symbol table entries. Here is an example of the ""hello world"" module:. .. code-block:: llvm. ; Declare the string constant as a global constant.; @.str = private unnamed_addr constant [13 x i8] c""hello world\0A\00"". ; External declaration of the puts function; declare i32 @puts(ptr nocapture) nounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a modu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:5935,variab,variables,5935,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"d(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``ForStmt``; as we will want to do something with it:. .. code-block:: c++. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");. Once you have defined your matchers, you will need to add a little more; scaffolding in order to run them. Matchers are paired with a; ``MatchCallback`` and registered with a ``MatchFinder`` object, then run; from a ``ClangTool``. More code!. Add the following to ``LoopConvert.cpp``:. .. code-block:: c++. #include ""clang/ASTMatchers/ASTMatchers.h""; #include ""clang/ASTMatchers/ASTMatchFinder.h"". using namespace clang;; using namespace clang::ast_matchers;. StatementMatcher LoopMatcher =; forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))).bind(""forLoop"");.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:8377,variab,variables,8377,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variables']
Modifiability,"d) weighted ML fits by applying a correction to the covariance matrix; as follows. V' = V C-1 V. where V is the covariance matrix from the fit to weighted data, and C-1 is the inverse of the; covariance matrix calculated from a similar likelihood that constructed with the event weights applied squared. Redesign of RooFit dataset class structure. The original class structure of RooFit featured an abstract dataset; class RooAbsData. Inheriting from that was a single class; RooTreeData, which implemented datasets with a ROOT; TTree-based storage implementation, and inheriting from that; two classes RooDataSet , representing unbinned data, and; RooDataHist, representing binned data. A main problem with; this structure was that the implementation of the storage technology; (TTree) and the data representation (binned vs unbinned) were; intertwined. Starting with version 3.00, the class structure has been; rearranged: Now classes RooDataSet and RooDataHist inherit directly; from class RooAbsData, and class RooAbsData now owns an object that; inherits from RooAbsDataStore that implements the storage of the; data. This new class structure allows multiple data storage implementations to; be applied efficiently to both RooDataSet and RooDataHist; At present a single implementation of RooAbsDataStore exists,; class RooTreeDataStore, that contains the storage implementation; formerly implement in class RooTreeData. Methods in class RooTreeData; that were not specific to the storage technology have been moved to; class RooAbsData. If your user code only uses the classes RooDataSet,RooDataHist and RooAbsData; nothing will change: Existing RooDataSets and RooDataHists; (that inherit from RooTreeData) can be read in without problems in; RooFit 3.00 and will be converted on the fly to the new dataset structure; in memory. User code that explicitly uses RooTreeData pointers should; be changed to RooAbsData pointers. This change should be transparent; for all uses, with the exception of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:14068,inherit,inherit,14068,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['inherit'],"['inherit', 'inherits']"
Modifiability,"d);; ptrTrack = gGeoManager->GetTrack(index);; ```. Supposing a particle represented by a primary track decays or interacts,; one should not create new primaries as described before, but rather add; them as secondary:. ``` {.cpp}; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; ```. At any step made by the current track, one is able to add control points; to either primary or secondary:. ``` {.cpp}; track->AddPoint(x,y,z,t);; ```. After tracks were defined and filled during tracking, one will be able; to browse directly the list of tracks held by the manager class. Any; track can be drawn using its `Draw()` and `Animate()` methods, but there; are also global methods for drawing or animation that can be accessed; from **`TGeoManager`** context menu:. ``` {.cpp}; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; ```. The drawing/animation time range is a global variable that can be; directly set:. ``` {.cpp}; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; ```. Once set, the time range will be active both for individual or global; track drawing. For animation, this range is divided to the desired; number of frames and will be automatically updated at each frame in; order to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:128029,variab,variable,128029,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variable']
Modifiability,"d, a more consistent way of identifying; the instruction's value is to refer to the `MachineOperand` where the value is; defined: independently of which register is defined by that `MachineOperand`. In; the code above, the `DBG_INSTR_REF` instruction refers to instruction number; one, operand zero, while the `ADD32rr` has a `debug-instr-number` attribute; attached indicating that it is instruction number one. De-coupling variable locations from registers avoids difficulties involving; register allocation and optimisation, but requires additional instrumentation; when the instructions are optimised instead. Optimisations that replace; instructions with optimised versions that compute the same value must either; preserve the instruction number, or record a substitution from the old; instruction / operand number pair to the new instruction / operand pair -- see; `MachineFunction::substituteDebugValuesForInst`. If debug info maintenance is; not performed, or an instruction is eliminated as dead code, the variable; location is safely dropped and marked ""optimised out"". The exception is; instructions that are mutated rather than replaced, which always need debug info; maintenance. # Register allocator considerations. When the register allocator runs, debugging instructions do not directly refer; to any virtual registers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back in after register allocation; completes. The exception is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:3010,variab,variable,3010,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,"d-alone Builds; ------------------. Stand-alone builds allow you to build a sub-project against a pre-built; version of the clang or llvm libraries that is already present on your; system. You can use the source code from a standard checkout of the llvm-project; (as described above) to do stand-alone builds, but you may also build; from a :ref:`sparse checkout<workflow-multicheckout-nocommit>` or from the; tarballs available on the `releases <https://github.com/llvm/llvm-project/releases/>`_; page. For stand-alone builds, you must have an llvm install that is configured; properly to be consumable by stand-alone builds of the other projects.; This could be a distro provided LLVM install, or you can build it yourself,; like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/llvm -B $builddir \; -DLLVM_INSTALL_UTILS=ON \; -DCMAKE_INSTALL_PREFIX=/path/to/llvm/install/prefix \; < other options >. ninja -C $builddir install. Once llvm is installed, to configure a project for a stand-alone build, invoke CMake like this:. .. code-block:: console. cmake -G Ninja -S path/to/llvm-project/$subproj \; -B $buildir_subproj \; -DLLVM_EXTERNAL_LIT=/path/to/lit \; -DLLVM_ROOT=/path/to/llvm/install/prefix. Notice that:. * The stand-alone build needs to happen in a folder that is not the; original folder where LLVMN was built; (`$builddir!=$builddir_subproj`).; * ``LLVM_ROOT`` should point to the prefix of your llvm installation,; so for example, if llvm is installed into ``/usr/bin`` and; ``/usr/lib64``, then you should pass ``-DLLVM_ROOT=/usr/``.; * Both the ``LLVM_ROOT`` and ``LLVM_EXTERNAL_LIT`` options are; required to do stand-alone builds for all sub-projects. Additional; required options for each sub-project can be found in the table; below. The ``check-$subproj`` and ``install`` build targets are supported for the; sub-projects listed in the table below. ============ ======================== ======================; Sub-Project Required Sub-Directories Requir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:6110,config,configure,6110,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configure']
Modifiability,"d. \-. Mach-O: N_STAB symbol. ?. Something unrecognizable. Because LLVM bitcode files typically contain objects that are not considered to; have addresses until they are linked into an executable image or dynamically; compiled ""just-in-time"", :program:`llvm-nm` does not print an address for any; symbol in an LLVM bitcode file, even symbols which are defined in the bitcode; file. OPTIONS; -------. .. program:: llvm-nm. .. option:: -B. Use BSD output format. Alias for ``--format=bsd``. .. option:: -X. Specify the type of XCOFF object file, ELF object file, or IR object file input; from command line or from archive files that llvm-nm should examine. The; mode must be one of the following:; ; 32; Process only 32-bit object files.; 64; Process only 64-bit object files.; 32_64; Process both 32-bit and 64-bit object files.; any; Process all the supported object files. On AIX OS, the default is to process 32-bit object files only and to ignore; 64-bit objects. The can be changed by setting the OBJECT_MODE environment; variable. For example, OBJECT_MODE=64 causes :program:`llvm-nm` to process; 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. On other operating systems, the default is to process all object files: the; OBJECT_MODE environment variable is not supported. .. option:: --debug-syms, -a. Show all symbols, even those usually suppressed. .. option:: --defined-only, -U. Print only symbols defined in this file. .. option:: --demangle, -C. Demangle symbol names. .. option:: --dynamic, -D. Display dynamic symbols instead of normal symbols. .. option:: --export-symbols. Print sorted symbols with their visibility (if applicable), with duplicates; removed. .. option:: --extern-only, -g. Print only symbols whose definitions are external; that is, accessible from; other files. .. option:: --format=<format>, -f. Select an output format; *format* may be *sysv*, *posix*, *darwin*, *bsd* or; *just-symbols*.; The default is *bsd*. .. option:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:3553,variab,variable,3553,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['variab'],['variable']
Modifiability,d.; No specific algorithm exists. - **`GSLMultiMin`** (library *libMathMore*). Minimizer based on the Multidimensional Minimization routines of the Gnu Scientific Library (GSL). The list of available algorithms is; 	- *`BFGS2`* (default) : second version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`BFGS`* : old version of the vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm;; 	- *`ConjugateFR`* : Fletcher-Reeves conjugate gradient algorithm;; 	- *`ConjugatePR`* : Polak-Ribiere conjugate gradient algorithm;; 	- *`SteepestDescent`*: steepest descent algorithm;. - **`GSLMultiFit`** (library *libMathMore*). Minimizer based on the Non-Linear Least-Square routines of GSL. This minimizer can be used only for least-square fits. - **`GSLSimAn`** (library *libMathMore*). Minimizer based on simulated annealing. - **`Genetic`** (library *libGenetic*). Genetic minimizer based on an algorithm implemented in the *TMVA* package. Each minimizer can be configured using the `ROOT::Math::MinimizerOptions` class. The list of possible option that can be set are:. * *Minimizer type* (`MinimizerOptions::SetMinimizerType(const char *)`) .; * *Minimizer algorithm* (`MinimizerOptions::SetMinimizerAlgorithm(const char *)`).; * *Print Level* (`MinimizerOptions::SetPrintLevel(int )`) to set the verbose printing level (default is 0).; * *Tolerance* (`MinimizerOptions::SetTolerance(double )`) tolerance used to control the iterations.; * *Maximum number of function calls* (`MinimizerOptions::SetMaxFunctionCalls(int )`).; * *Maximum number of iterations* (`MinimizerOptions::SetMaxIterations(int )`). Note that this is not used by *Minuit*; * *FCN Upper value for Error Definition* (`MinimizerOptions::SetErrorDef(double )`). Value in the minimization function used to compute the parameter errors.; The default is to get the uncertainties at the 68% CL is a value of 1 for a chi-squared function minimization and 0.5 for a log-likelihood function.; * *Strategy* (`MinimizerO,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:42683,config,configured,42683,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configured']
Modifiability,"d:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optimized out:; in IR the location would be assigned ``undef`` by a debug intrinsic, and in MIR; the equivalent location is used. After MIR locations are assigned to each variable, machine pseudo-instructions; corresponding to each ``llvm.dbg.value`` intrinsic are inserted. There are two; forms of this type of instruction. The first form, ``DBG_VALUE``, appears thus:. .. code-block:: text. DBG_VAL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:26182,variab,variable,26182,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"d:c++17""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -D_SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING""); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -D_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING""); elseif(MSVC_VERSION GREATER_EQUAL 1910); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -std:c++14""); endif(); endif(); else(); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-rtti""); endif(). if(MSVC); add_definitions(/DNOMINMAX); set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} /Zc:preprocessor""); endif(). if (APPLE); set(CMAKE_MODULE_LINKER_FLAGS ""-Wl,-flat_namespace -Wl,-undefined -Wl,suppress""); endif (). include(CMakeParseArguments). macro(add_cling_subdirectory name); add_llvm_subdirectory(CLING TOOL ${name}); endmacro(). file (STRINGS ""VERSION"" CLING_VERSION); string(REGEX REPLACE ""([0-9]).[0-9]+~[a-zA-Z]+"" ""\\1"" CLING_VERSION_MAJOR ${CLING_VERSION}); string(REGEX REPLACE ""[0-9].([0-9]+)~[a-zA-Z]+"" ""\\1"" CLING_VERSION_MINOR ${CLING_VERSION}). if(DEFINED CLING_ROOT_BUILD); # Building as part of ROOT; visibility is ""inherited"" from ROOT/interpreter.; set(CLING_VERSION ROOT_${CLING_VERSION}); else(); # Lots of cling is needed at runtime (e.g. Value, or Interpreter::Evaluate()).; # The JIT needs to be able to resolve these symbols from cling; unhide them.; set(CMAKE_CXX_VISIBILITY_PRESET default); set(CMAKE_C_VISIBILITY_PRESET default); set(CMAKE_VISIBILITY_INLINES_HIDDEN ""ON""); endif(); message(STATUS ""Cling version (from VERSION file): ${CLING_VERSION}""). set(CLING_VERSION_PATCHLEVEL 0). macro(set_cling_windows_version_resource_properties name); if(DEFINED windows_resource_file); set_windows_version_resource_properties(${name} ${windows_resource_file}; VERSION_MAJOR ${CLING_VERSION_MAJOR}; VERSION_MINOR ${CLING_VERSION_MINOR}; VERSION_PATCHLEVEL ${CLING_VERSION_PATCHLEVEL}; VERSION_STRING ""${CLING_VERSION} (${BACKEND_PACKAGE_STRING})""; PRODUCT_NAME ""cling""); endif(); endmacro(). include_directories(BEFORE SYSTEM ${LLVM_INCLUDE_DIRS} ${CLANG_INCLUDE_DIRS}). macro(add_cling_libra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt:10625,inherit,inherited,10625,interpreter/cling/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/CMakeLists.txt,1,['inherit'],['inherited']
Modifiability,"d; the SelectionDAG is destroyed. Note that this phase is logically separate from the instruction selection phase,; but is tied to it closely in the code because it operates on SelectionDAGs. Future directions for the SelectionDAG; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. #. Optional function-at-a-time selection. #. Auto-generate entire selector from ``.td`` file. .. _SSA-based Machine Code Optimizations:. SSA-based Machine Code Optimizations; ------------------------------------. To Be Written. Live Intervals; --------------. Live Intervals are the ranges (intervals) where a variable is *live*. They are; used by some `register allocator`_ passes to determine if two or more virtual; registers which require the same physical register are live at the same point in; the program (i.e., they conflict). When this situation occurs, one virtual; register must be *spilled*. Live Variable Analysis; ^^^^^^^^^^^^^^^^^^^^^^. The first step in determining the live intervals of variables is to calculate; the set of registers that are immediately dead after the instruction (i.e., the; instruction calculates the value, but it is never used) and the set of registers; that are used by the instruction, but are never used after the instruction; (i.e., they are killed). Live variable information is computed for; each *virtual* register and *register allocatable* physical register; in the function. This is done in a very efficient manner because it uses SSA to; sparsely compute lifetime information for virtual registers (which are in SSA; form) and only has to track physical registers within a block. Before register; allocation, LLVM can assume that physical registers are only live within a; single basic block. This allows it to do a single, local analysis to resolve; physical register lifetimes within each basic block. If a physical register is; not register allocatable (e.g., a stack pointer or condition codes), it is not; tracked. Physical registers may be live in to or out of a functio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:54919,variab,variables,54919,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variables']
Modifiability,"dNode(""n9"",""Node 9"");. n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);. n3->SetTextFont(132);. n0->SetTextColor(kRed);. n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);. // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);. TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; }; . This new funtionnality relies on the graphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax.; each time step has a new list of objects. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:3583,config,configure,3583,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['config'],['configure']
Modifiability,"d_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; CD2; Late-specified return types in function definitions; Unknown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:50355,variab,variables,50355,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"d``) :versionbadge:`clang-format 17` :ref:`¶ <BracedInitializerIndentWidth>`; The number of columns to use to indent the contents of braced init lists.; If unset, ``ContinuationIndentWidth`` is used. .. code-block:: c++. AlignAfterOpenBracket: AlwaysBreak; BracedInitializerIndentWidth: 2. void f() {; SomeClass c{; ""foo"",; ""bar"",; ""baz"",; };; auto s = SomeStruct{; .foo = ""foo"",; .bar = ""bar"",; .baz = ""baz"",; };; SomeArrayT a[3] = {; {; foo,; bar,; },; {; foo,; bar,; },; SomeArrayT{},; };; }. .. _BreakAdjacentStringLiterals:. **BreakAdjacentStringLiterals** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <BreakAdjacentStringLiterals>`; Break between adjacent string literals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:43897,variab,variable,43897,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['variab'],['variable']
Modifiability,"daemon is required. To start a session; just use TProof::Open("""") or TProof::Open(""lite""). From there on; everything should be as in normal PROOF, though some functionality may; not have been ported yet. To start a standard PROOF; session (i.e. via daemons) on the localhost use; TProof::Open(""localhost"").XrdProofd plug-in. Possibility to define the list worker directly in the; xrootd config file (new directive xpd.worker, see Wiki reference pages); Support for automatic reconnections in the case xrootd; is restarted; Dedicated admin area (under <xrd.admin>/.xproofd.<port>) to; keep information about active and terminated sessions, and active; clients. This is used to reguraly check the client and session; activity, to cleanup orphalin sessions and to shutdown inactive client; connections. ; domain + level control of printout message. Dynamic ""per-query"" scheduling. Dynamic worker startup. It can be enabled by the cluster; administrator with the 'xpd.putrc Proof.DynamicStartup 1' directive; in the config file. The effect is that a session starts only on; the master. When a query is submitted (call to TProof::Process),; the session master contacts the scheduler.; In response it receives a list of workers and starts the worker; processes. The environment is copied from the master to the workers.; It consist of: the include and library paths, the set of enabled; packages as well as the macros loaded by the user. . Flexible and fault-tolerant workers. A packet resubmitting mechanism. When a worker dies all the; packets that it processed are resubmitted.; Added the possibility to handle dynamically removed workers and partly processed; packets (when a worker is stopped while processing a packet it finishes; the current event and the rest of the packet is reassigned to another workers).; It's done by a new method TPacketizerAdaptive::AddProcessed(TSlave *sl,; TProofProgressStatus *st, TList **) and TPacketizerAdaptive::ReassignPacket. ; Memory controlAdd; the possibility t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:1178,config,config,1178,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['config'],['config']
Modifiability,"dant; we simply; need to check that the address is in range and well aligned. This is more; likely to occur if the virtual tables are padded. Forward-Edge CFI for Virtual Calls by Interleaving Virtual Tables; -----------------------------------------------------------------. Dimitar et. al. proposed a novel approach that interleaves virtual tables in [1]_.; This approach is more efficient in terms of space because padding and bit vectors are no longer needed.; At the same time, it is also more efficient in terms of performance because in the interleaved layout; address points of the virtual tables are consecutive, thus the validity check of a virtual; vtable pointer is always a range check. At a high level, the interleaving scheme consists of three steps: 1) split virtual table groups into; separate virtual tables, 2) order virtual tables by a pre-order traversal of the class hierarchy; and 3) interleave virtual tables. The interleaving scheme implemented in LLVM is inspired by [1]_ but has its own; enhancements (more in `Interleave virtual tables`_). .. [1] `Protecting C++ Dynamic Dispatch Through VTable Interleaving <https://cseweb.ucsd.edu/~lerner/papers/ivtbl-ndss16.pdf>`_. Dimitar Bounov, Rami Gökhan Kıcı, Sorin Lerner. Split virtual table groups into separate virtual tables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The Itanium C++ ABI glues multiple individual virtual tables for a class into a combined virtual table (virtual table group).; The interleaving scheme, however, can only work with individual virtual tables so it must split the combined virtual tables first.; In comparison, the old scheme does not require the splitting but it is more efficient when the combined virtual tables have been split.; The `GlobalSplit`_ pass is responsible for splitting combined virtual tables into individual ones. .. _GlobalSplit: https://github.com/llvm/llvm-project/blob/main/llvm/lib/Transforms/IPO/GlobalSplit.cpp. Order virtual tables by a pre-order trave",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:10410,enhance,enhancements,10410,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['enhance'],['enhancements']
Modifiability,"dates on how standards activities are going. Meeting agendas and minutes are; available. here. Clang office hours -; People within the community hold dedicated office hours at different points; during the month, which is a great way opportunity for getting questions; answered, having more in-depth design discussions, or learning about what's; going on in the community in general.; cfe-commits; - Historical record of commits to Clang and contains early community patch; review commentary. The most common way to talk with other developers on the project is through; the Clang Frontend Discourse forum; . The clang forum is a very friendly place and we welcome newcomers. The; forum is archived so you can browse through previous discussions or follow; development on the web if you prefer.; If you're looking for something to work on, check out our Open Projects page or look through the LLVM bug tracker.; Contributing Extensions to Clang; Clang is designed to support experimentation,; allowing programmers to easily extend the compiler to support great; new language features and tools. At some point, the authors of these; extensions may propose that the extensions become a part of Clang; itself, to benefit the whole Clang community. However, extensions; (particularly language extensions) have long-term maintenance costs; for Clang. The benefits of the extension need to be evaluated against; these costs. The Clang project uses the following criteria for this; evaluation:. Evidence of a significant user community: This is based on a number of; factors, including an existing user community, the perceived likelihood that; users would adopt such a feature if it were available, and any secondary; effects that come from, e.g., a library adopting the feature and providing; benefits to its users.; A specific need to reside within the Clang tree: There are some extensions; that would be better expressed as a separate tool, and should remain as; separate tools even if they end up being ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html:2029,extend,extend,2029,interpreter/llvm-project/clang/www/get_involved.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/get_involved.html,1,['extend'],['extend']
Modifiability,"dd support for multiple secondary-selection and partial; highlightning of secondary-selectable sub-items. This requires new; signals to be emitted from TGLViewer:. virtual void MouseOver (TObject *obj, UInt_t state); // *SIGNAL*; virtual void ReMouseOver(TObject *obj, UInt_t state); // *SIGNAL*; virtual void UnMouseOver(TObject *obj, UInt_t state); // *SIGNAL*. TGLEventHandler emits them when needed. For example see TEveDigitSet; and its sub-classes TEveQuadSet and TEveBoxSet. It is now possible to enforce all tesselations of geometry shapes; to only use triangles via static function void; TGLFaceSet::EnforceTriangles(). This is needed to export TGeo; shapes and CSG meshes to external triangle-mesh libraries that can; not handle arbitrary polygons.; Add support for full-scene anti-aliasing (the actual benefits; depend on graphics card / driver). It is controlled via rootrc,; e.g.:. OpenGL.Framebuffer.Multisample: 4. Minor changes. Extend configurability of GL event-handler to allow inversion of; controls from scene-centric to viewer-centric. The following rootrc; variables control the behaviour:. OpenGL.EventHandler.ViewerCentricControls: 1; OpenGL.EventHandler.ArrowKeyFactor: -1.0; OpenGL.EventHandler.MouseDragFactor: -1.0; OpenGL.EventHandler.MouseWheelFactor: -1.0. Add camera auto-rotation support. Controls are available from the; ""Extras"" tab of TGLViewer GUI editor. Implemented in class; TGLAutoRotator, can be sub-classed and attached to a viewer via; TGLViewer::SetAutoRotator() method.; Added new overlay element class TGLCameraGuide that shows the; orientation of major axes. To use, call this on a TGLViewer object:. gl_viewer->AddOverlayElement(new TGLCameraGuide(0.9, 0.1, 0.08));. Fix an issue with GL-clip object not being properly updated after; a scene update.; Hide / show menu-bar with a time-out (default 400ms). This can be; adjusted by calling static method:; TGLSAViewer::SetMenuHidingTimeout(200);; To disable menu hiding for Eve viewers, where it is enab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:1496,config,configurability,1496,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['config'],['configurability']
Modifiability,"ddress of an object in the stack frame. .. code-block:: none. %1:_(p0) = G_FRAME_INDEX %stack.0.ptr0. G_GLOBAL_VALUE; ^^^^^^^^^^^^^^. The address of a global value. .. code-block:: none. %0(p0) = G_GLOBAL_VALUE @var_local. G_BLOCK_ADDR; ^^^^^^^^^^^^. The address of a basic block. .. code-block:: none. %0:_(p0) = G_BLOCK_ADDR blockaddress(@test_blockaddress, %ir-block.block). G_CONSTANT_POOL; ^^^^^^^^^^^^^^^. The address of an object in the constant pool. .. code-block:: none. %0:_(p0) = G_CONSTANT_POOL %const.0. Integer Extension and Truncation; --------------------------------. G_ANYEXT; ^^^^^^^^. Extend the underlying scalar type of an operation, leaving the high bits; unspecified. .. code-block:: none. %1:_(s32) = G_ANYEXT %0:_(s16). G_SEXT; ^^^^^^. Sign extend the underlying scalar type of an operation, copying the sign bit; into the newly-created space. .. code-block:: none. %1:_(s32) = G_SEXT %0:_(s16). G_SEXT_INREG; ^^^^^^^^^^^^. Sign extend the value from an arbitrary bit position, copying the sign bit; into all bits above it. This is equivalent to a shl + ashr pair with an; appropriate shift amount. $sz is an immediate (MachineOperand::isImm(); returns true) to allow targets to have some bitwidths legal and others; lowered. This opcode is particularly useful if the target has sign-extension; instructions that are cheaper than the constituent shifts as the optimizer is; able to make decisions on whether it's better to hang on to the G_SEXT_INREG; or to lower it and optimize the individual shifts. .. code-block:: none. %1:_(s32) = G_SEXT_INREG %0:_(s32), 16. G_ZEXT; ^^^^^^. Zero extend the underlying scalar type of an operation, putting zero bits; into the newly-created space. .. code-block:: none. %1:_(s32) = G_ZEXT %0:_(s16). G_TRUNC; ^^^^^^^. Truncate the underlying scalar type of an operation. This is equivalent to; G_EXTRACT for scalar types, but acts elementwise on vectors. .. code-block:: none. %1:_(s16) = G_TRUNC %0:_(s32). Type Conversions; ---------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst:1548,extend,extend,1548,interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GenericOpcode.rst,1,['extend'],['extend']
Modifiability,"ddressing problems; which arise with said buildbot. We generally expect the bot owner to be; reasonably responsive. For some bots, the ownership responsibility is split between a ""resource owner""; who provides the underlying machine resource, and a ""configuration owner"" who; maintains the build configuration. Generally, operational responsibility lies; with the ""config owner"". We do expect ""resource owners"" - who are generally; the contact listed in a workers attributes - to proxy requests to the relevant; ""config owner"" in a timely manner. Most issues with a buildbot should be addressed directly with a bot owner; via email. Please CC `Galina Kistanova <mailto:gkistanova@gmail.com>`_. Steps To Add Builder To LLVM Buildbot; =====================================; Volunteers can provide their build machines to work as build workers to; public LLVM Buildbot. Here are the steps you can follow to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:2469,config,configurations,2469,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configurations']
Modifiability,"de ``lldb`` headers first, followed by ``clang`` headers, followed by; ``llvm`` headers, to reduce the possibility (for example) of an LLDB header; accidentally picking up a missing include due to the previous inclusion of that; header in the main source file or some earlier header file. clang should; similarly include its own headers before including llvm headers. This rule; applies to all LLVM subprojects. .. _fit into 80 columns:. Source Code Width; ^^^^^^^^^^^^^^^^^. Write your code to fit within 80 columns. There must be some limit to the width of the code in; order to allow developers to have multiple files side-by-side in; windows on a modest display. If you are going to pick a width limit, it is; somewhat arbitrary but you might as well pick something standard. Going with 90; columns (for example) instead of 80 columns wouldn't add any significant value; and would be detrimental to printing out code. Also many other projects have; standardized on 80 columns, so some people have already configured their editors; for it (vs something else, like 90 columns). Whitespace; ^^^^^^^^^^. In all cases, prefer spaces to tabs in source files. People have different; preferred indentation levels, and different styles of indentation that they; like; this is fine. What isn't fine is that different editors/viewers expand; tabs out to different tab stops. This can cause your code to look completely; unreadable, and it is not worth dealing with. As always, follow the `Golden Rule`_ above: follow the style of existing code; if you are modifying and extending it. Do not add trailing whitespace. Some common editors will automatically remove; trailing whitespace when saving a file which causes unrelated changes to appear; in diffs and commits. Format Lambdas Like Blocks Of Code; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". When formatting a multi-line lambda, format it like a block of code. If there; is only one multi-line lambda in a statement, and there are no expressions; lexically afte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:18085,config,configured,18085,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['config'],['configured']
Modifiability,"de as well. These kind of cross-file issues are currently only support by Xcode, not the HTML output.; This build is built with LLVM's Link-Time Optimization (LTO), which should make it slightly faster.; LTO also reduces the download size (about 19% smaller than checker-274).; Many sundry fixes. checker-274; built: April 23, 2013; download: checker-274.tar.bz2; highlights:. Improved use-after-free and mismatched deallocator checking.; Diagnostic polish.; Fixes crashes found in checker-273. checker-273; built: April 8, 2013; download: checker-273.tar.bz2; highlights:. Additional checks for misuse of Foundation collection APIs.; New C++ checker for attempting to create a reference to null.; New use-after-free checker for C++ 'delete'.; New checker for simple cases of mismatched allocators and deallocators, e.g. ""delete malloc(4);""; Support for basic interprocedural analysis of C++ destructors.; Additional heuristics for suppressing null pointer false positives.; Misc. bug fixes and performance enhancements. checker-272; built: March 1, 2013; highlights:. Better modeling of C++ constructors:; ; Interprocedural analysis support for constructors of types with trivial destructors; Efficient model of trivial copy and move constructors. Better diagnostics for loops that execute 0 times; Fixes a linking issue that prevented the checker from running on OS X v10.6 and earlier; Fixes for misc. crashes and false positives. checker-271; built: February 8, 2013; highlights:. Faster analysis for scan-build xcodebuild when using Xcode 4.6 and higher:; ; scan-build now uses Xcode's built-in interposition mechanism for the static analyzer to provide faster builds while doing static analysis (PCH files are now built).; This change also allows scan-build to have better support for iOS project analysis without having to specifying weird SDK settings to scan-build. Better diagnostics for implicitly-defined member functions in C++.; New warning for malloc/free checker when passing malloc'e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html:5117,enhance,enhancements,5117,interpreter/llvm-project/clang/www/analyzer/release_notes.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/release_notes.html,1,['enhance'],['enhancements']
Modifiability,"de flag of; scan-build tool which would enable assertions automatically.; Use verbose output when debugging scan-build; scan-build takes a -v option to emit verbose output about; what it's doing; two -v options emit more information. Redirecting the; output of scan-build to a text file (make sure to redirect standard; error) is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., setup code signing).; Recommendation: use ""Build and Analyze""; The absolute easiest way to analyze iPhone projects is to use the; Analyze; feature in Xcode (which is based on the Clang Static Analyzer). There a; user can a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7517,variab,variable,7517,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['variab'],['variable']
Modifiability,"de that only makes use of entities in the public ROOT namespace, and should not impact downstream code unless it was patching or reusing internal `RDataFrame` types. ### Notable bug fixes and improvements. - A critical issue has been fixed that could potentially result in wrong data being silently read in multi-thread runs when an input `TChain` contained more than one `TTree` coming from the _same_ input file. More details are available at [#7143](https://github.com/root-project/root/issues/7143).; - The start-up time of event loops with large computation graphs with many just-in-time-compiled expressions (e.g. thousands of string `Filter`s and `Define`s) has been greatly reduced. See [the corresponding pull request](https://github.com/root-project/root/pull/7651) for more details. The full list of bug fixes for this release is available below. ### Distributed computing with RDataFrame; ROOT 6.24 introduces `ROOT.RDF.Experimental.Distributed`, an experimental python package that enhances RDataFrame with distributed computing capabilities. The new package allows distributing RDataFrame applications through one of the supported distributed backends. The package was designed so that different backends can be easily plugged in. Currently the [Apache Spark](http://spark.apache.org/) backend is supported and support for [Dask](https://dask.org/) is coming soon. The backend submodules of this package expose their own `RDataFrame` objects. The only needed change in user code is to substitute `ROOT.RDataFrame` calls with such backend-specific `RDataFrame`s. For example:. ```python; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; ```. The main goal of this package is to support running any RDataFrame applicat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:10161,enhance,enhances,10161,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['enhance'],['enhances']
Modifiability,"de the dot. For example for ""t."" the names where ""t._"" and ""t..fValue"" and are now ""t_"" and ""t.fValue"". . ## RDataFrame. ### New features. - Introduce `ROOT::RDF::RunGraphs`, which allows to compute the results of multiple `RDataFrame`s (or better, multiple independent computation graphs) concurrently while sharing the same thread pool. The computation may be more efficient than running the `RDataFrame`s sequentially if an analysis consists of several computation graphs that individually do not fully utilize the available resources. See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.; - `RDataFrame` now supports reading friend `TTree`s with a `TTreeIndex`, aka ""indexed friends"". More details at [ROOT-9559](https://sft.its.cern.ch/jira/browse/ROOT-9559).; - Experimental logging capabilities have been added to `RDataFrame`. To activate logging, define the following variable before creating the `RDataFrame` object: `auto verbosity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel.kInfo);`.; - With [ROOT-10023](https://sft.its.cern.ch/jira/browse/ROOT-10023) fixed, `RDataFrame` can now read and write certain branches containing unsplit objects, i.e. `TBranchObjects`. More information is available at [ROOT-10022](https://sft.its.cern.ch/jira/browse/ROOT-10022).; - CSV files can now be opened and processed from remote HTTP(S) locations; - `RDataFrame` results produced by the same action in different computation graphs can now be merged thanks to the new interface provided by `ROOT::Detail::RDF::RMergeableValue`, introduced in [#5552](https://github.com/root-project/root/pull/5552). A feature originally requested with [ROOT-9869](https://sft.its.cern.ch/jira/browse/ROOT-9869), it helps streamline `RDataFrame` workflows in a distributed environment. Currently only a subset of `RDataFrame` actions have their corresponding mergeable class, but in the future it w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:6517,variab,variable,6517,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"de the improvements below:. - add support for using HTTPS : you can use different schemas for; specifying the underlying transport protocol to use ""s3:"",; ""s3http:"", ""s3https:"" [""s3"" uses HTTPS]. The current schema, namely; ""as3:"", is supported for backwards compatibility.; - extend support for other S3 service providers that do not offer the; virtual hosting functionality (currently only Amazon offers this).; - support the possibility of specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:1485,variab,variables,1485,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['variab'],['variables']
Modifiability,"de. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; confi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:1891,config,configuration,1891,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,2,['config'],['configuration']
Modifiability,"de/clang/Tooling/Transformer/RewriteRule.h#L165-L167>`_; ``EditGenerator``\ s, like list flattening. For the full list, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Rules; ^^^^^. We can also compose multiple *rules*, rather than just edits within a rule,; using ``applyFirst``: it composes a list of rules as an ordered choice, where; Transformer applies the first rule whose pattern matches, ignoring others in the; list that follow. If the matchers are independent then order doesn't matter. In; that case, ``applyFirst`` is simply joining the set of rules into one. The benefit of ``applyFirst`` is that, for some problems, it allows the user to; more concisely formulate later rules in the list, since their patterns need not; explicitly exclude the earlier patterns of the list. For example, consider a set; of rules that rewrite compound statements, where one rule handles the case of an; empty compound statement and the other handles non-empty compound statements.; With ``applyFirst``, these rules can be expressed compactly as:. .. code-block:: c++. applyFirst({; makeRule(compoundStmt(statementCountIs(0)).bind(""empty""), ...),; makeRule(compoundStmt().bind(""non-empty""),...); }). The second rule does not need to explicitly specify that the compound statement; is non-empty -- it follows from the rules position in ``applyFirst``. For more; complicated examples, this can lead to substantially more readable code. Sometimes, a modification to the code might require the inclusion of a; particular header file. To this end, users can modify rules to specify include; directives with ``addInclude``. For additional documentation on these functions, see the header file; `clang/Tooling/Transformer/RewriteRule.h <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Tooling/Transformer/RewriteRule.h>`_. Using a RewriteRule as a clang-tidy check; ---------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:15300,rewrite,rewrite,15300,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"de; to interoperate easily with precompiled code in the application or shared; libraries. The kind of mangling will depend on the DataLayout, which in turn; depends on the target platform. To allow us to remain portable and search based; on the un-mangled name, we just re-produce this mangling ourselves using our; ``Mangle`` member function object. This brings us to the end of Chapter 1 of Building a JIT. You now have a basic; but fully functioning JIT stack that you can use to take LLVM IR and make it; executable within the context of your JIT process. In the next chapter we'll; look at how to extend this JIT to produce better quality code, and in the; process take a deeper look at the ORC layer concept. `Next: Extending the KaleidoscopeJIT <BuildingAJIT2.html>`_. Full Code Listing; =================. Here is the complete code listing for our running example. To build this; example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../examples/Kaleidoscope/BuildingAJIT/Chapter1/KaleidoscopeJIT.h; :language: c++. .. [1] Actually we use a cut-down version of KaleidoscopeJIT that makes a; simplifying assumption: symbols cannot be re-defined. This will make it; impossible to re-define symbols in the REPL, but will make our symbol; lookup logic simpler. Re-introducing support for symbol redefinition is; left as an exercise for the reader. (The KaleidoscopeJIT.h used in the; original tutorials will be a helpful reference). .. [2] +-----------------------------+-----------------------------------------------+; | File | Reason for inclusion |; +=============================+===============================================+; | CompileUtils.h | Provides the SimpleCompiler class. |; +-----------------------------+-----------------------------------------------+; | Core.h | Core utilities such as ExecutionSession and |; | | JITDyl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst:13039,config,config,13039,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT1.rst,1,['config'],['config']
Modifiability,"de` for more details. * LLVM contains an optional package called ``llvm-test``, which provides; benchmarks and programs that are known to compile with the Clang front; end. You can use these programs to test your code, gather statistical; information, and compare it to the current LLVM performance statistics. Currently, there is no way to hook your tests directly into the ``llvm/test``; testing harness. You will simply need to find a way to use the source; provided within that directory on your own. Typically, you will want to build your **lib** directory first followed by your; **tools** directory. Writing LLVM Style Makefiles; ============================. The LLVM build system provides a convenient way to build libraries and; executables. Most of your project Makefiles will only need to define a few; variables. Below is a list of the variables one can set and what they can; do:. Required Variables; ------------------. ``LEVEL``. This variable is the relative path from this ``Makefile`` to the top; directory of your project's source code. For example, if your source code; is in ``/tmp/src``, then the ``Makefile`` in ``/tmp/src/jump/high``; would set ``LEVEL`` to ``""../..""``. Variables for Building Subdirectories; -------------------------------------. ``DIRS``. This is a space separated list of subdirectories that should be built. They; will be built, one at a time, in the order specified. ``PARALLEL_DIRS``. This is a list of directories that can be built in parallel. These will be; built after the directories in DIRS have been built. ``OPTIONAL_DIRS``. This is a list of directories that can be built if they exist, but will not; cause an error if they do not exist. They are built serially in the order; in which they are listed. Variables for Building Libraries; --------------------------------. ``LIBRARYNAME``. This variable contains the base name of the library that will be built. For; example, to build a library named ``libsample.a``, ``LIBRARYNAME`` should; be s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst:4437,variab,variable,4437,interpreter/llvm-project/llvm/docs/Projects.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Projects.rst,1,['variab'],['variable']
Modifiability,"dealing with the obtained results and concrete classes implementing the statistical methods.; ; All the classes and functions in RooStats are provided in the namespace RooStats.; ; RooStats interfaces. ConfInterval: interface for describing a confidence interval. ; IntervalCalculator: interface for a statistical tool producing confidence intervals (class ConfInterval).; HypoTestResult: interface for representing results of a hypothesis test; HypoTestCalculator: interface for a statistical tool performing an hypothesis test. ; CombinedCalculator: interface for a statistical tool which can produce both hypothesis test results and confidence intervals. ; RooStats concrete classes. The concrete classes describing statistical tools implementing the above interfaces are:; ; ProfileLikelihoodCalculator: it is an implementation of a CombinedCalculator using the profile likelihood ratio as a test statistics. After configuring the calculator, one only needs to ask GetHypoTest() (which will return a HypoTestResult pointer) or GetInterval() (which will return an ConfInterval pointer).; LikelihoodInterval: concrete implementation of a ConfInterval interface. It implements connected N-dimensional intervals based on the contour of a likelihood ratio. The boundary of the interval is equivalent to a MINUIT/MINOS contour about the maximum likelihood estimator. . HybridCalculator: hypothesis test calculator using a Bayesian-frequentist hybrid method (often called in HEP as CLs method). This class extends the functionality of the TLimit class by taking advantage of the RooFit package. The result of the calculator is returned as an HybridResult pointer. HybridResult implements the HypoTestResult interface. The class HybridPlot allows for a graphical representation of a HybridResult.; ; HybridCalculator implements the interface class HypoTestCalculator. A constructor exists taking as input the pdf's (expressed as RooAbsPdf instances) for the signal+background (alternate) and background on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:10544,config,configuring,10544,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['config'],['configuring']
Modifiability,"debug-macro, --debug-names, --debug-pubnames, --debug-pubtypes, --debug-ranges, --debug-rnglists, --debug-str, --debug-str-offsets, --debug-tu-index, --debug-types [=<offset>], --eh-frame [=<offset>], --gdb-index, --apple-names, --apple-types, --apple-namespaces, --apple-objc. Dump the specified DWARF section by name. Only the; `.debug_info` section is shown by default. Some entries; support adding an `=<offset>` as a way to provide an; optional offset of the exact entry to dump within the; respective section. When an offset is provided, only the; entry at that offset will be dumped, else the entire; section will be dumped. The :option:`--debug-macro` option prints both the .debug_macro and the .debug_macinfo sections. The :option:`--debug-frame` and :option:`--eh-frame` options are aliases, in cases where both sections are present one command outputs both. .. option:: @<FILE>. Read command-line options from `<FILE>`. .. _stats-format:. FORMAT OF STATISTICS OUTPUT; ---------------------------. The :option:`--statistics` option generates single-line JSON output; representing quality metrics of the processed debug info. These metrics are; useful to compare changes between two compilers, particularly for judging; the effect that a change to the compiler has on the debug info quality. The output is formatted as key-value pairs. The first pair contains a version; number. The following naming scheme is used for the keys:. - `variables` ==> local variables and parameters; - `local vars` ==> local variables; - `params` ==> formal parameters. For aggregated values, the following keys are used:. - `sum_of_all_variables(...)` ==> the sum applied to all variables; - `#bytes` ==> the number of bytes; - `#variables - entry values ...` ==> the number of variables excluding; the entry values etc. EXIT STATUS; -----------. :program:`llvm-dwarfdump` returns 0 if the input files were parsed and dumped; successfully. Otherwise, it returns 1. SEE ALSO; --------. :manpage:`dsymutil(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-dwarfdump.rst:5810,variab,variables,5810,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-dwarfdump.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-dwarfdump.rst,6,['variab'],['variables']
Modifiability,"debugging.; * Builds with debug information can use a lot of RAM and disk space and is; usually slower to run. You can improve RAM usage by using ``lld``, see; the :ref:`LLVM_USE_LINKER <llvm_use_linker>` option.; * Assertions are internal checks to help you find bugs. They typically slow; down LLVM and Clang when enabled, but can be useful during development.; You can manually set :ref:`LLVM_ENABLE_ASSERTIONS <llvm_enable_assertions>`; to override the default from `CMAKE_BUILD_TYPE`. If you are using an IDE such as Visual Studio or Xcode, you should use; the IDE settings to set the build type. **CMAKE_INSTALL_PREFIX**:PATH; Path where LLVM will be installed when the ""install"" target is built. **CMAKE_{C,CXX}_FLAGS**:STRING; Extra flags to use when compiling C and C++ source files respectively. **CMAKE_{C,CXX}_COMPILER**:STRING; Specify the C and C++ compilers to use. If you have multiple; compilers installed, CMake might not default to the one you wish to; use. .. _Frequently Used LLVM-related variables:. Frequently Used LLVM-related variables; --------------------------------------. The default configuration may not match your requirements. Here are; LLVM variables that are frequently used to control that. The full; description is in `LLVM-related variables`_ below. **LLVM_ENABLE_PROJECTS**:STRING; Control which projects are enabled. For example you may want to work on clang; or lldb by specifying ``-DLLVM_ENABLE_PROJECTS=""clang;lldb""``. **LLVM_ENABLE_RUNTIMES**:STRING; Control which runtimes are enabled. For example you may want to work on; libc++ or libc++abi by specifying ``-DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi""``. **LLVM_LIBDIR_SUFFIX**:STRING; Extra suffix to append to the directory where libraries are to be; installed. On a 64-bit architecture, one could use ``-DLLVM_LIBDIR_SUFFIX=64``; to install libraries to ``/usr/lib64``. **LLVM_PARALLEL_{COMPILE,LINK}_JOBS**:STRING; Building the llvm toolchain can use a lot of resources, particularly; linking. These ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:8737,variab,variables,8737,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"ded some functionality on how to keep track of the; line and column of the ""source file"". As we lex every token we set our current; current ""lexical location"" to the assorted line and column for the beginning; of the token. We do this by overriding all of the previous calls to; ``getchar()`` with our new ``advance()`` that keeps track of the information; and then we have added to all of our AST classes a source location:. .. code-block:: c++. class ExprAST {; SourceLocation Loc;. public:; ExprAST(SourceLocation Loc = CurLoc) : Loc(Loc) {}; virtual ~ExprAST() {}; virtual Value* codegen() = 0;; int getLine() const { return Loc.Line; }; int getCol() const { return Loc.Col; }; virtual raw_ostream &dump(raw_ostream &out, int ind) {; return out << ':' << getLine() << ':' << getCol() << '\n';; }. that we pass down through when we create a new expression:. .. code-block:: c++. LHS = std::make_unique<BinaryExprAST>(BinLoc, BinOp, std::move(LHS),; std::move(RHS));. giving us locations for each of our expressions and variables. To make sure that every instruction gets proper source location information,; we have to tell ``Builder`` whenever we're at a new source location.; We use a small helper function for this:. .. code-block:: c++. void DebugInfo::emitLocation(ExprAST *AST) {; if (!AST); return Builder->SetCurrentDebugLocation(DebugLoc());; DIScope *Scope;; if (LexicalBlocks.empty()); Scope = TheCU;; else; Scope = LexicalBlocks.back();; Builder->SetCurrentDebugLocation(; DILocation::get(Scope->getContext(), AST->getLine(), AST->getCol(), Scope));; }. This both tells the main ``IRBuilder`` where we are, but also what scope; we're in. The scope can either be on compile-unit level or be the nearest; enclosing lexical block like the current function.; To represent this we create a stack of scopes in ``DebugInfo``:. .. code-block:: c++. std::vector<DIScope *> LexicalBlocks;. and push the scope (function) to the top of the stack when we start; generating the code for each function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:11438,variab,variables,11438,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variables']
Modifiability,"ded to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their normal; qualification (i.e. without adding const). In C++11, ``__block``; variables are copied as x-values if that is possible, then as l-values; if not; if both fail, it's an error. The destructor for any initial; stack-based version is called at the variable's normal end of scope. References to ``this``, as well as references to non-static members of; any enclosing class, are evaluated by capturing ``this`` just like a; normal variable of C pointer type. Member variables that are Blocks may not be overloaded by the types of; their argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:12000,variab,variables,12000,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"ded vector functionality as proposed by Peter D Barnes from LNL; (http://root.cern.ch/phpBB2/viewtopic.php?t=8351).; ; double s = v1 * M * v2; // Mult Function : e.g., physics matrix element; TMatrixD M = v1' * v2 // outer product of v1 and v2; . SMatrix. Use specialized structures for building automatically static; tables for mapping the indices conversion from standard row-wise one to the; compact one used internally for storing the memory of a symmetrix matrix. This change gives an; improvements of around 10-20% in the Kalman filter test (testKalman.cxx) and in the matrix operations test. Minuit. Implement in the TMinuitMinimizer class the method SetPrecision() using the ""SET EPS"" Minuit command; Fix a problem when using the user provided gradient in TMinuitMinimizer. The gradient calculation is always forced, i.e. Minuit will always use the derivatives calculations provided by the user. This is now the same behavior as in Minuit2Minimizer.; Implement in TMinuitMinimizer a method to retrieve the variable name given the index.; Fix a printout in TMinuit::mnscan and a problem observed with valgrind. Minuit2. Fix a bug in MnFunctionCross. ; Add a protection against very small step sizes which can cause; nan values in InitialGradientCalculator.; Implement a new function in the MnUserTransformation class, FindIndex(name), which returns -1 when the parameter name does not exist.; Implement new methods in Minuit2Minimizer as requested by the Minimizer interface:; SetPrecision(double eps) to change the precision value used internally in Minuit2 (in MnPrecision), VariableName(index) to return the name of a variable (parameter) given an index, and VariableIndex(name) to return the index of a variable given a name.; Set a status code in Minuit2Minimizer according to the following convention:; status = minimizeStatus + 10 * minosStatus + 100 * hesseStatus.; See the Minuit2Minimizer reference documentation for the possible values of minimizeStatus , minosStatus and hesseStatus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:1550,variab,variable,1550,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,1,['variab'],['variable']
Modifiability,"defined; functions, and defined macros. The CMake distribution also contains a suite of; CMake modules that contain definitions for useful functionality. The example below is the full CMake build for building a C++ ""Hello World""; program. The example uses only CMake language-defined functions. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp). The CMake language provides control flow constructs in the form of foreach loops; and if blocks. To make the example above more complicated you could add an if; block to define ""APPLE"" when targeting Apple platforms:. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(HelloWorld); add_executable(HelloWorld HelloWorld.cpp); if(APPLE); target_compile_definitions(HelloWorld PUBLIC APPLE); endif(). Variables, Types, and Scope; ===========================. Dereferencing; -------------. In CMake variables are ""stringly"" typed. All variables are represented as; strings throughout evaluation. Wrapping a variable in ``${}`` dereferences it; and results in a literal substitution of the name for the value. CMake refers to; this as ""variable evaluation"" in their documentation. Dereferences are performed; *before* the command being called receives the arguments. This means; dereferencing a list results in multiple separate arguments being passed to the; command. Variable dereferences can be nested and be used to model complex data. For; example:. .. code-block:: cmake. set(var_name var1); set(${var_name} foo) # same as ""set(var1 foo)""; set(${${var_name}}_var bar) # same as ""set(foo_var bar)"". Dereferencing an unset variable results in an empty expansion. It is a common; pattern in CMake to conditionally set variables knowing that it will be used in; code paths that the variable isn't set. There are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sour",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:2891,variab,variables,2891,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"definitions. .. code-block:: c++. namespace N; {; enum E {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Mozilla`` (in configuration: ``Mozilla``); Like ``Attach``, but break before braces on enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Stroustrup`` (in configuration: ``Stroustrup``); Like ``Attach``, but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:49271,config,configuration,49271,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"der to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories of editable; objects](pictures/020001EA.jpg) ![Accessing/creating different; categories of editable objects](",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165868,plug-in,plug-in,165868,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['plug-in'],['plug-in']
Modifiability,"der to; complete ~10-15 builds an hour. Resource Appropriately; At 10-15 builds per hour, we need to complete a new build on average every; 4 to 6 minutes. For anything except the fastest of hardware/build configs,; this is going to be well beyond the ability of a single machine. In buildbot; terms, we likely going to need multiple workers to build requests in parallel; under a single builder configuration. For some rough back of the envelope; numbers, if your build config takes e.g. 30 minutes, you will need something; on the order of 5-8 workers. If your build config takes ~2 hours, you'll; need something on the order of 20-30 workers. The rest of this section; focuses on how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang build on your target, you; may be better off with two separate bots. Splitting increases resource; consumption, but makes it easy for each bot to keep up with commit flow.; Additionally, splitting bots may assist in triage by narrowing attention to; relevant parts of the failing configuration. In general, we recommend Release build types with Assertions enabled. This; generally provides a good balance between build times and bug detection for; most buildbots. There may be room for including some debug info (e.g. with; `-gmlt`), but in general the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:9673,config,configuration,9673,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['configuration']
Modifiability,"dered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4297,config,configured,4297,interpreter/llvm-project/clang/docs/Toolchain.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst,1,['config'],['configured']
Modifiability,"description is invalid (see; :ref:`amdgpu-dwarf-location-description`). *An initial stack*. This is a list of values or location descriptions that will be pushed on the; operation expression evaluation stack in the order provided before evaluation; of an operation expression starts. Some debugger information entries have attributes that evaluate their DWARF; expression value with initial stack entries. In all other cases the initial; stack is empty. The result is undefined if any location descriptions are invalid (see; :ref:`amdgpu-dwarf-location-description`). If the evaluation requires a context element that is not specified, then the; result of the evaluation is an error. *A DWARF expression for a location description may be able to be evaluated; without a thread, lane, call frame, program location, or architecture context.; For example, the location of a global variable may be able to be evaluated; without such context. If the expression evaluates with an error then it may; indicate the variable has been optimized and so requires more context.*. *The DWARF expression for call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) operations are restricted to; those that do not require the compilation unit context to be specified.*. The DWARF is ill-formed if all the ``address_size`` fields in the headers of all; the entries in the ``.debug_info``, ``.debug_addr``, ``.debug_line``,; ``.debug_rnglists``, ``.debug_rnglists.dwo``, ``.debug_loclists``, and; ``.debug_loclists.dwo`` sections corresponding to any given program location do; not match. .. _amdgpu-dwarf-expression-value:. A.2.5.2 DWARF Expression Value; ++++++++++++++++++++++++++++++. A value has a type and a literal value. It can represent a literal value of any; supported base type of the target architecture. The base type specifies the; size, encoding, and endianity of the literal value. .. note::. It may be desirable to add an implicit pointer base type encoding. It would be; used for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:54493,variab,variable,54493,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"destroyed. The superclass's implementation of ``dealloc`` will be called; automatically when the method returns. .. admonition:: Rationale. Even though ARC destroys instance variables automatically, there are still; legitimate reasons to write a ``dealloc`` method, such as freeing; non-retainable resources. Failing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:88735,variab,variables,88735,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit conversions from the address space-attributed type to the default; address space; - explicit conversions to/from the global address space from/to the; ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type; - implicit conversions from the ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type to the; global address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((ope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:2570,variab,variables,2570,interpreter/llvm-project/clang/docs/SYCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst,1,['variab'],['variables']
Modifiability,"details. .. _glattrs:. Global Attributes; -----------------. Attributes may be set to communicate additional information about a global variable.; Unlike :ref:`function attributes <fnattrs>`, attributes on a global variable; are grouped into a single :ref:`attribute group <attrgrp>`. ``no_sanitize_address``; This attribute indicates that the global variable should not have; AddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""address"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``no_sanitize_hwaddress``; This attribute indicates that the global variable should not have; HWAddressSanitizer instrumentation applied to it, because it was annotated; with `__attribute__((no_sanitize(""hwaddress"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file.; ``sanitize_memtag``; This attribute indicates that the global variable should have AArch64 memory; tags (MTE) instrumentation applied to it. This attribute causes the; suppression of certain optimisations, like GlobalMerge, as well as ensuring; extra directives are emitted in the assembly and extra bits of metadata are; placed in the object file so that the linker can ensure the accesses are; protected by MTE. This attribute is added by clang when; `-fsanitize=memtag-globals` is provided, as long as the global is not marked; with `__attribute__((no_sanitize(""memtag"")))`,; `__attribute__((disable_sanitizer_instrumentation))`, or included in the; `-fsanitize-ignorelist` file. The AArch64 Globals Tagging pass may remove; this attribute when it's not possible to tag the global (e.g. it's a TLS; variable).; ``sanitize_address_dyninit``; This attribute indicates that the global variable, when instrumented with; AddressSanitizer, should be checked for ODR violations. This attribute is; applied to global variables that are dynamically initialized according to; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:115849,variab,variable,115849,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,dex/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/suppor,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80175,refactor,refactor,80175,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"dge(n3,n6);; gs->AddEdge(n4,n5);. TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; }; . This new funtionnality relies on the graphivz package.; This package can be downloaded from; http://www.graphviz.org/. At installation time, to find graphviz, the ROOT's configure file looks in; standard locations. It is possible to define a specific location using the; configure flags:. --with-gviz-incdir=""the directory where gvc.h is""; --with-gviz-libdir=""the directory where the libgvc library is"". To install graphviz (if needed) it is recommended to use the following configure flags:. --enable-static=yes --enable-shared=no --with-pic --prefix=""graphviz installed here"". On 64 bits machines, the ROOT sources are compiled with the option -m64. In; that case graphviz should be also compiled in 64 bits mode. It might be the; default option, but on some machine it is not. In that case the environment; variable CC should be defined as:. CC=""gcc -m64"". before doing configure. On Windows machines it recommended to not install graphviz but to download the; pre-installed version from http://www.graphviz.org/. The ROOT configure command; remains the same.; Graphics Primitives; New class TGraphTime; TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax.; each time step has a new list of objects. This list can be identical to; the list of objects in the previous steps, but with different attributes.; see example of use in $ROOTSYS/tutorials/graphs/gtime.C. TLatex. In the following macro the #int and #sum symbols had; wrong limits placement if the character just before started with ""#"".; ; {; TCanvas *c1 = new TCanvas(""c1"",""c1"",500,500);; TLatex l;; l.SetTextSize(0.1);. l.DrawLatex(0.1,0.6,""#nu#int^{1-x}_{2#pi}"");; l.DrawLatex(0.1,0.2,""a#int^{1-x}_{2#pi}"");. l.DrawLatex(0.5,0.6,""#nu#sum^{1-x}_{2#pi}"");; l.DrawLatex(0.5,0.2,""a#sum^{1-x}_{2#pi}"");; }; . This problem is there since the 1st version of TLatex. It is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html:4185,config,configure,4185,graf2d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v526/index.html,1,['config'],['configure']
Modifiability,"dget, a menu item is a widget, a; scrollbar is a widget, and a complete dialog box is a widget too. Some; widgets may have sub widgets. For example, a dialog box can contain; buttons, text fields, a combo-box, etc. On the screen widgets look like rectangular areas with special; behaviors. In terms of the object-oriented programming we can define a; widget in ROOT as an object of a class deriving from **`TGObject`**. This section presents all currently supported widgets in ROOT and their; most useful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:20816,inherit,inheritance,20816,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inheritance']
Modifiability,"directory and is; stored in the global variable ***`gDirectory`***. Let us look at a more; detailed example of a ROOT file and its role as the current directory.; First, we create a ROOT file by executing a sample script. ``` {.cpp}; root[] .x $ROOTSYS/tutorials/hsimple.C; ```. Now you should have `hsimple.root` in your directory. The file was; closed by the script so we have to open it again to work with it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21211,variab,variable,21211,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"directory. If so, it loads that test suite recursively,; otherwise it instantiates a local test config for the directory (see; :ref:`local-configuration-files`). Tests are identified by the test suite they are contained within, and the; relative path inside that suite. Note that the relative path may not refer to; an actual file on disk; some test formats (such as *GoogleTest*) define; ""virtual tests"" which have a path that contains both the path to the actual; test file and a subpath to identify the virtual test. .. _local-configuration-files:. LOCAL CONFIGURATION FILES; ~~~~~~~~~~~~~~~~~~~~~~~~~. When :program:`lit` loads a subdirectory in a test suite, it instantiates a; local test configuration by cloning the configuration for the parent directory; --- the root of this configuration chain will always be a test suite. Once the; test configuration is cloned :program:`lit` checks for a *lit.local.cfg* file; in the subdirectory. If present, this file will be loaded and can be used to; specialize the configuration for each individual directory. This facility can; be used to define subdirectories of optional tests, or to change other; configuration parameters --- for example, to change the test format, or the; suffixes which identify test files. SUBSTITUTIONS; ~~~~~~~~~~~~~. :program:`lit` allows patterns to be substituted inside RUN commands. It also; provides the following base set of substitutions, which are defined in; TestRunner.py:. ======================= ==============; Macro Substitution; ======================= ==============; %s source path (path to the file currently being run); %S source dir (directory of the file currently being run); %p same as %S; %{pathsep} path separator; %{fs-src-root} root component of file system paths pointing to the LLVM checkout; %{fs-tmp-root} root component of file system paths pointing to the test's temporary directory; %{fs-sep} file system path separator; %t temporary file name unique to the test; %basename_t The last path ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:18684,config,configuration,18684,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['configuration']
Modifiability,"dle in Clang. HLSL is not a conforming or valid extension or superset of C or C++. The; language has key incompatibilities with C and C++, both syntactically and; semantically. An Aside on GPU Languages; -------------------------. Due to HLSL being a GPU targeted language HLSL is a Single Program Multiple Data; (SPMD) language relying on the implicit parallelism provided by GPU hardware.; Some language features in HLSL enable programmers to take advantage of the; parallel nature of GPUs in a hardware abstracted language. HLSL also prohibits some features of C and C++ which can have catastrophic; performance or are not widely supportable on GPU hardware or drivers. As an; example, register spilling is often excessively expensive on GPUs, so HLSL; requires all functions to be inlined during code generation, and does not; support a runtime calling convention. Pointers & References; ---------------------. HLSL does not support referring to values by address. Semantically all variables; are value-types and behave as such. HLSL disallows the pointer dereference; operators (unary ``*``, and ``->``), as well as the address of operator (unary; &). While HLSL disallows pointers and references in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropria",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:6408,variab,variables,6408,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['variab'],['variables']
Modifiability,"documented here.; All globals of this sort should have a section specified as; ""``llvm.metadata``"". This section and all globals that start with; ""``llvm.``"" are reserved for use by LLVM. .. _gv_llvmused:. The '``llvm.used``' Global Variable; -----------------------------------. The ``@llvm.used`` global is an array which has; :ref:`appending linkage <linkage_appending>`. This array contains a list of; pointers to named global variables, functions and aliases which may optionally; have a pointer cast formed of bitcast or getelementptr. For example, a legal; use of it is:. .. code-block:: llvm. @X = global i8 4; @Y = global i32 123. @llvm.used = appending global [2 x ptr] [; ptr @X,; ptr @Y; ], section ""llvm.metadata"". If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler,; and linker are required to treat the symbol as if there is a reference to the; symbol that it cannot see (which is why they have to be named). For example, if; a variable has internal linkage and no references other than that from the; ``@llvm.used`` list, it cannot be deleted. This is commonly used to represent; references from inline asms and other things the compiler cannot ""see"", and; corresponds to ""``attribute((used))``"" in GNU C. On some targets, the code generator must emit a directive to the; assembler or object file to prevent the assembler and linker from; removing the symbol. .. _gv_llvmcompilerused:. The '``llvm.compiler.used``' Global Variable; --------------------------------------------. The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used``; directive, except that it only prevents the compiler from touching the; symbol. On targets that support it, this allows an intelligent linker to; optimize references to the symbol without being impeded as it would be; by ``@llvm.used``. This is a rare construct that should only be used in rare circumstances,; and should not be exposed to source languages. .. _gv_llvmglobalctors:. The '``llvm.global_ctors",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:351551,variab,variable,351551,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) return;; else if (b); return;; else; return;. if (c) return;; else {; return;; }. * ``SIS_AllIfsAndElse`` (in configuration: ``AllIfsAndElse``); Always put short ifs, else ifs and else statements on the same; line. .. code-block:: c++. if (a) return;. if (b) return;; else return;. if (c) return;; else {; return;; }. .. _AllowShortLambdasOnASingleLine:. **AllowShortLambdasOnASingleLine** (``ShortLambdaStyle``) :versionbadge:`clang-format 9` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:30081,config,configuration,30081,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"dom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficiencies belonging into a bin. Since the best; background rejection is in general obtained for the lowest; possible signal efficiency, the reference signal efficiency; is the lowest value in the bin.; ; Cuts: Fixed Cuts (optimisaton) method -> event; with smallest value was not included in search for optimal; cut (thanks to Dimitris Varouchas, LAL-Orsay, for helping; us detecting the problem).; ; Genetic Algorithm: Corrected configurable random; seed in GeneticAlgorithm (thanks to David Gonzalez Maline,; CERN, for pointing this out); ; GUI: Fixes in input-variable and MVA plotting:; under/over-flow numbers given on plots were not properly; normalised; the maximum histogram ranges have been; increased to avoid cut-offs. Thanks to Andreas Wenger,; Zuerich, for pointing these out.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:5555,config,configurable,5555,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,2,"['config', 'variab']","['configurable', 'variable']"
Modifiability,"don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working with the CI system; --------------------------. The main continuous integration (CI) tool for the LLVM project is the; `LLVM Buildbot <https://lab.llvm.org/buildbot/>`_. It uses different *builders*; to cover a wide variety of sub-projects and configurations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/llvm/llvm-project/pulls>`_; (if available) or email the author, explain the problem and how this impacts; you. Add a link to the broken build and the error message so folks can; understand the problem.; * Revert the commit if this blocks your work",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:36163,config,configured,36163,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['config'],['configured']
Modifiability,"downstream-fork.py`` run).; for project in ${subprojects[@]}; do; git remote add local/split/${project} \; https://my.local.mirror.org/${subproject}.git; git fetch local/split/${project}; done. # Import umbrella history.; git -C my-monorepo remote add umbrella \; https://my.local.mirror.org/umbrella.git; git fetch umbrella. # Put myproj in local/myproj; echo ""myproj local/myproj"" > my-monorepo/submodule-map.txt. # Rewrite history; (; cd my-monorepo; zip-downstream-fork.py \; refs/remotes/umbrella \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --old-repo-prefix=refs/remotes/upstream/split \; --revmap-in=monorepo-map.txt \; --revmap-out=zip-map.txt \; --subdir=local \; --submodule-map=submodule-map.txt \; --update-tags; ). # Create the zip branch (assuming umbrella main is wanted).; git -C my-monorepo branch --no-track local/zip/main refs/remotes/umbrella/main. Note that if the umbrella has submodules to non-LLVM repositories,; ``zip-downstream-fork.py`` needs to know about them to be able to; rewrite commits. That is why the first step above is to fetch commits; from such repositories. With ``--update-tags`` the tool will migrate annotated tags pointing; to submodule commits that were inlined into the zipped history. If; the umbrella pulled in an upstream commit that happened to have a tag; pointing to it, that tag will be migrated, which is almost certainly; not what is wanted. The tag can always be moved back to its original; commit after rewriting, or the ``--update-tags`` option may be; discarded and any local tags would then be migrated manually. **Example 2: Nested sources layout**. The tool handles nested submodules (e.g. llvm is a submodule in; umbrella and clang is a submodule in llvm). The file; ``submodule-map.txt`` is a list of pairs, one per line. The first; pair item describes the path to a submodule in the umbrella; repository. The second pair item describes the path where trees for; that submodule should be written in the zipped history. Let's ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:29571,rewrite,rewrite,29571,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['rewrite'],['rewrite']
Modifiability,"dr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the runtime preemption specifier of this variable:. * ``dso_preemptable``: code 0; * ``dso_local``: code 1. .. _FUNCTION:. MODULE_CODE_FUNCTION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[FUNCTION, strtab offset, strtab size, type, callingconv, isproto, linkage, paramattr, alignment, section, visibility, gc, prologuedata, dllstorageclass, comdat, prefixdata, personalityfn, preemptionspecifier]``. The ``FUNCTION`` record (code 8) marks the declaration or definition of a; function. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the function.; See `STRTAB_BLOCK Contents`_. * *type*: The type index of the function type describing th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:29122,variab,variable,29122,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"draw option can include ""+"" sign itself, for superposition one could specify arrays of items and draw options like:. - [item=[hpx;1,hprof;1]&opt=[logy,hist]](https://root.cern/js/latest/?file=../files/hsimple.root&item=[hpx;1,hprof;1]&opt=[logy,hist]). ## TTree draw. JSROOT provides possibility to display TTree data, using [TTree::Draw](https://root.cern/doc/master/classTTree.html) syntax:. - [opt=px](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px); - [opt=px:py](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px:py); - [opt=px:py:pz](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple;1&opt=px:py:pz). It is also possible to use branch by id number specifying name like ""br_0"", ""br_1"" and so on:. - [opt=br_0:br_1](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple&opt=br_0:br_1). Histogram ranges and binning defined after reading first 1000 entries from the tree.; Like in ROOT, one could configure histogram binning and range directly:. - [opt=px:py>>h(50,-5,5,50,-5,5)](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple&opt=px:py>>h%2850,-5,5,50,-5,5%29). One and two dimensional draw expressions can be resulted into TGraph object, using "">>Graph"" as output:. - [opt=px:py>>Graph](https://root.cern/js/latest/?file=../files/hsimple.root&item=ntuple&opt=px:py>>Graph). For any integer value one can accumulate histogram with value bits distribution, specifying as output "">>bits(16)"" or "">>bits"":. - [opt=event.fTracks.fBits>>bits](https://root.cern/js/latest/?file=https://root.cern/files/Event100000.root&item=T;2&opt=event.fTracks.fBits>>bits). There is special handling of TBits objects:. - [opt=event.fTriggerBits](https://root.cern/js/latest/?file=https://root.cern/files/event/event_0.root&item=EventTree&opt=event.fTriggerBits). It is allowed to use different expressions with branch values:. - [opt=px+py:px-py](https://root.cern/js/latest/?file=../files/hsimple.root&ite",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:15320,config,configure,15320,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"ds ``%{inner}`` in the ``RUN:`` line, and the output from the ``echo``; command when then be:. .. code-block:: shell. expanded. To improve performance, lit will stop making passes when it notices the ``RUN:``; line has stopped changing. In the above example, setting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit to 1 will thus cause lit to report an error instead of; producing incorrect output. Options; -------. The llvm lit configuration allows to customize some things with user options:. ``llc``, ``opt``, ...; Substitute the respective llvm tool name with a custom command line. This; allows to specify custom paths and default arguments for these tools.; Example:. % llvm-lit ""-Dllc=llc -verify-machineinstrs"". ``run_long_tests``; Enable the execution of long running tests. ``llvm_site_config``; Load the specified lit configuration instead of the default one. Other Features; --------------. To make RUN line writing easier, there are several helper programs. These; helpers are in the PATH when running tests, so you can just call them using; their name. For example:. ``not``; This program runs its arguments and then inverts the result code from it.; Zero result codes become 1. Non-zero result codes become 0. To make the output more useful, :program:`lit` will scan; the lines of the test case for ones that contain a pattern that matches; ``PR[0-9]+``. This is the syntax for specifying a PR (Problem Report) number; that is related to the test case. The number after ""PR"" specifies the; LLVM Bugzilla number. When a PR number is specified, it will be used in; the pass/fail reporting. This is useful to quickly get some context when; a test fails. Finally, any line that contains ""END."" will cause the special; interpretation of lines to terminate. This is generally done right after; the last RUN: line. This",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:38123,config,configuration,38123,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"ds i1:false; %W = trunc <2 x i16> <i16 8, i16 7> to <2 x i8> ; yields <i8 8, i8 7>. .. _i_zext:. '``zext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = zext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``zext``' instruction zero extends its operand to type ``ty2``. The ``nneg`` (non-negative) flag, if present, specifies that the operand is; non-negative. This property may be used by optimization passes to later; convert the ``zext`` into a ``sext``. Arguments:; """""""""""""""""""". The '``zext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The ``zext`` fills the high order bits of the ``value`` with zero bits; until it reaches the size of the destination type, ``ty2``. When zero extending from i1, the result will always be either 0 or 1. If the ``nneg`` flag is set, and the ``zext`` argument is negative, the result; is a poison value. Example:; """""""""""""""". .. code-block:: llvm. %X = zext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:444034,extend,extending,444034,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability,"dynamic calls will use the DynamicTypeInfo in their; ProgramState to attempt to devirtualize the call. In the case of no dynamic; dispatch, or perfectly constrained devirtualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:11934,config,config,11934,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"e 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile::Open` via XRootD protocol rather than via FUSE when that is possible. The; redirection uses the `eos.url.xroot` extended file attribute that is present on files in EOS.; The attribute can be viewed with `getfattr -n eos.url.xroot [file]` on the command line.; When the URL passed into `TFile::Open` is a for a file on an EOS mount, the extended; attribute is used to attempt the redirection to XRootD protocol. If the redirection fails,; the file is opened using the plain file path as before. This feature is controlled by the; pre-existing configuration option `TFile.CrossProtocolRedirects` and is enabled by default.; It can be disabled by setting `TFile.CrossProtocolRedirects` to `0` in `rootrc`. ## TTree Libraries. ## RNTuple; ROOT's experimental successor of TTree has seen many updates during the last few months. Specifically, v6.28 includes the following changes:. - Complete support for big-endian architectures (PR [#10402](https://github.com/root-project/root/pull/10402)). - Support for `std::pair<T1, T2>` and `std::tuple<Ts...>` fields. - Support for C array fields whose type is of the form `T[N]`. Note that only single-dimension arrays are currently supported. - Improvements to the ROOT file embedding (PR [#10558](https://github.com/root-project/root/pull/10558)). In particular, a `RNTupleReader` or `RDataFram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:8112,extend,extended,8112,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['extend'],['extended']
Modifiability,"e (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ""``Quiet``"", and ""``Quiet2``"") to recognize these options. Note; that the ""``-q``"" option is specified with the ""`cl::Hidden`_"" flag. This; modifier prevents it from being shown by the standard ""``-help``"" output (note; that it is still shown in the ""``-help-hidden``"" output). The CommandLine library uses a `different parser`_ for different data types.; For example, in the string case, the argument passed to the option is copied; literally into the content of the string variable... we obviously cannot do that; in the boolean case, however, so we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the following inputs:. ::. compiler -f # No value, 'Force' == true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value specified, 'Force' == false. ... you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USAGE: compiler [options] <input file>. OPTIONS:; -f - Enable binary output on terminals; -o - Override output filename; -quiet - Don't print informational messages; -help - display available options (-help-hidden for more). and ""``compiler -help-hidden``"" prints this:. ::. U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:10204,variab,variable,10204,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"e (by avoid the fast merge technique). The equivalent in TFileMerger is to call; merger->SetFastMethod(kFALSE); To make sure that the class emulation layer of ROOT does not double delete an object,; tell the StreamerElement representing one of the pointers pointing to the object; to never delete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. The handling of memory by the collection proxy has been improved in the case of a; collection of pointers which can now become owner of its content. The default, for backward compatibility reasons and to avoid double delete (at the expense; of memory leaks), the container of pointers are still not owning their content; unless they are a free standing container (i.e. itself not contained in another; object).; To make a container of pointers become owner of its content do something like:. TClass::AddRule(""ObjectVector<LHCb::MCRichDigitSummary> m_vector options=Owner"");. Added TKey::Reset and TKey::WriteFileKeepBuffer to allow derived classes (TBasket) to be re-use as key rather than always recreated.; TH1::Streamer and TGraph2D::Streamer no longer reset the kCanDelete bit directly so that the user can give; ownership of the object to the canvas they are stored with. However, if they are saved on their own, the mechanism; that associates them to the current directory (DirectoryAutoAdd) will now reset the bit to avoid any possible; ownsership confusion.; Added TFile::SetOffset and TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); to drastically reduce; the number of fseek done on the physical file when using the TTreeCache.; To support future changes in the API of the CollectionProxy, we added the new #define:; ROOT_COLLECTIONPROXY_VERSION and REFLEX_COLLECTIONPROXY_VERSION. Reduce possible confusions and conflicts by always using in TClass and TStreamerInfo the version of template instance names with ULong64_t and Long64_t rather than [unsigned] long long.; new Hadoop TFile plugin. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:12943,plugin,plugin,12943,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,1,['plugin'],['plugin']
Modifiability,"e *BinaryExprAST::codegen() {; // Special case '=' because we don't want to emit the LHS as an expression.; if (Op == '=') {; // This assume we're building without RTTI because LLVM builds that way by; // default. If you build LLVM with RTTI this can be changed to a; // dynamic_cast for automatic error checking.; VariableExprAST *LHSE = static_cast<VariableExprAST*>(LHS.get());; if (!LHSE); return LogErrorV(""destination of '=' must be a variable"");. Unlike the rest of the binary operators, our assignment operator doesn't; follow the ""emit LHS, emit RHS, do computation"" model. As such, it is; handled as a special case before the other binary operators are handled.; The other strange thing is that it requires the LHS to be a variable. It; is invalid to have ""(x+1) = expr"" - only things like ""x = expr"" are; allowed. .. code-block:: c++. // Codegen the RHS.; Value *Val = RHS->codegen();; if (!Val); return nullptr;. // Look up the name.; Value *Variable = NamedValues[LHSE->getName()];; if (!Variable); return LogErrorV(""Unknown variable name"");. Builder->CreateStore(Val, Variable);; return Val;; }; ... Once we have the variable, codegen'ing the assignment is; straightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:21845,variab,variable,21845,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"e = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p);; ^; t.mm:5:6: note: candidate function not viable: no known conversion from 'struct objc_object *' to 'id' for 1st argument; void f(id x);; ^. Code should use types id, SEL, and Class; instead of the internal types. C variables in @interface or @protocol. GCC allows the declaration of C variables in; an @interface or @protocol; declaration. Clang does not allow variable declarations to appear; within these declarations unless they are marked extern.; Variables may still be declared in an @implementation. @interface XX; int a; // not allowed in clang; int b = 1; // not allowed in clang; extern int c; // allowed; @end. C++ compatibility. Variable-length arrays. GCC and C99 allow an array's size to be determined at run; time. This extension is not permitted in standard C++. However, Clang; supports such variable length arrays for compatibility with GNU C and; C99 programs.; If you would prefer not to use this extension, you can disable it with; -Werror=vla. There are several ways to fix your code:. replace the variable length array with a fixed-size array if you can; determine a reasonable upper bound at compile time; sometimes this is as; simple as changing int size = ...; to const int size; = ...; (if the initializer is a compile-time constant);; use std::vector or some other sui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:10614,variab,variables,10614,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability,"e DWARF procedures can use the active lane artificial variable described in; :ref:`amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane` rather than the actual; ``EXEC`` mask in order to support whole or quad wavefront mode. .. _amdgpu-dwarf-amdgpu-dw-at-llvm-active-lane:. ``DW_AT_LLVM_active_lane``; ~~~~~~~~~~~~~~~~~~~~~~~~~~. The ``DW_AT_LLVM_active_lane`` attribute on a subprogram debugger information; entry is used to specify the lanes that are conceptually active for a SIMT; thread. The execution mask may be modified to implement whole or quad wavefront mode; operations. For example, all lanes may need to temporarily be made active to; execute a whole wavefront operation. Such regions would save the ``EXEC`` mask,; update it to enable the necessary lanes, perform the operations, and then; restore the ``EXEC`` mask from the saved value. While executing the whole; wavefront region, the conceptual execution mask is the saved value, not the; ``EXEC`` value. This is handled by defining an artificial variable for the active lane mask. The; active lane mask artificial variable would be the actual ``EXEC`` mask for; normal regions, and the saved execution mask for regions where the mask is; temporarily updated. The location list expression created for this artificial; variable is used to define the value of the ``DW_AT_LLVM_active_lane``; attribute. ``DW_AT_LLVM_augmentation``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. For AMDGPU, the ``DW_AT_LLVM_augmentation`` attribute of a compilation unit; debugger information entry has the following value for the augmentation string:. ::. [amdgpu:v0.0]. The ""vX.Y"" specifies the major X and minor Y version number of the AMDGPU; extensions used in the DWARF of the compilation unit. The version number; conforms to [SEMVER]_. Call Frame Information; ----------------------. DWARF Call Frame Information (CFI) describes how a consumer can virtually; *unwind* call frames in a running process or core dump. See DWARF Version 5; section 6.4 and :ref:`amdgpu-dwarf-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:109982,variab,variable,109982,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"e DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17541,variab,variable,17541,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"e FLT_MAX mechanism for `THStack::GetMaximum()` and `THStack::GetMiniumum()`.; - Print a warning when the range given to `TAxis::SetRange` is invalid.; - Fix projection name in `TH3` as requested [here](https://root-forum.cern.ch/t/project3d-letter-d-in-name-option/57612). ## Parallelism; - The ROOT::Experimental::TFuture template has been removed. ## RooFit Libraries. ### New CPU likelihood evaluation backend by default. The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods.; Likelihood minimization is now up to 10x faster on a single CPU core. If you experience unexpected problems related to the likelihood evaluation, you; can revert back to the old backend by passing `RooFit::EvalBackend(""legacy"")`; to `RooAbsPdf::fitTo()` or `RooAbsPdf::createNLL()`. In case you observe any slowdowns with the new likelihood evaluation, please; open a GitHub issue about this, as such a performance regression is considered; a bug. ### Asymptotically correct uncertainties for extended unbinned likelihood fits. Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights.; This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the `RooFit::AsymptoticError()` command argument in [RooAbsPdf::fitTo()](https://root.cern.ch/doc/master/classRooAbsPdf.html#ab0721374836c343a710f5ff92a326ff5).; See also this [writeup on extended weighted fits](https://root.cern/files/extended_weighted_fits.pdf) that is also linked from the reference guide.; The [pull request](https://github.com/root-project/root/pull/14751) that introduced this feature might also be a good reference. ### Compile your code with memory safe interfaces. If you define the `ROOFIT_MEMORY_SAFE_INTERFACES` preprocessor macro, the; RooFit interface changes in a way such that memory leaks are avoided. The most prominent effect of this change is that many functions ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:7643,extend,extended,7643,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['extend'],['extended']
Modifiability,"e Gradients With the Fletcher-Reeves Updating Formula. Weights are set to the minimum along the line defined by the conjugate; gradient. Parameters are `Tau` and `Reset`, which defines the epochs; where the direction is reset to the steepest descent (estimated by; using the Fletcher-Reeves formula). #### The Broyden, Fletcher, Goldfarb, Shanno (BFGS) Method. It implies the computation of a `NxN` matrix, but seems more powerful; at least for less than 300 weights. Parameters are `Tau` and `Reset`,; which defines the epochs where the direction is reset to the steepest; descent. ### Using the Network. Neural network are build from a set of ""samples"". A sample is a set of; values defining the inputs and the corresponding output that the; network should ideally provide. In ROOT this is a **`TTree`** entry.; The first thing to be decided is the network layout. This layout is; described in a string where the layers are separated by semicolons.; The input/output layers are defined by giving the expression for each; neuron, separated by comas. Hidden layers are just described by the; number of neurons. In addition, input and output layer formulas can be preceded by '@'; (e.g. ""@out"") if one wants to normalize the corresponding value. Also,; if the string ends with '`!`', output neurons are set up for; classification, i.e. with a sigmoid (1 neuron) or softmax (more; neurons) activation function. Many questions on the good usage of neural network, including rules of; dumb to determine the best network topology are addressed at; <ftp://ftp.sas.com/pub/neural/FAQ.html>. ``` {.cpp}; // a simple network: 2 inputs, 10 hidden and 1 normalized; // output neuron; TMultiLayerPerceptron network(""r,z:10:@Br"",tree);; ```. Expressions are evaluated as for `TTree::Draw()`. Input and outputs; are taken from the **`TTree`** associated with the network. This; **`TTree`** can be given as argument of the constructor or defined; later with `TMultiLayerPerceptron::SetData()`. Events can also be; w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:74450,layers,layers,74450,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['layers'],['layers']
Modifiability,"e Linux distributions multiarch; support to fulfill the dependencies for building but unfortunately due to; /usr/local/include being added some host includes are selected. The easiest way; to supply a sysroot is to download the arm-linux-gnueabihf toolchain. This can; be found at:; * https://developer.arm.com/open-source/gnu-toolchain/gnu-a/downloads for gcc 8 and above; * https://releases.linaro.org/components/toolchain/binaries/ for gcc 4.9 to 7.3. Building compiler-rt builtins for Arm; =====================================; We will be doing a standalone build of compiler-rt using the following cmake; options. * ``path/to/compiler-rt``; * ``-G Ninja``; * ``-DCMAKE_AR=/path/to/llvm-ar``; * ``-DCMAKE_ASM_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_ASM_FLAGS=""build-c-flags""``; * ``-DCMAKE_C_COMPILER=/path/to/clang``; * ``-DCMAKE_C_COMPILER_TARGET=""arm-linux-gnueabihf""``; * ``-DCMAKE_C_FLAGS=""build-c-flags""``; * ``-DCMAKE_EXE_LINKER_FLAGS=""-fuse-ld=lld""``; * ``-DCMAKE_NM=/path/to/llvm-nm``; * ``-DCMAKE_RANLIB=/path/to/llvm-ranlib``; * ``-DCOMPILER_RT_BUILD_BUILTINS=ON``; * ``-DCOMPILER_RT_BUILD_LIBFUZZER=OFF``; * ``-DCOMPILER_RT_BUILD_MEMPROF=OFF``; * ``-DCOMPILER_RT_BUILD_PROFILE=OFF``; * ``-DCOMPILER_RT_BUILD_SANITIZERS=OFF``; * ``-DCOMPILER_RT_BUILD_XRAY=OFF``; * ``-DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON``; * ``-DLLVM_CONFIG_PATH=/path/to/llvm-config``. The ``build-c-flags`` need to be sufficient to pass the C-make compiler check,; compile compiler-rt, and if you are running the tests, compile and link the; tests. When cross-compiling with clang we will need to pass sufficient; information to generate code for the Arm architecture we are targeting. We will; need to select the Arm target, select the Armv7-A architecture and choose; between using Arm or Thumb.; instructions. For example:. * ``--target=arm-linux-gnueabihf``; * ``-march=armv7a``; * ``-mthumb``. When using a GCC arm-linux-gnueabihf toolchain the following flags are; needed to pick up the includes a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:3343,config,config,3343,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['config'],['config']
Modifiability,"e MVC, XC and CLC for constant-length block operations.; We could extend them to variable-length operations too,; using EXECUTE RELATIVE LONG. MVCIN, MVCLE and CLCLE may be worthwhile too. --. We don't use CUSE or the TRANSLATE family of instructions for string; operations. The TRANSLATE ones are probably more difficult to exploit. --. We don't take full advantage of builtins like fabsl because the calling; conventions require f128s to be returned by invisible reference. --. ADD LOGICAL WITH SIGNED IMMEDIATE could be useful when we need to; produce a carry. SUBTRACT LOGICAL IMMEDIATE could be useful when we; need to produce a borrow. (Note that there are no memory forms of; ADD LOGICAL WITH CARRY and SUBTRACT LOGICAL WITH BORROW, so the high; part of 128-bit memory operations would probably need to be done; via a register.). --. We don't use ICM, STCM, or CLM. --. We don't use ADD (LOGICAL) HIGH, SUBTRACT (LOGICAL) HIGH,; or COMPARE (LOGICAL) HIGH yet. --. DAGCombiner doesn't yet fold truncations of extended loads. Functions like:. unsigned long f (unsigned long x, unsigned short *y); {; return (x << 32) | *y;; }. therefore end up as:. sllg %r2, %r2, 32; llgh %r0, 0(%r3); lr %r2, %r0; br %r14. but truncating the load would give:. sllg %r2, %r2, 32; lh %r2, 0(%r3); br %r14. --. Functions like:. define i64 @f1(i64 %a) {; %and = and i64 %a, 1; ret i64 %and; }. ought to be implemented as:. lhi %r0, 1; ngr %r2, %r0; br %r14. but two-address optimizations reverse the order of the AND and force:. lhi %r0, 1; ngr %r0, %r2; lgr %r2, %r0; br %r14. CodeGen/SystemZ/and-04.ll has several examples of this. --. Out-of-range displacements are usually handled by loading the full; address into a register. In many cases it would be better to create; an anchor point instead. E.g. for:. define void @f4a(i128 *%aptr, i64 %base) {; %addr = add i64 %base, 524288; %bptr = inttoptr i64 %addr to i128 *; %a = load volatile i128 *%aptr; %b = load i128 *%bptr; %add = add i128 %a, %b; store i128 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt:2020,extend,extended,2020,interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/README.txt,1,['extend'],['extended']
Modifiability,"e TableGen; definitions in a compact manner. - OpenCL specific code in ``SemaLookup.cpp``. When ``Sema::LookupBuiltin``; encounters a potential builtin function, it will check if the name corresponds; to a valid OpenCL builtin function. If so, all overloads of the function are; inserted using ``InsertOCLBuiltinDeclarationsFromTable`` and overload; resolution takes place. OpenCL Extensions and Features; ------------------------------. Clang implements various extensions to OpenCL kernel languages. New functionality is accepted as soon as the documentation is detailed to the; level sufficient to be implemented. There should be an evidence that the; extension is designed with implementation feasibility in consideration and; assessment of complexity for C/C++ based compilers. Alternatively, the; documentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:8301,extend,extend,8301,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['extend'],['extend']
Modifiability,"e XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to define the dataset information; sources via the directive 'xpd.datasetsrc'.; In this way the permissions; should be set correctly and the related problems disappear.; Record the logs from the ROOT version validation tests; (proofserv forked in test mode). In case of failure - or if the debug; flag is on - the log files are kept under; <xproof_adminpath>/rootsysvalidation/root.<tag>.log; (the <tag> has all the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:2488,config,configuration,2488,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['config'],['configuration']
Modifiability,e [External Suites](#external-suites). - `Bitcode/`. These tests are mostly written in LLVM bitcode. - `CTMark/`. Contains symbolic links to other benchmarks forming a representative sample; for compilation performance measurements. ### Benchmarks. Every program can work as a correctness test. Some programs are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:4275,variab,variable,4275,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"e ``HasCustomParsing`` bit can be set to ``1`` for the class,; and the parsing code in `Parser::ParseGNUAttributeArgs(); <https://github.com/llvm/llvm-project/blob/main/clang/lib/Parse/ParseDecl.cpp>`_; can be updated for the special case. Note that this only applies to arguments; with a GNU spelling -- attributes with a __declspec spelling currently ignore; this flag and are handled by ``Parser::ParseMicrosoftDeclSpec``. Note that setting this member to 1 will opt out of common attribute semantic; handling, requiring extra implementation efforts to ensure the attribute; appertains to the appropriate subject, etc. If the attribute should not be propagated from a template declaration to an; instantiation of the template, set the ``Clone`` member to 0. By default, all; attributes will be cloned to template instantiations. Attributes that do not require an AST node should set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:138789,inherit,inheriting,138789,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inheriting']
Modifiability,"e ``__block`` variable resides in allocated storage and as such; is assumed to reference a Block that is also in allocated storage; (that it is the result of a ``Block_copy`` operation). Despite this; there is no provision to do a ``Block_copy`` or a ``Block_release`` if; an implementation provides initial automatic storage for Blocks. This; is due to the inherent race condition of potentially several threads; trying to update the shared variable and the need for synchronization; around disposing of older values and copying new ones. Such; synchronization is beyond the scope of this language specification. Control Flow; ============. The compound statement of a Block is treated much like a function body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:8670,extend,extends,8670,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['extend'],['extends']
Modifiability,"e `fEstimate` can be set via `TTree::SetEstimate`. If you have more; entries than `fEstimate` only the first `fEstimate` selected entries; will be stored in the arrays. The arrays are used as buffers. When; `fEstimate` entries have been processed, ROOT scans the buffers to; compute the minimum and maximum of each coordinate and creates the; corresponding histograms. You can use these lines to read all entries; into these arrays:. ``` {.cpp}; root[] Int_t nestimate = (Int_t)T->GetEntries();; root[] T->SetEstimate(nestimate);; ```. Obviously, this will not work if the number of entries is very large.; This technique is useful in several cases, for example if you want to; draw a graph connecting all the `x`, `y(or z)` points. Note that you may; have a tree (or chain) with 1 billion entries, but only a few may; survive the cuts and will fit without problems in these arrays. ## Using TTree::MakeClass; \index{tree!MakeClass}. The `TTree::Draw` method is convenient and easy to use; however it falls; short if you need to do some programming with the variable. For example, for plotting the masses of all oppositely changed pairs of; tracks, you would need to write a program that loops over all events,; finds all pairs of tracks, and calculates the required quantities. We; have shown how to retrieve the data arrays from the branches of the tree; in the previous section, and you could just write that program from; scratch. Since this is a very common task, ROOT provides a utility that; generates a skeleton class designed to loop over the entries of the; tree. This is the `TTree::MakeClass` method. We will now go through the steps; of using `MakeClass` with a simplified example. The methods used here; obviously work for complex event loop calculations. These are our assumptions: we would like to do selective plotting and; loop through each entry of the tree and tracks. We chose a simple; example: we want to plot `fPx` of the first 100 tracks of each entry. We; have a ROOT tree w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:121135,variab,variable,121135,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"e `libc++ C++ standard library <https://libcxx.llvm.org>`_,; the `LLD linker <https://lld.llvm.org>`_, and more. Getting the Source Code and Building LLVM; =========================================. #. Check out LLVM (including subprojects like Clang):. * ``git clone https://github.com/llvm/llvm-project.git``; * Or, on windows:. ``git clone --config core.autocrlf=false; https://github.com/llvm/llvm-project.git``; * To save storage and speed-up the checkout time, you may want to do a; `shallow clone <https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---depthltdepthgt>`_.; For example, to get the latest revision of the LLVM project, use. ``git clone --depth 1 https://github.com/llvm/llvm-project.git``. * You are likely only interested in the main branch moving forward, if; you don't want `git fetch` (or `git pull`) to download user branches, use:. ``sed 's#fetch = +refs/heads/\*:refs/remotes/origin/\*#fetch = +refs/heads/main:refs/remotes/origin/main#' -i llvm-project/.git/config``. #. Configure and build LLVM and Clang:. * ``cd llvm-project``; * ``cmake -S llvm -B build -G <generator> [options]``. Some common build system generators are:. * ``Ninja`` --- for generating `Ninja <https://ninja-build.org>`_; build files. Most llvm developers use Ninja.; * ``Unix Makefiles`` --- for generating make-compatible parallel makefiles.; * ``Visual Studio`` --- for generating Visual Studio projects and; solutions.; * ``Xcode`` --- for generating Xcode projects. * See the `CMake docs; <https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html>`_; for a more comprehensive list. Some common options:. * ``-DLLVM_ENABLE_PROJECTS='...'`` --- semicolon-separated list of the LLVM; subprojects you'd like to additionally build. Can include any of: clang,; clang-tools-extra, lldb, lld, polly, or cross-project-tests. For example, to build LLVM, Clang, and LLD, use; ``-DLLVM_ENABLE_PROJECTS=""clang;lld""``. * ``-DCMAKE_INSTALL_PREFIX=directory`` --- Specify for *directory* t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:1784,config,config,1784,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['config']
Modifiability,"e algorithm is controlled by the given absolute and relative tolerance. The iterations are continued until the following condition is satisfied; $$; absErr <= max ( epsAbs, epsRel * Integral); $$; Where *absErr* is an estimate of the absolute error (it can be retrieved with `GSLIntegrator::Error()`) and *Integral* is the estimate of the function integral; (it can be obtained with `GSLIntegrator::Result()`). The possible integration algorithm types to use with the GSLIntegrator are the following. More information is provided in the `GSL` users documentation.; * `ROOT::Math::Integration::kNONADAPTIVE` : based on `gsl_integration_qng`. It is a non-adaptive procedure which uses fixed Gauss-Kronrod-Patterson abscissae; to sample the integrand at a maximum of 87 points. It is provided for fast integration of smooth functions.; * `ROOT::Math::Integration::kADAPTIVE`: based on `gsl_integration_qag`. It is an adaptiva Gauss-Kronrod integration algorithm, the integration region is divided into subintervals, and on each; iteration the subinterval with the largest estimated error is bisected. It is possible to specify the integration rule as an extra enumeration parameter. The possible rules are; * `Integration::kGAUSS15` : 15 points Gauss-Konrod rule (value = 1); * `Integration::kGAUSS21` : 21 points Gauss-Konrod rule (value = 2); * `Integration::kGAUSS31` : 31 points Gauss-Konrod rule (value = 3); * `Integration::kGAUSS41` : 41 points Gauss-Konrod rule (value = 4); * `Integration::kGAUSS51` : 51 points Gauss-Konrod rule (value = 5); * `Integration::kGAUSS61` : 61 points Gauss-Konrod rule (value = 6); 	 The higher-order rules give better accuracy for smooth functions, while lower-order rules save time when the function contains local difficulties, such as discontinuities. If no integration rule; 	 is passed, the 31 points rule is used as default. * 	 `ROOT::Math::Integration::kADAPTIVESINGULAR`: based on `gsl_integration_qags`. It is an integration type which can be used in the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:56553,adapt,adaptiva,56553,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['adapt'],['adaptiva']
Modifiability,"e alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17903,variab,variable,17903,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability,"e always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15216,config,config,15216,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config']
Modifiability,"e an object to be; deallocated during a message send to that object. In an init method, ``self``; follows the :ref:``init family rules <arc.family.semantics.init>``. .. admonition:: Rationale. The cost of retaining ``self`` in all methods was found to be prohibitive, as; it tends to be live across calls, preventing the optimizer from proving that; the retain and release are unnecessary --- for good reason, as it's quite; possible in theory to cause an object to be deallocated during its execution; without this retain and release. Since it's extremely uncommon to actually; do so, even unintentionally, and since there's no natural way for the; programmer to remove this retain/release pair otherwise (as there is for; other parameters by, say, making the variable ``objc_externally_retained`` or; qualifying it with ``__unsafe_unretained``), we chose to make this optimizing; assumption and shift some amount of risk to the user. .. _arc.misc.enumeration:. Fast enumeration iteration variables; ------------------------------------. If a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:95399,variab,variables,95399,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"e and Building; --------------------------. Finally, if you're using your platform compiler, run:. .. code-block:: bash. $ cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you're using Clang as the cross-compiler, run:. .. code-block:: bash. $ CC='clang' CXX='clang++' cmake -G Ninja <source-dir> -DCMAKE_BUILD_TYPE=<type> <options above>. If you have ``clang``/``clang++`` on the path, it should just work, and special; Ninja files will be created in the build directory. I strongly suggest; you to run ``cmake`` on a separate build directory, *not* inside the; source tree. To build, simply type:. .. code-block:: bash. $ ninja. It should automatically find out how many cores you have, what are; the rules that needs building and will build the whole thing. You can't run ``ninja check-all`` on this tree because the created; binaries are targeted to ARM, not x86_64. Installing and Using; --------------------. After the LLVM/Clang has built successfully, you should install it; via:. .. code-block:: bash. $ ninja install. which will create a sysroot on the install-dir. You can then tar; that directory into a binary with the full triple name (for easy; identification), like:. .. code-block:: bash. $ ln -sf <install-dir> arm-linux-gnueabihf-clang; $ tar zchf arm-linux-gnueabihf-clang.tar.gz arm-linux-gnueabihf-clang. If you copy that tarball to your target board, you'll be able to use; it for running the test-suite, for example. Follow the guidelines at; https://llvm.org/docs/lnt/quickstart.html, unpack the tarball in the; test directory, and use options:. .. code-block:: bash. $ ./sandbox/bin/python sandbox/bin/lnt runtest nt \; --sandbox sandbox \; --test-suite `pwd`/test-suite \; --cc `pwd`/arm-linux-gnueabihf-clang/bin/clang \; --cxx `pwd`/arm-linux-gnueabihf-clang/bin/clang++. Remember to add the ``-jN`` options to ``lnt`` to the number of CPUs; on your board. Also, the path to your clang has to be absolute, so; you'll need the `pwd` trick above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst:7744,sandbox,sandbox,7744,interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileLLVM.rst,4,['sandbox'],['sandbox']
Modifiability,"e as the executable. OPTIONS; -------; .. option:: --accelerator=<accelerator type>. Specify the desired type of accelerator table. Valid options are 'Apple',; 'Dwarf', 'Default' and 'None'. .. option:: --arch <arch>. Link DWARF debug information only for specified CPU architecture types.; Architectures may be specified by name. When using this option, an error will; be returned if any architectures can not be properly linked. This option can; be specified multiple times, once for each desired architecture. All CPU; architectures will be linked by default and any architectures that can't be; properly linked will cause :program:`dsymutil` to return an error. .. option:: --build-variant-suffix <suffix=buildvariant>. Specify the build variant suffix used to build the executable file.; There can be multiple variants for the binary of a product, each built; slightly differently. The most common build variants are 'debug' and; 'profile'. Setting the DYLD_IMAGE_SUFFIX environment variable will; cause dyld to load the specified variant at runtime. .. option:: --dump-debug-map. Dump the *executable*'s debug-map (the list of the object files containing the; debug information) in YAML format and exit. No DWARF link will take place. .. option:: -D <path>. Specify a directory that contain dSYM files to search for.; This is used for mergeable libraries, so dsymutil knows where to look; for dSYM files with debug information about symbols present in those; libraries. .. option:: --fat64. Use a 64-bit header when emitting universal binaries. .. option:: --flat, -f. Produce a flat dSYM file. A ``.dwarf`` extension will be appended to the; executable name unless the output file is specified using the ``-o`` option. .. option:: --gen-reproducer. Generate a reproducer consisting of the input object files. Alias for; --reproducer=GenerateOnExit. .. option:: --help, -h. Print this help output. .. option:: --keep-function-for-static. Make a static variable keep the enclosing function even ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst:1489,variab,variable,1489,interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,1,['variab'],['variable']
Modifiability,"e been solved. Step #3: Write Access Move; --------------------------. 9. Collect developers' GitHub account information, and add them to the project.; 10. Switch the SVN repository to read-only and allow pushes to the GitHub repository.; 11. Update the documentation.; 12. Mirror Git to SVN. Step #4 : Post Move; -------------------. 13. Archive the SVN repository.; 14. Update links on the LLVM website pointing to viewvc/klaus/phab etc. to; point to GitHub instead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all sub-projects in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revisi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:8887,refactor,refactoring,8887,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['refactor'],['refactoring']
Modifiability,"e being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beginning of the scope on the declare. One interesting thing to note at this point is that various debuggers have; assumptions based on how code and debug information was generated for them; in the past. In this case we need to do a little bit of a hack to avoid; generating line information for the function prologue so that the debugger; knows to skip over those instructions when setting a breakpoint. So in; ``FunctionAST::CodeGen`` we add some more lines:. .. code-block:: c++. // Unset the location for the prologue emission (leading instructions with no; // location in a function are considered part of the prologue and the debugger; // will run past them when breaking on a function); KSDbgInfo.emitLocation(n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:14071,variab,variable,14071,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variable']
Modifiability,"e believe that the C and C++ tools; ecosystem has been significantly limited by how difficult it is to parse and; represent the source code for these languages, and we aim to rectify this; problem in clang.; The problem with this goal is that different clients have very different; requirements. Consider code generation, for example: a simple front-end that; parses for code generation must analyze the code for validity and emit code; in some intermediate form to pass off to a optimizer or backend. Because; validity analysis and code generation can largely be done on the fly, there is; not hard requirement that the front-end actually build up a full AST for all; the expressions and statements in the code. TCC and GCC are examples of; compilers that either build no real AST (in the former case) or build a stripped; down and simplified AST (in the later case) because they focus primarily on; codegen.; On the opposite side of the spectrum, some clients (like refactoring) want; highly detailed information about the original source code and want a complete; AST to describe it with. Refactoring wants to have information about macro; expansions, the location of every paren expression '(((x)))' vs 'x', full; position information, and much more. Further, refactoring wants to look; across the whole program to ensure that it is making transformations; that are safe. Making this efficient and getting this right requires a; significant amount of engineering and algorithmic work that simply are; unnecessary for a simple static compiler.; The beauty of the clang approach is that it does not restrict how you use it.; In particular, it is possible to use the clang preprocessor and parser to build; an extremely quick and light-weight on-the-fly code generator (similar to TCC); that does not build an AST at all. As an intermediate step, clang supports; using the current AST generation and semantic analysis code and having a code; generation client free the AST for each function after co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:7598,refactor,refactoring,7598,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['refactor'],['refactoring']
Modifiability,"e between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashbo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:3387,config,configuration,3387,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,2,"['config', 'variab']","['configuration', 'variables']"
Modifiability,"e blocks throughout the file; at intervals of BlockSize. Because each FPM block is of size ``BlockSize``; bytes, it contains 8 times as many bits as an interval has blocks. This means; that the first block of each FPM refers to the first 8 intervals of the file; (the first 32768 blocks), the second block of each FPM refers to the next 8; blocks, and so on. This results in far more FPM blocks being present than are; required, but in order to maintain backwards compatibility the format must stay; this way. The Stream Directory; ====================; The Stream Directory is the root of all access to the other streams in an MSF; file. Beginning at byte 0 of the stream directory is the following structure:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams;; ulittle32_t StreamSizes[NumStreams];; ulittle32_t StreamBlocks[NumStreams][];; };. And this structure occupies exactly ``SuperBlock->NumDirectoryBytes`` bytes.; Note that each of the last two arrays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9000};; ulittle32_t StreamBlocks[][] = {; {4},; {5, 6},; {11, 9, 7, 8},; {10, 15, 12}; };; };. In total, this occupies ``15 * 4 = 60`` bytes, so; ``SuperBlock->NumDirectoryBytes`` would equal ``60``, and; ``SuperBlock->BlockMapAddr`` would be an array of one ``ulittle32_t``, since; ``60 <= SuperBlock->BlockSize``. Note also that the streams are discontiguous, and that part of stream 3 is in the; middle of part of stream 2. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:5728,variab,variable,5728,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['variab'],['variable']
Modifiability,"e bodies go out of scope; when the bodies are finished (see `Defvar in a Record Body`_ for more details). The ``if`` statement can also be used in a record :token:`Body`. ``assert`` --- check that a condition is true; ---------------------------------------------. The ``assert`` statement checks a boolean condition to be sure that it is true; and prints an error message if it is not. .. productionlist::; Assert: ""assert"" `condition` "","" `message` "";"". If the boolean condition is true, the statement does nothing. If the; condition is false, it prints a nonfatal error message. The **message**, which; can be an arbitrary string expression, is included in the error message as a; note. The exact behavior of the ``assert`` statement depends on its; placement. * At top level, the assertion is checked immediately. * In a record definition, the statement is saved and all assertions are; checked after the record is completely built. * In a class definition, the assertions are saved and inherited by all; the subclasses and records that inherit from the class. The assertions are; then checked when the records are completely built. * In a multiclass definition, the assertions are saved with the other; components of the multiclass and then checked each time the multiclass; is instantiated with ``defm``. Using assertions in TableGen files can simplify record checking in TableGen; backends. Here is an example of an ``assert`` in two class definitions. .. code-block:: text. class PersonName<string name> {; assert !le(!size(name), 32), ""person name is too long: "" # name;; string Name = name;; }. class Person<string name, int age> : PersonName<name> {; assert !and(!ge(age, 1), !le(age, 120)), ""person age is invalid: "" # age;; int Age = age;; }. def Rec20 : Person<""Donald Knuth"", 60> {; ...; }. Additional Details; ==================. Directed acyclic graphs (DAGs); ------------------------------. A directed acyclic graph can be represented directly in TableGen using the; ``dag`` dataty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:49662,inherit,inherited,49662,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,2,['inherit'],"['inherit', 'inherited']"
Modifiability,"e cache. The BinInterface tries to find live-outs for traces so that it can do; register allocation on just the trace, and stitch the trace back into; the original code. It has to preserve the live-ins and live-outs when; it does its register allocation. (On exits from the trace we have; epilogues that copy live-outs back into the right registers, but; live-ins have to be in the right registers.). Limitations of BinInterface; ---------------------------. It does copy insertions for PHIs, which it infers from the machine; code. The mapping info inserted by LLC is not sufficient to determine; the PHIs. It does not handle integer or floating-point condition codes and it; does not handle floating-point register allocation. It is not aggressively able to use lots of registers. There is a problem with alloca: we cannot find our spill space for; spilling registers, normally allocated on the stack, if the trace; follows an alloca(). What might be an acceptable solution would be to; disable trace generation on functions that have variable-sized; alloca()s. Variable-sized allocas in the trace would also probably; screw things up. Because of the FP and alloca limitations, the BinInterface is; completely disabled right now. Demo; ----. This is a demo of the Ball & Larus version that does NOT use 2-level; profiling. 1. Compile program with llvm-gcc.; 2. Run opt -lowerswitch -paths -emitfuncs on the bytecode.; -lowerswitch change switch statements to branches; -paths Ball & Larus path-profiling algorithm; -emitfuncs emit the table of functions; 3. Run llc to generate SPARC assembly code for the result of step 2.; 4. Use g++ to link the (instrumented) assembly code. We use a script to do all this:; ------------------------------------------------------------------------------; #!/bin/sh; llvm-gcc $1.c -o $1; opt -lowerswitch -paths -emitfuncs $1.bc > $1.run.bc; llc -f $1.run.bc ; LIBS=$HOME/llvm_sparc/lib/Debug; GXX=/usr/dcs/software/evaluation/bin/g++; $GXX -g -L $LIBS $1.run.s -o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt:1786,variab,variable-sized,1786,interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2003-06-26-Reoptimizer2.txt,1,['variab'],['variable-sized']
Modifiability,"e call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems, you need to use structures with same length members.; If your structure does not qualify, you need to create one branch for; each element of the structure. The leaf name is NOT used to pick the variable out of the structure, but; is only used as the name for the leaf. This means that the list of; variables needs to be in a structure in the order described in the third; parameter. This third parameter is a string describing the leaf list. Each leaf has; a name and a type separated by a ""/"" and it is separated from the next; leaf by a ""`:`"". ``` {.cpp}; <Variable>/<type>:<Variable>/<type>; ```. The example on the next line has two leafs: a floating-point number; called temp and an integer named `ntrack`. ``` {.cpp}; ""temp/F:ntr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:19701,variab,variable,19701,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"e captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47312,variab,variables,47312,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variables']
Modifiability,"e care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%`. `set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%`. where `$ROOTSYS` should be set to; `/afs/cern.ch/sw/root/<version>/<platform>`, and `PYTHONDIR` to; `/afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform>` with `<version>`; and `<platform>` as appropriate. Note that the latest version of Python; is 2.4.1. #### Building from Source. The standard installation instructions for building ROOT from source; apply, with the addition that the build of `PyROOT` needs to be enabled; at the configuration step. First, follow the instructions for obtaining; and unpacking the source, and setting up the build environment. Then, use the following command to configure the build process (of; course, feel free to add any additional flags you may need):. `$ ./configure <arch> [--with-python-incdir=<dir>][--with-python-libdir=>dir>]`. For details on `<arch>` see the official build pages, the Python include; directory should point to the directory that contains `Python.h` and the; library directory should point to the directory containing; `libpythonx.y.so`, where '`x`' and '`y`' are the major and minor version; number, respectively. If you do not specify include and library; directories explicitly, the configuration process will try the; `PYTHONDIR` environment variable or, alternatively, the standard; locations. A recent distribution of Python is required: version 2.4.3 is preferred,; but the older 2.2.x and 2.3.x v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:6850,config,configuration,6850,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['config'],['configuration']
Modifiability,"e caveat. .. _arc.optimization.precise:. Precise lifetime semantics; --------------------------. In general, ARC maintains an invariant that a retainable object pointer held in; a ``__strong`` object will be retained for the full formal lifetime of the; object. Objects subject to this invariant have :arc-term:`precise lifetime; semantics`. By default, local variables of automatic storage duration do not have precise; lifetime semantics. Such objects are simply strong references which hold; values of retainable object pointer type, and these values are still fully; subject to the optimizations on values under local control. .. admonition:: Rationale. Applying these precise-lifetime semantics strictly would be prohibitive.; Many useful optimizations that might theoretically decrease the lifetime of; an object would be rendered impossible. Essentially, it promises too much. A local variable of retainable object owner type and automatic storage duration; may be annotated with the ``objc_precise_lifetime`` attribute to indicate that; it should be considered to be an object with precise lifetime semantics. .. admonition:: Rationale. Nonetheless, it is sometimes useful to be able to force an object to be; released at a precise time, even if that object does not appear to be used.; This is likely to be uncommon enough that the syntactic weight of explicitly; requesting these semantics will not be burdensome, and may even make the code; clearer. .. _arc.misc:. Miscellaneous; =============. .. _arc.misc.special_methods:. Special methods; ---------------. .. _arc.misc.special_methods.retain:. Memory management methods; ^^^^^^^^^^^^^^^^^^^^^^^^^. A program is ill-formed if it contains a method definition, message send, or; ``@selector`` expression for any of the following selectors:. * ``autorelease``; * ``release``; * ``retain``; * ``retainCount``. .. admonition:: Rationale. ``retainCount`` is banned because ARC robs it of consistent semantics. The; others were banned after we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:84344,variab,variable,84344,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"e character literals and multicharacter wide character literals; P2362R3; Clang 14. Labels at the end of compound statements; P2324R2; Clang 16. Delimited escape sequences; P2290R3; Clang 15. Named universal character escapes; P2071R2; Clang 15. Relaxing some constexpr restrictions; P2448R2. Clang 17 (Partial); 	 We do not support outside of defaulted special memeber functions the change that constexpr functions no; longer have to be constexpr compatible but rather support a less restricted requirements for constexpr; functions. Which include allowing non-literal types as return values and parameters, allow calling of; non-constexpr functions and constructors.; . Using unknown pointers and references in constant expressions; P2280R4 (DR); No. static operator(); P1169R4; Clang 16. Extended floating-point types and standard names; P1467R9; No. Class template argument deduction from inherited constructors; P2582R1; No. Portable assumptions; P1774R8; No. Support for UTF-8 as a portable source file encoding; P2295R6; Clang 15. char8_t Compatibility and Portability Fix; P2513R3; Clang 16. Relax requirements on wchar_t to match existing practices; P2460R2; Yes. Explicit lifetime management; P2590R2; No. static operator[]; P2589R1; Clang 16. Permitting static constexpr variables in constexpr functions; P2647R1; Clang 16. consteval needs to propagate up; P2564R3 (DR); Clang 17. Lifetime extension in range-based for loops; P2718R0; No. Referencing The Unicode Standard; P2736R2; Yes. C++20 implementation status; Clang has support for some of the features of the; ISO C++ 2020 standard.; You can use Clang in C++20 mode with the -std=c++20 option; (use -std=c++2a in Clang 9 and earlier). List of features and minimum Clang version with support. Language Feature; C++20 Proposal; Available in Clang?. Default member initializers for bit-fields; P0683R1; Clang 6. const&-qualified pointers to members; P0704R1; Clang 6. Allow lambda-capture [=, this]; P0409R2; Clang 6. __VA_OPT__ for pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:5000,portab,portable,5000,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['portab'],['portable']
Modifiability,"e character. This mode matches the emitted diagnostic when the; text appears as a substring at any position of the emitted message. To enable matching against desired strings that contain `}}` or `{{`, the; string-mode parser accepts opening delimiters of more than two curly braces,; like `{{{`. It then looks for a closing delimiter of equal ""width"" (i.e `}}}`).; For example:. .. code-block:: c++. // expected-note {{{evaluates to '{{2, 3, 4}} == {0, 3, 4}'}}}. The intent is to allow the delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult propert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162099,variab,variable,162099,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,"e checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:1464,config,config,1464,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['config']
Modifiability,"e client:. ```{.cpp}. // get connection id for the first connection in the list. if (win->NumConnections() > 0) {; unsigned connid = win->GetConnectionId();; std::string msg = ""Hello, world"";; win->Send(msg, connid);; }. ```. ## Display window. To display window in the browser, one should call `win->Show()` method.; This will starts new window (or new tab) in the default browser and show content of HTML page,; configured for the window. As argument of `Show()` method one can specify browser kind like; ""chromium"" or ""firefox"" or just full path to the program which should be invoked.; With the method `win->GetUrl()` one obtains URL string, which can be typed in the browser address string directly. Same window can be displayed several times in different browsers or different browser tabs - one only; must allow appropriate number of connections calling `win->SetConnLimit(3)`. For the local displays **Chromium Embeded Framework (CEF)** is used. It provides functionality; of Chrome web browser in ROOT application without need to create and start real http server.; If CEF was configured correctly, it is enough to call `win->Show(""cef"")` to display window in CEF. ## Client code. There is no limitations which framework should be used on the client side.; The minimal HTML/JavaScript code, which establish connection with the server, looks like:. ``` {.html}; <!DOCTYPE HTML>; <html>; <head>; <meta charset=""utf-8"">; <title>RWebWindow Example</title>; </head>; <body>; <div id=""main""></div>; <script type=""module"">; import { connectWebWindow } from './jsrootsys/modules/webwindow.mjs';; connectWebWindow({; receiver: {; onWebsocketOpened(handle) {; console.log('Connected');; handle.send('Init msg from client');; },; onWebsocketMsg(handle, msg) {; console.log('Get message ' + msg);; document.getElementById('main').innerHTML = msg;; },; onWebsocketClosed(handle) {; // when connection closed, close panel as well; if (window) window.close();; }; }; });; </script>; </body>; </html>. ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md:2543,config,configured,2543,documentation/users-guide/WebDisplay.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WebDisplay.md,1,['config'],['configured']
Modifiability,"e code squashing task; will automatically build a For loop around the indented statements that follow; this function. - Input: `in` (a pointer to the calling class, used to determine the loop; dependent variables).; - Output: A scope for iterating over vector observables. - **RooFit::Detail::CodeSquashContext::buildArg()**: helps convert RooFit; objects into arrays or other C++ representations for efficient computation. - Input: `in` (the list to convert to array).; - Output: Name of the array that stores the input list in the squashed code. - **RooFit::Detail::CodeSquashContext::buildCall()**: Creates a string; representation of the function to be called and its arguments. - Input: A function with name `funcname`, passing some arguments.; - Output: A string representation of the function to be called. - **RooFit::Detail::makeValidVarName()**: It helps fetch and save a valid name; from the name of the respective RooFit class. - Input: `in` (the input string).; - Output: A new string that is a valid variable name. - **RooFuncWrapper::buildCode()**: Generates the optimized code for evaluating; the function and its derivatives. - Input: `head` (starting mathematical expression).; - Output: code for evaluating the function. - **RooFuncWrapper::declareAndDiffFunction()**: Declare the function and create; its derivative. - Inputs: `funcName` (name of the function being differentiated), `funcBody`; (actual mathematical formula or equation).; - Output: Function declaration and its derivative. - **RooFuncWrapper::dumpCode()**: Prints the squashed code body to console; (useful for debugging). - Output: Print squashed code body to console. - **RooFuncWrapper::dumpGradient()**: Prints the derivative code body to; console (useful for debugging). - Output: Print derivative code body to console. - **RooFuncWrapper::gradient()**: Calculates the gradient of the function with; respect to its parameters. - Input: `out` (array where the computed gradient values will be stored).; - Outpu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:37420,variab,variable,37420,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variable']
Modifiability,"e command properties for commands that are used in documentation comments. ClangCommentCommandList; -----------------------. Generate list of commands that are used in documentation comments. ArmNeon; -------. Generate arm_neon.h for clang. ArmNeonSema; -----------. Generate ARM NEON sema support for clang. ArmNeonTest; -----------. Generate ARM NEON tests for clang. AttrDocs; --------. **Purpose**: Creates ``AttributeReference.rst`` from ``AttrDocs.td``, and is; used for documenting user-facing attributes. General BackEnds; ================. Print Records; -------------. The TableGen command option ``--print-records`` invokes a simple backend; that prints all the classes and records defined in the source files. This is; the default backend option. See the :doc:`TableGen Backend Developer's Guide; <./BackGuide>` for more information. Print Detailed Records; ----------------------. The TableGen command option ``--print-detailed-records`` invokes a backend; that prints all the global variables, classes, and records defined in the; source files, with more detail than the default record printer. See the; :doc:`TableGen Backend Developer's Guide <./BackGuide>` for more; information. JSON Reference; --------------. **Purpose**: Output all the values in every ``def``, as a JSON data; structure that can be easily parsed by a variety of languages. Useful; for writing custom backends without having to modify TableGen itself,; or for performing auxiliary analysis on the same TableGen data passed; to a built-in backend. **Output**:. The root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. * ``!tablegen_json_version``: a numeric version field that will; increase if an incompatible change is ever made to the structure of; this data. The format described here corresponds to version 1. * ``!instanceof``: a dictionary whose keys are the class names defined; in the TableGen input. For each key, the corresponding value is an; array of strin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:14619,variab,variables,14619,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['variab'],['variables']
Modifiability,"e compiled in the same way so that it doesn't attempt to dllimport; the inline member functions. The reverse scenario should generally work though:; a DLL compiled without this flag (such as a system library compiled with Visual; C++) can be referenced from code compiled using the flag, meaning that the; referencing code will use the inline definitions instead of importing them from; the DLL. Also note that like when using ``-fvisibility-inlines-hidden``, the address of; `S::foo()` will be different inside and outside the DLL, breaking the C/C++; standard requirement that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189023,variab,variables,189023,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"e considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount *)amount; __attribute__((objc_externally_retained)) {; // 'amount' and 'alias' aren't retained on entry, nor released on exit.; __attribute__((objc_externally_retained)) WobbleAmount *alias = amount;; }; @end. Annotating a function with this attribute makes every parameter with strong; retainable object pointer type externally-retained, unless the variable was; explicitly qualified with ``__strong``. For instance, ``first_param`` is; externally-retained (and therefore ``const``) below, but not ``second_param``:. .. code-block:: objc. __attribute__((objc_externally_retained)); void f(NSArray *first_param, __strong NSArray *second_param) {; // ...; }. You can test if your compiler has support for ``objc_externally_retained`` with; ``__has_attribute``:. .. code-block:: objc. #if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:93067,variab,variables,93067,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"e current file.; If you're not familiar with them, consult a decent C++ book for more; information. Next, we declare our pass itself:. .. code-block:: c++. struct Hello : public FunctionPass {. This declares a ""``Hello``"" class that is a subclass of :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>`. The different builtin pass subclasses; are described in detail :ref:`later <writing-an-llvm-pass-pass-classes>`, but; for now, know that ``FunctionPass`` operates on a function at a time. .. code-block:: c++. static char ID;; Hello() : FunctionPass(ID) {}. This declares pass identifier used by LLVM to identify pass. This allows LLVM; to avoid using expensive C++ runtime information. .. code-block:: c++. bool runOnFunction(Function &F) override {; errs() << ""Hello: "";; errs().write_escaped(F.getName()) << '\n';; return false;; }; }; // end of struct Hello; } // end of anonymous namespace. We declare a :ref:`runOnFunction <writing-an-llvm-pass-runOnFunction>` method,; which overrides an abstract virtual method inherited from :ref:`FunctionPass; <writing-an-llvm-pass-FunctionPass>`. This is where we are supposed to do our; thing, so we just print out our message with the name of each function. .. code-block:: c++. char Hello::ID = 0;. We initialize pass ID here. LLVM uses ID's address to identify a pass, so; initialization value is not important. .. code-block:: c++. static RegisterPass<Hello> X(""hello"", ""Hello World Pass"",; false /* Only looks at CFG */,; false /* Analysis Pass */);. Lastly, we :ref:`register our class <writing-an-llvm-pass-registration>`; ``Hello``, giving it a command line argument ""``hello``"", and a name ""Hello; World Pass"". The last two arguments describe its behavior: if a pass walks CFG; without modifying it then the third argument is set to ``true``; if a pass is; an analysis pass, for example dominator tree pass, then ``true`` is supplied as; the fourth argument. As a whole, the ``.cpp`` file looks like:. .. code-block:: c++. #include ""llvm/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:5700,inherit,inherited,5700,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['inherit'],['inherited']
Modifiability,"e decision for most; variables early on, which can result in suboptimal variable locations that may; be either incorrect or incomplete. A secondary goal of assignment tracking is to cause minimal additional work for; LLVM pass writers, and minimal disruption to LLVM in general. ## Status and usage. **Status**: Experimental work in progress. Enabling is strongly advised against; except for development and testing. **Enable in Clang**: `-Xclang -fexperimental-assignment-tracking`. That causes Clang to get LLVM to run the pass `declare-to-assign`. The pass; converts conventional debug intrinsics to assignment tracking metadata and sets; the module flag `debug-info-assignment-tracking` to the value `i1 true`. To; check whether assignment tracking is enabled for a module call; `isAssignmentTrackingEnabled(const Module &M)` (from `llvm/IR/DebugInfo.h`). ## Design and implementation. ### Assignment markers: `llvm.dbg.assign`. `llvm.dbg.value`, a conventional debug intrinsic, marks out a position in the; IR where a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to know where in IR it is appropriate to use a memory location for a; variable, each assignment marker must in some way refer to the store, if any; (or multiple!), that performs the assignment. That way, the position of the; store and marker can be considered together when making that choice. Another; important benefit of referring to the store is that we can then build a two-way; mapping of stores<->markers that can be used to find markers that need to be; updated when stores are modified. An `llvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsVa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:1835,variab,variable,1835,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"e declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constructors; Unknown. 1021; CD4; Definitions of namespace members; Unknown. 1022; C++11; Can an enumeration variable have values outside the values of the enumeration?; Unknown. 1023; dup; thread_local objects as non-type template arguments; Unknown. 1024; CD3; Limits on multicharacter literals; Unknown. 1025; C++11; Use of a reference as a non-type template argument; Unknown. 1026; NAD; Cv-qualified non-class rvalues; Unknown. 1027; review; Type consistency and reallocation of scalar types; Not resolved. 1028; CD6; Dependent names in non-defining declarations; Unknown. 1029; C++11; Type of a destructor call; Unknown. 1030; C++11; Evaluation order in initializer-lists used in aggregate initialization; Unknown. 1031; C++11; Optional elements in attributes; Unknown. 1032; C++11; Empty pack expansions; Unknown. 1033; C++11; Restrictions on alignment attributes; Unknown. 1034; C++11; Attributes for return statements in lambdas; Unknown. 1035; C++11; Omitted and required decl-specifiers; Unknown. 1036; C++11; Alignment attribute in an exception-declaration; Unknown. 1037; C++11; Requirements for operands of delete",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:67463,variab,variable,67463,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"e decoded instructions, but consumes a register for counting; iterations. If performing an analysis over many opcodes, it may be best to; instead use the `min` mode, which will run each other mode,; and produce the minimal measured result. .. option:: --num-repetitions=<Number of repetitions>. Specify the target number of executed instructions. Note that the actual; repetition count of the snippet will be `num-repetitions`/`snippet size`.; Higher values lead to more accurate measurements but lengthen the benchmark. .. option:: --loop-body-size=<Preferred loop body size>. Only effective for `-repetition-mode=[loop|min]`.; Instead of looping over the snippet directly, first duplicate it so that the; loop body contains at least this many instructions. This potentially results; in loop body being cached in the CPU Op Cache / Loop Cache, which allows to; which may have higher throughput than the CPU decoders. .. option:: --max-configs-per-opcode=<value>. Specify the maximum configurations that can be generated for each opcode.; By default this is `1`, meaning that we assume that a single measurement is; enough to characterize an opcode. This might not be true of all instructions:; for example, the performance characteristics of the LEA instruction on X86; depends on the value of assigned registers and immediates. Setting a value of; `-max-configs-per-opcode` larger than `1` allows `llvm-exegesis` to explore; more configurations to discover if some register or immediate assignments; lead to different performance characteristics. .. option:: --benchmarks-file=</path/to/file>. File to read (`analysis` mode) or write (`latency`/`uops`/`inverse_throughput`; modes) benchmark results. ""-"" uses stdin/stdout. .. option:: --analysis-clusters-output-file=</path/to/file>. If provided, write the analysis clusters as CSV to this file. ""-"" prints to; stdout. By default, this analysis is not run. .. option:: --analysis-inconsistencies-output-file=</path/to/file>. If non-empty, write inc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:13905,config,configurations,13905,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['config'],['configurations']
Modifiability,"e definition of this flag is very closely defined by the; stringizing requirements of the preprocessor.; #. **DisableExpand** --- This flag is used internally to the preprocessor to; represent identifier tokens which have macro expansion disabled. This; prevents them from being considered as candidates for macro expansion ever; in the future.; #. **NeedsCleaning** --- This flag is set if the original spelling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are creat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48441,variab,variable,48441,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['variab'],['variable']
Modifiability,"e discussion, we will discuss a custom parser that accepts file; sizes, specified with an optional unit after the numeric size. For example, we; would like to parse ""102kb"", ""41M"", ""1G"" into the appropriate integer value. In; this case, the underlying data type we want to parse into is '``unsigned``'. We; choose approach #2 above because we don't want to make this the default for all; ``unsigned`` options. To start out, we declare our new ``FileSizeParser`` class:. .. code-block:: c++. struct FileSizeParser : public cl::parser<unsigned> {; // parse - Return true on error.; bool parse(cl::Option &O, StringRef ArgName, const std::string &ArgValue,; unsigned &Val);; };. Our new class inherits from the ``cl::parser`` template class to fill in; the default, boiler plate code for us. We give it the data type that we parse; into, the last argument to the ``parse`` method, so that clients of our custom; parser know what object type to pass in to the parse method. (Here we declare; that we parse into '``unsigned``' variables.). For most purposes, the only method that must be implemented in a custom parser; is the ``parse`` method. The ``parse`` method is called whenever the option is; invoked, passing in the option itself, the option name, the string to parse, and; a reference to a return value. If the string to parse is not well-formed, the; parser should output an error message and return true. Otherwise it should; return false and set '``Val``' to the parsed value. In our example, we; implement ``parse`` as:. .. code-block:: c++. bool FileSizeParser::parse(cl::Option &O, StringRef ArgName,; const std::string &Arg, unsigned &Val) {; const char *ArgStart = Arg.c_str();; char *End;. // Parse integer part, leaving 'End' pointing to the first non-integer char; Val = (unsigned)strtol(ArgStart, &End, 0);. while (1) {; switch (*End++) {; case 0: return false; // No error; case 'i': // Ignore the 'i' in KiB if people use that; case 'b': case 'B': // Ignore B suffix; break;. case 'g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:63922,variab,variables,63922,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability,"e elements for ``DW_TAG_array_type`` variants of; :ref:`DICompositeType`. - ``count: -1`` indicates an empty array.; - ``count: !10`` describes the count with a :ref:`DILocalVariable`.; - ``count: !12`` describes the count with a :ref:`DIGlobalVariable`. .. code-block:: text. !0 = !DISubrange(count: 5, lowerBound: 0) ; array counting from 0; !1 = !DISubrange(count: 5, lowerBound: 1) ; array counting from 1; !2 = !DISubrange(count: -1) ; empty array. ; Scopes used in rest of example; !6 = !DIFile(filename: ""vla.c"", directory: ""/path/to/file""); !7 = distinct !DICompileUnit(language: DW_LANG_C99, file: !6); !8 = distinct !DISubprogram(name: ""foo"", scope: !7, file: !6, line: 5). ; Use of local variable as count value; !9 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed); !10 = !DILocalVariable(name: ""count"", scope: !8, file: !6, line: 42, type: !9); !11 = !DISubrange(count: !10, lowerBound: 0). ; Use of global variable as count value; !12 = !DIGlobalVariable(name: ""count"", scope: !8, file: !6, line: 22, type: !9); !13 = !DISubrange(count: !12, lowerBound: 0). .. _DIEnumerator:. DIEnumerator; """""""""""""""""""""""". ``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type``; variants of :ref:`DICompositeType`. .. code-block:: text. !0 = !DIEnumerator(name: ""SixKind"", value: 7); !1 = !DIEnumerator(name: ""SevenKind"", value: 7); !2 = !DIEnumerator(name: ""NegEightKind"", value: -8). DITemplateTypeParameter; """""""""""""""""""""""""""""""""""""""""""""". ``DITemplateTypeParameter`` nodes represent type parameters to generic source; language constructs. They are used (optionally) in :ref:`DICompositeType` and; :ref:`DISubprogram` ``templateParams:`` fields. .. code-block:: text. !0 = !DITemplateTypeParameter(name: ""Ty"", type: !1). DITemplateValueParameter; """""""""""""""""""""""""""""""""""""""""""""""". ``DITemplateValueParameter`` nodes represent value parameters to generic source; language constructs. ``tag:`` defaults to ``DW_TAG_template_value_parameter``,; but if specified can also be set to ``DW_TAG",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:254826,variab,variable,254826,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"e end-point URL for local; files; Improve realtime notification during 'verify'. TProofDraw. Fix a problem with the axis ranges of the underlying; histogram in PolyMarker3D; Allow to use the default pad instead of forcing; creation of one pad per object; Add wrapper to handle the feedback default canvas. TEventIter. Fix a problem with changing the tree cache size: the; size was reset to the default value after the first file. TDataSetManagerFile. Solve a consistency problem in checking URLs for; duplication when adding them to the relevant TFileInfo; During dataset validation, do not fail on duplications; but notify and add them to the bad file list. TPacketizerAdaptive, TPacketizer. Improve data node / worker matching by always using the; host FQDN. TPacketizerUnit, TEventIter. Make sure that the entry; number passed to TSelector::Process is unique and in increasing order; for non-data driven processing (packetizer TPacketizerUnit). This; allows to give a meaning to this variable, for example to related it to; one dimension of an integration. Fixes in PROOF-Lite:. Make sure that with envs settings via TProof::AddEnvVar; are effective; this enables, for example, the automatic valgrind setup; introduced in 5.24/00 or the experiment specific settings via the; script defined by the env PROOF_INIT; Fix a problem with TProof::Load so that now it can be; also be used for PROOF-Lite. TProofPlayerRemote. In SendSelector, add misisng; option kCpBin when sending the selector source; the binary files were;  never retrieved, even if present and valid. TProofPlayerSlave. In; Process, fix a problem with cache directory locking while building; the selector;  the net effect was that each worker process was; re-buidling its own selector binary. . TProofServ; Fix; the order in which the log file is sent in asynchronous processing; the; wrong order was screwing up an immediate synchronous query submission; after an asynchronous run; this case occured, for example, in; 'stressProof' . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:9034,variab,variable,9034,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,1,['variab'],['variable']
Modifiability,"e equivalent of:. .. code-block:: c++. static task coro_task(int v) {; store v to __int_32_0 in the frame; co_await await_counter{};; a = load __int_32_0; std::cout << a+1 << ""\n"";; std::cout << a+2 << ""\n"";; std::cout << a+3 << ""\n"";; co_await await_counter{};; a = load __int_32_0; std::cout << a+4 << ""\n"";; std::cout << a+5 << ""\n"";; }. It should now be obvious why the value of `__int_32_0` remains unchanged; throughout the function. It is important to recognize that `__int_32_0`; does not directly correspond to `a`, but is instead a variable generated; to assist the compiler in code generation. The variables in an optimized; coroutine frame should not be thought of as directly representing the; variables in the C++ source. Get the suspended points; ========================. An important requirement for debugging coroutines is to understand suspended; points, which are where the coroutine is currently suspended and awaiting. For simple cases like the above, inspecting the value of the `__coro_index`; variable in the coroutine frame works well. However, it is not quite so simple in really complex situations. In these; cases, it is necessary to use the coroutine libraries to insert the; line-number. For example:. .. code-block:: c++. // For all the promise_type we want:; class promise_type {; ...; + unsigned line_number = 0xffffffff;; };. #include <source_location>. // For all the awaiter types we need:; class awaiter {; ...; template <typename Promise>; void await_suspend(std::coroutine_handle<Promise> handle,; std::source_location sl = std::source_location::current()) {; ...; handle.promise().line_number = sl.line();; }; };. In this case, we use `std::source_location` to store the line number of the; await inside the `promise_type`. Since we can locate the coroutine function; from the address of the coroutine, we can identify suspended points this way; as well. The downside here is that this comes at the price of additional runtime cost.; This is consistent with th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst:10733,variab,variable,10733,interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DebuggingCoroutines.rst,1,['variab'],['variable']
Modifiability,"e executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; Reasonably small histograms (GetSize() <; MsgSizeHWM) are merged in one-go at the end instead of one-by-one to; exploit, for example, the better performance of TH1::Merge on the full; list of histos.; Add possibility to compress the messages; this is; controlled by ProofServ.CompressMessage; <compression_level>; The default is still 'no compression' but this will allow to study the; impact of compression. Add sort of 'progress' counter for merging is now shown; on the client:;  ;     root [n] p->Process(...);       ... ;       Mst-0: merging output objects ... / (4; worker",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:6330,config,configuration,6330,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['config'],['configuration']
Modifiability,"e file. ### RDataFrame (formerly TDataFrame); #### Behaviour, interface and naming changes; - `TDataFrame` and `TDataSource` together with their federation of classes have been renamed according to the coding conventions for new interfaces and extracted from the `Experimental` namespace: they can now be found in the ROOT namespace and they are called `ROOT::RDataFrame` and `ROOT::RDataSource`.; - `ROOT::Experimental::TDF::TResultProxy` has been renamed to `ROOT::RDF::RResultPtr`.; - `Report` now behaves identically to all other actions: it executes lazily and returns a `RResultPtr` (see the `New features` section for more details).; - `Snapshot` now returns a `RResultPtr` like all other actions: specifically, this is a pointer to a new `RDataFrame` which will run on the snapshotted dataset.; - `RDataFrame` has been removed from tree/treeplayer and put in its own package, tree/dataframe. The library where this code can be found is `libROOTDataFrame`. This new library is included in the list provided by `root-config --libs`.; - The `TArrayBranch` class has been removed and replaced by the more powerful `RVec` (see the `New features` section for more details).; - All `RDataFrame` tutorials are now prefixed with `df` rather than `tdf`.; - Histograms and profiles returned by RDataFrame (e.g. by a Histo1D action) are now not associated to a ROOT directory (their fDirectory is a nullptr).; The following still works as expected:; ```; auto h = tdf.Histo1D(""x"");; TFile f(fname, ""RECREATE"");; h->Write(); // event loop is run here and h is written to the TFile f; ```. #### New features; - The TDataSource interface changed. The `TDataSource::SetEntry` method now returns a boolean. If true the entry is processed within the event loop managed by the tdf, skipped otherwise.; - The TLazyDS data source has been added. It allows to create a source starting from ResultProxies to vectors.; - `TDataFrameInterface<T>::Report` returns a `TCutflowReport` object which can be inspected progra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md:6623,config,config,6623,README/ReleaseNotes/v614/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v614/index.md,1,['config'],['config']
Modifiability,"e for CMAKE_CXX_STANDARD to ${LLVM_REQUIRED_CXX_STANDARD}""); unset(CMAKE_CXX_STANDARD CACHE); endif(). # if CMAKE_CXX_STANDARD is still set after the cache unset above it means that the user requested it; # and we allow it to be set to something newer than the required standard but otherwise we fail.; if(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS ${LLVM_REQUIRED_CXX_STANDARD}); message(FATAL_ERROR ""Requested CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} which is less than the required ${LLVM_REQUIRED_CXX_STANDARD}.""); endif(). set(CMAKE_CXX_STANDARD ${LLVM_REQUIRED_CXX_STANDARD} CACHE STRING ""C++ standard to conform to""); set(CMAKE_CXX_STANDARD_REQUIRED YES). if (CYGWIN); # Cygwin is a bit stricter and lack things like 'strdup', 'stricmp', etc in; # c++xx mode.; set(CMAKE_CXX_EXTENSIONS YES); else(); set(CMAKE_CXX_EXTENSIONS NO); endif(). if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(FATAL_ERROR ""; No build type selected. You need to pass -DCMAKE_BUILD_TYPE=<type> in order to configure LLVM.; Available options are:; * -DCMAKE_BUILD_TYPE=Release - For an optimized build with no assertions or debug info.; * -DCMAKE_BUILD_TYPE=Debug - For an unoptimized build with assertions and debug info.; * -DCMAKE_BUILD_TYPE=RelWithDebInfo - For an optimized build with no assertions but with debug info.; * -DCMAKE_BUILD_TYPE=MinSizeRel - For a build optimized for size instead of speed.; Learn more about these options in our documentation at https://llvm.org/docs/CMake.html#cmake-build-type; ""); endif(). # Set default build type for cmake's try_compile module.; # CMake 3.17 or newer sets CMAKE_DEFAULT_BUILD_TYPE to one of the; # items from CMAKE_CONFIGURATION_TYPES. Logic below can be further; # simplified once LLVM's minimum CMake version is updated to 3.17.; if(CMAKE_DEFAULT_BUILD_TYPE); set(CMAKE_TRY_COMPILE_CONFIGURATION ${CMAKE_DEFAULT_BUILD_TYPE}); else(); if(CMAKE_CONFIGURATION_TYPES); list(GET CMAKE_CONFIGURATION_TYPES 0 CMAKE_TRY_COMPILE_CONFIGU",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:3942,config,configure,3942,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['configure']
Modifiability,"e function object is that it can have a state and reference therefore what-ever other object; the user needs, without using globals. This is an example to define first the function object. ``` {.cpp}; class MyFunctionObject {; public:; // use constructor to customize your function object; MyFunctionObject(......) { ......}. double operator() (double *x, double *p) {; // function implementation using class data members; }; };; ```. and then use it to create the **`TF1`**:. ```{.cpp}; MyFunctionObject fobj(....); // create the function object; TF1 * f = new TF1(""f"",fobj,xmin,xmax,npar); // create TF1 class with n-parameters and range [xmin,xmax]; ```. If using C++11, one can create a **`TF1`** also from a C++ `lambda` function:. ```{.cpp}; // create TF1 class with 2 parameters and range [xmin,xmax] using a lambda; TF1 * f = new TF1(""f"",[](double*x,double*p){return p[0] + p[1]*x[0];},xmin,xmax,2);; ```. ## Configuring the Fit. We will show here some configuration actions that can or must be done; when fitting histogram or graph using the `Fit` method. ### Fixing and Setting Parameters' Bounds. Parameters must be initialized before invoking the `Fit` method. The; setting of the parameter initial values is automatic for the; predefined functions: `poln`, `exp`, `gaus`, and `landau`. You can fix; one or more parameters by specifying the ""B"" option when calling the; `Fit` method. When a function is not predefined, the fit parameters; must be initialized to some value as close as possible to the expected; values before calling the fit function. To set bounds for one parameter, use `TF1::SetParLimits`:. ``` {.cpp}; func->SetParLimits(0,-1,1);; ```. When the lower and upper limits are equal, the parameter is fixed.; Next two statements fix parameter 4 at 10. ``` {.cpp}; func->SetParameter(4,10);; func->SetParLimits(4,10,10);; ```. However, to fix a parameter to 0, one must call the `FixParameter`; function:. ``` {.cpp}; func->SetParameter(4,0);; func->FixParameter(4,0);; ```. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:10234,config,configuration,10234,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['config'],['configuration']
Modifiability,"e go in TProof::Process(const char; *dataset, ...).; Two options are provided:;  - 'grand; dataset':   the datasets are added up; and considered as a single dataset (syntax:; ""dataset1|dataset2|..."");  - 'keep; separated':; the datasets are processed one after the other; the user is notified in; the selector of the change of dataset so they have the opportunity to; separate the results. A new packetizer, TPacketizerMulti, has been; developed for this case: it basically contains a list of standard; packetizers (one for each dataset) and loops over them (syntax:; ""dataset1,dataset2,..."" or dataset1 dataset2 ..."").; In; both cases, entry-list can be applied using the syntax; ""dataset<<entrylist"", e.g.; ""dataset1<<el1|dataset2<<el2|"".; The datasets to be processed can also be specified on one or multiple lines in a text file.; Add; support for automatic download of a package when available on the; master but not locally. The downloaded packages are store under <sandbox>/packages/downloaded; and automatically checked for updates against the master repository. If; a local version of the same package is created (using the; UploadPackage) the entry in downloaded is; cleared, so that the behaviour is unchanged.; Add; the possibility to remap the server for the files in a dataset. This; allows, for example, to reuse the dataset information for the same; files stored in a different cluster.; Add a local cache for; TDataSetManagerFile. This is mainly used to improve the speed of; TDataSetManager::ShowDataSets, which is run very often by users and may; be very slow if the number of dataset is large. The cache is also used; to cache frequently received dataset objects.Add the possibility to audit the activity on the nodes via syslog. .; New packetizer TPacketizerFile generating packets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - contain",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:1047,sandbox,sandbox,1047,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['sandbox'],['sandbox']
Modifiability,"e information about some of the advanced build configurations supported; via Cache files see :doc:`AdvancedBuilds`. Executing the Tests; ===================. Testing is performed when the *check-all* target is built. For instance, if you are; using Makefiles, execute this command in the root of your build directory:. .. code-block:: console. $ make check-all. On Visual Studio, you may run tests by building the project ""check-all"".; For more information about testing, see the :doc:`TestingGuide`. Cross compiling; ===============. See `this wiki page <https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/CrossCompiling>`_ for; generic instructions on how to cross-compile with CMake. It goes into detailed; explanations and may seem daunting, but it is not. On the wiki page there are; several examples including toolchain files. Go directly to the; ``Information how to set up various cross compiling toolchains`` section; for a quick solution. Also see the `LLVM-related variables`_ section for variables used when; cross-compiling. Embedding LLVM in your project; ==============================. From LLVM 3.5 onwards the CMake build system exports LLVM libraries as; importable CMake targets. This means that clients of LLVM can now reliably use; CMake to develop their own LLVM-based projects against an installed version of; LLVM regardless of how it was built. Here is a simple example of a CMakeLists.txt file that imports the LLVM libraries; and uses them to build a simple application ``simple-tool``. .. code-block:: cmake. cmake_minimum_required(VERSION 3.20.0); project(SimpleProject). find_package(LLVM REQUIRED CONFIG). message(STATUS ""Found LLVM ${LLVM_PACKAGE_VERSION}""); message(STATUS ""Using LLVMConfig.cmake in: ${LLVM_DIR}""). # Set your project compile flags.; # E.g. if using the C++ header files; # you will need to enable C++11 support; # for your compiler. include_directories(${LLVM_INCLUDE_DIRS}); separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND ${LLVM_DE",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:40727,variab,variables,40727,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,2,['variab'],['variables']
Modifiability,"e instruction with.; list<dag> Pattern; // Set to the DAG pattern for this instruction.; list<Register> Uses = [];; list<Register> Defs = [];; list<Predicate> Predicates = []; // predicates turned into isel match code; ... remainder not shown for space ...; }. A ``SelectionDAG`` node (``SDNode``) should contain an object representing a; target-specific instruction that is defined in ``XXXInstrInfo.td``. The; instruction objects should represent instructions from the architecture manual; of the target machine (such as the SPARC Architecture Manual for the SPARC; target). A single instruction from the architecture manual is often modeled as multiple; target instructions, depending upon its operands. For example, a manual might; describe an add instruction that takes a register or an immediate operand. An; LLVM target could model this with two instructions named ``ADDri`` and; ``ADDrr``. You should define a class for each instruction category and define each opcode; as a subclass of the category with appropriate parameters such as the fixed; binary encoding of opcodes and extended opcodes. You should map the register; bits to the bits of the instruction in which they are encoded (for the JIT).; Also you should specify how the instruction should be printed when the; automatic assembly printer is used. As is described in the SPARC Architecture Manual, Version 8, there are three; major 32-bit formats for instructions. Format 1 is only for the ``CALL``; instruction. Format 2 is for branch on condition codes and ``SETHI`` (set high; bits of a register) instructions. Format 3 is for other instructions. Each of these formats has corresponding classes in ``SparcInstrFormat.td``.; ``InstSP`` is a base class for other instruction classes. Additional base; classes are specified for more precise formats: for example in; ``SparcInstrFormat.td``, ``F2_1`` is for ``SETHI``, and ``F2_2`` is for; branches. There are three other base classes: ``F3_1`` for register/register; operations, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:31193,extend,extended,31193,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['extend'],['extended']
Modifiability,"e interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and not need a gazillion; of command-line options. Such file should be simple JSON / INI or anything that; a text editor could change. If you hit a bug with Clang, it is very useful for us if you reduce the code; that demonstrates the problem down to something small. There are many ways to; do this; ask on ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5755,config,configuration,5755,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['config'],['configuration']
Modifiability,"e is enabled by a new parameter 'queue:fifo' in; the 'xpd.schedparam'; directive. In case of static worker assignment; (default, random,; round-robin) the max number of running sessions can be limited by; another new parameter 'mxrun';; for; example;            ;     xpd.schedparam default; mxrun:3 queue:fifo; will run concurrently only 3 sessions. Additional requests are queued; and run as soon as one of the running; sessions goes idle. The current policy is FIFO, so that there is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1308,variab,variable,1308,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['variab'],['variable']
Modifiability,"e is included as part of ``Attr.h``. ClangAttrParserStringSwitches; -----------------------------. **Purpose**: Creates AttrParserStringSwitches.inc, which contains; StringSwitch::Case statements for parser-related string switches. Each switch; is given its own macro (such as ``CLANG_ATTR_ARG_CONTEXT_LIST``, or; ``CLANG_ATTR_IDENTIFIER_ARG_LIST``), which is expected to be defined before; including AttrParserStringSwitches.inc, and undefined after. ClangAttrImpl; -------------. **Purpose**: Creates AttrImpl.inc, which contains semantic attribute class; definitions for any attribute in ``Attr.td`` that has not set ``ASTNode = 0``.; This file is included as part of ``AttrImpl.cpp``. ClangAttrList; -------------. **Purpose**: Creates AttrList.inc, which is used when a list of semantic; attribute identifiers is required. For instance, ``AttrKinds.h`` includes this; file to generate the list of ``attr::Kind`` enumeration values. This list is; separated out into multiple categories: attributes, inheritable attributes, and; inheritable parameter attributes. This categorization happens automatically; based on information in ``Attr.td`` and is used to implement the ``classof``; functionality required for ``dyn_cast`` and similar APIs. ClangAttrPCHRead; ----------------. **Purpose**: Creates AttrPCHRead.inc, which is used to deserialize attributes; in the ``ASTReader::ReadAttributes`` function. ClangAttrPCHWrite; -----------------. **Purpose**: Creates AttrPCHWrite.inc, which is used to serialize attributes in; the ``ASTWriter::WriteAttributes`` function. ClangAttrSpellings; ---------------------. **Purpose**: Creates AttrSpellings.inc, which is used to implement the; ``__has_attribute`` feature test macro. ClangAttrSpellingListIndex; --------------------------. **Purpose**: Creates AttrSpellingListIndex.inc, which is used to map parsed; attribute spellings (including which syntax or scope was used) to an attribute; spelling list index. These spelling list index values are inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:10241,inherit,inheritable,10241,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,2,['inherit'],['inheritable']
Modifiability,"e is used to specify the desired GC strategy to the; compiler. Its programmatic equivalent is the ``setGC`` method of ``Function``. Setting ``gc ""name""`` on a function triggers a search for a matching subclass; of GCStrategy. Some collector strategies are built in. You can add others; using either the loadable plugin mechanism, or by patching your copy of LLVM.; It is the selected GC strategy which defines the exact nature of the code; generated to support GC. If none is found, the compiler will raise an error. Specifying the GC style on a per-function basis allows LLVM to link together; programs that use different garbage collection algorithms (or none at all). .. _gcroot:. Identifying GC roots on the stack; ----------------------------------. LLVM currently supports two different mechanisms for describing references in; compiled code at safepoints. ``llvm.gcroot`` is the older mechanism;; ``gc.statepoint`` has been added more recently. At the moment, you can choose; either implementation (on a per :ref:`GC strategy <plugin>` basis). Longer; term, we will probably either migrate away from ``llvm.gcroot`` entirely, or; substantially merge their implementations. Note that most new development; work is focused on ``gc.statepoint``. Using ``gc.statepoint``; ^^^^^^^^^^^^^^^^^^^^^^^^; :doc:`This page <Statepoints>` contains detailed documentation for; ``gc.statepoint``. Using ``llvm.gcwrite``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.gcroot(i8** %ptrloc, i8* %metadata). The ``llvm.gcroot`` intrinsic is used to inform LLVM that a stack variable; references an object on the heap and is to be tracked for garbage collection.; The exact impact on generated code is specified by the Function's selected; :ref:`GC strategy <plugin>`. All calls to ``llvm.gcroot`` **must** reside; inside the first basic block. The first argument **must** be a value referring to an alloca instruction or a; bitcast of an alloca. The second contains a pointer to metadata that s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:9673,plugin,plugin,9673,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"e it into a (hopefully) more optimized but semantically; equivalent form. In the original tutorial series the FunctionPassManager was; created outside the KaleidoscopeJIT and modules were optimized before being; added to it. In this Chapter we will make optimization a phase of our JIT; instead. For now this will provide us a motivation to learn more about ORC; layers, but in the long term making optimization part of our JIT will yield an; important benefit: When we begin lazily compiling code (i.e. deferring; compilation of each function until the first time it's run) having; optimization managed by our JIT will allow us to optimize lazily too, rather; than having to do all our optimization up-front. To add optimization support to our JIT we will take the KaleidoscopeJIT from; Chapter 1 and compose an ORC *IRTransformLayer* on top. We will look at how the; IRTransformLayer works in more detail below, but the interface is simple: the; constructor for this layer takes a reference to the execution session and the; layer below (as all layers do) plus an *IR optimization function* that it will; apply to each Module that is added via addModule:. .. code-block:: c++. class KaleidoscopeJIT {; private:; ExecutionSession ES;; RTDyldObjectLinkingLayer ObjectLayer;; IRCompileLayer CompileLayer;; IRTransformLayer TransformLayer;. DataLayout DL;; MangleAndInterner Mangle;; ThreadSafeContext Ctx;. public:. KaleidoscopeJIT(JITTargetMachineBuilder JTMB, DataLayout DL); : ObjectLayer(ES,; []() { return std::make_unique<SectionMemoryManager>(); }),; CompileLayer(ES, ObjectLayer, ConcurrentIRCompiler(std::move(JTMB))),; TransformLayer(ES, CompileLayer, optimizeModule),; DL(std::move(DL)), Mangle(ES, this->DL),; Ctx(std::make_unique<LLVMContext>()) {; ES.getMainJITDylib().addGenerator(; cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(DL.getGlobalPrefix())));; }. Our extended KaleidoscopeJIT class starts out the same as it did in Chapter 1,; but after the CompileLayer we int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst:2817,layers,layers,2817,interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/BuildingAJIT2.rst,1,['layers'],['layers']
Modifiability,"e language semantics. A.3 Program Scope Entries; -------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 3 sections. A.3.1 Unit Entries; ~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-full-and-partial-compilation-unit-entries:. A.3.1.1 Full and Partial Compilation Unit Entries; +++++++++++++++++++++++++++++++++++++++++++++++++. .. note::. This augments DWARF Version 5 section 3.1.1 and Table 3.1. Additional language codes defined for use with the ``DW_AT_language`` attribute; are defined in :ref:`amdgpu-dwarf-language-names-table`. .. table:: Language Names; :name: amdgpu-dwarf-language-names-table. ==================== =============================; Language Name Meaning; ==================== =============================; ``DW_LANG_LLVM_HIP`` HIP Language.; ==================== =============================. The HIP language [:ref:`HIP <amdgpu-dwarf-HIP>`] can be supported by extending; the C++ language. .. note::. The following new attribute is added. 1. A ``DW_TAG_compile_unit`` debugger information entry for a compilation unit; may have a ``DW_AT_LLVM_augmentation`` attribute, whose value is an; augmentation string. *The augmentation string allows producers to indicate that there is; additional vendor or target specific information in the debugging; information entries. For example, this might be information about the; version of vendor specific extensions that are being used.*. If not present, or if the string is empty, then the compilation unit has no; augmentation string. The format for the augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor Y; version number of the extensions used, and *options* is an optional string; providing additional information about the extensions. The version number; must conform to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:154500,extend,extending,154500,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extending']
Modifiability,"e likelihoods; Automatic handling of constraint terms; It is no longer necessary to add a Constrain() argument to fitTo() calls to have internal constraints; applied. Any pdf term appearing in a product that does not contain an observable and shares one or more parameters; with another pdf term in the same product that does contain an observable is automatically picked up as a constraint term.; For example given a dataset D(x) which defines variable x as observable, the default logic works out as follows. F(x,a,b)*G(a,a0,a1) --> G is constraint term (a also appears in F(x)); F(x,a,b)*G(y,c,d) --> G is dropped (factorizing term). A Constrain(y) term in the above example will still force term G(y,c,d) to be interpreted as constraint term; Automatic caching of numeric integral calculations; Integrals that require numeric integrations in two of more dimensions are now automatically cached in the expensive object store.; The expensive object store allows to cache such values between difference instance of integral objects that represent the; same configuration. If integrals are created from an object (function or pdf) that live in a RooWorkspace the ; expensive object cache of the workspace will be used instead of the global store instance, and values stored in the workspace; store will also be persisted if the workspace is persisted. The global caching behavior of integral objects can be ; controlled through RooRealIntegral::setCacheAllNumeric(Int_t nDimNumMin). Miscellaneous improvements data classes. The RooAbsData::tree() method has been restored. It will only return a TTree* pointer for datasets; that are based on a RooTreeDataStore implementation, i.e. not for the composite datasets mentioned below; A new composite data storage class RooCompositeDataStore has been added that allows to construct composite; RooDataSet objects without copying the input data. . // Make 2 input datasets and an index category; RooWorkspace w(""w"",true) ;; w->factory(""Gaussian::g(x[-10,10]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:7986,config,configuration,7986,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['config'],['configuration']
Modifiability,"e limit, and ``0`` is the default. Note that this is not an; alias for :option:`--max-time`; the two are different kinds of maximums. .. option:: --filter=REGEXP. Run only those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER`` can be also used in place; of this option, which is especially useful in environments where the call; to ``lit`` is issued indirectly. .. option:: --filter-out=REGEXP. Filter out those tests whose name matches the regular expression specified in; ``REGEXP``. The environment variable ``LIT_FILTER_OUT`` can be also used in; place of this option, which is especially useful in environments where the; call to ``lit`` is issued indirectly. .. option:: --xfail=LIST. Treat those tests whose name is in the semicolon separated list ``LIST`` as; ``XFAIL``. This can be helpful when one does not want to modify the test; suite. The environment variable ``LIT_XFAIL`` can be also used in place of; this option, which is especially useful in environments where the call to; ``lit`` is issued indirectly. A test name can specified as a file name relative to the test suite directory.; For example:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;offloading/memory_manager.cpp"". In this case, all of the following tests are treated as ``XFAIL``:. .. code-block:: none. libomp :: affinity/kmp-hw-subset.c; libomptarget :: nvptx64-nvidia-cuda :: offloading/memory_manager.cpp; libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp. Alternatively, a test name can be specified as the full test name; reported in LIT output. For example, we can adjust the previous; example not to treat the ``nvptx64-nvidia-cuda`` version of; ``offloading/memory_manager.cpp`` as XFAIL:. .. code-block:: none. LIT_XFAIL=""affinity/kmp-hw-subset.c;libomptarget :: x86_64-pc-linux-gnu :: offloading/memory_manager.cpp"". .. option:: --xfail-not=LIST. Do not treat the specified tests as ``XFAIL``. The environment va",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:8876,variab,variable,8876,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['variab'],['variable']
Modifiability,"e link fails at any point. It can be; overridden to react to the failure (e.g. to deallocate any already allocated; resources). .. code-block:: c++. Error notifyFailed(MaterializationResponsibility &MR). * ``notifyRemovingResources`` is called when a request is made to remove any; resources associated with the ``ResourceKey`` *K* for the; ``MaterializationResponsibility``. .. code-block:: c++. Error notifyRemovingResources(ResourceKey K). * ``notifyTransferringResources`` is called if/when a request is made to; transfer tracking of any resources associated with ``ResourceKey``; *SrcKey* to *DstKey*. .. code-block:: c++. void notifyTransferringResources(ResourceKey DstKey,; ResourceKey SrcKey). Plugin authors are required to implement the ``notifyFailed``,; ``notifyRemovingResources``, and ``notifyTransferringResources`` methods in; order to safely manage resources in the case of resource removal or transfer,; or link failure. If no resources are managed by the plugin then these methods; can be implemented as no-ops returning ``Error::success()``. Plugin instances are added to an ``ObjectLinkingLayer`` by; calling the ``addPlugin`` method [1]_. E.g. .. code-block:: c++. // Plugin class to print the set of defined symbols in an object when that; // object is linked.; class MyPlugin : public ObjectLinkingLayer::Plugin {; public:. // Add passes to print the set of defined symbols after dead-stripping.; void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config) override {; Config.PostPrunePasses.push_back([this](jitlink::LinkGraph &G) {; return printAllSymbols(G);; });; }. // Implement mandatory overrides:; Error notifyFailed(MaterializationResponsibility &MR) override {; return Error::success();; }; Error notifyRemovingResources(ResourceKey K) override {; return Error::success();; }; void notifyTransferringResources(ResourceKey DstKey,; ResourceKey SrcKey) override {}. // JITLink pass to print all defined symbols in G",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:4581,plugin,plugin,4581,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['plugin'],['plugin']
Modifiability,"e llvm documentation."" OFF); option (LLVM_INCLUDE_DOCS ""Generate build targets for llvm documentation."" ON); option (LLVM_ENABLE_DOXYGEN ""Use doxygen to generate llvm API documentation."" OFF); option (LLVM_ENABLE_SPHINX ""Use Sphinx to generate llvm documentation."" OFF); option (LLVM_ENABLE_OCAMLDOC ""Build OCaml bindings documentation."" ON); option (LLVM_ENABLE_BINDINGS ""Build bindings."" ON). set(LLVM_INSTALL_DOXYGEN_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/doxygen-html""; CACHE STRING ""Doxygen-generated HTML documentation install directory""); set(LLVM_INSTALL_OCAMLDOC_HTML_DIR ""${CMAKE_INSTALL_DOCDIR}/llvm/ocaml-html""; CACHE STRING ""OCamldoc-generated HTML documentation install directory""). option (LLVM_BUILD_EXTERNAL_COMPILER_RT; ""Build compiler-rt as an external project."" OFF). option (LLVM_VERSION_PRINTER_SHOW_HOST_TARGET_INFO; ""Show target and host info when tools are invoked with --version."" ON). # You can configure which libraries from LLVM you want to include in the; # shared library by setting LLVM_DYLIB_COMPONENTS to a semi-colon delimited; # list of LLVM components. All component names handled by llvm-config are valid.; if(NOT DEFINED LLVM_DYLIB_COMPONENTS); set(LLVM_DYLIB_COMPONENTS ""all"" CACHE STRING; ""Semicolon-separated list of components to include in libLLVM, or \""all\"".""); endif(). if(MSVC); option(LLVM_BUILD_LLVM_C_DYLIB ""Build LLVM-C.dll (Windows only)"" ON); # Set this variable to OFF here so it can't be set with a command-line; # argument.; set (LLVM_LINK_LLVM_DYLIB OFF); if (BUILD_SHARED_LIBS); message(FATAL_ERROR ""BUILD_SHARED_LIBS options is not supported on Windows.""); endif(); else(); option(LLVM_LINK_LLVM_DYLIB ""Link tools against the libllvm dynamic library"" OFF); option(LLVM_BUILD_LLVM_C_DYLIB ""Build libllvm-c re-export library (Darwin only)"" OFF); set(LLVM_BUILD_LLVM_DYLIB_default OFF); if(LLVM_LINK_LLVM_DYLIB OR LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_BUILD_LLVM_DYLIB_default ON); endif(); option(LLVM_BUILD_LLVM_DYLIB ""Build libllvm dynamic lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:33185,config,configure,33185,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['configure']
Modifiability,"e local variables on the stack. This is; to ensure that if a local variable on the stack is overwritten, it will destroy; the value of the guard. When the function exits, the guard on the stack is; checked against the original guard by ``llvm.stackprotectorcheck``. If they are; different, then ``llvm.stackprotectorcheck`` causes the program to abort by; calling the ``__stack_chk_fail()`` function. '``llvm.stackguard``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stackguard(). Overview:; """""""""""""""""". The ``llvm.stackguard`` intrinsic returns the system stack guard value. It should not be generated by frontends, since it is only for internal usage.; The reason why we create this intrinsic is that we still support IR form Stack; Protector in FastISel. Arguments:; """""""""""""""""""". None. Semantics:; """""""""""""""""""". On some platforms, the value returned by this intrinsic remains unchanged; between loads in the same thread. On other platforms, it returns the same; global variable value, if any, e.g. ``@__stack_chk_guard``. Currently some platforms have IR-level customized stack guard loading (e.g.; X86 Linux) that is not handled by ``llvm.stackguard()``, while they should be; in the future. '``llvm.objectsize``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.objectsize.i32(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>); declare i64 @llvm.objectsize.i64(ptr <object>, i1 <min>, i1 <nullunknown>, i1 <dynamic>). Overview:; """""""""""""""""". The ``llvm.objectsize`` intrinsic is designed to provide information to the; optimizer to determine whether a) an operation (like memcpy) will overflow a; buffer that corresponds to an object, or b) that a runtime check for overflow; isn't necessary. An object in this context means an allocation of a specific; class, structure, array, or other object. Arguments:; """""""""""""""""""". The ``llvm.objectsize`` intrinsic takes four arguments. The first argument is a; pointer to or in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:931362,variab,variable,931362,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"e maximal number of unwrapped lines that a short namespace spans.; Defaults to 1. This determines the maximum length of short namespaces by counting; unwrapped lines (i.e. containing neither opening nor closing; namespace brace) and makes ""FixNamespaceComments"" omit adding; end comments for those. .. code-block:: c++. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace a { namespace a {; int foo; int foo;; } } // namespace a. ShortNamespaceLines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109229,config,configuration,109229,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"e memory of ``this``,; or if ``self`` is a by-value return. * ``__release_gil__``: a flag that every C++ overload carries and determines; whether the Global Interpreter Lock (GIL) should be released during the C++; call to allow multi-threading.; The default is ``False``. * ``__useffi__``: a flag that every C++ overload carries and determines; whether generated wrappers or direct foreign functions should be used.; This is for PyPy only; the flag has no effect on CPython. * ``__sig2exc__``: a flag that every C++ overload carries and determines; whether C++ signals (such as SIGABRT) should be converted into Python; exceptions. * ``__cpp_name__``: a string that every C++ bound class carries and contains; the actual C++ name (as opposed to ``__name__`` which has the Python name).; This can be useful for template instantiations, documentation, etc. * ``__cpp_template__``: a back-reference to the template used to instantiate; a templated class.; This variable only exists if the class was dynamically instantiated from; Python at least once. `STL algorithms`; ----------------. It is usually easier to use a Python equivalent or code up the effect of an; STL algorithm directly, but when operating on a large container, calling an; STL algorithm may offer better performance.; It is important to note that all STL algorithms are templates and need the; correct types to be properly instantiated.; STL containers offer typedefs to obtain those exact types and these should; be used rather than relying on the usual implicit conversions of Python types; to C++ ones.; For example, as there is no ``char`` type in Python, the ``std::remove`` call; below can not be instantiated using a Python string, but the; ``std::string::value_type`` must be used instead:. .. code-block:: python. >>> cppstr = cppyy.gbl.std.string; >>> n = cppstr('this is a C++ string'); >>> print(n); this is a C++ string; >>> n.erase(cppyy.gbl.std.remove(n.begin(), n.end(), cppstr.value_type(' '))); <cppyy.gbl.__wrap_ite",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst:2825,variab,variable,2825,bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/misc.rst,1,['variab'],['variable']
Modifiability,"e methods:. * ``printOperand``; * ``printMemOperand``; * ``printCCOperand`` (for conditional statements); * ``printDataDirective``; * ``printDeclare``; * ``printImplicitDef``; * ``printInlineAsm``. The implementations of ``printDeclare``, ``printImplicitDef``,; ``printInlineAsm``, and ``printLabel`` in ``AsmPrinter.cpp`` are generally; adequate for printing assembly and do not need to be overridden. The ``printOperand`` method is implemented with a long ``switch``/``case``; statement for the type of operand: register, immediate, basic block, external; symbol, global address, constant pool index, or jump table index. For an; instruction with a memory address operand, the ``printMemOperand`` method; should be implemented to generate the proper output. Similarly,; ``printCCOperand`` should be used to print a conditional operand. ``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it should be; called to shut down the assembly printer. During ``doFinalization``, global; variables and constants are printed to output. Subtarget Support; =================. Subtarget support is used to inform the code generation process of instruction; set variations for a given chip set. For example, the LLVM SPARC; implementation provided covers three major versions of the SPARC microprocessor; architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a; 64-bit architecture), and the UltraSPARC architecture. V8 has 16; double-precision floating-point registers that are also usable as either 32; single-precision or 8 quad-precision registers. V8 is also purely big-endian.; V9 has 32 double-precision floating-point registers that are also usable as 16; quad-precision registers, but cannot be used as single-precision registers.; The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set; extensions. If subtarget support is needed, you should implement a target-specific; ``XXXSubtarget`` class for your architecture. This class should proces",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:71175,variab,variables,71175,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variables']
Modifiability,"e modifier can be append to a directive by following the directive; with ``{<modifier>}`` where the only supported value for ``<modifier>`` is; ``LITERAL``. The ``LITERAL`` directive modifier can be used to perform a literal match. The; modifier results in the directive not recognizing any syntax to perform regex; matching, variable capture or any substitutions. This is useful when the text; to match would require excessive escaping otherwise. For example, the; following will perform literal matches rather than considering these as; regular expressions:. .. code-block:: text. Input: [[[10, 20]], [[30, 40]]]; Output %r10: [[10, 20]]; Output %r10: [[30, 40]]. ; CHECK{LITERAL}: [[[10, 20]], [[30, 40]]]; ; CHECK-DAG{LITERAL}: [[30, 40]]; ; CHECK-DAG{LITERAL}: [[10, 20]]. FileCheck Regex Matching Syntax; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. All FileCheck directives take a pattern to match.; For most uses of FileCheck, fixed string matching is perfectly sufficient. For; some things, a more flexible form of matching is desired. To support this,; FileCheck allows you to specify regular expressions in matching strings,; surrounded by double braces: ``{{yourregex}}``. FileCheck implements a POSIX; regular expression matcher; it supports Extended POSIX regular expressions; (ERE). Because we want to use fixed string matching for a majority of what we; do, FileCheck has been designed to support mixing and matching fixed string; matching with regular expressions. This allows you to write things like this:. .. code-block:: llvm. ; CHECK: movhpd	{{[0-9]+}}(%esp), {{%xmm[0-7]}}. In this case, any offset from the ESP register will be allowed, and any xmm; register will be allowed. Because regular expressions are enclosed with double braces, they are; visually distinct, and you don't need to use escape characters within the double; braces like you would in C. In the rare case that you want to match double; braces explicitly from the input, you can use something ugly like; ``{{[}][}]}}`` as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:24764,flexible,flexible,24764,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['flexible'],['flexible']
Modifiability,"e most use. Many users just want their; code to compile, they don't care to argue about whether it is pedantically C99; or not.; As mentioned above, all; extensions are explicitly recognized as such and marked with extension; diagnostics, which can be mapped to warnings, errors, or just ignored. Utility and Applications. Library Based Architecture. A major design concept for clang is its use of a library-based; architecture. In this design, various parts of the front-end can be cleanly; divided into separate libraries which can then be mixed up for different needs; and uses. In addition, the library-based approach encourages good interfaces; and makes it easier for new developers to get involved (because they only need; to understand small pieces of the big picture). ""The world needs better compiler tools, tools which are built as libraries.; This design point allows reuse of the tools in new and novel ways. However,; building the tools as libraries isn't enough: they must have clean APIs, be as; decoupled from each other as possible, and be easy to modify/extend. This; requires clean layering, decent design, and keeping the libraries independent of; any specific client."". Currently, clang is divided into the following libraries and tool:. libsupport - Basic support library, from LLVM.; libsystem - System abstraction library, from LLVM.; libbasic - Diagnostics, SourceLocations, SourceBuffer abstraction,; file system caching for input source files.; libast - Provides classes to represent the C AST, the C type system,; builtin functions, and various helpers for analyzing and manipulating the; AST (visitors, pretty printers, etc).; liblex - Lexing and preprocessing, identifier hash table, pragma; handling, tokens, and macro expansion.; libparse - Parsing. This library invokes coarse-grained 'Actions'; provided by the client (e.g. libsema builds ASTs) but knows nothing about; ASTs or other client-specific data structures.; libsema - Semantic Analysis. This provides a set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:4573,extend,extend,4573,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['extend'],['extend']
Modifiability,"e multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. Attrib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:35346,config,configuration,35346,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"e native ``__weak`` support to ensure; calling convention compatibility, this transfer is always handled; automatically by the compiler. .. admonition:: Rationale. In earlier releases, when non-trivial ownership was only permitted; on fields in Objective-C++, the ABI used for such classes was the; ordinary ABI for non-trivial C++ classes, which passes arguments and; returns indirectly and does not transfer responsibility for arguments.; When support for Objective-C structs was added, it was decided to; change to the current ABI for three reasons:. - It permits ARC / non-ARC compatibility for structs containing only; ``__strong`` references, as long as the non-ARC side is careful about; transferring ownership. - It avoids unnecessary indirection for sufficiently small types that; the C ABI would prefer to pass in registers. - Given that struct arguments must be produced at +1 to satisfy C's; semantics of initializing the local parameter variable, transferring; ownership of that copy to the callee is generally better for ARC; optimization, since otherwise there will be releases in the caller; that are much harder to pair with transfers in the callee. Breaking compatibility with existing Objective-C++ structures was; considered an acceptable cost, as most Objective-C++ code does not have; binary-compatibility requirements. Any existing code which cannot accept; this compatibility break, which is necessarily Objective-C++, should; force the use of the standard C++ ABI by declaring an empty (but; non-defaulted) destructor. .. _arc.ownership.inference:. Ownership inference; -------------------. .. _arc.ownership.inference.variables:. Objects; ^^^^^^^. If an object is declared with retainable object owner type, but without an; explicit ownership qualifier, its type is implicitly adjusted to have; ``__strong`` qualification. As a special case, if the object's base type is ``Class`` (possibly; protocol-qualified), the type is adjusted to have ``__unsafe_unretained``; qualifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:64086,variab,variable,64086,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"e newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3836,plugin,plugin,3836,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"e now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters of reference type. Fixes:; (`#65153 <https://github.com/llvm/llvm-project/issues/65153>`_). - Clang now properly compares constraints on an out of line class template; declaration definition. Fixes:; (`#61763 <https://github.com/llvm/llvm-project/issues/61763>`_). - Fix a bug where implicit deduction guides are not correctly generated for nested template; classes. Fixes:; (`#46200 <https://github.com/llvm/llvm-project/issues/46200>`_); (`#57812 <https://github.com/llvm/llvm-project/issues/57812>`_). - Diagnose use of a variable-length array in a coroutine. The design of; coroutines is such that it is not possible to support VLA use. Fixes:; (`#65858 <https://github.com/llvm/llvm-project/issues/65858>`_). - Fix bug where we were overriding zero-initialization of class members when; default initializing a base class in a constant expression context. Fixes:; (`#69890 <https://github.com/llvm/llvm-project/issues/69890>`_). - Fix crash when template class static member imported to other translation unit.; Fixes:; (`#68769 <https://github.com/llvm/llvm-project/issues/68769>`_). - Clang now rejects incomplete types for ``__builtin_dump_struct``. Fixes:; (`#63506 <https://github.com/llvm/llvm-project/issues/63506>`_). - Fixed a crash for C++98/03 while checking an ill-formed ``_Static_assert`` expression.; Fixes: (`#72025 <https://github.com/llvm/llvm-project/issues/72025>`_). - Clang now defers the instantiation of explicit specifier until constraint checking; completes (except deduction guides). Fixes:; (`#59827 <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:52232,variab,variable-length,52232,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable-length']
Modifiability,"e of rule is suitable for your needs you can; implement the refactoring by subclassing the rule and implementing its; interface. The subclass should have a constructor that takes the inputs that; are needed to perform the refactoring. For example, if you want to implement a; rule that simply deletes a selection, you should create a subclass of; ``SourceChangeRefactoringRule`` with a constructor that accepts the selection; range:. .. code-block:: c++. class DeleteSelectedRange final : public SourceChangeRefactoringRule {; public:; DeleteSelection(SourceRange Selection) : Selection(Selection) {}. Expected<AtomicChanges>; createSourceReplacements(RefactoringRuleContext &Context) override {; AtomicChange Replacement(Context.getSources(), Selection.getBegin());; Replacement.replace(Context.getSource,; CharSourceRange::getCharRange(Selection), """");; return { Replacement };; }; private:; SourceRange Selection;; };. The rule's subclass can then be added to the list of refactoring action's; rules for a particular action using the ``createRefactoringActionRule``; function. For example, the class that's shown above can be added to the; list of action rules using the following code:. .. code-block:: c++. RefactoringActionRules Rules;; Rules.push_back(; createRefactoringActionRule<DeleteSelectedRange>(; SourceRangeSelectionRequirement()); );. The ``createRefactoringActionRule`` function takes in a list of refactoring; action rule requirement values. These values describe the initiation; requirements that have to be satisfied by the refactoring engine before the; provided action rule can be constructed and invoked. The next section; describes how these requirements are evaluated and lists all the possible; requirements that can be used to construct a refactoring action rule. Refactoring Action Rule Requirements; ------------------------------------. A refactoring action rule requirement is a value whose type derives from the; ``RefactoringActionRuleRequirement`` class. The type m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:6005,refactor,refactoring,6005,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,1,['refactor'],['refactoring']
Modifiability,"e ones which we think may surprise users when upgrading to; Clang |release| because of the opportunity they pose for disruption to existing; code bases. - Fix a bug in reversed argument for templated operators.; This breaks code in C++20 which was previously accepted in C++17.; Clang did not properly diagnose such casese in C++20 before this change. Eg:. .. code-block:: cpp. struct P {};; template<class S> bool operator==(const P&, const S&);. struct A : public P {};; struct B : public P {};. // This equality is now ambiguous in C++20.; bool ambiguous(A a, B b) { return a == b; }. template<class S> bool operator!=(const P&, const S&);; // Ok. Found a matching operator!=.; bool fine(A a, B b) { return a == b; }. To reduce such widespread breakages, as an extension, Clang accepts this code; with an existing warning ``-Wambiguous-reversed-operator`` warning.; Fixes `#53954 <https://github.com/llvm/llvm-project/issues/53954>`_. - The CMake variable ``GCC_INSTALL_PREFIX`` (which sets the default; ``--gcc-toolchain=``) is deprecated and will be removed. Specify; ``--gcc-install-dir=`` or ``--gcc-triple=`` in a `configuration file; <https://clang.llvm.org/docs/UsersManual.html#configuration-files>`_ as a; replacement.; (`#77537 <https://github.com/llvm/llvm-project/pull/77537>`_). C/C++ Language Potentially Breaking Changes; -------------------------------------------. - The default extension name for PCH generation (``-c -xc-header`` and ``-c; -xc++-header``) is now ``.pch`` instead of ``.gch``.; - ``-include a.h`` probing ``a.h.gch`` will now ignore ``a.h.gch`` if it is not; a clang pch file or a directory containing any clang pch file.; - Fixed a bug that caused ``__has_cpp_attribute`` and ``__has_c_attribute``; return incorrect values for some C++-11-style attributes. Below is a complete; list of behavior changes. .. csv-table::; :header: Test, Old value, New value. ``__has_cpp_attribute(unused)``, 201603, 0; ``__has_cpp_attribute(gnu::unused)``, 201603, 1; ``__has_c_a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:2253,variab,variable,2253,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability,"e public web server by a server-side; process that runs daily. Generally, the documentation for an attribute is a; stand-alone definition in `include/clang/Basic/AttrDocs.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/AttrDocs.td>`_; that is named after the attribute being documented. If the attribute is not for public consumption, or is an implicitly-created; attribute that has no visible spelling, the documentation list can specify the; ``InternalOnly`` object. Otherwise, the attribute should have its documentation; added to AttrDocs.td. Documentation derives from the ``Documentation`` tablegen type. All derived; types must specify a documentation category and the actual documentation itself.; Additionally, it can specify a custom heading for the attribute, though a; default heading will be chosen when possible. There are four predefined documentation categories: ``DocCatFunction`` for; attributes that appertain to function-like subjects, ``DocCatVariable`` for; attributes that appertain to variable-like subjects, ``DocCatType`` for type; attributes, and ``DocCatStmt`` for statement attributes. A custom documentation; category should be used for groups of attributes with similar functionality.; Custom categories are good for providing overview information for the attributes; grouped under it. For instance, the consumed annotation attributes define a; custom category, ``DocCatConsumed``, that explains what consumed annotations are; at a high level. Documentation content (whether it is for an attribute or a category) is written; using reStructuredText (RST) syntax. After writing the documentation for the attribute, it should be locally tested; to ensure that there are no issues generating the documentation on the server.; Local testing requires a fresh build of clang-tblgen. To generate the attribute; documentation, execute the following command::. clang-tblgen -gen-attr-docs -I /path/to/clang/include /path/to/clang/include/clang/Basic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:135359,variab,variable-like,135359,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable-like']
Modifiability,"e relative indent of the subsequent; lines is kept, that means the following:. .. code-block:: c++. before: after:; Minimum: 1; //if (b) { // if (b) {; // return true; // return true;; //} // }. Maximum: 0; /// List: ///List:; /// - Foo /// - Foo; /// - Bar /// - Bar. This option has only effect if ``ReflowComments`` is set to ``true``. Nested configuration flags:. Control of spaces within a single line comment. * ``unsigned Minimum`` The minimum number of spaces at the start of the comment. * ``unsigned Maximum`` The maximum number of spaces at the start of the comment. .. _SpacesInParens:. **SpacesInParens** (``SpacesInParensStyle``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParens>`; Defines in which cases spaces will be inserted after ``(`` and before; ``)``. Possible values:. * ``SIPO_Never`` (in configuration: ``Never``); Never put a space in parentheses. .. code-block:: c++. void f() {; if(true) {; f();; }; }. * ``SIPO_Custom`` (in configuration: ``Custom``); Configure each individual space in parentheses in; `SpacesInParensOptions`. .. _SpacesInParensOptions:. **SpacesInParensOptions** (``SpacesInParensCustom``) :versionbadge:`clang-format 17` :ref:`¶ <SpacesInParensOptions>`; Control of individual spaces in parentheses. If ``SpacesInParens`` is set to ``Custom``, use this to specify; how each individual space in parentheses case should be handled.; Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; InEmptyParentheses: true. Nested configuration flags:. Precise control over the spacing in parentheses. .. code-block:: c++. # Should be declared this way:; SpacesInParens: Custom; SpacesInParensOptions:; InConditionalStatements: true; Other: true. * ``bool InConditionalStatements`` Put a space in parentheses only inside conditional statements; (``for/if/while/switch...``). .. code-block:: c++. true: false:; if ( a ) { ... } vs. if (a) { ... }; while ( i < 5 ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:126388,config,configuration,126388,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"e results; in the summary output. This is useful for determining which tests in a test; suite take the most time to execute. .. option:: --ignore-fail. Exit with status zero even if some tests fail. .. _selection-options:. SELECTION OPTIONS; -----------------. By default, `lit` will run failing tests first, then run tests in descending; execution time order to optimize concurrency. The execution order can be; changed using the :option:`--order` option. The timing data is stored in the `test_exec_root` in a file named; `.lit_test_times.txt`. If this file does not exist, then `lit` checks the; `test_source_root` for the file to optionally accelerate clean builds. .. option:: --shuffle. Run the tests in a random order, not failing/slowest first. Deprecated,; use :option:`--order` instead. .. option:: --per-test-coverage. Emit the necessary test coverage data, divided per test case (involves; setting a unique value to LLVM_PROFILE_FILE for each RUN). The coverage; data files will be emitted in the directory specified by `config.test_exec_root`. .. option:: --max-failures N. Stop execution after the given number ``N`` of failures.; An integer argument should be passed on the command line; prior to execution. .. option:: --max-tests=N. Run at most ``N`` tests and then terminate. .. option:: --max-time=N. Spend at most ``N`` seconds (approximately) running tests and then terminate.; Note that this is not an alias for :option:`--timeout`; the two are; different kinds of maximums. .. option:: --num-shards=M. Divide the set of selected tests into ``M`` equal-sized subsets or; ""shards"", and run only one of them. Must be used with the; ``--run-shard=N`` option, which selects the shard to run. The environment; variable ``LIT_NUM_SHARDS`` can also be used in place of this; option. These two options provide a coarse mechanism for partitioning large; testsuites, for parallel execution on separate machines (say in a large; testing farm). .. option:: --order={lexical,random,smart}. D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:6142,config,config,6142,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config']
Modifiability,"e second property, let us look at f2 as an example. In the interleaved layout,; there are two entries for f2: B::f2 and D::f2. The distance between &B::f2; and its address point D::offset-to-top (the entry immediately after &B::rtti) is 5 entry-length, so is the distance between &D::f2 and C::offset-to-top (the entry immediately after &D::rtti). Forward-Edge CFI for Indirect Function Calls; ============================================. Under forward-edge CFI for indirect function calls, each unique function; type has its own bit vector, and at each call site we need to check that the; function pointer is a member of the function type's bit vector. This scheme; works in a similar way to forward-edge CFI for virtual calls, the distinction; being that we need to build bit vectors of function entry points rather than; of virtual tables. Unlike when re-arranging global variables, we cannot re-arrange functions; in a particular order and base our calculations on the layout of the; functions' entry points, as we have no idea how large a particular function; will end up being (the function sizes could even depend on how we arrange; the functions). Instead, we build a jump table, which is a block of code; consisting of one branch instruction for each of the functions in the bit; set that branches to the target function, and redirect any taken function; addresses to the corresponding jump table entry. In this way, the distance; between function entry points is predictable and controllable. In the object; file's symbol table, the symbols for the target functions also refer to the; jump table entries, so that addresses taken outside the module will pass; any verification done inside the module. In more concrete terms, suppose we have three functions ``f``, ``g``,; ``h`` which are all of the same type, and a function foo that returns their; addresses:. .. code-block:: none. f:; mov 0, %eax; ret. g:; mov 1, %eax; ret. h:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:16710,variab,variables,16710,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['variab'],['variables']
Modifiability,"e set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk1' instead of 'host' only as; it was so far). These feature can be enabled by defining the rootrc; variable 'Packetizer.Partitions', e.g.;            Packetizer.Partitions  /disk1,/disk2,/disk3; Add to the output list the parameters used by the active packetizer. . In the PrintProgress function used to display a text progress; bar, show also the average reading rate in [k,M,G}bytes/s in addition; to the event processing rate. This is useful to have a feeling of the; rate when running of a remote machine in batch mode.; Add the possibility to control the resident and virtual; memory of a proofserv using 'ulimit', which has less limitations and; more flexibility than setrlimit.; Deactivate workers when the requested packages could not be enabled properly.; Add support for reconfiguring the group manager and the; {env,rootrc} settings. The related configuration files are checked for; changes during the regular checks done by the XrdProofdManager.; Add support for selective definition of env and rootrc; variables. Different values can be set for different users, groups, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:7651,variab,variable,7651,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['variab'],['variable']
Modifiability,"e set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via using the following scripts. Similarly to the local environment, configuration is split in different files; to allow for a system-wide configuration, which has precedence over; user's configuration in the home directory. If a script cannot be found,; it will be silently skipped. - `<output_of_payload>`. - `common.before`. - `remote.before`. - `remote.conf`. - `common.after`. - `remote.after`. For an explanation on how to pass extra data to the workers safely; through the payload, see below. ### Payload: sending local files to the remote nodes. In many cases it is necessary to send some local data to the remote; workers: it is very common, for instance, to distribute a local Grid; authentication proxy on the remote workers to let them authenticate to; access a data storage. The `payload` file must be an executable generating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:4369,config,configured,4369,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configured']
Modifiability,"e show how to extend; it with control flow operations ('if' statement and a 'for' loop). This; gives us a chance to talk about SSA construction and control; flow.; - `Chapter #6: Extending the Language: User-defined Operators; <LangImpl06.html>`_ - This chapter extends the language to let; users define arbitrary unary and binary operators - with assignable; precedence! This allows us to build a significant piece of the; ""language"" as library routines.; - `Chapter #7: Extending the Language: Mutable Variables; <LangImpl07.html>`_ - This chapter talks about adding user-defined local; variables along with an assignment operator. This shows how easy it is; to construct SSA form in LLVM: LLVM does *not* require your front-end; to construct SSA form in order to use it!; - `Chapter #8: Compiling to Object Files <LangImpl08.html>`_ - This; chapter explains how to take LLVM IR and compile it down to object; files, like a static compiler does.; - `Chapter #9: Debug Information <LangImpl09.html>`_ - A real language; needs to support debuggers, so we; add debug information that allows setting breakpoints in Kaleidoscope; functions, print out argument variables, and call functions!; - `Chapter #10: Conclusion and other tidbits <LangImpl10.html>`_ - This; chapter wraps up the series by discussing ways to extend the language; and includes pointers to info on ""special topics"" like adding garbage; collection support, exceptions, debugging, support for ""spaghetti; stacks"", etc. By the end of the tutorial, we'll have written a bit less than 1000 lines; of (non-comment, non-blank) lines of code. With this small amount of; code, we'll have built up a nice little compiler for a non-trivial; language including a hand-written lexer, parser, AST, as well as code; generation support - both static and JIT! The breadth of this is a great; testament to the strengths of LLVM and shows why it is such a popular; target for language designers and others who need high performance code; generation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst:3867,variab,variables,3867,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/index.rst,2,"['extend', 'variab']","['extend', 'variables']"
Modifiability,"e split-level is 1, an object data member is assigned a branch.; If the split-level is 2, the data member objects will be split also, and; a split level of 3 its data members objects, will be split. As the; split-level increases so does the splitting depth. The ROOT default for; the split-level is 99. This means the object will be split to the; maximum. #### Memory Considerations when Splitting a Branch. Splitting a branch can quickly generate many branches. Each branch has; its own buffer in memory. In case of many branches (say more than 100),; you should adjust the buffer size accordingly. A recommended buffer size; is 32000 bytes if you have less than 50 branches. Around 16000 bytes if; you have less than 100 branches and 4000 bytes if you have more than 500; branches. These numbers are recommended for computers with memory size; ranging from 32MB to 256MB. If you have more memory, you should specify; larger buffer sizes. However, in this case, do not forget that your file; might be used on another machine with a smaller memory configuration. #### Performance Considerations when Splitting a Branch. A split branch is faster to read, but slightly slower to write. The; reading is quicker because variables of the same type are stored; consecutively and the type does not have to be read each time. It is; slower to write because of the large number of buffers as described; above. See "". Performance Benchmarks"" for performance impact of split and non-split; mode. #### Rules for Splitting. When splitting a branch, variables of different types are handled; differently. Here are the rules that apply when splitting a branch. - If a data member is a basic type, it becomes one branch of class; **`TBranchElement`**. - A data member can be an array of basic types. In this case, one; single branch is created for the array. - A data member can be a pointer to an array of basic types. The; length can vary, and must be specified in the comment field of the; data member in the class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:26389,config,configuration,26389,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['config'],['configuration']
Modifiability,"e statistics; gathered, use the '``-stats``' option:. .. code-block:: none. $ opt -stats -mypassname < program.bc > /dev/null; ... statistics output ... Note that in order to use the '``-stats``' option, LLVM must be; compiled with assertions enabled. When running ``opt`` on a C file from the SPEC benchmark suite, it gives a; report that looks like this:. .. code-block:: none. 7646 bitcodewriter - Number of normal instructions; 725 bitcodewriter - Number of oversized instructions; 129996 bitcodewriter - Number of bitcode bytes written; 2817 raise - Number of insts DCEd or constprop'd; 3213 raise - Number of cast-of-self removed; 5046 raise - Number of expression trees converted; 75 raise - Number of other getelementptr's formed; 138 raise - Number of load/store peepholes; 42 deadtypeelim - Number of unused typenames removed from symtab; 392 funcresolve - Number of varargs functions resolved; 27 globaldce - Number of global variables removed; 2 adce - Number of basic blocks removed; 134 cee - Number of branches revectored; 49 cee - Number of setcc instruction eliminated; 532 gcse - Number of loads removed; 2919 gcse - Number of instructions removed; 86 indvars - Number of canonical indvars added; 87 indvars - Number of aux indvars removed; 25 instcombine - Number of dead inst eliminate; 434 instcombine - Number of insts combined; 248 licm - Number of load insts hoisted; 1298 licm - Number of insts hoisted to a loop pre-header; 3 licm - Number of insts hoisted to multiple loop preds (bad, no loop pre-header); 75 mem2reg - Number of alloca's promoted; 1444 cfgsimplify - Number of blocks simplified. Obviously, with so many optimizations, having a unified framework for this stuff; is very nice. Making your pass fit well into the framework makes it more; maintainable and useful. .. _DebugCounters:. Adding debug counters to aid in debugging your code; ---------------------------------------------------. Sometimes, when writing new passes, or trying to track down bugs, it; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:48791,variab,variables,48791,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variables']
Modifiability,"e symbol table. For; example:. .. code-block:: llvm. !foo = !{!4, !3}. Metadata can be used as function arguments. Here the ``llvm.dbg.value``; intrinsic is using three metadata arguments:. .. code-block:: llvm. call void @llvm.dbg.value(metadata !24, metadata !25, metadata !26). Metadata can be attached to an instruction. Here metadata ``!21`` is attached; to the ``add`` instruction using the ``!dbg`` identifier:. .. code-block:: llvm. %indvar.next = add i64 %indvar, 1, !dbg !21. Instructions may not have multiple metadata attachments with the same; identifier. Metadata can also be attached to a function or a global variable. Here metadata; ``!22`` is attached to the ``f1`` and ``f2`` functions, and the globals ``g1``; and ``g2`` using the ``!dbg`` identifier:. .. code-block:: llvm. declare !dbg !22 void @f1(); define void @f2() !dbg !22 {; ret void; }. @g1 = global i32 0, !dbg !22; @g2 = external global i32, !dbg !22. Unlike instructions, global objects (functions and global variables) may have; multiple metadata attachments with the same identifier. A transformation is required to drop any metadata attachment that it; does not know or know it can't preserve. Currently there is an; exception for metadata attachment to globals for ``!func_sanitize``,; ``!type``, ``!absolute_symbol`` and ``!associated`` which can't be; unconditionally dropped unless the global is itself deleted. Metadata attached to a module using named metadata may not be dropped, with; the exception of debug metadata (named metadata with the name ``!llvm.dbg.*``). More information about specific metadata nodes recognized by the; optimizers and code generator is found below. .. _specialized-metadata:. Specialized Metadata Nodes; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Specialized metadata nodes are custom data structures in metadata (as opposed; to generic tuples). Their fields are labelled, and can be specified in any; order. These aren't inherently debug info centric, but currently all the specialized; metada",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:245064,variab,variables,245064,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"e that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consider the example in `$ROOTSYS/test/Event.h`. The top-level branch in; the tree `T` is declared with:. ``` {.cpp}; Event *event = 0;; // event must be null or point to a valid object;; // it must be initialized; T.SetBranchAddress(""event"",&event);; ```. When reading the Tree, one can choose one of these 3 options:. Option 1:. ``` {.cpp}; for (Int_t i = 0; i<nentries; i++) {; T.GetEntry(i);; //the object event has been filled at this point; }; ```. This ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38542,variab,variable,38542,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"e the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:7328,config,configuration,7328,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"e the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different interpreters and versions; (as e.g. done for conda). In the case of cppyy, only CPython/CPyCppyy and PyPy/_cppyy (an internal; module) depend on the Python interpreter (see:; :ref:`Package Structure <package-structure>`).; The user-facing ``cppyy`` module is pure Python and the backend (Cling) is; Python-independent.; Most importantly, since all bindings are generated at run-time, there are no; extension mod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10387,portab,portable,10387,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['portab'],['portable']
Modifiability,"e the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70708,adapt,adapter,70708,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['adapt'],['adapter']
Modifiability,"e the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; sta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15238,config,config,15238,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,['config'],['config']
Modifiability,"e the hierarchy; of nodes, after setting this point it is mandatory to call the; `‘Where am I?'` method:. ~~~{.cpp}; gGeoManager->FindNode();; ~~~. In order to have more flexibility, there are in fact several alternative; ways of initializing a modeller state:. ~~~{.cpp}; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; ~~~. Note that the current point coordinates can be changed and the state; re-initialized at any time. This represents the `‘Where am I?'`; geometrical query representing the basic navigation functionality; provided by the modeller. \anchor GP02e; ### Checking the Current State. The current state and all variables related to this are essential during; tracking and have to be checked several times. Besides the current point; and direction, the following additional information can be retrieved; from TGeoManager interface:. - The `current path`. This represents a string containing the names; and copy numbers of all positioned objects in the current `branch`; written in the /folder/folder/.../folder/file fashion. The final node; pointed by the path is the deepest object containing the current; point and is representative for the current state. All intermediate; `folders` in the path are in fact also nodes ""touched"" by the; current point, but having some ""touched"" containment. The current; path can be retrieved only after the state was initialized and is; useful for getting an idea of the current point location. ~~~{.cpp}; const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; ~~~. - The `current node`, `volume` and `material`. In order to; take decisions on post-step or",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:67708,variab,variables,67708,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['variab'],['variables']
Modifiability,"e the opening `{`. You'll know that `D` inherits from `C` by the `// C` comment on the `class D {` line in the output. Not very interesting though, what are we actually inheriting? The members of the parent class. ```tablegen; class C {; int a;; }; class D : C {}; ```. ------------- Classes -----------------; class C {; int a = ?;; }; class D {	// C; int a = ?;; }; ------------- Defs -----------------. Note that `D` now has the `a` member which was defined in the class `C`. You can inherit from multiple classes. In that case the order that that happens in matches the order you write the class names after the `:`. ```tablegen; class C {; int a = 1;; }; class D {; int a = 2;; }; class E : C, D {}; ```. ------------- Classes -----------------; class C {; int a = 1;; }; class D {; int a = 2;; }; class E {	// C D; int a = 2;; }; ------------- Defs -----------------. Class `E` first inherits from class `C`. This gives `E` a member `a` with value `1`. Then it inherits from class `D` which also has a member `a` but with a value of `2`. Meaning the final value of `E`'s `a` is `2`. When a member has the same name this is handled on a ""last one in wins"" basis. Assuming the types match. ```tablegen; class C {; string a = """";; }; class D {; int a = 2;; }; class E : C, D {}; ```. <stdin>:7:14: error: New definition of 'a' of type 'int' is incompatible with previous definition of type 'string'; class E : C, D {}; ^. When they don't match, we get an error. Luckily for us, we're about to learn all about types. ## Types. TableGen is statically typed with error checking to prevent you from assigning things with mismatched types. ```tablegen; class C {; int a;; bit b = 0;; string s = ""Hello"";; }; ```. ------------- Classes -----------------; class C {; int a = ?;; bit b = 0;; string s = ""Hello"";; }; ------------- Defs -----------------. Here we've created a class C with integer, bit (1 or 0) and string members. See [here](https://llvm.org/docs/TableGen/ProgRef.html#types) for a full lis",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:4217,inherit,inherits,4217,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['inherit'],['inherits']
Modifiability,"e the parameters, but the errors will; scale with the sum of the weights, rather than the number of the events in the dataset (i.e.; if you double all event weights, all parameter errors will go down with sqrt(2)). In chi-squared; fits event weights can processed correctly by using both the sum of the weights and the; sum of the weights-squared for each bin. The newly added option SumW2Error() implements a similar; strategy for (unbinned) weighted ML fits by applying a correction to the covariance matrix; as follows. V' = V C-1 V. where V is the covariance matrix from the fit to weighted data, and C-1 is the inverse of the; covariance matrix calculated from a similar likelihood that constructed with the event weights applied squared. Redesign of RooFit dataset class structure. The original class structure of RooFit featured an abstract dataset; class RooAbsData. Inheriting from that was a single class; RooTreeData, which implemented datasets with a ROOT; TTree-based storage implementation, and inheriting from that; two classes RooDataSet , representing unbinned data, and; RooDataHist, representing binned data. A main problem with; this structure was that the implementation of the storage technology; (TTree) and the data representation (binned vs unbinned) were; intertwined. Starting with version 3.00, the class structure has been; rearranged: Now classes RooDataSet and RooDataHist inherit directly; from class RooAbsData, and class RooAbsData now owns an object that; inherits from RooAbsDataStore that implements the storage of the; data. This new class structure allows multiple data storage implementations to; be applied efficiently to both RooDataSet and RooDataHist; At present a single implementation of RooAbsDataStore exists,; class RooTreeDataStore, that contains the storage implementation; formerly implement in class RooTreeData. Methods in class RooTreeData; that were not specific to the storage technology have been moved to; class RooAbsData. If your user code ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:13673,inherit,inheriting,13673,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['inherit'],['inheriting']
Modifiability,"e the program bottom-up on the call graph (callees; before callers). Deriving from ``CallGraphSCCPass`` provides some mechanics; for building and traversing the ``CallGraph``, but also allows the system to; optimize execution of ``CallGraphSCCPass``\ es. If your pass meets the; requirements outlined below, and doesn't meet the requirements of a; :ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`, you should derive from; ``CallGraphSCCPass``. ``TODO``: explain briefly what SCC, Tarjan's algo, and B-U mean. To be explicit, CallGraphSCCPass subclasses are:. #. ... *not allowed* to inspect or modify any ``Function``\ s other than those; in the current SCC and the direct callers and direct callees of the SCC.; #. ... *required* to preserve the current ``CallGraph`` object, updating it to; reflect any changes made to the program.; #. ... *not allowed* to add or remove SCC's from the current Module, though; they may change the contents of an SCC.; #. ... *allowed* to add or remove global variables from the current Module.; #. ... *allowed* to maintain state across invocations of :ref:`runOnSCC; <writing-an-llvm-pass-runOnSCC>` (including global data). Implementing a ``CallGraphSCCPass`` is slightly tricky in some cases because it; has to handle SCCs with more than one node in it. All of the virtual methods; described below should return ``true`` if they modified the program, or; ``false`` if they didn't. The ``doInitialization(CallGraph &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(CallGraph &CG);. The ``doInitialization`` method is allowed to do most of the things that; ``CallGraphSCCPass``\ es are not allowed to do. They can add and remove; functions, get pointers to functions, etc. The ``doInitialization`` method is; designed to do simple initialization type of stuff that does not depend on the; SCCs being processed. The ``doInitialization`` method call is not scheduled to; overlap with any other pass e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:15297,variab,variables,15297,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['variab'],['variables']
Modifiability,"e the source base approachable; by commenting it well, including citations of the language standards where; appropriate, and designing the code for simplicity. Beyond that, clang offers; a set of AST dumpers, printers, and visualizers that make it easy to put code in; and see how it is represented. A single unified parser for C, Objective C, C++,; and Objective C++. Clang is the ""C Language Family Front-end"", which means we intend to support; the most popular members of the C family. We are convinced that the right; parsing technology for this class of languages is a hand-built recursive-descent; parser. Because it is plain C++ code, recursive descent makes it very easy for; new developers to understand the code, it easily supports ad-hoc rules and other; strange hacks required by C/C++, and makes it straight-forward to implement; excellent diagnostics and error recovery.; We believe that implementing C/C++/ObjC in a single unified parser makes the; end result easier to maintain and evolve than maintaining a separate C and C++; parser which must be bugfixed and maintained independently of each other. Conformance with C/C++/ObjC and their; variants. When you start work on implementing a language, you find out that there is a; huge gap between how the language works and how most people understand it to; work. This gap is the difference between a normal programmer and a (scary?; super-natural?) ""language lawyer"", who knows the ins and outs of the language; and can grok standardese with ease.; In practice, being conformant with the languages means that we aim to support; the full language, including the dark and dusty corners (like trigraphs,; preprocessor arcana, C99 VLAs, etc). Where we support extensions above and; beyond what the standard officially allows, we make an effort to explicitly call; this out in the code and emit warnings about it (which are disabled by default,; but can optionally be mapped to either warnings or errors), allowing you to use; clang in ""str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:13451,evolve,evolve,13451,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['evolve'],['evolve']
Modifiability,"e this:. int mask[1000];; int foo(unsigned x) {; if (x < 10); x = x * 45;; else; x = x * 78;; return mask[x];; }. _foo:; LBB1_0:	## entry; 	cmpl	$9, %edi; 	jbe	LBB1_3	## bb; LBB1_1:	## bb1; 	imull	$78, %edi, %eax; LBB1_2:	## bb2; 	movl	%eax, %eax <----; 	movq	_mask@GOTPCREL(%rip), %rcx; 	movl	(%rcx,%rax,4), %eax; 	ret; LBB1_3:	## bb; 	imull	$45, %edi, %eax; 	jmp	LBB1_2	## bb2; ; Before regalloc, we have:. %reg1025 = IMUL32rri8 %reg1024, 45, implicit-def %eflags; JMP mbb<bb2,0x203afb0>; Successors according to CFG: 0x203afb0 (#3). bb1: 0x203af60, LLVM BB @0x1e02310, ID#2:; Predecessors according to CFG: 0x203aec0 (#0); %reg1026 = IMUL32rri8 %reg1024, 78, implicit-def %eflags; Successors according to CFG: 0x203afb0 (#3). bb2: 0x203afb0, LLVM BB @0x1e02340, ID#3:; Predecessors according to CFG: 0x203af10 (#1) 0x203af60 (#2); %reg1027 = PHI %reg1025, mbb<bb,0x203af10>,; %reg1026, mbb<bb1,0x203af60>; %reg1029 = MOVZX64rr32 %reg1027. so we'd have to know that IMUL32rri8 leaves the high word zero extended and to; be able to recognize the zero extend. This could also presumably be implemented; if we have whole-function selectiondags. //===---------------------------------------------------------------------===//. Take the following code; (from http://gcc.gnu.org/bugzilla/show_bug.cgi?id=34653):; extern unsigned long table[];; unsigned long foo(unsigned char *p) {; unsigned long tag = *p;; return table[tag >> 4] + table[tag & 0xf];; }. Current code generated:; 	movzbl	(%rdi), %eax; 	movq	%rax, %rcx; 	andq	$240, %rcx; 	shrq	%rcx; 	andq	$15, %rax; 	movq	table(,%rax,8), %rax; 	addq	table(%rcx), %rax; 	ret. Issues:; 1. First movq should be movl; saves a byte.; 2. Both andq's should be andl; saves another two bytes. I think this was; implemented at one point, but subsequently regressed.; 3. shrq should be shrl; saves another byte.; 4. The first andq can be completely eliminated by using a slightly more; expensive addressing mode. //===---------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt:3885,extend,extended,3885,interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-X86-64.txt,2,['extend'],"['extend', 'extended']"
Modifiability,"e to fill a histogram, but not draw it you can use the; `TTree::Project()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119033,variab,variable,119033,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"e to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; point. ## How to Use Folders. Using folders means to build a hierarchy of folders, posting the; reference to the data in the folder by the producer, and creating a; reference to the folder by the user. ### Creating a Folder Hierarchy. To create a folder hierarchy you add the top folder of your hierarchy to; `//root`. Then you add a folder to an existing folder with the; **`TFolder::AddFolder`** method. This method takes two parameters: the; name and title of the folder to be added. It returns a pointer of the; newly created folder. The code below creates the folder hierarc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1789,enhance,enhances,1789,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['enhance'],['enhances']
Modifiability,"e transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line style is; set with:. ``` {.cpp}; root[] li->SetLineStyle(style); ```. The argument style is one of: 1=solid, 2=dash, 3=dot, 4=dash-dot. The line width may be set by a method call. What is said here applies to; all objects deriving from **`TAttLine`**, and there are many; (histograms, plots). We will take an example that may be transposed to; other types. Suppose ""`li`"" is a **`TLine`** object. The line width is; set with:. ``` {.cpp}; root[] li->SetLineWidth(width); ```. The `width` is the width expressed in pixel units. ![](pictures/030000D1.png) The user interface for changing the line; color, line width and style looks like shown in this picture. It takes; place in the editor frame anytime the selected object inherits the class; **`TAttLine`**. ### Fill Attributes. Almost all graphics classes have a fill area somewhere. These classes; have to deal with fill attributes. This is done by using secondary; inheritance of the class **`TAttFill`**. Fill color may be set by a; method call. What is said here applies to all objects deriving from; **`TAttFill`**, and there are many (histograms, plots). We will take an; example that may be transposed to other types. Suppose ""`h`"" is a; **`TH1F`** (1 dim histogram) object. The histogram fill color is set; with:. ``` {.cpp}; root[] h->SetFillColor(color); ```. The color is a color number. The colors are described in ""Color and; color palettes"". Fill style may be set by a method call. What is said here applies to all; objects deriving from `TAttFill`, and there are many (histograms,; plots). We will take an example that may be transposed to other types.; Suppose ""`h`"" is a **TH1F** (1 dim histogram) object. The histogram fill; style is set with:. ``` {.cpp}; root[] h->SetFillStyle(style); ```. The convention for style is: 0:hollow, 1001:solid, 2001:hatch style,; 3000+pattern number:patterns, 4000 to 4100:transparency, 4000:fully; transparent, 4100: f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:77410,inherit,inheritance,77410,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inheritance']
Modifiability,"e used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_ENABLE_LTO=Thin`` will enable ThinLTO for stage 2 and; stage 3 in case the compiler used for stage 1 does not support the ThinLTO; option. More Information; ================. * From LLVM project blog:; `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8767,config,configuring,8767,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,3,"['config', 'plugin']","['configure', 'configuring', 'plugin']"
Modifiability,"e was used. The distinction between actions and rules enables the creation of actions; that define a set of different rules that produce similar results. For example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks mig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3459,refactor,refactor,3459,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"e we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (integers and floating-point) variables. ### Writing the Tree. Below is the function that writes the tree (`tree1w`). First, the; variables are defined (`px, py, pz,` `random` and `ev`). Then we add a; branch for each of the variables to the tree, by calling the; `TTree::Branch` method for each variable. ``` {.cpp}; void tree1w(){. // create a tree file tree1.root - create the file, the Tree and; // a few branches; TFile f(""tree1.root"",""recreate"");; TTree t1(""t1"",""a simple Tree with simple variables"");; Float_t px, py, pz;; Double_t random;; Int_t ev;; t1.Branch(""px"",&px,""px/F"");; t1.Branch(""py"",&py,""py/F"");; t1.Branch(""pz"",&pz,""pz/F"");; t1.Branch(""ev"",&ev,""ev/I"");. // fill the tree; for (Int_t i=0; i<10000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; random = gRandom->Rndm();; ev = i;; t1.Fill();; }; // save the Tree heade; the file will be automatically closed; // when going out of the function scope; t1.Write();; }; ```. #### Creating Branches with A single Variable. This is the signature of `TTree::Branch` to create a branch with a list; of variables:. ``` {.cpp}; TBranch* TTree::Branch(const char* name,void* address,; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:35067,variab,variables,35067,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"e with an unreachable unwind destination to a call instruction. #. Use profile metadata to indicate statically known cold paths, even if; dynamic profiling information is not available. This can make a large; difference in code placement and thus the performance of tight loops. #. When generating code for loops, try to avoid terminating the header block of; the loop earlier than necessary. If the terminator of the loop header; block is a loop exiting conditional branch, the effectiveness of LICM will; be limited for loads not in the header. (This is due to the fact that LLVM; may not know such a load is safe to speculatively execute and thus can't; lift an otherwise loop invariant load unless it can prove the exiting; condition is not taken.) It can be profitable, in some cases, to emit such; instructions into the header even if they are not used along a rarely; executed path that exits the loop. This guidance specifically does not; apply if the condition which terminates the loop header is itself invariant,; or can be easily discharged by inspecting the loop index variables. #. In hot loops, consider duplicating instructions from small basic blocks; which end in highly predictable terminators into their successor blocks.; If a hot successor block contains instructions which can be vectorized; with the duplicated ones, this can provide a noticeable throughput; improvement. Note that this is not always profitable and does involve a; potentially large increase in code size. #. When checking a value against a constant, emit the check using a consistent; comparison type. The GVN pass *will* optimize redundant equalities even if; the type of comparison is inverted, but GVN only runs late in the pipeline.; As a result, you may miss the opportunity to run other important; optimizations. #. Avoid using arithmetic intrinsics unless you are *required* by your source; language specification to emit a particular code sequence. The optimizer; is quite good at reasoning about gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:8030,variab,variables,8030,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['variab'],['variables']
Modifiability,"e(""bar_body""), ReexportedFlags } }; }));. A full example of how to use lazyReexports with the LLJIT class can be found at; ``llvm/examples/OrcV2Examples/LLJITWithLazyReexports``. Supporting Custom Compilers; ===========================. TBD. .. _transitioning_orcv1_to_orcv2:. Transitioning from ORCv1 to ORCv2; =================================. Since LLVM 7.0, new ORC development work has focused on adding support for; concurrent JIT compilation. The new APIs (including new layer interfaces and; implementations, and new utilities) that support concurrency are collectively; referred to as ORCv2, and the original, non-concurrent layers and utilities; are now referred to as ORCv1. The majority of the ORCv1 layers and utilities were renamed with a 'Legacy'; prefix in LLVM 8.0, and have deprecation warnings attached in LLVM 9.0. In LLVM; 12.0 ORCv1 will be removed entirely. Transitioning from ORCv1 to ORCv2 should be easy for most clients. Most of the; ORCv1 layers and utilities have ORCv2 counterparts [2]_ that can be directly; substituted. However there are some design differences between ORCv1 and ORCv2; to be aware of:. 1. ORCv2 fully adopts the JIT-as-linker model that began with MCJIT. Modules; (and other program representations, e.g. Object Files) are no longer added; directly to JIT classes or layers. Instead, they are added to ``JITDylib``; instances *by* layers. The ``JITDylib`` determines *where* the definitions; reside, the layers determine *how* the definitions will be compiled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:19785,layers,layers,19785,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['layers'],['layers']
Modifiability,"e(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; -------------------------. XRay supports a logging mode which allows the application to only capture a; fixed amount of memory's worth of events. Flight Data Recorder (FDR) mode works; very much like a plane's ""black box"" which keeps recording data to memory in a; fixed-size circular queue of buffers, and have the data available; programmatically until the buffers are finalized and flushed. To use FDR mode; on your application, you may set the ``xray_mode`` variable to ``xray-fdr`` in; the ``XRAY_OPTIONS`` environment variable. Additional options to the FDR mode; implementation can be provided in the ``XRAY_FDR_OPTIONS`` environment; variable. Programmatic configuration can be done by calling; ``__xray_log_init_mode(""xray-fdr"", <configuration string>)`` once it has been; selected/installed. When the buffers are flushed to disk, the result is a binary trace format; described by `XRay FDR format <XRayFDRFormat.html>`_. When FDR mode is on, it will keep writing and recycling memory buffers until; the logging implementation is finalized -- at which point it can be flushed and; re-initialised later. To do this programmatically, we follow the workflow; provided below:. .. code-block:: c++. // Patch the sleds, if we haven't yet.; auto patch_status = __xray_patch();. // Maybe handle the patch_status errors. // When we want to flush the log, we need to finalize it first, to give; // threads a chance to return buffers to the queue.; auto finalize_status = __xray_log_finalize();; if (finalize_status != XRAY_LOG_FINALIZED) {; // maybe retry, or bail out.; }. // At this point, we are sure that the log is finalized, so we may try; // flushing the log.; auto flush_status = __xray_log_flushLog();; if (flush_statu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:9451,config,configuration,9451,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,2,['config'],['configuration']
Modifiability,"e(42)); matches ""int a[42]"" and ""int b[2 * 21]""; stringLiteral(hasSize(4)); matches ""abcd"", L""abcd"". Matcher<DeclStmt>declCountIsunsigned N; Matches declaration statements that contain a specific number of; declarations. Example: Given; int a, b;; int c;; int d = 2, e;; declCountIs(2); matches 'int a, b;' and 'int d = 2, e;', but not 'int c;'. Matcher<Decl>equalsBoundNodestd::string ID; Matches if a node equals a previously bound node. Matches a node if it equals the node previously bound to ID. Given; class X { int a; int b; };; cxxRecordDecl(; has(fieldDecl(hasName(""a""), hasType(type().bind(""t"")))),; has(fieldDecl(hasName(""b""), hasType(type(equalsBoundNode(""t"")))))); matches the class X, as a and b have the same type. Note that when multiple matches are involved via forEach* matchers,; equalsBoundNodes acts as a filter.; For example:; compoundStmt(; forEachDescendant(varDecl().bind(""d"")),; forEachDescendant(declRefExpr(to(decl(equalsBoundNode(""d"")))))); will trigger a match for each combination of variable declaration; and reference to that variable declaration within a compound statement. Matcher<Decl>equalsNodeconst Decl* Other; Matches if a node equals another node. Decl has pointer identity in the AST. Matcher<Decl>hasAttrattr::Kind AttrKind; Matches declaration that has a given attribute. Given; __attribute__((device)) void f() { ... }; decl(hasAttr(clang::attr::CUDADevice)) matches the function declaration of; f. If the matcher is used from clang-query, attr::Kind parameter should be; passed as a quoted string. e.g., hasAttr(""attr::CUDADevice""). Matcher<Decl>isExpandedFromMacrostd::string MacroName; Matches statements that are (transitively) expanded from the named macro.; Does not match if only part of the statement is expanded from that macro or; if different parts of the statement are expanded from different; appearances of the macro. Matcher<Decl>isExpansionInFileMatchingStringRef RegExp, Regex::RegexFlags Flags = NoFlags; Matches AST nodes that were exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:81294,variab,variable,81294,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"e(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. However, this will cause ``!3`` to have the return value of ``@gazonk()`` at; the same time as ``!1`` has the constant value zero -- a pair of assignments; that never occurred in the unoptimized program. To avoid this, we must terminate; the range that ``!1`` has the constant value assignment by inserting a poison; dbg.value before the dbg.value for ``!3``:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); %g = call i32 @gazonk(); call @llvm.dbg.value(metadata i32 poison, metadata !1, metadata !2); call @llvm.dbg.value(metadata i32 %g, metadata !3, metadata !2); %addoper = select i1 %cond, i32 11, i32 12; %plusten = add i32 %bar, %addoper; %toret = add i32 %plusten, %g; call @llvm.dbg.value(metadata i32 %toret, metadata !1, metadata !2); ret i32 %toret; }. There are a few other dbg.value configurations that mean it terminates; dominating location definitions without adding a new location. The complete; list is:. * Any location operand is ``poison`` (or ``undef``).; * Any location operand is an empty metadata tuple (``!{}``) (which cannot; occur in a ``!DIArgList``).; * There are no location operands (empty ``DIArgList``) and the ``DIExpression``; is empty. This class of dbg.value that kills variable locations is called a ""kill; dbg.value"" or ""kill location"", and for legacy reasons the term ""undef; dbg.value"" may be used in existing code. The ``DbgVariableIntrinsic`` methods; ``isKillLocation`` and ``setKillLocation`` should be used where possible rather; than inspecting location operands directly to check or set whether a dbg.value; is a kill location. In general, if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:22780,config,configurations,22780,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['config'],['configurations']
Modifiability,"e); // Unsafe read; } else {; kGlobalCustomer = c; // Pointer escape; }; // Unsafe read, Pointer escape; }; ```. ## Example: finding dead stores. Let's say we want to find redundant stores, because they indicate potential; bugs. ```c++; x = GetX();; x = GetY();; ```. The first store to `x` is never read, probably there is a bug. The implementation of dead store analysis is very similar to output parameter; analysis: we need to track stores and loads, and find stores that were never; read. [Liveness analysis](https://en.wikipedia.org/wiki/Live_variable_analysis) is a; generalization of this idea, which is often used to answer many related; questions, for example:. * finding dead stores,; * finding uninitialized variables,; * finding a good point to deallocate memory,; * finding out if it would be safe to move an object. ## Example: definitive initialization. Definitive initialization proves that variables are known to be initialized when; read. If we find a variable which is read when not initialized then we generate; a warning. ```c++; void Init() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; } else {; x = 20; // x is initialized; }; print(x); // x is initialized; }; ```. ```c++; void Uninit() {; int x; // x is uninitialized; if (cond()) {; x = 10; // x is initialized; }; print(x); // x is maybe uninitialized, x is being read, report a bug.; }; ```. For this purpose we can use lattice in a form of a mapping from variable; declarations to initialization states; each initialization state is represented; by the following lattice:. ![Lattice for definitive initialization analysis](DataFlowAnalysisIntroImages/DefinitiveInitializationLattice.svg). A lattice element could also capture the source locations of the branches that; lead us to the corresponding program point. Diagnostics would use this; information to show a sample buggy code path to the user. ## Example: refactoring raw pointers to `unique_ptr`. Modern idiomatic C++ uses smart poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:20483,variab,variable,20483,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variable']
Modifiability,"e-1294211. LLVM has a StringMap class that is advertised as more efficient than; std::map<std::string, ValueType>. Mainly it does fewer allocations; because the key is not a std::string. Replace the use of std::map<std::string, ValueType> with String Map.; One specific case is the LVSymbolNames definitions. //===----------------------------------------------------------------------===//; // Calculate unique offset for CodeView elements.; //===----------------------------------------------------------------------===//; In order to have the same logical functionality as the ELF Reader, such; as:. - find scopes contribution to debug info; - sort by its physical location. The logical elements must have an unique offset (similar like the DWARF; DIE offset). //===----------------------------------------------------------------------===//; // Move 'initializeFileAndStringTables' to the COFF Library.; //===----------------------------------------------------------------------===//; There is some code in the CodeView reader that was extracted/adapted; from 'tools/llvm-readobj/COFFDumper.cpp' that can be moved to the COFF; library. We had a similar case with code shared with llvm-pdbutil that was moved; to the PDB library: https://reviews.llvm.org/D122226. //===----------------------------------------------------------------------===//; // Move 'getSymbolKindName'/'formatRegisterId' to the CodeView Library.; //===----------------------------------------------------------------------===//; There is some code in the CodeView reader that was extracted/adapted; from 'lib/DebugInfo/CodeView/SymbolDumper.cpp' that can be used. //===----------------------------------------------------------------------===//; // Use of std::unordered_set instead of std::set.; //===----------------------------------------------------------------------===//; https://reviews.llvm.org/D125784#inline-1221421. Replace the std::set usage for DeducedScopes, UnresolvedScopes and; IdentifiedNamespaces with std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt:5598,adapt,adapted,5598,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/README.txt,1,['adapt'],['adapted']
Modifiability,"e-block:: text. def RetCC_X86_32 : CallingConv<[; CCIfCC<""CallingConv::Fast"", CCDelegateTo<RetCC_X86_32_Fast>>,; CCIfCC<""CallingConv::X86_SSECall"", CCDelegateTo<RetCC_X86_32_SSE>>,; CCDelegateTo<RetCC_X86_32_C>; ]>;. ``CCAssignToRegAndStack`` is the same as ``CCAssignToReg``, but also allocates; a stack slot, when some register is used. Basically, it works like:; ``CCIf<CCAssignToReg<regList>, CCAssignToStack<size, align>>``. .. code-block:: text. class CCAssignToRegAndStack<list<Register> regList, int size, int align>; : CCAssignToReg<regList> {; int Size = size;; int Align = align;; }. Other calling convention interfaces include:. * ``CCIf <predicate, action>`` --- If the predicate matches, apply the action. * ``CCIfInReg <action>`` --- If the argument is marked with the ""``inreg``""; attribute, then apply the action. * ``CCIfNest <action>`` --- If the argument is marked with the ""``nest``""; attribute, then apply the action. * ``CCIfNotVarArg <action>`` --- If the current function does not take a; variable number of arguments, apply the action. * ``CCAssignToRegWithShadow <registerList, shadowList>`` --- similar to; ``CCAssignToReg``, but with a shadow list of registers. * ``CCPassByVal <size, align>`` --- Assign value to a stack slot with the; minimum specified size and alignment. * ``CCPromoteToType <type>`` --- Promote the current value to the specified; type. * ``CallingConv <[actions]>`` --- Define each calling convention that is; supported. Assembly Printer; ================. During the code emission stage, the code generator may utilize an LLVM pass to; produce assembly output. To do this, you want to implement the code for a; printer that converts LLVM IR to a GAS-format assembly language for your target; machine, using the following steps:. * Define all the assembly strings for your target, adding them to the; instructions defined in the ``XXXInstrInfo.td`` file. (See; :ref:`instruction-set`.) TableGen will produce an output file; (``XXXGenAsmWriter.inc``)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:66064,variab,variable,66064,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['variab'],['variable']
Modifiability,"e-types-functions-variables-and-enumerators-properly>`_; states:. Variable names should be nouns (as they represent state). The name should be; camel case, and start with an upper case letter (e.g. Leader or Boats). This rule is the same as that for type names. This is a problem because the; type name cannot be reused for a variable name [*]_. LLVM developers tend to; work around this by either prepending ``The`` to the type name::. Triple TheTriple;. ... or more commonly use an acronym, despite the coding standard stating ""Avoid; abbreviations unless they are well known""::. Triple T;. The proliferation of acronyms leads to hard-to-read code such as `this; <https://github.com/llvm/llvm-project/blob/0a8bc14ad7f3209fe702d18e250194cd90188596/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L7445>`_::. InnerLoopVectorizer LB(L, PSE, LI, DT, TLI, TTI, AC, ORE, VF.Width, IC,; &LVL, &CM);. Many other coding guidelines [LLDB]_ [Google]_ [WebKit]_ [Qt]_ [Rust]_ [Swift]_; [Python]_ require that variable names begin with a lower case letter in contrast; to class names which begin with a capital letter. This convention means that the; most readable variable name also requires the least thought::. Triple triple;. There is some agreement that the current rule is broken [LattnerAgree]_; [ArsenaultAgree]_ [RobinsonAgree]_ and that acronyms are an obstacle to reading; new code [MalyutinDistinguish]_ [CarruthAcronym]_ [PicusAcronym]_. There are; some opposing views [ParzyszekAcronym2]_ [RicciAcronyms]_. This work-in-progress proposal is to change the coding standard for variable; names to require that they start with a lower case letter. .. [*] In `some cases; <https://github.com/llvm/llvm-project/blob/8b72080d4d7b13072f371712eed333f987b7a18e/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp#L2727>`_; the type name *is* reused as a variable name, but this shadows the type name; and confuses many debuggers [DenisovCamelBack]_. Variable Names Coding Standard Options; =======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:1796,variab,variable,1796,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"e. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; to build MinGW makefiles if you have a POSIX shell reachable through the PATH; environment variable, for instance. You can force CMake to use a given build; tool; for instructions, see the `Usage`_ section, below. You may; also wish to control which targets LLVM enables, or which LLVM; components are built; see the `Frequently Used LLVM-related; variables`_ below. #. After CMake has finished running, proceed to use IDE project files, or start; the build from the build directory:. .. code-block:: console. $ cmake --build . The ``--build`` option tells ``cmake`` to invoke the underlying build; tool (``make``, ``ninja``, ``xcodebuild``, ``msbuild``, etc.). The underlying build tool can be invoked directly, of course, but; the ``--build`` option is portable. #. After LLVM has finished building, install it from the build directory:. .. code-block:: console. $ cmake --build . --target install. The ``--target`` option with ``install`` parameter in addition to; the ``--build`` option tells ``cmake`` to build the ``install`` target. It is p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:2550,variab,variable,2550,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"e. For example, you may have created a histogram in a; previous session and saved it in a file. Meanwhile, if you have changed; the style, the histogram will be drawn with the old attributes. You can; force the current style attributes to be set when you read an object; from a file by calling `ForceStyle` before reading the objects from the; file. ``` {.cpp}; gROOT->ForceStyle();; ```. When you call `gROOT->ForceStyle()` and read an object from a ROOT file,; the object's method `UseCurrentStyle` is called. The attributes saved; with the object are replaced by the current style attributes. You call; also call `myObject->UseCurrentStyle()` directly. For example if you; have a canvas or pad with your histogram or any other object, you can; force these objects to get the attributes of the current style by:. ``` {.cpp}; canvas->UseCurrentStyle();; ```. The description of the style functions should be clear from the name of; the **`TStyle`** setters or getters. Some functions have an extended; description, in particular:. - `TStyle::SetLabelFont`. - `TStyle::SetLineStyleString`: set the format of dashed lines. - `TStyle::SetOptStat`. - `TStyle::SetPalette` to change the colors palette. - `TStyle::SetTitleOffset`. - `TStyle::SetOptDate(Int_t optdate)` to support several date formats.; If `optdate` is non-null, the current date/time will be printed in; the canvas. The position of the date string can be controlled by:; `optdate = 10*format `+` mode`. - `mode = 1` the date is printed in the bottom/left corner. - `mode = 2` date is printed in the bottom/right corner. - `mode = 3` date is printed in the top/right corner. - `format = 0` (default) date format is like: ""Wed Sep 25 17:10:35; 2002"". - `format = 1` date format is: ""2002-09-25"". - `format = 2` date format is: ""2002-09-25 17:10:35"". ## 3D Viewers. ROOT provides several viewers capable of displaying 3D content:. - the Pad - simple line drawing using **`TPad`** and associated; projection class **`TView`**;. - GL Viewer -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:104233,extend,extended,104233,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['extend'],['extended']
Modifiability,"e. Note that branch regions are created to track branch conditions in the source; code and refer to two coverage mapping counters, one to track the number of; times the branch condition evaluated to ""true"", and one to track the number of; times the branch condition evaluated to ""false"". LLVM IR Representation; ======================. The coverage mapping data is stored in the LLVM IR using a global constant; structure variable called *__llvm_coverage_mapping* with the *IPSK_covmap*; section specifier (i.e. "".lcovmap$M"" on Windows and ""__llvm_covmap"" elsewhere). For example, let’s consider a C file and how it gets compiled to LLVM:. .. _coverage mapping sample:. .. code-block:: c. int foo() {; return 42;; }; int bar() {; return 13;; }. The coverage mapping variable generated by Clang has 2 fields:. * Coverage mapping header. * An optionally compressed list of filenames present in the translation unit. The variable has 8-byte alignment because ld64 cannot always pack symbols from; different object files tightly (the word-level alignment assumption is baked in; too deeply). .. code-block:: llvm. @__llvm_coverage_mapping = internal constant { { i32, i32, i32, i32 }, [32 x i8] }; {; { i32, i32, i32, i32 } ; Coverage map header; {; i32 0, ; Always 0. In prior versions, the number of affixed function records; i32 32, ; The length of the string that contains the encoded translation unit filenames; i32 0, ; Always 0. In prior versions, the length of the affixed string that contains the encoded coverage mapping data; i32 3, ; Coverage mapping format version; },; [32 x i8] c""..."" ; Encoded data (dissected later); }, section ""__llvm_covmap"", align 8. The current version of the format is version 6. There is one difference between versions 6 and 5:. * The first entry in the filename list is the compilation directory. When the; filename is relative, the compilation directory is combined with the relative; path to get an absolute path. This can reduce size by omitting the duplicate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:14619,variab,variable,14619,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['variab'],['variable']
Modifiability,"e.g. from ``int`` to ``double`` type, or from; pointer to derived to pointer to base class).; As a consequence, however, with STL containers being allowed where Python; containers are, this in turn means that you can pass e.g. an; ``std::vector<int>`` (or ``std::list<int>``) where a ``std::vector<double>``; is expected and a temporary is allowed:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... double sumit4(const std::vector<double>& data) {; ... return std::accumulate(data.begin(), data.end(), 0);; ... }""""""); ...; True; >>> cppyy.gbl.sumit4(vector[int](range(7))); 21.0; >>>. Normal overload resolution rules continue to apply, however, thus if an; overload were available that takes an ``const std::vector<int>&``, it would; be preferred. When templates are involved, overload resolution is stricter, to ensure that; a better matching instantiation is preferred over an implicit conversion.; However, that does mean that as-is, C++ is actually more flexible: it has the; curly braces initializer syntax to explicitly infer an; ``std::initializer_list``, with no such equivalent in Python. Although in general this approach guarantees the intended result, it does put; some strictures on the Python side, requiring careful use of types.; However, an easily fixable error is preferable over an implicitly wrong; result.; Note the type of the init argument in the call resulting in an (attempted); implicit instantiation in the following example:. .. code-block:: python. >>> cppyy.cppdef(""""""; ... template<class T>; ... T sumit_T(const std::vector<T>& data, T init) {; ... return std::accumulate(data.begin(), data.end(), init);; ... }""""""); ...; True; >>> cppyy.gbl.sumit_T(vector['double'](range(7)), 0); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: Template method resolution failed:; Failed to instantiate ""sumit_T(std::vector<double>&,int)""; Failed to instantiate ""sumit_T(std::vector<double>*,int)""; Failed to instantiate ""sumit_T(std::vector<doub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:6214,flexible,flexible,6214,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['flexible'],['flexible']
Modifiability,"e.g.; PyPy uses a garbage collector and that makes it sometimes useful to destruct; a C++ object exactly when you want it destroyed.; Destructors are by convention accessible through the ``__destruct__`` method; (since ""~"" can not be part of a Python method name).; If a Python-side derived class overrides ``__destruct__``, that method will; be called when the instance gets deleted in C++.; The Python destructor, ``__del__``, gets called when the Python proxy goes; away, which will only delete the C++ instance if owned by Python.; Note that ``__del__`` is not guaranteed to be called, it may e.g. be skipped; on program shutdown or because of an outstanding exception.; Accessing an object after it has been destroyed using ``__destruct__`` will; result in a Python ``ReferenceError`` exception. `Inheritance`; -------------. The output of help shows the inheritance hierarchy, constructors, public; methods, and public data.; For example, ``Concrete`` inherits from ``Abstract`` and it has; a constructor that takes an ``int`` argument, with a default value of 42.; Consider:. .. code-block:: python. >>> from cppyy.gbl import Abstract; >>> issubclass(Concrete, Abstract); True; >>> a = Abstract(); Traceback (most recent call last):; File ""<console>"", line 1, in <module>; TypeError: cannot instantiate abstract class 'Abstract'; >>> c = Concrete(); >>> isinstance(c, Concrete); True; >>> isinstance(c, Abstract); True; >>> d = Concrete(13); >>>. Just like in C++, interface classes that define pure virtual methods, such; as ``Abstract`` does, can not be instantiated, but their concrete; implementations can.; As the output of ``help`` showed, the ``Concrete`` constructor takes; an integer argument, that by default is 42. `Cross-inheritance`; -------------------. Python classes that derive from C++ classes can override virtual methods as; long as those methods are declared on class instantiation (adding methods to; the Python class after the fact will not provide overrides on the C++ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:3769,inherit,inherits,3769,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['inherit'],['inherits']
Modifiability,e/clang/Tooling/Transformer/Parsing.h; clang/include/clang/Tooling/Transformer/RangeSelector.h; clang/include/clang/Tooling/Transformer/SourceCode.h; clang/include/clang/Tooling/Transformer/SourceCodeBuilders.h; clang/include/clang/Tooling/Transformer/Transformer.h; clang/include/clang-c/ExternC.h; clang/include/clang-c/FatalErrorHandler.h; clang/include/clang-c/Index.h; clang/lib/Analysis/CalledOnceCheck.cpp; clang/lib/Analysis/CloneDetection.cpp; clang/lib/Analysis/CodeInjector.cpp; clang/lib/Analysis/FlowSensitive/ControlFlowContext.cpp; clang/lib/Analysis/FlowSensitive/DataflowAnalysisContext.cpp; clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp; clang/lib/Analysis/FlowSensitive/DebugSupport.cpp; clang/lib/Analysis/FlowSensitive/Transfer.cpp; clang/lib/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.cpp; clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp; clang/lib/Analysis/plugins/CheckerDependencyHandling/CheckerDependencyHandling.cpp; clang/lib/Analysis/plugins/SampleAnalyzer/MainCallChecker.cpp; clang/lib/APINotes/APINotesFormat.h; clang/lib/APINotes/APINotesTypes.cpp; clang/lib/APINotes/APINotesYAMLCompiler.cpp; clang/lib/AST/DataCollection.cpp; clang/lib/AST/Linkage.h; clang/lib/AST/Interp/ByteCodeGenError.cpp; clang/lib/AST/Interp/ByteCodeGenError.h; clang/lib/AST/Interp/Context.cpp; clang/lib/AST/Interp/Context.h; clang/lib/AST/Interp/Descriptor.cpp; clang/lib/AST/Interp/Disasm.cpp; clang/lib/AST/Interp/EvalEmitter.h; clang/lib/AST/Interp/Frame.cpp; clang/lib/AST/Interp/Frame.h; clang/lib/AST/Interp/InterpState.h; clang/lib/AST/Interp/Opcode.h; clang/lib/AST/Interp/Pointer.cpp; clang/lib/AST/Interp/PrimType.cpp; clang/lib/AST/Interp/Record.h; clang/lib/AST/Interp/Source.cpp; clang/lib/AST/Interp/Source.h; clang/lib/AST/Interp/State.cpp; clang/lib/AST/Interp/State.h; clang/lib/ASTMatchers/GtestMatchers.cpp; clang/lib/ASTMatchers/Dynamic/Marshallers.cpp; clang/lib/Basic/Attributes.cpp; clang/lib/Basic/DarwinSDKInfo.cpp; clang/lib/Basic/Dia,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:15486,plugin,plugins,15486,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"e1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4688,config,configurations,4688,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configurations']
Modifiability,"e: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file, which have to be updated whenever line numbers; change due to text addition or deletion. To support this case, FileCheck expressions understand the ``@LINE`` pseudo; numeric variable which evaluates to the line number of the CHECK pattern where; it is found. This way match patterns can be put near the relevant test lines and include; relative line number references, for example:. .. code-block:: c++. // CHECK: test.cpp:[[# @LINE + 4]]:6: error: expected ';' after top level declarator; // CHECK-NEXT: {{^int a}}; // CHECK-NEXT: {{^ \^}}; // CHECK-NEXT: {{^ ;}}; int a. To support legacy uses of ``@LINE`` as a special string variable,; :program:`FileCheck` also accepts the following uses of ``@LINE`` with string; substitution block syntax: ``[[@LINE]]``, ``[[@LINE+<offset>]]`` and; ``[[@LINE-<offset>]]`` without any spaces inside the brackets and where; ``offset`` is an integer. Matching Newline Characters; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. To match newline characters in regular expressions the character class; ``[[:space:]]`` can be used. For example, the following pattern:. .. code-block:: c++. // CHECK: DW_AT_location [DW_FORM_sec_offset] ([[DLOC:0x[0-9a-f]+]]){{[[:space:]].*}}""intd"". matches output of the form (from llvm-dwarfdump):. .. code-block:: text. DW_AT_location [DW_FORM_sec_offset] (0x00000233); DW_AT_name [DW_FORM_strp] ( .debug_str[0x000000c9] = ""intd""). letting us set the :program:`FileCheck` variable ``DLOC`` to the desired value; ``0x00000233``, extracted from the line immediately preceding ""``intd``"".; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:34528,variab,variable,34528,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,['variab'],['variable']
Modifiability,"e:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn in the active pad. The obvious question is: what is the relation; between a canvas and a pad? In fact, a canvas is a pad that spans; through an entire window. This is nothing else than the notion of; inheritance. The **`TPad`** class is the parent of the **`TCanvas`**; class. In ROOT, most objects derive from a base class **`TObject`**.; This class has a virtual method `Draw()` such as all objects are; supposed to be able to be ""drawn"". If several canvases are defined,; there is only one active at a time. One draws an object in the active; canvas by using the statement:. ``` {.cpp}; object.Draw(); ```. This instructs the object ""`object`"" to draw itself. If no canvas is; opened, a default one (named ""`c1`"") is created. In the next example,; the first statement defines a function and the second one draws it. A; default canvas is created since there was no opened one. You should; see the picture as shown in the next figure. ``` {.cpp}; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. ![A canvas with drawing](pictures/0300000A.png). The following components comprise the canvas window:. - Menu ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:6016,inherit,inheritance,6016,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['inherit'],['inheritance']
Modifiability,"e:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ```. ACLiC simplifies this procedure and allows the dictionary generation by:. ``` {.cpp}; root[] .L tst.C++; ```. It will create the shared library `tst_C.so.`. The next line will create an executable:. **`` g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE ``**. The library `tst_C.so` is a dynamically loaded library and should be; located in `$LD_LIBRARY_PATH`. The current working directory should be; added to `$LD_LIBRARY_PATH` via:. **`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./`**. To run it, you just do:. **`./tst`**. ## Widgets in Detail. ### Buttons. Buttons are a popular group of widgets designed to provide specific; interfaces for user interaction. **`TGButton`** is an abstract class; defining the general button behavior: width, height, state, its group,; tool tip text, etc. There are two main groups of buttons: command buttons with a text or; graphics inside that indicate the action to be accomplished and option; buttons well known as radio and check buttons that select or change; properties. The first group is presented in ROOT by; **`TGPictureButton`** and **`TGTextButton`** classes. They yield an; action as soon as they are clicked. It can be opening/closing a dialog; box or invoking a sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:53616,config,config,53616,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['config'],['config']
Modifiability,"e; - Test coverage has been increased with the introduction of google tests; - Interface change: users must now use TDF::TArrayBranch rather than std::array\_view to specify that the column being read is a c-style array TTree branch; - Interface change: `Min` and `Max` now return results as the same type specified as template parameter, or double if no template parameter was specified. ## Histogram Libraries; - Histogram-based fits are implicitly parallelized.; - Added new options to the histogram fitting interfaces to support explicit parallelization of the fit as well.; - `TF1` gradient evaluation supports vectorization.; - Refactor of `TF1` constructors, default initialization of its data members and fixed ambiguous TF1::operator().; - Extend `TFormula` parsing capabilities.; - The parsing of arguments for defining parametric function is improved. For example a Gaussian function in y can be defined as `gaus( y , [A], [Mean], [Sigma])`.; - One can define the function variables or parameters using another function or an expression. Example: `gaus(x, [A], [m0]*y+[m1], [sigma])`.; - Support for function composition in `TFormula`, i.e. a function can be composed from another function, Again, an example: `gaus( f1(x), [A],[Mean],[Sigma])`, where `f1` is a function defined; previously.; - Facilitate using Normalized sums of TF1 objects and convolutions, by adding the `NSUM` and `CONV` operators for TF1 objects built with formula expressions; - `TF1(""model"", ""NSUM(gaus , expo)"", xmin, xmax)` will create a function composed of a normalized sum of a gaussian and an exponential.; - `TF1(""voigt"", ""CONV(breitwigner, gausn) , -15, 15)` will create a TF1 object made of a convolution between a Breit-Wigner and a Gaussian. ; - `TFormula` supports vectorization. All the `TF1` objected created with a formula expression can have a vectorized signature using `ROOT::Double_v`: `TF1::EvalPar( ROOT::Double_v * x,; double * p)`. The vectorization can then be used to speed-up fitting. It ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:16369,variab,variables,16369,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['variab'],['variables']
Modifiability,"e; end of the code generation for the function:. .. code-block:: c++. // Pop off the lexical block for the function since we added it; // unconditionally.; KSDbgInfo.LexicalBlocks.pop_back();. Then we make sure to emit the location every time we start to generate code; for a new AST object:. .. code-block:: c++. KSDbgInfo.emitLocation(this);. Variables; =========. Now that we have functions, we need to be able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. Here we're first creating the variable, giving it the scope (``SP``),; the name, source location, type, and since it's an argument, the argument; index. Next, we create an ``lvm.dbg.declare`` call to indicate at the IR; level that we've got a variable in an alloca (and it gives a starting; location for the variable), and setting a source location for the; beginning of the scope on the declare. One interesting thing to note at this point is that various debuggers have; assumptions based on how code and debug in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:13570,variab,variable,13570,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variable']
Modifiability,"e; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6734,variab,variable,6734,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"e; keep propagating information through the CFG until the computed sets of values; stop changing. If the lattice has a finite height and transfer functions are monotonic the; algorithm is guaranteed to terminate. Each iteration of the algorithm can; change computed values only to larger values from the lattice. In the worst; case, all computed values become `⊤`, which is not very useful, but at least the; analysis terminates at that point, because it can't change any of the values. Fixpoint iteration can be optimised by only reprocessing basic blocks which had; one of their inputs changed on the previous iteration. This is typically; implemented using a worklist queue. With this optimisation the time complexity; becomes `O(m * |L|)`, where `m` is the number of basic blocks in the CFG and; `|L|` is the size of lattice used by the analysis. ## Symbolic execution: a very short informal introduction. ### Symbolic values. In the previous example where we tried to figure out what values a variable can; have, the analysis had to be seeded with a concrete value. What if there are no; assignments of concrete values in the program? We can still deduce some; interesting information by representing unknown input values symbolically, and; computing results as symbolic expressions:. ```c++; void PrintAbs(int x) {; int result;; if (x >= 0) {; result = x; // result is {x}; } else {; result = -x; // result is {-x}; }; print(result); // result is {x; -x}; }; ```. We can't say what specific value gets printed, but we know that it is either `x`; or `-x`. Dataflow analysis is an instance of abstract interpretation, and does not dictate; how exactly the lattice and transfer functions should be designed, beyond the; necessary conditions for the analysis to converge. Nevertheless, we can use; symbolic execution ideas to guide our design of the lattice and transfer; functions: lattice values can be symbolic expressions, and transfer functions; can construct more complex symbolic expressions",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:11179,variab,variable,11179,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['variab'],['variable']
Modifiability,"e; output is what we are verifying. FileCheck checks the machine code output to; verify that it matches what the ""``CHECK:``"" lines specify. The syntax of the ""``CHECK:``"" lines is very simple: they are fixed strings that; must occur in order. FileCheck defaults to ignoring horizontal whitespace; differences (e.g. a space is allowed to match a tab) but otherwise, the contents; of the ""``CHECK:``"" line is required to match some thing in the test file exactly. One nice thing about FileCheck (compared to grep) is that it allows merging; test cases together into logical groups. For example, because the test above; is checking for the ""``sub1:``"" and ""``inc4:``"" labels, it will not match; unless there is a ""``subl``"" in between those labels. If it existed somewhere; else in the file, that would not count: ""``grep subl``"" matches if ""``subl``""; exists anywhere in the file. The FileCheck -check-prefix option; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. The FileCheck `-check-prefix` option allows multiple test; configurations to be driven from one `.ll` file. This is useful in many; circumstances, for example, testing different architectural variants with; :program:`llc`. Here's a simple example:. .. code-block:: llvm. ; RUN: llvm-as < %s | llc -mtriple=i686-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X32; ; RUN: llvm-as < %s | llc -mtriple=x86_64-apple-darwin9 -mattr=sse41 \; ; RUN: | FileCheck %s -check-prefix=X64. define <4 x i32> @pinsrd_1(i32 %s, <4 x i32> %tmp) nounwind {; %tmp1 = insertelement <4 x i32>; %tmp, i32 %s, i32 1; ret <4 x i32> %tmp1; ; X32: pinsrd_1:; ; X32: pinsrd $1, 4(%esp), %xmm0. ; X64: pinsrd_1:; ; X64: pinsrd $1, %edi, %xmm0; }. In this case, we're testing that we get the expected code generation with; both 32-bit and 64-bit code generation. The ""COM:"" directive; ~~~~~~~~~~~~~~~~~~~~. Sometimes you want to disable a FileCheck directive without removing it; entirely, or you want to write comments that mention a directive by name. The; """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:9962,config,configurations,9962,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['config'],['configurations']
Modifiability,"e; source code. MC/DC Instrumentation; ---------------------. When instrumenting for Modified Condition/Decision Coverage (MC/DC) using the; clang option ``-fcoverage-mcdc``, users are limited to at most **six** leaf-level; conditions in a boolean expression. A warning will be generated for boolean; expressions that contain more than six, and they will not be instrumented for; MC/DC. Also, if a boolean expression is embedded in the nest of another boolean; expression but separated by a non-logical operator, this is also not supported.; For example, in ``x = (a && b && c && func(d && f))``, the ``d && f`` case; starts a new boolean expression that is separated from the other conditions by; the operator ``func()``. When this is encountered, a warning will be generated; and the boolean expression will not be instrumented. Switch statements; -----------------. The region mapping for a switch body consists of a gap region that covers the; entire body (starting from the '{' in 'switch (...) {', and terminating where the; last case ends). This gap region has a zero count: this causes ""gap"" areas in; between case statements, which contain no executable code, to appear uncovered. When a switch case is visited, the parent region is extended: if the parent; region has no start location, its start location becomes the start of the case.; This is used to support switch statements without a ``CompoundStmt`` body, in; which the switch body and the single case share a count. For switches with ``CompoundStmt`` bodies, a new region is created at the start; of each switch case. Branch regions are also generated for each switch case, including the default; case. If there is no explicitly defined default case in the source code, a; branch region is generated to correspond to the implicit default case that is; generated by the compiler. The implicit branch region is tied to the line and; column number of the switch statement condition since no source code for the; implicit case exists.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:21978,extend,extended,21978,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['extend'],['extended']
Modifiability,"e; transformation. A strong type system makes it easier to read the; generated code and enables novel analyses and transformations that are; not feasible to perform on normal three address code representations. .. _t_void:. Void Type; ---------. :Overview:. The void type does not represent any value and has no size. :Syntax:. ::. void. .. _t_function:. Function Type; -------------. :Overview:. The function type can be thought of as a function signature. It consists of a; return type and a list of formal parameter types. The return type of a function; type is a void type or first class type --- except for :ref:`label <t_label>`; and :ref:`metadata <t_metadata>` types. :Syntax:. ::. <returntype> (<parameter list>). ...where '``<parameter list>``' is a comma-separated list of type; specifiers. Optionally, the parameter list may include a type ``...``, which; indicates that the function takes a variable number of arguments. Variable; argument functions can access their arguments with the :ref:`variable argument; handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type; except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`. :Examples:. +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (i32)`` | function taking an ``i32``, returning an ``i32`` |; +---------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+; | ``i32 (ptr, ...)`` | A vararg function that takes at least one :ref:`pointer <t_pointer>` argument and returns an integer. This is the signature for ``printf`` in LLVM. |; +---------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:166486,variab,variable,166486,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"eBPF is reusing most of the opcode encoding from classic to simplify conversion; of classic BPF to eBPF. For arithmetic and jump instructions the 8-bit 'code'; field is divided into three parts:. ::. +----------------+--------+--------------------+; | 4 bits | 1 bit | 3 bits |; | operation code | source | instruction class |; +----------------+--------+--------------------+; (MSB) (LSB). Three LSB bits store instruction class which is one of:. ::. BPF_LD 0x0; BPF_LDX 0x1; BPF_ST 0x2; BPF_STX 0x3; BPF_ALU 0x4; BPF_JMP 0x5; (unused) 0x6; BPF_ALU64 0x7. When BPF_CLASS(code) == BPF_ALU or BPF_ALU64 or BPF_JMP,; 4th bit encodes source operand. ::. BPF_X 0x1 use src_reg register as source operand; BPF_K 0x0 use 32 bit immediate as source operand. and four MSB bits store operation code. ::. BPF_ADD 0x0 add; BPF_SUB 0x1 subtract; BPF_MUL 0x2 multiply; BPF_DIV 0x3 divide; BPF_OR 0x4 bitwise logical OR; BPF_AND 0x5 bitwise logical AND; BPF_LSH 0x6 left shift; BPF_RSH 0x7 right shift (zero extended); BPF_NEG 0x8 arithmetic negation; BPF_MOD 0x9 modulo; BPF_XOR 0xa bitwise logical XOR; BPF_MOV 0xb move register to register; BPF_ARSH 0xc right shift (sign extended); BPF_END 0xd endianness conversion. If BPF_CLASS(code) == BPF_JMP, BPF_OP(code) is one of. ::. BPF_JA 0x0 unconditional jump; BPF_JEQ 0x1 jump ==; BPF_JGT 0x2 jump >; BPF_JGE 0x3 jump >=; BPF_JSET 0x4 jump if (DST & SRC); BPF_JNE 0x5 jump !=; BPF_JSGT 0x6 jump signed >; BPF_JSGE 0x7 jump signed >=; BPF_CALL 0x8 function call; BPF_EXIT 0x9 function return. Instruction encoding (load, store); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; For load and store instructions the 8-bit 'code' field is divided as:. ::. +--------+--------+-------------------+; | 3 bits | 2 bits | 3 bits |; | mode | size | instruction class |; +--------+--------+-------------------+; (MSB) (LSB). Size modifier is one of. ::. BPF_W 0x0 word; BPF_H 0x1 half word; BPF_B 0x2 byte; BPF_DW 0x3 double word. Mode modifier is one of. ::. BPF_IMM 0x0 immediate; BPF_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:104494,extend,extended,104494,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['extend'],['extended']
Modifiability,"eLists.txt; # Setting variables that match the pattern LLVM_TOOL_{NAME}_BUILD to Off will; # prevent traversing into a directory.; #; # The only tools that need to be explicitly added are ones that have explicit; # ordering requirements. # Iterates all the subdirectories to create CMake options to enable/disable; # traversing each directory.; create_llvm_tool_options(). if(NOT LLVM_BUILD_LLVM_DYLIB AND NOT LLVM_BUILD_LLVM_C_DYLIB); set(LLVM_TOOL_LLVM_SHLIB_BUILD Off); endif(). if(NOT LLVM_USE_INTEL_JITEVENTS ); set(LLVM_TOOL_LLVM_JITLISTENER_BUILD Off); endif(). if(CYGWIN OR NOT LLVM_ENABLE_PIC); set(LLVM_TOOL_LTO_BUILD Off); endif(). if (LLVM_TOOL_LLVM_DRIVER_BUILD); add_llvm_tool(llvm-driver); endif(). # Add LTO, llvm-ar, llvm-config, and llvm-profdata before clang, ExternalProject; # requires targets specified in DEPENDS to exist before the call to; # ExternalProject_Add.; add_llvm_tool_subdirectory(lto); add_llvm_tool_subdirectory(gold); add_llvm_tool_subdirectory(llvm-ar); add_llvm_tool_subdirectory(llvm-config); add_llvm_tool_subdirectory(llvm-lto); add_llvm_tool_subdirectory(llvm-profdata). # Projects supported via LLVM_EXTERNAL_*_SOURCE_DIR need to be explicitly; # specified.; add_llvm_external_project(clang); add_llvm_external_project(lld); add_llvm_external_project(lldb); add_llvm_external_project(mlir); # Flang depends on mlir, so place it afterward; add_llvm_external_project(flang); add_llvm_external_project(bolt). # Automatically add remaining sub-directories containing a 'CMakeLists.txt'; # file as external projects.; add_llvm_implicit_projects(). add_llvm_external_project(polly). # Add subprojects specified using LLVM_EXTERNAL_PROJECTS; foreach(p ${LLVM_EXTERNAL_PROJECTS}); add_llvm_external_project(${p}); endforeach(p). set(LLVM_COMMON_DEPENDS ${LLVM_COMMON_DEPENDS} PARENT_SCOPE). if (LLVM_TOOL_LLVM_DRIVER_BUILD); # This is explicitly added at the end _after_ all tool projects so that it can; # scrape up tools from other projects into itself.; add_sub",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/CMakeLists.txt:1091,config,config,1091,interpreter/llvm-project/llvm/tools/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/CMakeLists.txt,1,['config'],['config']
Modifiability,"eNode.cpp; SuffixTree.cpp; SystemUtils.cpp; TarWriter.cpp; ThreadPool.cpp; TimeProfiler.cpp; Timer.cpp; ToolOutputFile.cpp; Twine.cpp; TypeSize.cpp; Unicode.cpp; UnicodeCaseFold.cpp; UnicodeNameToCodepoint.cpp; UnicodeNameToCodepointGenerated.cpp; VersionTuple.cpp; VirtualFileSystem.cpp; WithColor.cpp; YAMLParser.cpp; YAMLTraits.cpp; raw_os_ostream.cpp; raw_ostream.cpp; raw_socket_stream.cpp; regcomp.c; regerror.c; regexec.c; regfree.c; regstrlcpy.c; xxhash.cpp; Z3Solver.cpp. ${ALLOCATOR_FILES}; $<TARGET_OBJECTS:LLVMSupportBlake3>. # System; Atomic.cpp; DynamicLibrary.cpp; Errno.cpp; Memory.cpp; Path.cpp; Process.cpp; Program.cpp; RWMutex.cpp; Signals.cpp; Threading.cpp; Valgrind.cpp; Watchdog.cpp. ADDITIONAL_HEADER_DIRS; Unix; Windows; ${LLVM_MAIN_INCLUDE_DIR}/llvm/ADT; ${LLVM_MAIN_INCLUDE_DIR}/llvm/Support; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${system_libs} ${imported_libs} ${delayload_flags}. LINK_COMPONENTS; Demangle; ). set(llvm_system_libs ${system_libs}). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_ZLIB); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION_${build_type}); endif(); if(NOT zlib_library); get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION); endif(); get_library_name(${zlib_library} zlib_library); set(llvm_system_libs ${llvm_system_libs} ""${zlib_library}""); endif(). if(LLVM_ENABLE_ZSTD); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION_${build_type}); endif(); if(NOT zstd_library); get_property(zstd_library TARGET ${zstd_target} PROPERTY LOCATION); endif(); get_library_name(${zstd_library} zstd_library); set(llvm_sys",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt:8418,config,config,8418,interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CMakeLists.txt,1,['config'],['config']
Modifiability,"e_unique<int>();; if (...) {; Borrow(pi.get());; } else {; TakeOwnership(pi.release());; }; }; ```. This problem can be solved with a lattice in form of map from value declarations; to pointer states:. ![Lattice that identifies candidates for unique_ptr refactoring](DataFlowAnalysisIntroImages/UniquePtrLattice.svg). We can perform the refactoring if at the exit of a function `pi` is; `Compatible`. ```c++; void UniqueOwnership1() {; int *pi; // pi is Compatible; pi = new int; // pi is Defined; if (...) {; Borrow(pi); // pi is Defined; delete pi; // pi is Compatible; } else {; TakeOwnership(pi); // pi is Compatible; }; // pi is Compatible; }; ```. Let's look at an example where the raw pointer owns two different memory blocks:. ```c++; void UniqueOwnership2() {; int *pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; if (smth) {; pi = new int; // pi is Defined; Borrow(pi);; delete pi; // pi is Compatible; }; // pi is Compatible; }; ```. It can be refactored to use `unique_ptr` like this:. ```c++; void UniqueOwnership2() {; auto pi = make_unique<int>();; Borrow(pi);; if (smth) {; pi = make_unique<int>();; Borrow(pi);; }; }; ```. In the following example, the raw pointer is used to access the heap object; after the ownership has been transferred. ```c++; void UniqueOwnership3() {; int *pi = new int; // pi is Defined; if (...) {; Borrow(pi);; delete pi; // pi is Compatible; } else {; vector<unique_ptr<int>> v = {std::unique_ptr(pi)}; // pi is Compatible; print(*pi);; use(v);; }; // pi is Compatible; }; ```. We can refactor this code to use `unique_ptr`, however we would have to; introduce a non-owning pointer variable, since we can't use the moved-from; `unique_ptr` to access the object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:23117,refactor,refactored,23117,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactored']
Modifiability,"e`. This is used in; two main cases:. - as the default value for the requested number of entries a routine should be; applied to; for example this is used for `TTree::Draw` and `TTree::Process`.; Previously the default was only 1 billions entries, causing those routines to; end early in case of very large trees. - as the default value for the number of entries returned by TChain::GetEntriesFast.; The previous value was kBigNumber (set to 1234567890) and internally (but somewhat; inconsistently, see [ROOT-6885]) a larger value was used (named theBigNumber). Now; `TTree::kMaxEntries` is used throughout TChain. `TChain::kBigNumber` is deprecated and its value has been changed to be equal; to `TTree::kMaxEntries`. ### MakeSelector. `TTree::MakeSelector` has been update to generate a code skeleton based on the `TTreeReader` rather than the old style relying on numeric data members replacements for the user objects. The main advantage is the lifting of the problem related to the fact that the old style was using fixed size array to represent variable size collection. `TTree::MakeSelector` takes an option parameter that can be used to specify the branches that will have a data member.; - If option is `""=legacy""`, a pre-ROOT6 selector will be generated (data members and branch pointers instead of TTreeReaders).; - If option is empty, readers will be generated for each leaf.; - If option is ""@"", readers will be generated for the topmost branches.; - Individual branches can also be picked by their name:; - ""X"" generates readers for leaves of X.; - ""@X"" generates a reader for X as a whole.; - ""@X;Y"" generates a reader for X as a whole and also readers for the; leaves of Y.; - For further examples see the figure below. \image html ttree_makeselector_option_examples.png. The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:9731,variab,variable,9731,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['variab'],['variable']
Modifiability,"e``, spaces will be inserted after ``[`` and before ``]``.; Lambdas without arguments or unspecified size array declarations will not; be affected. .. code-block:: c++. true: false:; int a[ 5 ]; vs. int a[5];; std::unique_ptr<int[]> foo() {} // Won't be affected. .. _Standard:. **Standard** (``LanguageStandard``) :versionbadge:`clang-format 3.7` :ref:`¶ <Standard>`; Parse and format C++ constructs compatible with this standard. .. code-block:: c++. c++03: latest:; vector<set<int> > x; vs. vector<set<int>> x;. Possible values:. * ``LS_Cpp03`` (in configuration: ``c++03``); Parse and format as C++03.; ``Cpp03`` is a deprecated alias for ``c++03``. * ``LS_Cpp11`` (in configuration: ``c++11``); Parse and format as C++11. * ``LS_Cpp14`` (in configuration: ``c++14``); Parse and format as C++14. * ``LS_Cpp17`` (in configuration: ``c++17``); Parse and format as C++17. * ``LS_Cpp20`` (in configuration: ``c++20``); Parse and format as C++20. * ``LS_Latest`` (in configuration: ``Latest``); Parse and format using the latest supported language version.; ``Cpp11`` is a deprecated alias for ``Latest``. * ``LS_Auto`` (in configuration: ``Auto``); Automatic detection based on the input. .. _StatementAttributeLikeMacros:. **StatementAttributeLikeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <StatementAttributeLikeMacros>`; Macros which are ignored in front of a statement, as if they were an; attribute. So that they are not parsed as identifier, for example for Qts; emit. .. code-block:: c++. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: []; unsigned char data = 'x';; emit signal(data); // This is parsed as variable declaration. AlignConsecutiveDeclarations: true; StatementAttributeLikeMacros: [emit]; unsigned char data = 'x';; emit signal(data); // Now it's fine again. .. _StatementMacros:. **StatementMacros** (``List of Strings``) :versionbadge:`clang-format 8` :ref:`¶ <StatementMacros>`; A vector of macros that should be interpreted as c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:129561,config,configuration,129561,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"e``; ~~~~~~~~~~~~~~~~~~~~~~~~~~. The ``DW_AT_LLVM_active_lane`` attribute on a subprogram debugger information; entry is used to specify the lanes that are conceptually active for a SIMT; thread. The execution mask may be modified to implement whole or quad wavefront mode; operations. For example, all lanes may need to temporarily be made active to; execute a whole wavefront operation. Such regions would save the ``EXEC`` mask,; update it to enable the necessary lanes, perform the operations, and then; restore the ``EXEC`` mask from the saved value. While executing the whole; wavefront region, the conceptual execution mask is the saved value, not the; ``EXEC`` value. This is handled by defining an artificial variable for the active lane mask. The; active lane mask artificial variable would be the actual ``EXEC`` mask for; normal regions, and the saved execution mask for regions where the mask is; temporarily updated. The location list expression created for this artificial; variable is used to define the value of the ``DW_AT_LLVM_active_lane``; attribute. ``DW_AT_LLVM_augmentation``; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. For AMDGPU, the ``DW_AT_LLVM_augmentation`` attribute of a compilation unit; debugger information entry has the following value for the augmentation string:. ::. [amdgpu:v0.0]. The ""vX.Y"" specifies the major X and minor Y version number of the AMDGPU; extensions used in the DWARF of the compilation unit. The version number; conforms to [SEMVER]_. Call Frame Information; ----------------------. DWARF Call Frame Information (CFI) describes how a consumer can virtually; *unwind* call frames in a running process or core dump. See DWARF Version 5; section 6.4 and :ref:`amdgpu-dwarf-call-frame-information`. For AMDGPU, the Common Information Entry (CIE) fields have the following values:. 1. ``augmentation`` string contains the following null-terminated UTF-8 string:. ::. [amd:v0.0]. The ``vX.Y`` specifies the major X and minor Y version number of the AMDGPU; extens",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:110253,variab,variable,110253,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"each GC root on the stack.; /// root and meta are exactly the values passed to; /// @llvm.gcroot.; ///; /// Visitor could be a function to recursively mark live objects. Or it; /// might copy them to another heap or generation.; ///; /// @param Visitor A function to invoke for every GC root on the stack.; void visitGCRoots(void (*Visitor)(void **Root, const void *Meta)) {; for (StackEntry *R = llvm_gc_root_chain; R; R = R->Next) {; unsigned i = 0;. // For roots [0, NumMeta), the metadata pointer is in the FrameMap.; for (unsigned e = R->Map->NumMeta; i != e; ++i); Visitor(&R->Roots[i], R->Map->Meta[i]);. // For roots [NumMeta, NumRoots), the metadata pointer is null.; for (unsigned e = R->Map->NumRoots; i != e; ++i); Visitor(&R->Roots[i], NULL);; }; }. The 'Erlang' and 'Ocaml' GCs; -----------------------------. LLVM ships with two example collectors which leverage the ``gcroot``; mechanisms. To our knowledge, these are not actually used by any language; runtime, but they do provide a reasonable starting point for someone interested; in writing an ``gcroot`` compatible GC plugin. In particular, these are the; only in tree examples of how to produce a custom binary stack map format using; a ``gcroot`` strategy. As there names imply, the binary format produced is intended to model that; used by the Erlang and OCaml compilers respectively. .. _statepoint_example_gc:. The Statepoint Example GC; -------------------------. .. code-block:: c++. F.setGC(""statepoint-example"");. This GC provides an example of how one might use the infrastructure provided; by ``gc.statepoint``. This example GC is compatible with the; :ref:`PlaceSafepoints` and :ref:`RewriteStatepointsForGC` utility passes; which simplify ``gc.statepoint`` sequence insertion. If you need to build a; custom GC strategy around the ``gc.statepoints`` mechanisms, it is recommended; that you use this one as a starting point. This GC strategy does not support read or write barriers. As a result, these; intrinsics are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:19687,plugin,plugin,19687,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"ead of function addresses, the perf data will contain full function; names. In addition, stack frame pointers are enabled in JITted code, so full; stack traces can be generated. Debugging is aided by switching off optimisations; and adding frame pointers for better stack traces. However, since both have a; runtime cost, they are disabled by default. Similar to `LD_DEBUG` and `LD_PROFILE`; for `ld.so`, the environment variables `CLING_DEBUG=1` and/or `CLING_PROFILE=1`; can be set to enable debugging and/or profiling. ### Other changes. - Shadowing of declarations in the `std` namespace is now diagnosed. Specifically, given that ROOT injects `using namespace std` directive, _all_ the names in the `std` namespace become available in the global scope. However, in some circumstances users inadvertently introduce a declaration that conflicts with a name in `std` making references to the former declaration result in ambiguous lookup.; A fairly common case is trying to declare a global variable named `data` which conflict with [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) [C++17]. See [ROOT-5971](https://sft.its.cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the screen using Ctrl+L. Most users coming from a GUI will find these shortcuts convenient.; A list of the available key bindings is printed by; ```; root [] .help edit; ```. ## I/O Libraries. ### Faster reading from EOS. A new cross-protocol redirection has been added to allow files on EOS mounts to be opened; by `TFile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:6767,variab,variable,6767,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['variab'],['variable']
Modifiability,"ead. GitHub Repository Description; =============================. Monorepo; ----------------. The LLVM git repository hosted at https://github.com/llvm/llvm-project contains all; sub-projects in a single source tree. It is often referred to as a monorepo and; mimics an export of the current SVN repository, with each sub-project having its; own top-level directory. Not all sub-projects are used for building toolchains.; For example, www/ and test-suite/ are not part of the monorepo. Putting all sub-projects in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:9300,refactor,refactoring,9300,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['refactor'],['refactoring']
Modifiability,"ead.; Columns can be dynamically added (e.g. during event iteration, a new field view is created in a reader).; The cluster pool reads ahead a limited number of clusters given by the _cluster bunch size_ option (default = 1).; The read-ahead uses vector reads.; For the file backend, it additionally coalesces close read requests and uses uring reads when available. The page source can be restricted to a certain entry range.; This allows for optimizing the page lists that are being read.; Additionally, it allows for optimizing the cluster pool to not read-ahead beyond the limits. #### Late model extension; Reading an RNTuple with an extended model is transparent -- i.e., no additional interface calls are required.; Internally, columns that were created as part of late model extension will have synthesized zero-initialized column ranges for the clusters that were already written before the model was extended.; In addition, pages made up of 0x00 bytes are synthesized for deferred columns in the clusters that were already (partially) filled before the model was extended. Storage Backends; ----------------. Support for storage backends is implemented through derived classes of `RPageSink` and `RPageSource`.; The `RPage{Sink,Source}File` class provides a storage backend for RNTuple data in ROOT files, local or remote.; The `RPage{Sink,Source}Daos` class provides a storage backend for RNTuple data in the DAOS object store. Every new storage backend needs to define; 1) The RNTuple embedding: how are RNTuple data blobs stored, e.g. in keys of ROOT files, or in objects of object stores; 2) The RNTuple anchor: the initial link to the location of the header and footer (cf. format specification); 3) A locator format: how are byte ranges addressed (e.g., through an offset in a file or an object ID). That means that new backends are likely to have implications on the RNTuple format specification. The page sources and sinks are ROOT internal classes.; They are not meant to be extende",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:23430,extend,extended,23430,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['extend'],['extended']
Modifiability,"eader files to be compiled within C context or with RTTI on/off.; That's mostly for bootstrapping ROOT (aka rootcling stage1).; * modulemap.overlay.yaml -- automatically created virtual filesystem overlay; file. This file introduces C++ Modules for external dependencies.; For example, to 'modularize' glibc for ROOT we would need to place a modulemap; file in (usually) `/usr/include`. This folder is not writable on many; platforms. The vfs file tells the compiler to pretend there is a file at a; specific location. This way we 'mount' `/usr/include/module.modulemap`; non-invasively. The reasons why we need to extend the C++ modules support; beyond ROOT is described bellow.; * rootcling -cxxmodule creates a single artifact *Name.pcm* after the library; name. At a final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13125,variab,variables,13125,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['variab'],['variables']
Modifiability,"eads=*/8); // will still use 2 threads; ```. Note that the preferred way to steer ROOT's concurrency level is still through; [`ROOT::EnableImplicitMT`](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f); or by passing the appropriate parameter to executors' constructors, as in; [`TThreadExecutor::TThreadExecutor`](https://root.cern/doc/master/classROOT_1_1TThreadExecutor.html#ac7783d52c56cc7875d3954cf212247bb). See the discussion at [ROOT-11014](https://sft.its.cern.ch/jira/browse/ROOT-11014) for more context. ### Dynamic Path: `ROOT_LIBRARY_PATH`. A new way to set ROOT's ""Dynamic Path"" was added: the; environment variable `ROOT_LIBRARY_PATH`. On Unix it should contain a colon; separated list of paths, on Windows a semicolon separated list. It is; intended to be cross platform and to be specific to ROOT (and thus not; interfere with the system's shared linker).; The final ""Dynamic Path"" is now composed of these sources in order:; 1. `ROOT_LIBRARY_PATH` environment variable; 2. System specific shared linker environment variables like; `LD_LIBRARY_PATH`, `LIBPATH`, or `PATH`.; 3. Setting from rootrc; 4. ROOT's builtin library directory. ### Interpreter. - cling's LLVM is upgraded to version 9.0; - New interface to enable/disable optional cling features. Currently, it can be used to enable/disable support for redefinitions. See [this](https://github.com/root-project/cling/issues/360) issue for more information. ### Multithreading. - Fix an uninitialized variable in global read-write lock which could have caused deadlocks or crashes in some rare cases.; - Default global read-write lock transitioned to new implementation based on TBB thread local storage when TBB is available on supported platforms (all except Windows). This gives an O(10%) performance improvement for some typical RDataFrame scenarios with 256 threads due to reduced lock contention. ## I/O Libraries. - Exclusive use of the global lock is reduced or migrated to finer grained",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:3379,variab,variable,3379,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"eakSanitizer`. The leak detection is turned on by default on Linux,; and can be enabled using ``ASAN_OPTIONS=detect_leaks=1`` on macOS;; however, it is not yet supported on other platforms. Issue Suppression; =================. AddressSanitizer is not expected to produce false positives. If you see one,; look again; most likely it is a true positive!. Suppressing Reports in External Libraries; -----------------------------------------; Runtime interposition allows AddressSanitizer to find bugs in code that is; not being recompiled. If you run into an issue in external libraries, we; recommend immediately reporting it to the library maintainer so that it; gets addressed. However, you can use the following suppression mechanism; to unblock yourself and continue on with the testing. This suppression; mechanism should only be used for suppressing issues in external code; it; does not work on code recompiled with AddressSanitizer. To suppress errors; in external libraries, set the ``ASAN_OPTIONS`` environment variable to point; to a suppression file. You can either specify the full path to the file or the; path of the file relative to the location of your executable. .. code-block:: bash. ASAN_OPTIONS=suppressions=MyASan.supp. Use the following format to specify the names of the functions or libraries; you want to suppress. You can see these in the error report. Remember that; the narrower the scope of the suppression, the more bugs you will be able to; catch. .. code-block:: bash. interceptor_via_fun:NameOfCFunctionToSuppress; interceptor_via_fun:-[ClassName objCMethodToSuppress:]; interceptor_via_lib:NameOfTheLibraryToSuppress. Conditional Compilation with ``__has_feature(address_sanitizer)``; -----------------------------------------------------------------. In some cases one may need to execute different code depending on whether; AddressSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:7793,variab,variable,7793,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['variab'],['variable']
Modifiability,"eam; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %truebr ], [ %fval, %falsebr ]; %g = phi [ %g1, %truebr ], [ %g2, %falsebr ]; call @llvm.dbg.value(metadata i32 %merge, metadata !1, metadata !2); call @llvm.dbg.value(m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:19577,variab,variable,19577,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; ```. See ""Example 2: A Tree with a C Structure"" below; (`$ROOTSYS/tutorials/tree/tree2.C`) and `staff.C` at the beginning of; this chapter. ## Adding a TBranch to Hold an Object. To write a branch to hold an event object, we need to load the; definition of the `Event` class, which is in `$ROOTSYS/test/libEvent.so`; (if it doesn't exist type make in `$ROOTSYS/test`). An object can be; saved in a tree if a ROOT dictionary for its class has been generated; and loaded. ``` {.cpp}; root[] .L libEvent.so; ```. First, we need to open a file and create a tree. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); ```. We need to create a pointer to an `Event` obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:22677,variab,variable,22677,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"ean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCSpaceBeforeProtocolList>`; Add a space in front of an Objective-C protocol list, i.e. use; ``Foo <Protocol>`` instead of ``Foo<Protocol>``. .. _PPIndentWidth:. **PPIndentWidth** (``Integer``) :versionbadge:`clang-format 13` :ref:`¶ <PPIndentWidth>`; The number of columns to use for indentation of preprocessor statements.; When set to -1 (default) ``IndentWidth`` is used also for preprocessor; statements. .. code-block:: c++. PPIndentWidth: 1. #ifdef __linux__; # define FOO; #else; # define BAR; #endif. .. _PackConstructorInitializers:. **PackConstructorInitializers** (``PackConstructorInitializersStyle``) :versionbadge:`clang-format 14` :ref:`¶ <PackConstructorInitializers>`; The pack constructor initializers style to use. Possible values:. * ``PCIS_Never`` (in configuration: ``Never``); Always put each constructor initializer on its own line. .. code-block:: c++. Constructor(); : a(),; b(). * ``PCIS_BinPack`` (in configuration: ``BinPack``); Bin-pack constructor initializers. .. code-block:: c++. Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_CurrentLine`` (in configuration: ``CurrentLine``); Put all constructor initializers on the current line if they fit.; Otherwise, put each one on its own line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; ddddddddddddd(). * ``PCIS_NextLine`` (in configuration: ``NextLine``); Same as ``PCIS_CurrentLine`` except that if all constructor initializers; do not fit on the current line, try to fit them on the next line. .. code-block:: c++. Constructor() : a(), b(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd(). Constructor(); : aaaaaaaaaaaaaaaaaaaa(),; bbbbbbbbbbbbbbbbbbbb(),; cccccccccccccccccccc(). * ``PCIS_NextLineOnly`` (in configuration: ``NextLineOnly``); Put all constructor initializers on the next line if they fit.; Otherw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:92358,config,configuration,92358,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"eans automatic convergence check is turned off). ConvergenceTests No -1 − Number of steps (without improvement) required for convergence (<0 means automatic convergence check is turned off). UseRegulator No False − Use regulator to avoid over-training. UpdateLimit No 10000 − Maximum times of regulator update. CalculateErrors No False − Calculates inverse Hessian matrix at the end of the training to be able to calculate the uncertainties of an MVA value. WeightRange No 1 − Take the events for the estimator calculations from small deviations from the desired value to large deviations only over the weight range. Configuration options for MVA method :. Configuration options reference for MVA method: Cuts. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). FitMethod No GA GA, SA, MC, MCEvents, MINUIT, EventScan Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated). EffMethod No EffSel EffSel, EffPDF Selection Method. CutRangeMin Yes -1 − Minimum of allowed cut range (set per variable). CutRangeMax Yes -1 − Maximum of allowed cut range (set per variable). VarProp Yes NotEnforced ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:24563,variab,variable,24563,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"earch paths will be used as; for ``#include`` directives. The line number in an external file may be; substituted with ``*`` meaning that any line number will match (useful where; the included file is, for example, a system header where the actual line number; may change and is not critical). As an alternative to specifying a fixed line number, the location of a; diagnostic can instead be indicated by a marker of the form ``#<marker>``.; Markers are specified by including them in a comment, and then referenced by; appending the marker to the diagnostic with ``@#<marker>``, as with:. .. code-block:: c++. #warning some text // #1; // ... other code ...; // expected-warning@#1 {{some text}}. The name of a marker used in a directive must be unique within the compilation. The simple syntax above allows each specification to match exactly one; diagnostic. You can use the extended syntax to customize this. The extended; syntax is ``expected-<type> <n> {{diag text}}``, where ``<type>`` is one of; ``error``, ``warning``, ``remark``, or ``note``, and ``<n>`` is a positive; integer. This allows the diagnostic to appear as many times as specified. For; example:. .. code-block:: c++. void f(); // expected-note 2 {{previous declaration is here}}. Where the diagnostic is expected to occur a minimum number of times, this can; be specified by appending a ``+`` to the number. For example:. .. code-block:: c++. void f(); // expected-note 0+ {{previous declaration is here}}; void g(); // expected-note 1+ {{previous declaration is here}}. In the first example, the diagnostic becomes optional, i.e. it will be; swallowed if it occurs, but will not generate an error if it does not occur. In; the second example, the diagnostic must occur at least once. As a short-hand,; ""one or more"" can be specified simply by ``+``. For example:. .. code-block:: c++. void g(); // expected-note + {{previous declaration is here}}. A range can also be specified by ``<n>-<m>``. For example:. .. code-block:: c+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:159579,extend,extended,159579,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extended']
Modifiability,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136296,variab,variable,136296,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"earned some parsing techniques, how to build and represent; an AST, how to build LLVM IR, and how to optimize the resultant code as; well as JIT compile it. While Kaleidoscope is interesting as a functional language, the fact; that it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1486,variab,variables,1486,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"easePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; variables, functions, methods, or blocks:. .. code-block:: objc. @class WobbleAmount;. @interface Widget : NSObject; -(void)wobble:(WobbleAmount *)amount;; @end. @implementation Widget. -(void)wobble:(WobbleAmount",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92262,variab,variable,92262,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"eases/>`_. Non-comprehensive list of changes in this release; =================================================; .. NOTE; For small 1-3 sentence descriptions, just add an entry at the end of; this list. If your description won't fit comfortably in one bullet; point (e.g. maybe you would like to give an example of the; functionality, or simply have a lot to talk about), see the `NOTE` below; for adding a new subsection. * ... Update on required toolchains to build LLVM; -------------------------------------------. Changes to the LLVM IR; ----------------------. * The `llvm.stacksave` and `llvm.stackrestore` intrinsics now use; an overloaded pointer type to support non-0 address spaces.; * The constant expression variants of the following instructions have been; removed:. * ``and``; * ``or``; * ``lshr``; * ``ashr``; * ``zext``; * ``sext``; * ``fptrunc``; * ``fpext``; * ``fptoui``; * ``fptosi``; * ``uitofp``; * ``sitofp``. * Added `llvm.exp10` intrinsic. * Added a ``code_model`` attribute for the `global variable <LangRef.html#global-variables>`_. Changes to LLVM infrastructure; ------------------------------. * Minimum Clang version to build LLVM in C++20 configuration has been updated to clang-17.0.6. Changes to building LLVM; ------------------------. Changes to TableGen; -------------------. * Added constructs for debugging TableGen files:. * `dump` keyword to dump messages to standard error, see; https://github.com/llvm/llvm-project/pull/68793.; * `!repr` bang operator to inspect the content of values, see; https://github.com/llvm/llvm-project/pull/68716. Changes to Interprocedural Optimizations; ----------------------------------------. Changes to the AArch64 Backend; ------------------------------. * Added support for Cortex-A520, Cortex-A720 and Cortex-X4 CPUs. * Neoverse-N2 was incorrectly marked as an Armv8.5a core. This has been; changed to an Armv9.0a core. However, crypto options are not enabled; by default for Armv9 cores, so `-mcpu=neoverse-n2+crypto` is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:2287,variab,variable,2287,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability,"eated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_OBJECT | BLOCK_BYREF_CALLER);. for something declared as an object or:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:19744,variab,variables,19744,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"eated notebooks with viewers like https://nbviewer.jupyter.org/; - Fix problem with using of local JSROOT version. ## Tutorials. - The tutorial games.C was not working properly. - Improve tutorial ErrorIntegral.C. - Schrödinger's Hydrogen Atom example. - Tutorial demonstrating how the changing of the range can zoom into the histogram. - Tutorial demonstrating how a Histogram can be read from a ROOT File. - histMax.C: a tutorial demoing how the hist->GetMaximumBin() can be used. ## Class Reference Guide. - Images for ROOT7 tutorials can be generated, in json format, using the directive using; `\macro_image (json)` in the macro header. - Clarify THStack drawing options. - Add missing documentation to TH1 functions. - Restructure the math reference guide. - Make the web gui documentation visible in the reference guide. - Make clear THtml is legacy code. Add deprecated flag on PROOF and TGeoTrack. - Improve many classes documentation: TContext, TTreePlayer, THistPainter, TGraph, TSelector,; integrator, GUI, TH1, TH2, TH3, TColor classes ... - Make the TFile layout doc visible in Reference Guide. - Update the external links of the reference guide main page. - Reformat TMVA mathcore Unuran Roostats documentation . ## Build, Configuration and Testing Infrastructure. - For users building from source the `latest-stable` branch and passing `-Droottest=ON` to the CMake command line, the corresponding revision of roottest pointed to by `latest-stable` will be downloaded as required. ## PyROOT. - The `ROOT` Python module is now properly serializable so that it is automatically available in the Python environment if a function or ROOT object needs to be serialized. See issue [#6764](https://github.com/root-project/root/issues/6764) for a concrete usecase.; - Improve overload resolution of functions that accept classes with long inheritance trees. Now prefer to call the function overload of the most derived class type (PR [#9092](https://github.com/root-project/root/pull/9092)).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:40003,inherit,inheritance,40003,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['inherit'],['inheritance']
Modifiability,"eating and Visualizing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; TVirtualGeoTrack provides this functionality. It currently has one; implementation inside the drawing package (TGeoTrack class). A; track can be defined like:. ~~~{.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ~~~. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ~~~{.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ~~~. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; TVirtualGeoTrack class. We will describe the structure and; functionality provided by the default implementation of these, which are; TGeoTrack objects. A TGeoTrack is storing a list of `control points` `(x,y,z)`; belonging to the track, having also time information `(t)`. The painting; algorithm of such tracks allows drawing them in any time interval after; their creation. The track position at a given time is computed by; interpolation between control points. ~~~{.cpp}; myTrack->AddPoint(x,y,z,t);; ~~~. The creation and management of tracks is in fact fully controlled by the; TGeoManager class. This holds a list of `primary tracks` that is; also visible during browsing as `Tracks` folder. Primary tracks are; tracks having no parent in the tracking history (for instance the output; of particle generators may be considered as primaries from tracking; point of view). The manager class holds; in TGeoManager::fCurrentTrack a pointer to the current track. When; starting ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:85760,inherit,inheriting,85760,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['inherit'],['inheriting']
Modifiability,"ebug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:10751,variab,variables,10751,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"ebugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ; [debug line = 5:9] [debug variable = Z]. The third intrinsic ``%llvm.dbg.declare`` encodes debugging information for; variable ``Z``. The metadata ``!dbg !19`` attached to the intrinsic provides; scope information for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:17203,variab,variable,17203,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ecause they are not truly; ""type safe"". In the end, the compiler leaves it the user to ensure that; the types are correct. This only leaves the other alternative: creating; a new class each time a new (container organization) / (contained; object) combination is needed. To say the least this could be very; tedious. Most people faced with this choice would, for each type of; container:. Define the class leaving a dummy name for the contained object type.; When a particular container was needed, copy the code and then do a; global search and replace for the contained class. C++ has a built in; template scheme that effectively does just this. For example:. ``` {.cpp}; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; ```. This is an array container with a 10-element array of pointers to T, it; could hold up to 10 T objects. This array is flawed because it is static; and hard-coded, it should be dynamic. However, the important point is; that the template statement indicates that T is a template, or; parameterized class. If we need an `ArrayContainer` for Track objects,; it can be created by:. ``` {.cpp}; ArrayContainer<Track> MyTrackArrayContainer;; ```. C++ takes the parameter list and substitutes Track for T throughout the; definition of the class `ArrayContainer`, then compiles the code so; generated, effectively doing the same we could do by hand, but with a; lot less effort. This produces code that is type safe, but does have different drawbacks:. - Templates make code harder to read. - At the time of writing this documentation, some compilers can be; very slow when dealing with templates. - It does not solve the problem when a container has to hold a; heterogeneous set of objects. - The system can end up generating a great deal of code; each; container/object combination has its own code, a phenomenon that is; sometimes referred to as *code bloat*. - The Standard Template Library (STL) is part on ANSI C++, and; includes a set of templat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:19056,parameteriz,parameterized,19056,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['parameteriz'],['parameterized']
Modifiability,"ecified.; #. The optional :ref:`function attributes <fnattrs>` list.; #. The optional :ref:`operand bundles <opbundles>` list. Semantics:; """""""""""""""""""". The '``call``' instruction is used to cause control flow to transfer to; a specified function, with its incoming arguments bound to the specified; values. Upon a '``ret``' instruction in the called function, control; flow continues with the instruction after the function call, and the; return value of the function is bound to the result argument. Example:; """""""""""""""". .. code-block:: llvm. %retval = call i32 @test(i32 %argc); call i32 (ptr, ...) @printf(ptr %msg, i32 12, i8 42) ; yields i32; %X = tail call i32 @foo() ; yields i32; %Y = tail call fastcc i32 @foo() ; yields i32; call void %foo(i8 signext 97). %struct.A = type { i32, i8 }; %r = call %struct.A @foo() ; yields { i32, i8 }; %gr = extractvalue %struct.A %r, 0 ; yields i32; %gr1 = extractvalue %struct.A %r, 1 ; yields i8; %Z = call void @foo() noreturn ; indicates that %foo never returns normally; %ZZ = call zeroext i32 @bar() ; Return value is %zero extended. llvm treats calls to some functions with names and arguments that match; the standard C99 library as being the C99 library functions, and may; perform optimizations or generate code for them under that assumption.; This is something we'd like to change in the future to provide better; support for freestanding environments and non-C-based languages. .. _i_va_arg:. '``va_arg``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <resultval> = va_arg <va_list*> <arglist>, <argty>. Overview:; """""""""""""""""". The '``va_arg``' instruction is used to access arguments passed through; the ""variable argument"" area of a function call. It is used to implement; the ``va_arg`` macro in C. Arguments:; """""""""""""""""""". This instruction takes a ``va_list*`` value and the type of the; argument. It returns a value of the specified argument type and; increments the ``va_list`` to point to the next argument. The actual; type of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:478665,extend,extended,478665,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extended']
Modifiability,"ecify any custom filter (e.g. *.png) in the filter combo box; Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc); Create special icons for symlinks (shortcuts) in the browser (add a small arrow on bottom left corner of the original icon). TGFileDialog. Implemented the wish #78935: Longer ""File of type:"" selector is wanted (make more combo box entries visible); Enable the new (flat) button style. This can be enabled/disabled via the GUI.Style entry in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). TGFSContainer. The shortcuts are now working on Windows. TGColorDialog, TGFontDialog, TGTextEditDialogs. Several improvements in the layout when increasing the font size. TGTextEditor. Added a ""Close"" menu entry; Properly ask the user to save the currently opened file (if modified) when trying to open a new file; Moved the IsSaved() part of the code in the LoadFile() method, to make sure it works also when the text editor is used as a plugin in the browser; Change the text highlighing color; Cleanup the text when quitting root (avoid potential crash on Linux). TGFrame. Allow to override CTRL+S behavior by using the TGMainFrame::BindKey() function. TVirtualDragManager. Renamed TVirtualDragManager::GetDragType() to TVirtualDragManager::GetEDragType(), to avoid potential clash between two classes (TGFrame and TVirtualDragManager) having both GetDragType method with different return types. And they are both inherited by one class (TGuiBldDragManager) which doesn't define GetDragType. TGSlider. Added mouse wheel handling. TGToolTip. Properly set the text color of the tooltip label, using the value of Gui.TooltipForegroundColor in $ROOTSYS/etc/system.rootrc (or in a user defined $HOME/.rootrc). GUIHtml; TGHtmlBrowser. Only add non-empty strings (urls) in the combo box, to avoid empty entries; Enable the new (flat) button style. This can be enabled/disabled vi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html:3342,plugin,plugin,3342,gui/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v530/index.html,1,['plugin'],['plugin']
Modifiability,"ecify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); match false; floatLiteral(equals(3.14)) and floatLiteral(equals(314e-2)); match 3.14; integerLiteral(equals(42)); matches 42. Note that you cannot directly match a negative numeric literal because the; minus sign is not part of the literal: It is a unary operator whose operand; is the positive numeric literal. Instead, you must use a unaryOperator(); match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57714,inherit,inheritance,57714,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"ecise lifetime semantics and, at some point after ``T`` but; before the next store to ``S``, the computation history features a; load from ``S`` and in some way depends on the value loaded, or. * ``X`` is a value described as being released at the end of the; current full-expression and, at some point after ``T`` but before; the end of the full-expression, the computation history depends; on that value. .. admonition:: Rationale. The intent of the second rule is to say that objects held in normal; ``__strong`` local variables may be released as soon as the value in; the variable is no longer being used: either the variable stops; being used completely or a new value is stored in the variable. The intent of the third rule is to say that return values may be; released after they've been used. A computation history depends on a pointer value ``P`` if it:. * performs a pointer comparison with ``P``,; * loads from ``P``,; * stores to ``P``,; * depends on a pointer value ``Q`` derived via pointer arithmetic; from ``P`` (including an instance-variable or field access), or; * depends on a pointer value ``Q`` loaded from ``P``. Dependency applies only to values derived directly or indirectly from; a particular expression result and does not occur merely because a; separate pointer value dynamically aliases ``P``. Furthermore, this; dependency is not carried by values that are stored to objects. .. admonition:: Rationale. The restrictions on dependency are intended to make this analysis; feasible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:80060,variab,variable,80060,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"ecker-XXX.; You do not need to place this directory or the contents of this; directory in any special place. Uninstalling the analyzer is as simple; as deleting this directory.; Most of the files in the checker-XXX directory will; be supporting files for the analyzer that you can simply ignore. Most; users will only care about two files, which are located at the top of; the checker-XXX directory:. scan-build: scan-build is the high-level command line utility for running the analyzer; scan-view: scan-view a companion command line; utility to scan-build, scan-view is used to view; analysis results generated by scan-build. There is an option; that one can pass to scan-build to cause scan-view to; run as soon as it the analysis of a build completes. Running scan-build; For specific details on using scan-build, please see; scan-build's documentation.; To run scan-build, either add the; checker-XXX directory to your path or specify a complete; path for scan-build when running it. It is also possible to use; a symbolic link to scan-build, such one located in a directory; in your path. When scan-build runs it will automatically; determine where to find its accompanying files.; Other Platforms (Building the Analyzer from Source); For other platforms, you must build Clang and LLVM manually. To do; so, please follow the instructions for building Clang from; source code.; Once the Clang is built, you need to add the following to your path:. The location of the clang binary. For example, if you built a Debug+Asserts build of LLVM/Clang (the; default), the resultant clang binary will be in $(OBJDIR)/Debug+Asserts/bin; (where $(OBJDIR) is often the same as the root source directory). You; can also do make install to install the LLVM/Clang libraries and; binaries to the installation directory of your choice (specified when you run; configure).; The locations of the scan-build and scan-view; programs. These are installed via make install into the bin directory; when clang is built. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html:3021,config,configure,3021,interpreter/llvm-project/clang/www/analyzer/installation.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/installation.html,1,['config'],['configure']
Modifiability,"eckout release; ./configure.py --bootstrap; sudo cp ninja /usr/bin/. cd ~/clang-llvm; git clone https://gitlab.kitware.com/cmake/cmake.git; cd cmake; git checkout next; ./bootstrap; make; sudo make install. Okay. Now we'll build Clang!. .. code-block:: console. cd ~/clang-llvm; mkdir build && cd build; cmake -G Ninja ../llvm-project/llvm -DLLVM_ENABLE_PROJECTS=""clang;clang-tools-extra"" -DCMAKE_BUILD_TYPE=Release -DLLVM_BUILD_TESTS=ON; ninja; ninja check # Test LLVM only.; ninja clang-test # Test Clang only.; ninja install. And we're live. All of the tests should pass. Finally, we want to set Clang as its own compiler. .. code-block:: console. cd ~/clang-llvm/build; ccmake ../llvm-project/llvm. The second command will bring up a GUI for configuring Clang. You need; to set the entry for ``CMAKE_CXX_COMPILER``. Press ``'t'`` to turn on; advanced mode. Scroll down to ``CMAKE_CXX_COMPILER``, and set it to; ``/usr/bin/clang++``, or wherever you installed it. Press ``'c'`` to; configure, then ``'g'`` to generate CMake's files. Finally, run ninja one last time, and you're done. Step 1: Create a ClangTool; ==========================. Now that we have enough background knowledge, it's time to create the; simplest productive ClangTool in existence: a syntax checker. While this; already exists as ``clang-check``, it's important to understand what's; going on. First, we'll need to create a new directory for our tool and tell CMake; that it exists. As this is not going to be a core clang tool, it will; live in the ``clang-tools-extra`` repository. .. code-block:: console. cd ~/clang-llvm/llvm-project; mkdir clang-tools-extra/loop-convert; echo 'add_subdirectory(loop-convert)' >> clang-tools-extra/CMakeLists.txt; vim clang-tools-extra/loop-convert/CMakeLists.txt. CMakeLists.txt should have the following contents:. ::. set(LLVM_LINK_COMPONENTS support). add_clang_executable(loop-convert; LoopConvert.cpp; ); target_link_libraries(loop-convert; PRIVATE; clangAST; clangASTMatchers; cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:2287,config,configure,2287,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['config'],['configure']
Modifiability,"eclaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict dec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47221,config,configuration,47221,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['configuration']
Modifiability,"eclarations** (``SortUsingDeclarationsOptions``) :versionbadge:`clang-format 5` :ref:`¶ <SortUsingDeclarations>`; Controls if and how clang-format will sort using declarations. Possible values:. * ``SUD_Never`` (in configuration: ``Never``); Using declarations are never sorted. .. code-block:: c++. using std::chrono::duration_cast;; using std::move;; using boost::regex;; using boost::regex_constants::icase;; using std::string;. * ``SUD_Lexicographic`` (in configuration: ``Lexicographic``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. Sort; the lists of names lexicographically, and within those groups, names are; in case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::chrono::duration_cast;; using std::move;; using std::string;. * ``SUD_LexicographicNumeric`` (in configuration: ``LexicographicNumeric``); Using declarations are sorted in the order defined as follows:; Split the strings by ""::"" and discard any initial empty strings. The; last element of each list is a non-namespace name; all others are; namespace names. Sort the lists of names lexicographically, where the; sort order of individual names is that all non-namespace names come; before all namespace names, and within those groups, names are in; case-insensitive lexicographic order. .. code-block:: c++. using boost::regex;; using boost::regex_constants::icase;; using std::move;; using std::string;; using std::chrono::duration_cast;. .. _SpaceAfterCStyleCast:. **SpaceAfterCStyleCast** (``Boolean``) :versionbadge:`clang-format 3.5` :ref:`¶ <SpaceAfterCStyleCast>`; If ``true``, a space is inserted after C style casts. .. code-block:: c++. true: false:; (int) i; vs. (int)i;. .. _SpaceAfterLogicalNot:. **SpaceAfterLogicalNot** (``Boolean``) :versionbadge:`clang-format 9` :ref:`¶ <SpaceAfterLogicalNot>`; If ``true``, a space is inserted after the logical no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:111595,config,configuration,111595,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"eclare <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vector of; :ref:`floating-point <t_floating>` type. The bit size of the value must be; smaller than the bit size of the return type. This implies that; '``llvm.vp.fpext``' cannot be used to make a *no-op cast*. The second operand; is the vector mask. The return type, the value to cast, and the vector mask have; the same number of elements. The third operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The '``llvm.vp.fpext``' cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op cast* for a floating-point cast.; The conversion is performed on lane positions below the explicit vector length; and where the vector mask is true. Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x double> @llvm.vp.fpext.v4f64.v4f32(<4 x float> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = fpext <4 x float> %a to <4 x double>; %also.r = select <4 x i1> %mask, <4 x double> %t, <4 x double> poison. .. _int_vp_fptoui:. '``llvm.vp.fptoui.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.fptoui.v16i32.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.fp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:804147,extend,extends,804147,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"ect copy/move assignment function; Not resolved. 2788; open; Correspondence and redeclarations; Not resolved. 2789; DR; Overload resolution with implicit and explicit object member functions; Clang 18. 2790; open; Aggregate initialization and user-defined conversion sequence; Not resolved. 2791; DR; Unclear phrasing about ""returning to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194221,variab,variables,194221,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"ect files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31320,config,config,31320,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability,"ect pointer` (or ""retainable pointer"") is a value of; a :arc-term:`retainable object pointer type` (""retainable type""). There are; three kinds of retainable object pointer types:. * block pointers (formed by applying the caret (``^``) declarator sigil to a; function type); * Objective-C object pointers (``id``, ``Class``, ``NSFoo*``, etc.); * typedefs marked with ``__attribute__((NSObject))``. Other pointer types, such as ``int*`` and ``CFStringRef``, are not subject to; ARC's semantics and restrictions. .. admonition:: Rationale. We are not at liberty to require all code to be recompiled with ARC;; therefore, ARC must interoperate with Objective-C code which manages retains; and releases manually. In general, there are three requirements in order for; a compiler-supported reference-count system to provide reliable; interoperation:. * The type system must reliably identify which objects are to be managed. An; ``int*`` might be a pointer to a ``malloc``'ed array, or it might be an; interior pointer to such an array, or it might point to some field or local; variable. In contrast, values of the retainable object pointer types are; never interior. * The type system must reliably indicate how to manage objects of a type.; This usually means that the type must imply a procedure for incrementing; and decrementing retain counts. Supporting single-ownership objects; requires a lot more explicit mediation in the language. * There must be reliable conventions for whether and when ""ownership"" is; passed between caller and callee, for both arguments and return values.; Objective-C methods follow such a convention very reliably, at least for; system libraries on macOS, and functions always pass objects at +0. The; C-based APIs for Core Foundation objects, on the other hand, have much more; varied transfer semantics. The use of ``__attribute__((NSObject))`` typedefs is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:11098,variab,variable,11098,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"ect title |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `Title` | Title of the object |; +--------------------+-------------------+--------------------------------------+; | ... `->` ... | `DATA` | Data bytes associated to the object |; +--------------------+-------------------+--------------------------------------+. You see a reference to **`TKey`**. It is explained in detail in the next; section. ### The Class Description List (StreamerInfo List). The histogram records are followed by the `StreamerInfo` list of class; descriptions. The list contains the description of each class that has; been written to file. ``` {.cpp}; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; ```. The class description is recursive, because to fully describe a class,; its ancestors and object data members have to be described also. In; `demo.root`, the class description list contains the description for:. - **`TH1F`**. - all classes in the **`TH1F`** inheritance tree. - all classes of the object data members. - all classes in the object data members' inheritance tree. This description is implemented by the **`TStreamerInfo`** class`,` and; is often referred to as simply `StreamerInfo`. You can print a file's; `StreamerInfo`list with the `TFile::ShowStreamerInfo` method. Below is; an example of the output. Only the first line of each class description; is shown. The `demo.root` example contains only **`TH1F`** objects. Here; we see the recursive nature of the class description; it contains the; `StreamerInfo`of all the classes needed to describe **`TH1F`**. ``` {.cpp}; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:10890,inherit,inheritance,10890,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inheritance']
Modifiability,"ected from each entry:. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[3][2] - fVertex[3][1]`. 20. **`tree->Draw(""fMatrix[ ][2] - fVertex[ ][ ]"")`**. This is similar to case 19. Twelve values are selected (4x3) from each; entry:. `fMatrix[0][2] - fVertex[0][0]`. `fMatrix[0][2] - fVertex[0][1]`. `fMatrix[0][2] - fVertex[0][2]`. `fMatrix[1][2] - fVertex[1][0]`. `fMatrix[1][2] - fVertex[1][1]`. `fMatrix[1][2] - fVertex[1][2]`. `fMatrix[2][2] - fVertex[2][0]`. `fMatrix[2][2] - fVertex[2][1]`. `fMatrix[2][2] - fVertex[2][2]`. `fMatrix[3][2] - fVertex[3][0]`. `fMatrix[3][2] - fVertex[3][1]`. `fMatrix[3][2] - fVertex[3][2]`. 21. **`tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]"")`**. This is the same as case 15. The first dimension minimum is 4 (from; `fMatrix`), and the second dimension minimum is 3 (from `fVertex`).; Twelve values are selected from each entry. 22. **`tree->Draw(""fClosestDistance"")`**. This event data member `fClosestDistance` is a variable length array:. `Float_t *fClosestDistance; //[fNvertex]`. This command selects all elements, but the number per entry depends on; the number of vertices of that entry. 23. **`tree->Draw(""fClosestDistance[fNvertex/2]"")`**. With this command the element at `fNvertex/2` of the; `fClosestDistance `array is selected. Only one per entry is selected. 24. **`tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)"")`**. This command shows the use of a mathematical expression. It draws the; square root of the sum of the product. 25. **`tree->Draw(""TMath::BreitWigner(fPx,3,2)"")`**. The formula can contains call to a function that takes numerical; arguments and returns a numerical value. The function needs to be; declared to the dictionary and need to be available from the global; namespace. In particular, global functions and public static member; functions can be called. 26. **`tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" "")`**. You can compare strings, using the symbols == and !=, in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:85048,variab,variable,85048,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"ected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separated copy of the; variable). Not all targets support thread-local variables. Optionally, a; TLS model may be specified:. ``localdynamic``; For variables that are only used within the current shared library.; ``initialexec``; For variables in modules that will not be loaded dynamically.; ``localexec``;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:25082,variab,variable,25082,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ections that are not; `SHT_NOTE` by making them `SHT_NOBITS` and shrinking the program headers where; possible. .. option:: --only-section <section>, -j. Remove all sections from the output, except for sections named ``<section>``.; Can be specified multiple times to keep multiple sections. For MachO objects, ``<section>`` must be formatted as; ``<segment name>,<section name>``. .. option:: --redefine-sym <old>=<new>. Rename symbols called ``<old>`` to ``<new>`` in the output. Can be specified; multiple times to rename multiple symbols. .. option:: --redefine-syms <filename>. Rename symbols in the output as described in the file ``<filename>``. In the; file, each line represents a single symbol to rename, with the old name and new; name separated by whitespace. Leading and trailing whitespace is ignored, as is; anything following a '#'. Can be specified multiple times to read names from; multiple files. .. option:: --regex. If specified, symbol and section names specified by other switches are treated; as extended POSIX regular expression patterns. .. option:: --remove-section <section>, -R. Remove the specified section from the output. Can be specified multiple times; to remove multiple sections simultaneously. For MachO objects, ``<section>`` must be formatted as; ``<segment name>,<section name>``. .. option:: --set-section-alignment <section>=<align>. Set the alignment of section ``<section>`` to ``<align>``. Can be specified; multiple times to update multiple sections. .. option:: --set-section-flags <section>=<flag>[,<flag>,...]. Set section properties in the output of section ``<section>`` based on the; specified ``<flag>`` values. Can be specified multiple times to update multiple; sections. Supported flag names are `alloc`, `load`, `noload`, `readonly`, `exclude`,; `debug`, `code`, `data`, `rom`, `share`, `contents`, `merge`, `strings`, and; `large`. Not all flags are meaningful for all object file formats or target; architectures. For ELF objects, the flags ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst:4130,extend,extended,4130,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objcopy.rst,1,['extend'],['extended']
Modifiability,"ectives. It also has an EmitInstruction method, which is used; to output an MCInst to the streamer. This API is most important for two clients: the llvm-mc stand-alone assembler is; effectively a parser that parses a line, then invokes a method on MCStreamer. In; the code generator, the `Code Emission`_ phase of the code generator lowers; higher level LLVM IR and Machine* constructs down to the MC layer, emitting; directives through MCStreamer. On the implementation side of MCStreamer, there are two major implementations:; one for writing out a .s file (MCAsmStreamer), and one for writing out a .o; file (MCObjectStreamer). MCAsmStreamer is a straightforward implementation; that prints out a directive for each method (e.g. ``EmitValue -> .byte``), but; MCObjectStreamer implements a full assembler. For target specific directives, the MCStreamer has a MCTargetStreamer instance.; Each target that needs it defines a class that inherits from it and is a lot; like MCStreamer itself: It has one method per directive and two classes that; inherit from it, a target object streamer and a target asm streamer. The target; asm streamer just prints it (``emitFnStart -> .fnstart``), and the object; streamer implement the assembler logic for it. To make llvm use these classes, the target initialization must call; TargetRegistry::RegisterAsmStreamer and TargetRegistry::RegisterMCObjectStreamer; passing callbacks that allocate the corresponding target streamer and pass it; to createAsmStreamer or to the appropriate object streamer constructor. The ``MCContext`` class; -----------------------. The MCContext class is the owner of a variety of uniqued data structures at the; MC layer, including symbols, sections, etc. As such, this is the class that you; interact with to create symbols and sections. This class can not be subclassed. The ``MCSymbol`` class; ----------------------. The MCSymbol class represents a symbol (aka label) in the assembly file. There; are two interesting kinds of s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:28180,inherit,inherits,28180,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,2,['inherit'],"['inherit', 'inherits']"
Modifiability,"ects on the heap were located at an address that had already been used for an instance of the same class before.; With v6.28, this is not guaranteed anymore.; Hence, if your code uses pointer comparisons to uniquely identify RooArgSet or RooDataSet instances, please consider using the new `RooArgSet::uniqueId()` or `RooAbsData::uniqueId()`. ### Introducing binned likelihood fit optimization in HistFactory. In a binned likelihood fit, it is possible to skip the PDF normalization when; the unnormalized binned PDF can be interpreted directly in terms of event; yields. This is now done by default for HistFactory models, which; results in great speedups for binned fits with many channels. Some RooFit users; like ATLAS were already using this for a long time. To disable this optimization when using the `hist2workspace` executable, add the `-disable_binned_fit_optimization` command line argument.; Directly in C++, you can also set the `binnedFitOptimization` to `false` in the; HistFactory configuration as follows:; ```C++; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, {.binnedFitOptimization=false});; ```; If your compiler doesn't support aggregate initialization with designators, you; need to create and edit the configuration struct explicitely:; ```C++; RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:20738,config,configuration,20738,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configuration']
Modifiability,"ects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager may use the same pages for both working and target memory by marking; them as RWX, allowing code to be modified in place without further overhead.; Finally, if RWX pages are not permitted but dual-virtual-mappings of; physical memory pages are, then the memory manager can dual map physical pages; as RW- in the JITLink process and R-X in the executor process, allowing; modification from the JITLink process but not from the executor (at the cost of; extra administrative overhead for the dual mapping). Error Handling; --------------. JITLink makes extensive use of the ``llvm::Error`` type (see the error handling; section of :doc:`ProgrammersManual`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30991,flexible,flexible,30991,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['flexible'],['flexible']
Modifiability,"ecute in the default :ref:`floating-point; environment <floatenv>`. The conversion is performed on lane positions below the; explicit vector length and where the vector mask is true. Masked-off lanes are; ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x float> @llvm.vp.fptrunc.v4f32.v4f64(<4 x double> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = fptrunc <4 x double> %a to <4 x float>; %also.r = select <4 x i1> %mask, <4 x float> %t, <4 x float> poison. .. _int_vp_fpext:. '``llvm.vp.fpext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x double> @llvm.vp.fpext.v16f64.v16f32 (<16 x float> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x double> @llvm.vp.fpext.nxv4f64.nxv4f32 (<vscale x 4 x float> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vector of; :ref:`floating-point <t_floating>` type. The bit size of the value must be; smaller than the bit size of the return type. This implies that; '``llvm.vp.fpext``' cannot be used to make a *no-op cast*. The second operand; is the vector mask. The return type, the value to cast, and the vector mask have; the same number of elements. The third operand is the explicit vector length of; the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.fpext``' intrinsic extends the ``value`` from a smaller; :ref:`floating-point <t_floating>` type to a larger :ref:`floating-point; <t_floating>` type. The '``llvm.vp.fpext``' cannot be used to make a; *no-op cast* because it always changes bits. Use ``bitcast`` to make a; *no-op c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:803395,extend,extends,803395,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"ecvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73475,config,configuration,73475,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"ed Framework](https://bitbucket.org/chromiumembedded/cef). 1. Current code tested with CEF3 branch 5845, Chromium 116 (August 2023); Some older CEF versions (like 95 or 107) may also be supported. 2. Download binary code from [https://cef-builds.spotifycdn.com/index.html](https://cef-builds.spotifycdn.com/index.html); and unpack it in directory without spaces and special symbols:. ~~~; $ mkdir /d/cef; $ cd /d/cef/; $ wget https://cef-builds.spotifycdn.com/cef_binary_107.1.11%2Bg26c0b5e%2Bchromium-107.0.5304.110_linux64_minimal.tar.bz2; $ tar xjf cef_binary_107.1.11+g26c0b5e+chromium-107.0.5304.110_linux64_minimal.tar.bz2; ~~~. 3 Install prerequisites - see comments in package `CMakeLists.txt`.; For the linux these are: `build-essential`, `libgtk3.0-dev`. 4. Compile CEF to produce `libcef_dll_wrapper`:. ~~~; $ cd /d/cef/cef_binary_107.1.11+g26c0b5e+chromium-107.0.5304.110_linux64_minimal; $ mkdir build; $ cd build; $ cmake ..; $ make -j libcef_dll_wrapper; ~~~. 5. Set CEF_ROOT variable to unpacked directory:. ~~~; $ export CEF_ROOT=/d/cef/cef_binary_107.1.11+g26c0b5e+chromium-107.0.5304.110_linux64_minimal; ~~~. 6. When configure ROOT compilation with `cmake -Dwebgui=ON -Dcefweb=ON ...`, CEF_ROOT shell variable should be set appropriately.; During compilation library `$ROOTSYS/lib/libROOTCefDisplay.so` and executable `$ROOTSYS/bin/cef_main`; should be created. Also check that several files like `icudtl.dat`, `v8_context_snapshot_blob.bin`, `snapshot_blob.bin`; copied into ROOT library directory. 7. Run ROOT with `--web=cef` argument to use CEF web display like:. ~~~; $ root --web=cef $ROOTSYS/tutorials/rcanvas/rh2.cxx; ~~~. ## Compile libcef_dll_wrapper on Windows. 1. Download binary win32 build like https://cef-builds.spotifycdn.com/cef_binary_95.7.12%2Bg99c4ac0%2Bchromium-95.0.4638.54_windows32.tar.bz2. 2. Extract in directory without spaces like `C:\Soft\cef`. 3. Modify `cmake/cef_variables.cmake` to set dynamic linking, replace ""/MT"" by ""/MD"" in approx line 389. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md:1100,variab,variable,1100,gui/cefdisplay/Readme.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/Readme.md,1,['variab'],['variable']
Modifiability,"ed by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:134189,flexible,flexible,134189,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['flexible'],['flexible']
Modifiability,"ed by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:27524,variab,variable,27524,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"ed hooks that can be overridden in; WebAssemblyTargetLowering. //===---------------------------------------------------------------------===//. Instead of the OptimizeReturned pass, which should consider preserving the; ""returned"" attribute through to MachineInstrs and extending the; MemIntrinsicResults pass to do this optimization on calls too. That would also; let the WebAssemblyPeephole pass clean up dead defs for such calls, as it does; for stores. //===---------------------------------------------------------------------===//. Consider implementing optimizeSelect, optimizeCompareInstr, optimizeCondBranch,; optimizeLoadInstr, and/or getMachineCombinerPatterns. //===---------------------------------------------------------------------===//. Find a clean way to fix the problem which leads to the Shrink Wrapping pass; being run after the WebAssembly PEI pass. //===---------------------------------------------------------------------===//. When setting multiple local variables to the same constant, we currently get; code like this:. i32.const $4=, 0; i32.const $3=, 0. It could be done with a smaller encoding like this:. i32.const $push5=, 0; local.tee $push6=, $4=, $pop5; local.copy $3=, $pop6. //===---------------------------------------------------------------------===//. WebAssembly registers are implicitly initialized to zero. Explicit zeroing is; therefore often redundant and could be optimized away. //===---------------------------------------------------------------------===//. Small indices may use smaller encodings than large indices.; WebAssemblyRegColoring and/or WebAssemblyRegRenumbering should sort registers; according to their usage frequency to maximize the usage of smaller encodings. //===---------------------------------------------------------------------===//. Many cases of irreducible control flow could be transformed more optimally; than via the transform in WebAssemblyFixIrreducibleControlFlow.cpp. It may also be worthwhile to do transforms befo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt:3907,variab,variables,3907,interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/README.txt,1,['variab'],['variables']
Modifiability,"ed in clang-query, RegexFlags parameter; should be passed as a quoted string. e.g: ""NoFlags"".; Flags can be combined with '|' example ""IgnoreCase | BasicRegex"". Matcher<ObjCMessageExpr>numSelectorArgsunsigned N; Matches when the selector has the specified number of arguments. matcher = objCMessageExpr(numSelectorArgs(0));; matches self.bodyView in the code below. matcher = objCMessageExpr(numSelectorArgs(2));; matches the invocation of ""loadHTMLString:baseURL:"" but not that; of self.bodyView; [self.bodyView loadHTMLString:html baseURL:NULL];. Matcher<ObjCMethodDecl>isClassMethod; Returns true when the Objective-C method declaration is a class method. Example; matcher = objcMethodDecl(isClassMethod()); matches; @interface I + (void)foo; @end; but not; @interface I - (void)bar; @end. Matcher<ObjCMethodDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<ObjCMethodDecl>isInstanceMethod; Returns true when the Objective-C method declaration is an instance method. Example; matcher = objcMethodDecl(isInstanceMethod()); matches; @interface I - (void)bar; @end; but not; @interface I + (void)foo; @end. Matcher<ParmVarDecl>hasDefaultArgument; Matches a declaration that has default arguments. Example matches y (matcher = parmVarDecl(hasDefaultArgument())); void x(int val) {}; void y(int val = 0) {}. Deprecated. Use hasInitializer() instead to be able to; match on the contents of the default argument. For example:. void x(int val = 7) {}; void y(int val = 42) {}; parmVarDecl(hasInitializer(integerLiteral(equals(42)))); matches",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:109209,variab,variable,109209,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"ed into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the lifetime of this object. In garbage collected environments, the ``__weak`` variable is set to; nil when the object it references is collected, as long as the; ``__block`` variable resides in the heap (either by default or via; ``Block_copy()``). The initial Apple implementation does in fact; start ``__block`` variables on the stack and migrate them to the heap; only as a result of a ``Block_copy()`` operation. It is a runtime error to attempt to assign a reference to a; stack-based Block into any storage marked ``__weak``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were refe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:10265,variab,variables,10265,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"ed process; is associated with one or more threads. Threads execute independently.; All threads in a given process share the private address space of that; process. **`Concurrency`** exists when at least two threads are in progress at; the same time. A system with only a single processor can support; concurrency by switching execution contexts among multiple threads. **`Parallelism`** arises when at least two threads are executing; simultaneously. This requires a system with multiple processors.; Parallelism implies concurrency, but not vice-versa. A function is **`reentrant`** if it will behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:20986,variab,variables,20986,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['variab'],['variables']
Modifiability,"ed to apply attributes to C++ member; functions. This includes members like static functions, operators, and; constructors/destructors. - ``hasType(functionType)``: Can be used to apply attributes to functions, C++; member functions, and variables/fields whose type is a function pointer. It; does not apply attributes to Objective-C methods or blocks. - ``type_alias``: Can be used to apply attributes to ``typedef`` declarations; and C++11 type aliases. - ``record``: Can be used to apply attributes to ``struct``, ``class``, and; ``union`` declarations. - ``record(unless(is_union))``: Can be used to apply attributes only to; ``struct`` and ``class`` declarations. - ``enum``: Can be used to apply attributes to enumeration declarations. - ``enum_constant``: Can be used to apply attributes to enumerators. - ``variable``: Can be used to apply attributes to variables, including; local variables, parameters, global variables, and static member variables.; It does not apply attributes to instance member variables or Objective-C; ivars. - ``variable(is_thread_local)``: Can be used to apply attributes to thread-local; variables only. - ``variable(is_global)``: Can be used to apply attributes to global variables; only. - ``variable(is_local)``: Can be used to apply attributes to local variables; only. - ``variable(is_parameter)``: Can be used to apply attributes to parameters; only. - ``variable(unless(is_parameter))``: Can be used to apply attributes to all; the variables that are not parameters. - ``field``: Can be used to apply attributes to non-static member variables; in a record. This includes Objective-C ivars. - ``namespace``: Can be used to apply attributes to ``namespace`` declarations. - ``objc_interface``: Can be used to apply attributes to ``@interface``; declarations. - ``objc_protocol``: Can be used to apply attributes to ``@protocol``; declarations. - ``objc_category``: Can be used to apply attributes to category declarations,; including class extensions. - ``obj",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:183897,variab,variables,183897,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"ed to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; captured value. The syntax of ``<fmtspec>`` is: ``#.<precision><conversion specifier>`` where:. * ``#`` is an optional flag available for hex values (see; ``<conversion specifier>`` below) which requires the value matched to be; prefixed by ``0x``.; * ``.<precision>`` is an optional printf-style precision specifier in which; ``<precision>`` indicates the minimum number of digits that the value matched; must have, expecting leading zeros if needed. * ``<conversion specifier>`` is an optional scanf-style conversion specifier; to indicate what number format to match (e.g. hex number). Currently; accepted format specifiers are ``%u``, ``%d``, ``%x`` and ``%X``. If absent,; the format specifier defaults to ``%u``. For example:. .. code-block:: llvm. ; CHECK: mov r[[#REG:]], 0x[[#%.8X,ADDR:]]. would match ``mov r5, 0x0000FEFE`` and set ``REG`` to the value ``5`` and; ``ADDR`` to the value ``0xFEFE``. Note that due to the precision it would fail; to match ``mov ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:28569,variab,variable,28569,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"ed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6296,variab,variable,6296,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"ed up by the static analyzer to prune infeasible paths, which; in some cases can greatly reduce the number of false positives (bogus error; reports) emitted by the tool.; Another option is to use --force-analyze-debug-code flag of; scan-build tool which would enable assertions automatically.; Use verbose output when debugging scan-build; scan-build takes a -v option to emit verbose output about; what it's doing; two -v options emit more information. Redirecting the; output of scan-build to a text file (make sure to redirect standard; error) is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7248,config,configure,7248,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configure']
Modifiability,"ed with Xcode, and thus can; contain bug fixes, new checks, or simply better analysis.; On the other hand, new checks can be experimental, with results of variable; quality. Users are encouraged to file bug reports; (for any version of the analyzer) where they encounter false positives or other; issues.; set-xcode-analyzer; Starting with analyzer build checker-234, analyzer builds contain a command; line utility called set-xcode-analyzer that allows users to change what; copy of clang that Xcode uses for analysis:. $ set-xcode-analyzer -h; Usage: set-xcode-analyzer [options]. Options:; -h, --help show this help message and exit; --use-checker-build=PATH; Use the Clang located at the provided absolute path,; e.g. /Users/foo/checker-1; --use-xcode-clang Use the Clang bundled with Xcode. Operationally, set-xcode-analyzer edits Xcode's configuration files; to point it to use the version of clang you specify for static; analysis. Within this model it provides you two basic modes:. --use-xcode-clang: Switch Xcode (back) to using the clang that came bundled with it for static analysis.; --use-checker-build: Switch Xcode to using the clang provided by the specified analyzer build. Things to keep in mind. You should quit Xcode prior to running set-xcode-analyzer. You will need to run set-xcode-analyzer under; sudo in order to have write privileges to modify the Xcode; configuration files. Examples; Example 1: Telling Xcode to use checker-235:. $ pwd; /tmp; $ tar xjf checker-235.tar.bz2; $ sudo checker-235/set-xcode-analyzer --use-checker-build=/tmp/checker-235. Note that you typically won't install an analyzer build in /tmp, but; the point of this example is that set-xcode-analyzer just wants a full; path to an untarred analyzer build.; Example 2: Telling Xcode to use a very specific version of clang:. $ sudo set-xcode-analyzer --use-checker-build=~/mycrazyclangbuild/bin/clang. Example 3: Resetting Xcode to its default behavior:. $ sudo set-xcode-analyzer --use-xcode-clang. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html:2803,config,configuration,2803,interpreter/llvm-project/clang/www/analyzer/xcode.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/xcode.html,1,['config'],['configuration']
Modifiability,"ed with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:104044,variab,variable,104044,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['variab'],['variable']
Modifiability,"ed); ======================================. .. contents::; :local:. Overview; ========. First, all tests are executed within the LLVM object directory tree.; They *are not* executed inside of the LLVM source tree. This is because; the test suite creates temporary files during execution. To run the test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:980,config,configuration,980,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configuration']
Modifiability,"ed. However the movement can result in objects coming; ‘through the front' of the camera and disappearing. - When you zoom, the camera does not move - hence clipping of near; objects is unaffected. However with extremely small zooms (FOV; large/focal length short) noticeable distortions, causing straight; lines to become curved, can be seen with objects near the camera -; the ‘fisheye' lens effect. - Generally dollying is more ‘natural', but you may need to use both; to achieve the desired perspective and eye position - particularly; when you are working inside or very close to 3D objects. Configure the camera by calling the methods `SetPerspectiveCamera(`) or; `SetOrthographicCamera()` of **`TGLViewer`**:. ``` {.cpp}; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; v->SetOrthoCamera(TGLViewer::kCameraOrthoXOY,; left,right,top,bottom);; ...; v->SetPerspectiveCamera (camera,fov,dolly,center,hRotate,vRotate);; ```. Note - you can configure any of the six cameras in the viewer at any; time, but you will not see the result until the camera is made current. #### Draw Styles. The GL Viewer supports three different rendering modes, which are; applied to all the objects in your scene, but not Clip Shapes and Guides; (See ""Clipping"" and ""Manipulators""). These are shown below, along with; the key used to activate the style. ![GL Viewer draw styles](pictures/020000DC.jpg). **Filled Polygons** **Wireframe** **Outline** Enable with ‘r' key Enable; with ‘w' key Enable with ‘t' key Solid polygons, with hidden surface; Object edges in color, with Combination of Filled Polygons removal,; color surface materials, no surface filling/hiding. and Outline styles.; Solid opacity, specular reflection etc. shapes with edges. Black; background. Black background. White background. Call method `TGLViewer::SetStyle` with one of; **`TGLRnrCtx::EDrawStyle `flags `kFill`, `kOutline`, `kWireFrame`:**. ``` {.cpp}; v->SetStyle(TGLRnrCtx::kFill);; ```. #### Lighting / Style. The GL viewer creates f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:112357,config,configure,112357,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['config'],['configure']
Modifiability,"ed. Therefore, as histograms' titles, axis; titles, labels etc ... are drawn using `TLatex`, the `TMathText`; syntax can be used for them also.; - Fix a very old bug (in `TTF.cxx` since the beginning). With the; following code the spaces between ""text"" and \#lambda were ignored. ``` {.cpp}; TLatex t; t.DrawLatex( 0.1,0.1,""text \#Lambda"" ); ```. - Implement `#backslash`.; - Implement `DrawLatexNDC`.; - Implement `#minus` and `#plus` typographically better than the; standard `""-""` and `""+""`.; - Make sure all greek and math symbols are printed correctly by `TTexDump`.; - Implement dummy operators `#mbox` and `#hbox` to improve the compatibility; between `TLatex`, `TMathText` and `TTexDump`.; - Some operators like `#minus`, `#plus`, `#mp`, `#hbar` etc ...; ignored the color defined by the operator `#color`.; - With the Cocoa backend on Mac the text string were a bit too large; compared to the TTF rendering. ### TPave. - Implement `SetX1()` etc ... for `TPave` and inherited classes to make sure the; NDC coordinates are also defined. ### TLinearGradient and TRadialGradient. - Two new classes to support color gradient: `TLinearGradient` and `TRadialGradient`.; Both classes inherit from `TColor` and can be used the same way as ROOT's; standard colors in `TAttFill` (`SetFillColor(newColorIndex)`).; Gradient fill can be created using either RGBA values directly, or from; color indices (colors from the ROOT's color table).; - TRadialGradient supports a simple radial gradient (center + radius); and an ""extended"" radial gradient (starting/ending points + two radii).; - The new gradient fill option is available either with OpenGL (""gl-in-pad""); or with a Cocoa backend (OS X only).; - Please note, at the moment, a color gradient can not be saved; in a ROOT file or a pdf/ps file. It can be saved as an image (png/jpg etc.).; - There are several demos in the tutorials/cocoa and tutorials/gl sub-directories; explaining how to use these new classes:; * grad.C; * grad2.C; * radialgradie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:7562,inherit,inherited,7562,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['inherit'],['inherited']
Modifiability,"ed_execute.png"");; ```. In example usage of images from `$ROOTSYS/icons` directory is shown. One could prepend `button;`; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:. ```cpp; serv->Hide(""/DoSomething"");; ```. One can find example of command interface usage in [tutorials/http/httpcontrol.C](https://github.com/root-project/root/blob/master/tutorials/http/httpcontrol.C) macro. ## Customize user interface. JSROOT is used to implement UI for the THttpServer. Default webpage shows list of registered objects on the left side and drawing area on the right side - [see example](https://root.cern/js/latest/httpserver.C/). JSROOT allows to configure different parameters via URL - like monitoring interval or name of displayed items [item=Files/job1.root/hpxpy&opt=colz&monitoring=1000](https://root.cern/js/latest/httpserver.C/?item=Files/job1.root/hpxpy&opt=colz&monitoring=1000). Some of such parameters can be configured already on the server:. ```cpp; serv->SetItemField(""/"", ""_monitoring"", ""1000""); // monitoring interval in ms; serv->SetItemField(""/"", ""_drawitem"", ""Files/job1.root/hpxpy""); // item to draw; serv->SetItemField(""/"", ""_drawopt"", ""colz"");; ```. In such case URL parameters are not required - specified item will be displayed automatically when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:6876,config,configured,6876,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configured']
Modifiability,"ed_i);; _Block_object_assign(&dst->captured_i, src->captured_i, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);; }. void __block_dispose_5(struct __block_literal_5 *src) {; //_Block_byref_release(src->captured_i);; _Block_object_dispose(src->captured_i, BLOCK_FIELD_IS_BYREF | BLOCK_BYREF_CALLER);; }. static struct __block_descriptor_5 {; unsigned long int reserved;; unsigned long int Block_size;; void (*copy_helper)(struct __block_literal_5 *dst, struct __block_literal_5 *src);; void (*dispose_helper)(struct __block_literal_5 *);; } __block_descriptor_5 = { 0, sizeof(struct __block_literal_5) __block_copy_5, __block_dispose_5 };. and:. .. code-block:: c. struct _block_byref_i i = {( .isa=NULL, .forwarding=&i, .flags=0, .size=sizeof(struct _block_byref_i), .captured_i=2 )};; struct __block_literal_5 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<29), <uninitialized>,; __block_invoke_5,; &__block_descriptor_5,; &i,; };. Importing ``__attribute__((NSObject))`` ``__block`` variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ``__block`` variable that is also marked ``__attribute__((NSObject))`` should; have ``byref_keep`` and ``byref_dispose`` helper functions that use; ``_Block_object_assign`` and ``_Block_object_dispose``. ``__block`` escapes; ^^^^^^^^^^^^^^^^^^^. Because ``Blocks`` referencing ``__block`` variables may have ``Block_copy()``; performed upon them the underlying storage for the variables may move to the; heap. In Objective-C Garbage Collection Only compilation environments the heap; used is the garbage collected one and no further action is required. Otherwise; the compiler must issue a call to potentially release any heap storage for; ``__block`` variables at all escapes or terminations of their scope. The call; should be:. .. code-block:: c. _Block_object_dispose(&_block_byref_foo, BLOCK_FIELD_IS_BYREF);. Nesting; ^^^^^^^. ``Blocks`` may contain ``Block`` literal expressions. Any variables used within; inner blocks are imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:17418,variab,variables,17418,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"edicate*\ ``)``. This operator creates a new ``list`` by filtering the elements in; *list*. To perform the filtering, TableGen binds the variable *var* to each; element and then evaluates the *predicate* expression, which presumably; refers to *var*. The predicate must; produce a boolean value (``bit``, ``bits``, or ``int``). The value is; interpreted as with ``!if``:; if the value is 0, the element is not included in the new list. If the value; is anything else, the element is included. ``!find(``\ *string1*\ ``,`` *string2*\ [``,`` *start*]\ ``)``; This operator searches for *string2* in *string1* and produces its; position. The starting position of the search may be specified by *start*,; which can range between 0 and the length of *string1*; the default is 0.; If the string is not found, the result is -1. ``!foldl(``\ *init*\ ``,`` *list*\ ``,`` *acc*\ ``,`` *var*\ ``,`` *expr*\ ``)``; This operator performs a left-fold over the items in *list*. The; variable *acc* acts as the accumulator and is initialized to *init*.; The variable *var* is bound to each element in the *list*. The; expression is evaluated for each element and presumably uses *acc* and; *var* to calculate the accumulated value, which ``!foldl`` stores back in; *acc*. The type of *acc* is the same as *init*; the type of *var* is the; same as the elements of *list*; *expr* must have the same type as *init*. The following example computes the total of the ``Number`` field in the; list of records in ``RecList``::. int x = !foldl(0, RecList, total, rec, !add(total, rec.Number));. If your goal is to filter the list and produce a new list that includes only; some of the elements, see ``!filter``. ``!foreach(``\ *var*\ ``,`` *sequence*\ ``,`` *expr*\ ``)``; This operator creates a new ``list``/``dag`` in which each element is a; function of the corresponding element in the *sequence* ``list``/``dag``.; To perform the function, TableGen binds the variable *var* to an element; and then evaluates the expres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:63986,variab,variable,63986,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"educe the number of false positives (bogus error; reports) emitted by the tool.; Another option is to use --force-analyze-debug-code flag of; scan-build tool which would enable assertions automatically.; Use verbose output when debugging scan-build; scan-build takes a -v option to emit verbose output about; what it's doing; two -v options emit more information. Redirecting the; output of scan-build to a text file (make sure to redirect standard; error) is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., setup code signing).; Recommendation: use ""Build and Analyze""; The absolute easiest way to an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7299,config,configure,7299,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,1,['config'],['configure']
Modifiability,eduction for address of function; Unknown. 1675; NAD; Size limit for automatic array object; Unknown. 1676; drafting; auto return type for allocation and deallocation functions; Not resolved. 1677; C++17; Constant initialization via aggregate initialization; Unknown. 1678; NAD; Naming the type of an array of runtime bound; Unknown. 1679; NAD; Range-based for and array of runtime bound; Unknown. 1680; drafting; Including <initializer_list> for range-based for; Not resolved. 1681; C++14; init-captures and nested lambdas; Unknown. 1682; open; Overly-restrictive rules on function templates as allocation functions; Not resolved. 1683; CD4; Incorrect example after constexpr changes; Unknown. 1684; C++14; Static constexpr member functions for non-literal classes; Clang 3.6. 1685; NAD; Value category of noexcept expression; Unknown. 1686; CD4; Which variables are “explicitly declared const?”; Unknown. 1687; C++14; Conversions of operands of built-in operators; Clang 7. 1688; NAD; Volatile constexpr variables; Unknown. 1689; C++14; Syntactic nonterminal for operand of alignas; Unknown. 1690; C++14; Associated namespace for local type; Clang 9. 1691; C++14; Argument-dependent lookup and opaque enumerations; Clang 9. 1692; C++14; Associated namespaces of doubly-nested classes; Clang 9. 1693; C++14; Superfluous semicolons in class definitions; Unknown. 1694; CD4; Restriction on reference to temporary as a constant expression; Unknown. 1695; NAD; Lifetime extension via init-capture; Unknown. 1696; CD4; Temporary lifetime and non-static data member initializers; Clang 7. 1697; CD4; Lifetime extension and copy elision; Unknown. 1698; DR; Files ending in \; Unknown. 1699; open; Does befriending a class befriend its friends?; Not resolved. 1700; NAD; Does the special rvalue-reference deduction apply to alias templates?; Unknown. 1701; drafting; Array vs sequence in object representation; Not resolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:114248,variab,variables,114248,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"ee T;1 staff data from ascii file; ```. We can see the **`TTree `**""`T`"" in the file. We will use it to; experiment with the **`TTree::Draw`** method, so let's create a pointer to it:. ``` {.cpp}; root[] TTree *MyTree = T; ```. Cling allows us to get simply the object by using it. Here we define a; pointer to a **`TTree`** object and assign it the value of ""`T`"", the; **`TTree`** in the file. Cling looks for an object named ""`T`"" in the; current ROOT file and returns it (this assumes that ""T"" has not; previously been used to declare a variable or function). In contrast, in compiled code, you can use:. ``` {.cpp}; TTree *MyTree;f.GetObject(""T"",MyTree);; ```. To show the different `Draw` options, we create a canvas with four; sub-pads. We will use one sub-pad for each `Draw` command. ``` {.cpp}; root[] TCanvas *myCanvas = new TCanvas(); root[] myCanvas->Divide(2,2); ```. We activate the first pad with the `TCanvas::cd` statement:. ``` {.cpp}; root[] myCanvas->cd(1); ```. We then draw the variable `Cost`:. ``` {.cpp}; root[] MyTree->Draw(""C; ```. As you can see, the last call `TTree::Draw` has only one parameter. It; is a string containing the leaf name. A histogram is automatically; created as a result of a `TTree::Draw`. The style of the histogram is; inherited from the **`TTree`** attributes and the current style; (***`gStyle`***) is ignored. The **`TTree`** gets its attributes from; the current **`TStyle`** at the time it was created. You can call the; method `TTree::UseCurrentStyle` to change to the current style rather; than the **`TTree`** style. (See ***`gStyle`***; see also ""Graphics and; the Graphical User Interface"" ). In the next segment, we activate the second pad and draw a scatter plot; variables:. ``` {.cpp}; root[] myCanvas->cd(2); root[] MyTree->Draw(""Cost:Age""); ```. This signature still only has one parameter, but it now has two; dimensions separated by a colon `(""x:y"")`. The item to be plotted can be; an expression not just a simple variable. In gen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:69866,variab,variable,69866,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"ee the :doc:`FrontendAction; tutorial <RAVFrontendAction>` on how to write a ``FrontendAction`` using the; ``RecursiveASTVisitor``. In this tutorial, we'll demonstrate how to write a; simple clang plugin. Writing a ``PluginASTAction``; =============================. The main difference from writing normal ``FrontendActions`` is that you can; handle plugin command line options. The ``PluginASTAction`` base class declares; a ``ParseArgs`` method which you have to implement in your plugin. .. code-block:: c++. bool ParseArgs(const CompilerInstance &CI,; const std::vector<std::string>& args) {; for (unsigned i = 0, e = args.size(); i != e; ++i) {; if (args[i] == ""-some-arg"") {; // Handle the command line argument.; }; }; return true;; }. Registering a plugin; ====================. A plugin is loaded from a dynamic library at runtime by the compiler. To; register a plugin in a library, use ``FrontendPluginRegistry::Add<>``:. .. code-block:: c++. static FrontendPluginRegistry::Add<MyPlugin> X(""my-plugin-name"", ""my plugin description"");. Defining pragmas; ================. Plugins can also define pragmas by declaring a ``PragmaHandler`` and; registering it using ``PragmaHandlerRegistry::Add<>``:. .. code-block:: c++. // Define a pragma handler for #pragma example_pragma; class ExamplePragmaHandler : public PragmaHandler {; public:; ExamplePragmaHandler() : PragmaHandler(""example_pragma"") { }; void HandlePragma(Preprocessor &PP, PragmaIntroducer Introducer,; Token &PragmaTok) {; // Handle the pragma; }; };. static PragmaHandlerRegistry::Add<ExamplePragmaHandler> Y(""example_pragma"",""example pragma description"");. Defining attributes; ===================. Plugins can define attributes by declaring a ``ParsedAttrInfo`` and registering; it using ``ParsedAttrInfoRegister::Add<>``:. .. code-block:: c++. class ExampleAttrInfo : public ParsedAttrInfo {; public:; ExampleAttrInfo() {; Spellings.push_back({ParsedAttr::AS_GNU,""example""});; }; AttrHandling handleDeclAttribute(Sema &S, D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:1301,plugin,plugin-name,1301,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,2,['plugin'],"['plugin', 'plugin-name']"
Modifiability,"eed helper functions for program level; ``Block_copy()`` and ``Block_release()`` operations, in which case the; (1<<25) flags bit is set. As an example, the ``Block`` literal expression:. .. code-block:: c. ^ { printf(""hello world\n""); }. would cause the following to be created on a 32-bit system:. .. code-block:: c. struct __block_literal_1 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_1 *);; struct __block_descriptor_1 *descriptor;; };. void __block_invoke_1(struct __block_literal_1 *_block) {; printf(""hello world\n"");; }. static struct __block_descriptor_1 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_1 = { 0, sizeof(struct __block_literal_1) };. and where the ``Block`` literal itself appears:. .. code-block:: c. struct __block_literal_1 _block_literal = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. A ``Block`` imports other ``Block`` references, ``const`` copies of other; variables, and variables marked ``__block``. In Objective-C, variables may; additionally be objects. When a ``Block`` literal expression is used as the initial value of a global; or ``static`` local variable, it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:5882,variab,variables,5882,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,2,['variab'],['variables']
Modifiability,"eeded to allocate a new block) -; this slot's offset is again dictated by ``libgcc``. The generated; assembly looks like this on x86-64:. .. code-block:: text. leaq -8(%rsp), %r10; cmpq %fs:112, %r10; jg .LBB0_2. # More stack space needs to be allocated; movabsq $8, %r10 # The amount of space needed; movabsq $0, %r11 # The total size of arguments passed on stack; callq __morestack; ret # The reason for this extra return is explained below; .LBB0_2:; # Usual prologue continues here. The size of function arguments on the stack needs to be passed to; ``__morestack`` (this function is implemented in ``libgcc``) since that number; of bytes has to be copied from the previous stacklet to the current one. This is; so that SP (and FP) relative addressing of function arguments work as expected. The unusual ``ret`` is needed to have the function which made a call to; ``__morestack`` return correctly. ``__morestack``, instead of returning, calls; into ``.LBB0_2``. This is possible since both, the size of the ``ret``; instruction and the PC of call to ``__morestack`` are known. When the function; body returns, control is transferred back to ``__morestack``. ``__morestack``; then de-allocates the new stacklet, restores the correct SP value, and does a; second return, which returns control to the correct caller. Variable Sized Allocas; ----------------------. The section on `allocating stacklets`_ automatically assumes that every stack; frame will be of fixed size. However, LLVM allows the use of the ``llvm.alloca``; intrinsic to allocate dynamically sized blocks of memory on the stack. When; faced with such a variable-sized alloca, code is generated to:. * Check if the current stacklet has enough space. If yes, just bump the SP, like; in the normal case.; * If not, generate a call to ``libgcc``, which allocates the memory from the; heap. The memory allocated from the heap is linked into a list in the current; stacklet, and freed along with the same. This prevents a memory leak.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SegmentedStacks.rst:2713,variab,variable-sized,2713,interpreter/llvm-project/llvm/docs/SegmentedStacks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SegmentedStacks.rst,1,['variab'],['variable-sized']
Modifiability,"een 50 and 60 percentage of its scope; covered. OPTIONS; -------. .. option:: --only-variables. calculate the location statistics only for local variables. .. option:: --only-formal-parameters. calculate the location statistics only for formal parameters. .. option:: --ignore-debug-entry-values. ignore the location statistics on locations containing the; debug entry values DWARF operation. .. option:: --draw-plot. make histogram of location buckets generated (requires; matplotlib). .. option:: --compare. compare the debug location coverage on two files provided, and draw; a plot showing the difference (requires matplotlib). EXIT STATUS; -----------. :program:`llvm-locstats` returns 0 if the input file were parsed; successfully. Otherwise, it returns 1. EXAMPLE 1; --------------. Pretty print the location coverage on the standard output. .. code-block:: none. llvm-locstats a.out. =================================================; Debug Location Statistics; =================================================; cov% samples percentage(~); -------------------------------------------------; 0% 1 16%; (0%,10%) 0 0%; [10%,20%) 0 0%; [20%,30%) 0 0%; [30%,40%) 0 0%; [40%,50%) 0 0%; [50%,60%) 1 16%; [60%,70%) 0 0%; [70%,80%) 0 0%; [80%,90%) 1 16%; [90%,100%) 0 0%; 100% 3 50%; =================================================; -the number of debug variables processed: 6; -PC ranges covered: 81%; -------------------------------------------------; -total availability: 83%; =================================================. EXAMPLE 2; --------------. Generate a plot as an image file. .. code-block:: none. llvm-locstats --draw-plot file1.out. .. image:: locstats-draw-plot.png; :align: center. EXAMPLE 3; --------------. Generate a plot as an image file showing the difference in the debug location; coverage. .. code-block:: none. llvm-locstats --compare file1.out file1.withentryvals.out. .. image:: locstats-compare.png; :align: center. SEE ALSO; --------. :manpage:`llvm-dwarfdump(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst:2164,variab,variables,2164,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-locstats.rst,1,['variab'],['variables']
Modifiability,"ef:`Contributing <submit_patch>`. Bisecting commits; ^^^^^^^^^^^^^^^^^. See `Bisecting LLVM code <GitBisecting.html>`_ for how to use ``git bisect``; on LLVM. Reverting a change; ^^^^^^^^^^^^^^^^^^. When reverting changes using git, the default message will say ""This reverts; commit XYZ"". Leave this at the end of the commit message, but add some details; before it as to why the commit is being reverted. A brief explanation and/or; links to bots that demonstrate the problem are sufficient. Local LLVM Configuration; ------------------------. Once checked out repository, the LLVM suite source code must be configured; before being built. This process uses CMake. Unlinke the normal ``configure``; script, CMake generates the build files in whatever format you request as well; as various ``*.inc`` files, and ``llvm/include/llvm/Config/config.h.cmake``. Variables are passed to ``cmake`` on the command line using the format; ``-D<variable name>=<value>``. The following variables are some common options; used by people developing LLVM. +-------------------------+----------------------------------------------------+; | Variable | Purpose |; +=========================+====================================================+; | CMAKE_C_COMPILER | Tells ``cmake`` which C compiler to use. By |; | | default, this will be /usr/bin/cc. |; +-------------------------+----------------------------------------------------+; | CMAKE_CXX_COMPILER | Tells ``cmake`` which C++ compiler to use. By |; | | default, this will be /usr/bin/c++. |; +-------------------------+----------------------------------------------------+; | CMAKE_BUILD_TYPE | Tells ``cmake`` what type of build you are trying |; | | to generate files for. Valid options are Debug, |; | | Release, RelWithDebInfo, and MinSizeRel. Default |; | | is Debug. |; +-------------------------+----------------------------------------------------+; | CMAKE_INSTALL_PREFIX | Specifies the install directory to target when |; | | running the install",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:23950,variab,variables,23950,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['variab'],['variables']
Modifiability,"ef:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``Boolean``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceBeforeCaseColon>`; If ``false``, spaces will be removed before case colon. .. code-block:: c++. true: false; switch (x) { vs. switch (x) {; case 1 : break; case 1: break",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113841,config,configuration,113841,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"efault_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:108524,variab,variable,108524,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"eff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL project; @bib-SEAL at CERN @bib-CERN. ### From to ###. The program is entirely written in standard portable . M does not depend; on any external library. In its minimal usage the user must only provide; an implementation of the FCNBase class to M and parameters and; uncertainties in form of std::vector containers. ### Memory allocation and thread safety ###. Differently to the version of M , the version has its own memory manager; (StackAllocator. The user can select between the standard dynamic memory; allocation and deallocation (default) and performance-optimized; stack–like allocation (optional). However, the library is not thread; save using stack–allocation. ### M parameters ###. Differently to the version of M there is no limit on the numb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:24707,config,configure,24707,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['config'],['configure']
Modifiability,"efine the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.; @end; @implementation X; - (void)ma {}; @end. Usable as: Matcher<TagDecl>, Matcher<VarDecl>, Matcher<FunctionDecl>,; Matcher<ObjCMethodDecl>. Matcher<VarDecl>isExceptionVariable; Matches a variable declaration that is an exception variable from; a C++ catch block, or an Objective-C statement. Example matches x (matcher = varDecl(isExceptionVariable()); void f(int y) {; try {; } catch (int x) {; }; }. Matcher<VarDecl>isExplicitTemplateSpecialization; Matches explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127405,variab,variable,127405,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"efore non-static imports,; but this behavior is changed by another option,; ``SortJavaStaticImport``. In the .clang-format configuration file, this can be configured like; in the following yaml example. This will result in imports being; formatted as in the Java example below. .. code-block:: yaml. JavaImportGroups: ['com.example', 'com', 'org']. .. code-block:: java. import static com.example.function1;. import static com.test.function2;. import static org.example.function3;. import com.example.ClassA;; import com.example.Test;; import com.example.a.ClassB;. import com.test.ClassC;. import org.example.ClassD;. .. _JavaScriptQuotes:. **JavaScriptQuotes** (``JavaScriptQuoteStyle``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptQuotes>`; The JavaScriptQuoteStyle to use for JavaScript strings. Possible values:. * ``JSQS_Leave`` (in configuration: ``Leave``); Leave string quotes as they are. .. code-block:: js. string1 = ""foo"";; string2 = 'bar';. * ``JSQS_Single`` (in configuration: ``Single``); Always use single quotes. .. code-block:: js. string1 = 'foo';; string2 = 'bar';. * ``JSQS_Double`` (in configuration: ``Double``); Always use double quotes. .. code-block:: js. string1 = ""foo"";; string2 = ""bar"";. .. _JavaScriptWrapImports:. **JavaScriptWrapImports** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <JavaScriptWrapImports>`; Whether to wrap JavaScript import/export statements. .. code-block:: js. true:; import {; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; VeryLongImportsAreAnnoying,; } from 'some/module.js'. false:; import {VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,} from ""some/module.js"". .. _KeepEmptyLinesAtEOF:. **KeepEmptyLinesAtEOF** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <KeepEmptyLinesAtEOF>`; Keep empty lines (up to ``MaxEmptyLinesToKeep``) at end of file. .. _KeepEmptyLinesAtTheStartOfBlocks:. **KeepEmptyLinesAtTheStartOfBlocks** (``Boolean``) :versionbadge:`clang-format 3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:80787,config,configuration,80787,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"eg->Fill(event->GetNseg());; }; // Draw the histogram; hnseg->Draw();; }; ```. ### TChain::AddFriend; \index{tree!friend}. `A `**`TChain`** has a list of friends similar to a tree (see; `TTree::AddFriend)`. You can add a friend to a chain with the; `TChain::AddFriend` method. With `TChain::GetListOfFriends` you can; retrieve the list of friends. The next example has four chains each has; 20 ROOT trees from 20 ROOT files. ``` {.cpp}; TChain ch(""t""); // a chain with 20 trees from 20 files; TChain ch1(""t1"");; TChain ch2(""t2"");; TChain ch3(""t3"");; ```. Now we can add the friends to the first chain. ``` {.cpp}; ch.AddFriend(""t1"");; ch.AddFriend(""t2"");; ch.AddFriend(""t3"");; ```. The parameter is the name of friend chain (the name of a chain is always; the name of the tree from which it was created). The original chain has; access to all variables in its friends. We can use the `TChain::Draw`; method as if the values in the friends were in the original chain. To; specify the chain to use in the `Draw` method, use:. ``` {.cpp}; <chainname>.<branchname>.<varname>; ```. If the variable name is enough to identify uniquely the variable, you; can leave out the chain and/or branch name. For example, this generates; a 3-d scatter plot of variable ""`var`"" in the `TChain ch` versus; variable `v1 in `**`TChain t1` versus variable `v2` in `TChain`**` t2`. ``` {.cpp}; ch.Draw(""var:t1.v1:t2.v2"");; ```. When a `TChain::Draw` is executed, an automatic call to; `TTree::AddFriend `connects the trees in the chain. When a chain; is deleted, its friend elements are also deleted. ![](pictures/02000108.jpg). The number of entries in the friend must be equal or greater to the; number of entries of the original chain. If the friend has fewer entries; a warning is given and the resulting histogram will have missing; entries. For additional information see `TTree::AddFriends()`. A full; example of a tree and friends is in Example \#3; `($ROOTSYS/tutorials/tree/tree3.C`) in the Trees section above.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:143530,variab,variable,143530,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,5,['variab'],['variable']
Modifiability,"egate CTAD, string, and brace elision; Unknown. 2686; open; Pack expansion into a non-pack parameter of a concept; Not resolved. 2687; C++23; Calling an explicit object member function via an address-of-overload-set; Clang 18. 2688; open; Calling explicit object member functions; Not resolved. 2689; tentatively ready; Are cv-qualified std::nullptr_t fundamental types?; Unknown. 2690; C++23; Semantics of defaulted move assignment operator for unions; Unknown. 2691; C++23; hexadecimal-escape-sequence is too greedy; Unknown. 2692; C++23; Static and explicit object member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186308,extend,extended,186308,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extended']
Modifiability,"egend and some additional information in the form of graphics; primitives and text. A well formatted plot, clear for the reader is; crucial to communicate the relevance of your results to the; reader.\label{f31}][f31]. ## Summary of Visual effects. ### Colours and Graph Markers. We have seen that to specify a colour, some identifiers like kWhite,; kRed or kBlue can be specified for markers, lines, arrows etc. The; complete summary of colours is represented by the ROOT ""[colour; wheel](https://root.cern.ch/doc/master/classTColor.html#C02)"". To know more; about the full story, refer to the online documentation of `TColor`. ROOT provides several [graphics; markers](https://root.cern.ch/doc/master/classTAttMarker.html#M2) types. Select; the most suited symbols for your plot among dots, triangles, crosses or; stars. An alternative set of names for the markers is available. ### Arrows and Lines. The macro line *55* shows how to define an arrow and draw it. The class; representing arrows is `TArrow`, which inherits from `TLine`. The; constructors of lines and arrows always contain the coordinates of the; endpoints. Arrows also foresee parameters to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:7769,inherit,inherits,7769,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['inherit'],['inherits']
Modifiability,"egister"", ""RegisterClass"", and; ""Instruction"" in the LLVM code generator) or for the implementor to help factor; out common properties of records (such as ""FPInst"", which is used to represent; floating point instructions in the X86 backend). TableGen keeps track of all of; the classes that are used to build up a definition, so the backend can find all; definitions of a particular class, such as ""Instruction"". .. code-block:: text. class ProcNoItin<string Name, list<SubtargetFeature> Features>; : Processor<Name, NoItineraries, Features>;. Here, the class ProcNoItin, receiving parameters `Name` of type `string` and; a list of target features is specializing the class Processor by passing the; arguments down as well as hard-coding NoItineraries. **TableGen multiclasses** are groups of abstract records that are instantiated; all at once. Each instantiation can result in multiple TableGen definitions.; If a multiclass inherits from another multiclass, the definitions in the; sub-multiclass become part of the current multiclass, as if they were declared; in the current multiclass. .. code-block:: text. multiclass ro_signed_pats<string T, string Rm, dag Base, dag Offset, dag Extend,; dag address, ValueType sty> {; def : Pat<(i32 (!cast<SDNode>(""sextload"" # sty) address)),; (!cast<Instruction>(""LDRS"" # T # ""w_"" # Rm # ""_RegOffset""); Base, Offset, Extend)>;. def : Pat<(i64 (!cast<SDNode>(""sextload"" # sty) address)),; (!cast<Instruction>(""LDRS"" # T # ""x_"" # Rm # ""_RegOffset""); Base, Offset, Extend)>;; }. defm : ro_signed_pats<""B"", Rm, Base, Offset, Extend,; !foreach(decls.pattern, address,; !subst(SHIFT, imm_eq0, decls.pattern)),; i8>;. See the :doc:`TableGen Programmer's Reference <./ProgRef>` for an in-depth; description of TableGen. .. _backend:; .. _backends:. TableGen backends; =================. TableGen files have no real meaning without a backend. The default operation; when running ``*-tblgen`` is to print the information in a textual format, but; that's only useful ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:9639,inherit,inherits,9639,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['inherit'],['inherits']
Modifiability,"egratorMultiDim::kMISER` | `ROOT::Math:::GSLMCIntegrator` |; | `ROOT::Math::IntegratorMultiDim::kPLAIN` | `ROOT::Math:::GSLMCIntegrator` |. The control parameters for the integration algorithms can be specified using the; `ROOT::Math::IntegratorMultiDimOptions` class. Static methods are provided to change the default values.; It is possible to print the list of default control parameters using the `ROOT::Math::IntegratorMultiDimOptions::Print` function.; Example:; ```{.cpp}; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; ```; Depending on the algorithm, some of the control parameters might have no effect. #### `ROOT::Math::AdaptiveIntegratorMultiDim`. This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper; *Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302*.; It is part of the *MathCore* library.; The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation. #### `ROOT::Math::GSLMCIntegrator`. It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used; in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; For a detail description of the GSL methods visit the GSL users guide.; Specific configuration options (documented in the GSL user guide) for the `ROOT::Math::GSLMCIntegration` can be set directly in the class, or when using it via the `ROOT::Math::IntegratorMultiDim`; interface, can be defined using the `ROOT::Math::IntegratorMultiDimOptions`. ## Function Deriv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:61333,adapt,adaptive,61333,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['adapt'],['adaptive']
Modifiability,"ehavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill; (or ROOT_TTREECACHE_PREFILL) both to zero. TTree methods which are expected to modify a cache, like AddBranchToCache, will; attempt to setup a cache of default size if one does not exist, irrespective of; whether the auto cache creation is enabled. Additionally several methods giving; control of the cache have changed return type from void to Int_t, to be able to; return a code to indicate if there was an error. Usually TTree::SetCacheSize will no longer reset the list of branches to be; cached (either set or previously learnt) nor restart the learning phase.; The learning phase is restarted when a new cache is created, e.g. after having; removed a cache with SetCacheSize(0). ### TSelectorDraw. The axis titles in case of a `x:y:z` plot with the option `COLZ` were not correct. ### TParallelCoordVar. Chan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:14064,variab,variable,14064,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variable']
Modifiability,"el into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141484,portab,portable,141484,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['portab'],['portable']
Modifiability,"el the relevant instructions along with their def/use relations.; This too follows a staged approach: first, the new instructions that compute; masks are modeled as VPInstructions, along with their induced def/use subgraph.; This effectively models masks in VPlan, facilitating VPlan-based predication.; Next, the logic embedded within each Recipe for generating its instructions at; VPlan execution time, will instead take part in the planning process by modeling; them as VPInstructions. Finally, only logic that applies to instructions as a; group will remain in Recipes, such as interleave groups and potentially other; idiom groups having synergistic cost. Related LLVM components; -----------------------; 1. SLP Vectorizer: one can compare the VPlan model with LLVM's existing SLP; tree, where TSLP [3]_ adds Plan Step 2.b. 2. RegionInfo: one can compare VPlan's H-CFG with the Region Analysis as used by; Polly [7]_. 3. Loop Vectorizer: the Vectorization Plan aims to upgrade the infrastructure of; the Loop Vectorizer and extend it to handle outer loops [8]_, [9]_. References; ----------; .. [1] ""Outer-loop vectorization: revisited for short SIMD architectures"", Dorit; Nuzman and Ayal Zaks, PACT 2008. .. [2] ""Proposal for function vectorization and loop vectorization with function; calls"", Xinmin Tian, [`cfe-dev; <http://lists.llvm.org/pipermail/cfe-dev/2016-March/047732.html>`_].,; March 2, 2016.; See also `review <https://reviews.llvm.org/D22792>`_. .. [3] ""Throttling Automatic Vectorization: When Less is More"", Vasileios; Porpodas and Tim Jones, PACT 2015 and LLVM Developers' Meeting 2015. .. [4] ""Exploiting mixed SIMD parallelism by reducing data reorganization; overhead"", Hao Zhou and Jingling Xue, CGO 2016. .. [5] ""Register Allocation via Hierarchical Graph Coloring"", David Callahan and; Brian Koblenz, PLDI 1991. .. [6] ""Structural analysis: A new approach to flow analysis in optimizing; compilers"", M. Sharir, Journal of Computer Languages, Jan. 1980. .. [7] ""Enabling",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst:10593,extend,extend,10593,interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/VectorizationPlan.rst,1,['extend'],['extend']
Modifiability,"el``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the string at that point leads to it being indented; ``ContinuationIndentWidth`` spaces from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33767,config,configuration,33767,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"eld; of a heap object. The code fragments inserted at these points are called *read; barriers* and *write barriers*, respectively. The amount of code that needs to; be executed is usually quite small and not on the critical path of any; computation, so the overall performance impact of the barrier is tolerable. Barriers often require access to the *object pointer* rather than the *derived; pointer* (which is a pointer to the field within the object). Accordingly,; these intrinsics take both pointers as separate arguments for completeness. In; this snippet, ``%object`` is the object pointer, and ``%derived`` is the derived; pointer:. .. code-block:: llvm. ;; An array type.; %class.Array = type { %class.Object, i32, [0 x %class.Object*] }; ... ;; Load the object pointer from a gcroot.; %object = load %class.Array** %object_addr. ;; Compute the derived pointer.; %derived = getelementptr %object, i32 0, i32 2, i32 %n. LLVM does not enforce this relationship between the object and derived pointer; (although a particular :ref:`collector strategy <plugin>` might). However, it; would be an unusual collector that violated it. The use of these intrinsics is naturally optional if the target GC does not; require the corresponding barrier. The GC strategy used with such a collector; should replace the intrinsic calls with the corresponding ``load`` or; ``store`` instruction if they are used. One known deficiency with the current design is that the barrier intrinsics do; not include the size or alignment of the underlying operation performed. It is; currently assumed that the operation is of pointer size and the alignment is; assumed to be the target machine's default alignment. Write barrier: ``llvm.gcwrite``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.gcwrite(i8* %value, i8* %object, i8** %derived). For write barriers, LLVM provides the ``llvm.gcwrite`` intrinsic function. It; has exactly the same semantics as a non-volatile ``store`` to the derived; poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:13996,plugin,plugin,13996,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"elect the directory where you have LLVM extracted to, and; the default options should all be fine. One option you may really; want to change, regardless of anything else, might be the; ``CMAKE_INSTALL_PREFIX`` setting to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select configuration:. In the directory you created the project files will have an ``llvm.sln``; file, just double-click on that to open Visual Studio. The default Visual; Studio configuration is **Debug** which is slow and generates a huge amount; of debug information on disk. For now, we recommend selecting **Release**; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:6760,config,configuration,6760,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['config'],['configuration']
Modifiability,"electable sub-items. This requires new; signals to be emitted from TGLViewer:. virtual void MouseOver (TObject *obj, UInt_t state); // *SIGNAL*; virtual void ReMouseOver(TObject *obj, UInt_t state); // *SIGNAL*; virtual void UnMouseOver(TObject *obj, UInt_t state); // *SIGNAL*. TGLEventHandler emits them when needed. For example see TEveDigitSet; and its sub-classes TEveQuadSet and TEveBoxSet. It is now possible to enforce all tesselations of geometry shapes; to only use triangles via static function void; TGLFaceSet::EnforceTriangles(). This is needed to export TGeo; shapes and CSG meshes to external triangle-mesh libraries that can; not handle arbitrary polygons.; Add support for full-scene anti-aliasing (the actual benefits; depend on graphics card / driver). It is controlled via rootrc,; e.g.:. OpenGL.Framebuffer.Multisample: 4. Minor changes. Extend configurability of GL event-handler to allow inversion of; controls from scene-centric to viewer-centric. The following rootrc; variables control the behaviour:. OpenGL.EventHandler.ViewerCentricControls: 1; OpenGL.EventHandler.ArrowKeyFactor: -1.0; OpenGL.EventHandler.MouseDragFactor: -1.0; OpenGL.EventHandler.MouseWheelFactor: -1.0. Add camera auto-rotation support. Controls are available from the; ""Extras"" tab of TGLViewer GUI editor. Implemented in class; TGLAutoRotator, can be sub-classed and attached to a viewer via; TGLViewer::SetAutoRotator() method.; Added new overlay element class TGLCameraGuide that shows the; orientation of major axes. To use, call this on a TGLViewer object:. gl_viewer->AddOverlayElement(new TGLCameraGuide(0.9, 0.1, 0.08));. Fix an issue with GL-clip object not being properly updated after; a scene update.; Hide / show menu-bar with a time-out (default 400ms). This can be; adjusted by calling static method:; TGLSAViewer::SetMenuHidingTimeout(200);; To disable menu hiding for Eve viewers, where it is enabled by; default, set the following rootrc variable:; Eve.Viewer.HideMenus: off. EVE;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:1624,variab,variables,1624,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['variab'],['variables']
Modifiability,"elete the object. For example:. TClass::AddRule(""HepMC::GenVertex m_event attributes=NotOwner"");. MakeProject now implements a move constructor for each classes. For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation. Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor. MakeProject now adds dictionaries for auto_ptr. MakeProject no longer request the dictionary for std::pair instances that already have been loaded. Misc. TFile::Open now does variable expansion so that you can include the protocol in the variable (for example: export H1=""http://root.cern/files/h1""; ...; TFile::Open(""$H1/dstarmb.root"");; Added warning if the file does contain any StreamerInfo objects and was written with a different version of ROOT.; Implemented polymorphism for Emulated object (still not supporting polymorphism of Emulated Object inheriting from compiled class). See the Core/Meta section for details.; Add support for streaming auto_ptr when generating their dictionary via rootcint; Enable the use of the I/O customization rules on data members that are either a variable size array or a fixed size array. For example:. #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""Int_t *fArray; Int_t fN;"" \; target = ""fArray"" \; code = ""{ fArray = new Char_t[onfile.fN]; Char_t* gtc=fArray; Int_t* gti=onfile.fArray; \; for(Int_t i=0; i<onfile.fN; i++) *(gtc+i) = *(gti+i)+10; }""; #pragma read sourceClass = ""ACache"" targetClass = ""ACache"" version = ""[8]"" \; source = ""float fValues[3]"" \; target = ""fValues"" \; code = ""{ for(Int_t i=0; i<3; i++) fValues[i] = 1+onfile.fValues[i]; }"". Allow the seamless schema evolution from map<a,b> to vector<pair<a,b> >.; Avoid dropping information when reading a long written on a 64 bits platforms; and being read into a long ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html:9487,polymorphi,polymorphism,9487,io/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v528/index.html,3,"['inherit', 'polymorphi']","['inheriting', 'polymorphism']"
Modifiability,"else. Because we will; need it to create the Phi node, we remember the block that falls through; into the loop. Once we have that, we create the actual block that starts; the loop and create an unconditional branch for the fall-through between; the two blocks. .. code-block:: c++. // Start insertion in LoopBB.; Builder->SetInsertPoint(LoopBB);. // Start the PHI node with an entry for Start.; PHINode *Variable = Builder->CreatePHI(Type::getDoubleTy(*TheContext),; 2, VarName);; Variable->addIncoming(StartVal, PreheaderBB);. Now that the ""preheader"" for the loop is set up, we switch to emitting; code for the loop body. To begin with, we move the insertion point and; create the PHI node for the loop induction variable. Since we already; know the incoming value for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:22433,variab,variable,22433,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"ely useful for example to pre-load a custom; style for the plots created with ROOT. This is done most easily by; creating a new `TStyle` object with your preferred settings, as; described in the class reference guide, and then use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20049,config,configure-root-at-start-up,20049,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['config'],['configure-root-at-start-up']
Modifiability,"ely; implemented, because it requires support from both the object file; format and the linker. The notion is similar to Microsoft Visual; Studio's ``#pragma comment(lib...)``. Configuration macros declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The *config-macros-declaration* specifies the set of configuration macros that have an effect on the API of the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of diff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:46982,config,config-macros-declaration,46982,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['config-macros-declaration']
Modifiability,"ely; in the sandbox, as 'mymacro.C'; so they should be included directly by; 'mymacro.C', e.g. '#include ""thisheader.h""' .; Import the dataset stager daemon 'afdsmgrd' into ROOT; this is used; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or; printing the list. By default objects was names start with 'PROOF_' are; not shown. The presence of a non empty missing file list is; notified.; In the PROOF monitoring to: send additional information about memory; usage during the query, the name and size (# of files) of the dataset; processed (if any); add possibility to send the information to multiple; monitoring collectors.; Add support for block activation/deactivatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:1580,plugin,plugins,1580,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,1,['plugin'],['plugins']
Modifiability,"emaCXX/using-directive.cpp. If you used the make VERBOSE=1 option, the terminal; output will reflect the error messages from the compiler and; test runner.; The regression suite can also be run with Valgrind by running; make test VG=1 in the top-level clang directory.; For more intensive changes, running; the LLVM; Test Suite with clang is recommended. Currently the best way to; override LLVMGCC, as in: make LLVMGCC=""clang -std=gnu89""; TEST=nightly report (make sure clang is in your PATH or use the; full path). Testing using Visual Studio on Windows. The Clang test suite can be run from either Visual Studio or; the command line.; Note that the test runner is based on; Python, which must be installed. Find Python at:; https://www.python.org/downloads/.; Download the latest stable version.; The GnuWin32 tools are also necessary for running the tests.; Get them from ; http://getgnuwin32.sourceforge.net/.; If the environment variable %PATH% does not have GnuWin32,; or if other grep(s) supercedes GnuWin32 on %PATH%,; you should specify LLVM_LIT_TOOLS_DIR; to CMake explicitly.; The cmake build tool is set up to create Visual Studio project files; for running the tests, ""check-clang"" being the root. Therefore, to; run the test from Visual Studio, right-click the check-clang project; and select ""Build"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:5020,variab,variable,5020,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['variab'],['variable']
Modifiability,"ement is reached. To; give an object more permanence it has to be placed on the heap. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. The second line declares a pointer to `Quad` called `my_objptr`. From; the syntax point of view, this is just like all the other declarations; we have seen so far, i.e. this is a stack variable. The value of the; pointer is set equal to. ``` {.cpp}; new Quad(1.,2.,-3.);; ```. `new`, despite its looks, is an operator and creates an object or; variable of the type that comes next, `Quad` in this case, on the; heap. Just as with stack objects it has to be initialized by calling; its constructor. The syntax requires that the argument list follows the; type. This one statement has brought two items into existence, one on; the heap and one on the stack. The heap object will live until the; delete operator is applied to it. There is no FORTRAN parallel to a heap object; variables either come; or go as control passes in and out of a function or subroutine, or,; like a COMMON block variables, live for the lifetime of the program.; However, most people in HEP who use FORTRAN will have experience of a; memory manager and the act of creating a bank is a good equivalent of; a heap object. For those who know systems like ZEBRA, it will come as; a relief to learn that objects do not move, C++ does not garbage; collect, so there is never a danger that a pointer to an object; becomes invalid for that reason. However, having created an object,; it is the user's responsibility to ensure that it is deleted when no; longer needed, or to pass that responsibility onto to some other; object. Failing to do that will result in a memory leak, one of the; most common and most hard-to-find C++ bugs. To send a message to an object via a pointer to it, you need to use; the ""`->`"" operator e.g.:. ``` {.cpp}; root[] my_objptr->Solve();; ```. Although we chose to call our pointer `my_objptr`, to emphasize that; it is a pointer, heap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:10173,variab,variables,10173,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,2,['variab'],['variables']
Modifiability,"emental bitcode loader. N: Cameron Buschardt; E: buschard@uiuc.edu; D: The `mem2reg' pass - promotes values stored in memory to registers. N: Brendon Cahoon; E: bcahoon@codeaurora.org; D: Loop unrolling with run-time trip counts. N: Chandler Carruth; E: chandlerc@gmail.com; E: chandlerc@google.com; D: Hashing algorithms and interfaces; D: Inline cost analysis; D: Machine block placement pass; D: SROA. N: Casey Carter; E: ccarter@uiuc.edu; D: Fixes to the Reassociation pass, various improvement patches. N: Evan Cheng; E: evan.cheng@apple.com; D: ARM and X86 backends; D: Instruction scheduler improvements; D: Register allocator improvements; D: Loop optimizer improvements; D: Target-independent code generator improvements. N: Dan Villiom Podlaski Christiansen; E: danchr@gmail.com; E: danchr@cs.au.dk; W: http://villiom.dk; D: LLVM Makefile improvements; D: Clang diagnostic & driver tweaks; S: Aarhus, Denmark. N: Jeff Cohen; E: jeffc@jolt-lang.org; W: http://jolt-lang.org; D: Native Win32 API portability layer. N: John T. Criswell; E: criswell@uiuc.edu; D: Original Autoconf support, documentation improvements, bug fixes. N: Anshuman Dasgupta; E: adasgupt@codeaurora.org; D: Deterministic finite automaton based infrastructure for VLIW packetization. N: Stefanus Du Toit; E: stefanus.du.toit@intel.com; D: Bug fixes and minor improvements. N: Rafael Avila de Espindola; E: rafael@espindo.la; D: MC and LLD work. N: Dave Estes; E: cestes@codeaurora.org; D: AArch64 machine description for Cortex-A53. N: Alkis Evlogimenos; E: alkis@evlogimenos.com; D: Linear scan register allocator, many codegen improvements, Java frontend. N: Hal Finkel; E: hfinkel@anl.gov; D: Basic-block autovectorization, PowerPC backend improvements. N: Eric Fiselier; E: eric@efcs.ca; D: LIT patches and documentation. N: Ryan Flynn; E: pizza@parseerror.com; D: Miscellaneous bug fixes. N: Brian Gaeke; E: gaeke@uiuc.edu; W: http://www.students.uiuc.edu/~gaeke/; D: Portions of X86 static and JIT compilers; initia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT:2839,portab,portability,2839,interpreter/llvm-project/llvm/CREDITS.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CREDITS.TXT,1,['portab'],['portability']
Modifiability,"ements the ""wwopen"" class of APIs):. $ clang -fsyntax-only t.c; t.c:22:2: warning: type specifier missing, defaults to 'int'; ILPAD();; ^; t.c:17:17: note: expanded from:; #define ILPAD() PAD((NROW - tt.tt_row) * 10) /* 1 ms per char */; ^; t.c:14:2: note: expanded from:; register i; \; ^. In practice, we've found that Clang's treatment of macros is actually more useful in multiply nested; macros than in simple ones.; Quality of Implementation and Attention to Detail; Finally, we have put a lot of work polishing the little things, because; little things add up over time and contribute to a great user experience.; The following example shows that we recover from the simple case of; forgetting a ; after a struct definition much better than GCC. $ cat t.cc; template<class T>; class a {};; struct b {}; a<int> c;; $ gcc-4.9 t.cc; t.cc:4:8: error: invalid declarator before 'c'; a<int> c;; ^; $ clang t.cc; t.cc:3:12: error: expected ';' after struct; struct b {}; ^; ;. The following example shows that we diagnose and recover from a missing; typename keyword well, even in complex circumstances where GCC; cannot cope. $ cat t.cc; template<class T> void f(T::type) { }; struct A { };; void g(); {; A a;; f<A>(a);; }; $ gcc-4.9 t.cc; t.cc:1:33: error: variable or field 'f' declared void; template<class T> void f(T::type) { }; ^; t.cc: In function 'void g()':; t.cc:6:5: error: 'f' was not declared in this scope; f<A>(a);; ^; t.cc:6:8: error: expected primary-expression before '>' token; f<A>(a);; ^; $ clang t.cc; t.cc:1:26: error: missing 'typename' prior to dependent type name 'T::type'; template<class T> void f(T::type) { }; ^~~~~~~; typename ; t.cc:6:5: error: no matching function for call to 'f'; f<A>(a);; ^~~~; t.cc:1:24: note: candidate template ignored: substitution failure [with T = A]: no type named 'type' in 'A'; template<class T> void f(T::type) { }; ^ ~~~~. While each of these details is minor, we feel that they all add up to provide; a much more polished experience. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:10813,variab,variable,10813,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,1,['variab'],['variable']
Modifiability,"ements, not to those of class, function; or other definitions. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; }; while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_WebKit`` (in configuration: ``WebKit``); Like ``Attach``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:51891,config,configuration,51891,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"emicolons after the closing brace of a non-empty function. .. warning::. Setting this option to ``true`` could lead to incorrect code formatting; due to clang-format's lack of complete semantic information. As such,; extra care should be taken to review code changes made by this option. .. code-block:: c++. false: true:. int max(int a, int b) { int max(int a, int b) {; return a > b ? a : b; return a > b ? a : b;; }; }. .. _RequiresClausePosition:. **RequiresClausePosition** (``RequiresClausePositionStyle``) :versionbadge:`clang-format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:104687,config,configuration,104687,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"emove, verify} datasets on a given; PROOF master. See $ROOTSYS/etc/proof/utils/pq2/README for more; information. Improvements. Enable by default schema evolution in TMessage; can be; disabled setting 'Proof.SchemaEvolution:; 0' .; Extend the functionality of the dataset API to obtaine; information on per-server base; add also two new methods:. TProof::SetDataSetTreeName(<dataset>,<treename>):; set/change the default tree name in the TFileCollection;; TProof::ExistsDataSet(<dataset>):; check; by-name the availability of a given dataset;. In ProofBench, . Load the macro before executing it. This allows to; circumvent a problem recently fixed giving less dependency on the; server version.; In make_dset.C, simplification of the body and of the; signature, eliminating one redundant argument. In TProofOutputFile, improve flexibility in defining the; URL for the local files server. The ""LOCALDATASERVER"" env is tested,; which can defined with placeholders via the xpd.putenv directive in the; xrootd/xproofd config files.; Improving parsing of lines with memory info.; This solves occasional crashes while generating the memory; plots.; In TProofMgr::GetSessionLogs:. add the possibility to postpone the retrieval of the; logs files when the TProofLog object is created. This improved; functionality is exploited in the log window.; add decoding of the session starting time and full; information about the master URL. Enable new xrootd configuration options, including the; possibility to set the compiler and linker; Cleanup of the TProofMgr functions DetachSession and; ShutdownSession, and better handling of the internal list registration,; to fix potential segvs when reopening a PROOF session inside the same; ROOT session.; Optimize the way results are transferred and merged:. Output objects are added to the same TMessage until a; HWM is reached (default 1MB; controlled by 'ProofServ.MsgSizeHWM');; this limits the number of transfers in the case of large numbers of; small objects.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:5901,config,config,5901,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['config'],['config']
Modifiability,"en (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing directly the model and the data) the HypoTestInverter; can be configured to use either the frequentist or the hybrid calculator. The user can then configure the class; afterwards. For example set the test statistic to use via the method SetTestStatistic, number of toys to run; for each hypothesis, by retrieving the contained HypoTestCalculator:. HypoTestInverter inverter(obsData, model_B, model_SB, parameterToScan, HypoTestInverter::kFrequentist);; ProfileLikelihoodRatioTestStat profLR( *model_SB->GetPdf() );; inverter.SetTestStatistic(&profLR);; FrequentistCalculator * htcalc = (FrequentistCalculator*) inverter.GetHypoTestCalculator();; htcalc->SetToys( ntoySB, ntoyB);. The Inverter can then run using a fixed grid of npoint between xmin and xmax or by using an automatic scan, where a; bisection algorithm is used.; For running a fixed grid one needs to call SetFixedScan(npoints, xmin, xmax), while for running an autoscan use; the function SetAutoScan. The result is returned in the GetInterval function as an; HypoTestInverterResult ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:4233,config,configured,4233,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['config'],['configured']
Modifiability,"en an object is stored in a split branch; the rule is associtated with the branch of the last of the rule's sources rather; than the last of the object's data member. - Properly support TStreamerInfo written by ROOT v4.00. - Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. ## Networking Libraries. ### HTTP Server. ##### Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call. ##### Custom Properties ; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could 'hide' any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details. ##### Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality. ##### Misc; Correctly set 'Cache-Control' headers when replying to http requests.; Better support of STL containers when converting objects into json with TBufferJSON class. ## JavaScript ROOT. - Several files can now be loaded simultaneously; - Use d3.time.scale to display time scales; - Implemented drag and drop to superimpose histograms or graphs; - Allow selection of drawing option via context menu; - Better support of touch devices; - Provide simple layout, making it default; - Allow to open ROOT files in online session (via url parameter); - One could monitor simultaneously objects from server and root files; - Implement 'autocol' draw option - when superimposing histograms,; their line colors will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:9933,config,configure,9933,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['config'],['configure']
Modifiability,"en developing a; refactoring action. Refactoring engine can be used to implement local refactorings that are; initiated using a selection in an editor or an IDE. You can combine; :doc:`AST matchers<LibASTMatchers>` and the refactoring engine to implement; refactorings that don't lend themselves well to source selection and/or have to; query ASTs for some particular nodes. We assume basic knowledge about the Clang AST. See the :doc:`Introduction; to the Clang AST <IntroductionToTheClangAST>` if you want to learn more; about how the AST is structured. .. FIXME: create new refactoring action tutorial and link to the tutorial. Introduction; ------------. Clang's refactoring engine defines a set refactoring actions that implement; a number of different source transformations. The ``clang-refactor``; command-line tool can be used to perform these refactorings. Certain; refactorings are also available in other clients like text editors and IDEs. A refactoring action is a class that defines a list of related refactoring; operations (rules). These rules are grouped under a common umbrella - a single; ``clang-refactor`` command. In addition to rules, the refactoring action; provides the action's command name and description to ``clang-refactor``.; Each action must implement the ``RefactoringAction`` interface. Here's an; outline of a ``local-rename`` action:. .. code-block:: c++. class LocalRename final : public RefactoringAction {; public:; StringRef getCommand() const override { return ""local-rename""; }. StringRef getDescription() const override {; return ""Finds and renames symbols in code with no indexer support"";; }. RefactoringActionRules createActionRules() const override {; ...; }; };. Refactoring Action Rules; ------------------------. An individual refactoring action is responsible for creating the set of; grouped refactoring action rules that represent one refactoring operation.; Although the rules in one action may have a number of different implementations,; they ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:1327,refactor,refactoring,1327,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],['refactoring']
Modifiability,"en distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: clients will; now; receive a message containing the low level reason for the failure and a; hint for getting more info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4472,plug-in,plug-in,4472,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['plug-in'],['plug-in']
Modifiability,"en geometry is shooting random; points. This can be called with the method; TGeoVolume::RandomPoints() and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. \image html geometry011.png ""Random rays"" width=500px. A ray tracing method can be called TGeoVolume::RandomRays(). This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. \anchor GP04; ## The Drawing Package. \image html geometry012.png. The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:97209,plug-in,plug-in,97209,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['plug-in'],['plug-in']
Modifiability,"en the block is exited with an exception, the pool is not; drained. ``@autoreleasepool`` may be used in non-ARC translation units, with equivalent; semantics. A program is ill-formed if it refers to the ``NSAutoreleasePool`` class. .. admonition:: Rationale. Autorelease pools are clearly important for the compiler to reason about, but; it is far too much to expect the compiler to accurately reason about control; dependencies between two calls. It is also very easy to accidentally forget; to drain an autorelease pool when using the manual API, and this can; significantly inflate the process's high-water-mark. The introduction of a; new scope is unfortunate but basically required for sane interaction with the; rest of the language. Not draining the pool during an unwind is apparently; required by the Objective-C exceptions implementation. .. _arc.misc.externally_retained:. Externally-Retained Variables; -----------------------------. In some situations, variables with strong ownership are considered; externally-retained by the implementation. This means that the variable is; retained elsewhere, and therefore the implementation can elide retaining and; releasing its value. Such a variable is implicitly ``const`` for safety. In; contrast with ``__unsafe_unretained``, an externally-retained variable still; behaves as a strong variable outside of initialization and destruction. For; instance, when an externally-retained variable is captured in a block the value; of the variable is retained and released on block capture and destruction. It; also affects C++ features such as lambda capture, ``decltype``, and template; argument deduction. Implicitly, the implementation assumes that the :ref:`self parameter in a; non-init method <arc.misc.self>` and the :ref:`variable in a for-in loop; <arc.misc.enumeration>` are externally-retained. Externally-retained semantics can also be opted into with the; ``objc_externally_retained`` attribute. This attribute can apply to strong local; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:92032,variab,variables,92032,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"en the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a TGraph which on exit will be filled with the scanned or contour points. ; TH1. Re-implement TH1::Fit using the functions defined in HFitImpl.cxx.; Add new function TH1::Interpolate to approximate the value via linear interpolation. Implementation from Any Mastbaum. ; Fixed a bug in rebinning in a new variable bin histogram.; Fixed a bug in copy constructor of histograms; define now kNstat as an enumeration in the TH1 class, to avoid using wrong values for this constant variable. This fixes a previous bug in TProfile3D; ; TH2. Share a common implementation for (FitSlicesX,FitSclicesY) and (ProfileX, ProfileY) using a common protected method.; Add possibility to be used in the FitPanel (add a TH2::FitPanel() method).; Add also here the new function TH2::Interpolate. ; fix a bug in the resulting statistics in TH2::ProjectionX(Y) when all range was used; fix a bug in getting the right axis and limits in TH2::ProfileX(Y); ; TH3. Add new option ""NUF"" and ""NOF"" in TH3::Project to have excluded the underflow/overflow (they are included by default).; Add option ""UF"" and ""OF"" in TH3::ProjectProfile to include the underflow/overflow. By default they are now excluded while in the previous version they were included. This is consistent with the projection from a TH2.; ; Fixed a bug in TH",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:2729,variab,variable,2729,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['variab'],['variable']
Modifiability,"en they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objective-C; protocol conformance list items into as few lines as possible; whenever they go over ``ColumnLimit``. If ``Always``, always bin-packs Objective-C protocol conformance; list items into as few lines as possible whenever they go over; ``ColumnLimit``. If ``Never``, lays out Objective-C protocol conformance list items; onto individual lines whenever they go over ``ColumnLimit``. .. code-block:: objc. Always (or Auto, if BinPackParameters=true):; @interface ccccccccccccc () <; ccccccccccccc, ccccccccccccc,; ccccccccccccc, ccccccccccccc> {; }. Never (or Auto, if BinPackParameters=false):; @interface ddddddddddddd () <; ddddddddddddd,; ddddddddddddd,; ddddddddddddd,; ddddddddddddd> {; }. Possible values:. * ``BPS_Auto`` (in configuration: ``Auto``); Automatically determine parameter bin-packing behavior. * ``BPS_Always`` (in configuration: ``Always``); Always bin-pack parameters. * ``BPS_Never`` (in configuration: ``Never``); Never bin-pack parameters. .. _ObjCBlockIndentWidth:. **ObjCBlockIndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <ObjCBlockIndentWidth>`; The number of characters to use for indentation of ObjC blocks. .. code-block:: objc. ObjCBlockIndentWidth: 4. [operation setCompletionBlock:^{; [self onOperationDone];; }];. .. _ObjCBreakBeforeNestedBlockParam:. **ObjCBreakBeforeNestedBlockParam** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <ObjCBreakBeforeNestedBlockParam>`; Break parameters list into lines when there is nested block; parameters in a function call. .. code-block:: c++. false:; - (void)_aMethod; {; [self.test1 t:self w:self callback:^(typeof(self) self, NSNumber; *u, NSNumber *v) {; u = c;; }]; }; true:; - (void)_aMethod; {; [self.test1 t:self; w:self; callback:^(typeof(self) self, NSNumber *u, NSNumber *v) {; u = c;; }]; }. .. _ObjCPropertyAttributeOrder:. **ObjCPro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:89173,config,configuration,89173,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"en though there is nothing that specifies the size of the instruction (and; the assembler randomly picks a 32-bit add). Because it is ambiguous, Clang; rejects the instruction with this error message:. <inline asm>:3:1: error: ambiguous instructions require an explicit suffix (could be 'addb', 'addw', 'addl', or 'addq'); add $4, (%rax); ^. To fix this compatibility issue, add an explicit suffix to the instruction:; this makes your code more clear and is compatible with both GCC and Clang. Objective-C compatibility. Cast of super. GCC treats the super identifier as an expression that; can, among other things, be cast to a different type. Clang treats; super as a context-sensitive keyword, and will reject a; type-cast of super:. super.m:11:12: error: cannot cast 'super' (it isn't an expression); [(Super*)super add:4];; ~~~~~~~~^. To fix this problem, remove the type cast, e.g. [super add:4];. Size of interfaces. When using the ""non-fragile"" Objective-C ABI in use, the size of an; Objective-C class may change over time as instance variables are added; (or removed). For this reason, Clang rejects the application of the; sizeof operator to an Objective-C class when using this; ABI:. sizeof.m:4:14: error: invalid application of 'sizeof' to interface 'NSArray' in non-fragile ABI; int size = sizeof(NSArray);; ^ ~~~~~~~~~. Code that relies on the size of an Objective-C class is likely to; be broken anyway, since that size is not actually constant. To address; this problem, use the Objective-C runtime API function; class_getInstanceSize():. class_getInstanceSize([NSArray class]). Internal Objective-C types. GCC allows using pointers to internal Objective-C objects, struct objc_object*,; struct objc_selector*, and struct objc_class* in place of the types; id, SEL, and Class respectively. Clang treats the; internal Objective-C structures as implementation detail and won't do implicit conversions:. t.mm:11:2: error: no matching function for call to 'f'; f((struct objc_object *)p)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:9367,variab,variables,9367,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variables']
Modifiability,"en two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; para",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6270,variab,variable,6270,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"en we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-defined encapsulation symbols ``__start_<section_name>`` and; ``__stop_<section_name>``. It does not have any effect on non-ELF targets. Example:. .. code-block:: text. $a = comdat any; @a = global i32 1, comdat $a; @b = internal global i32 2, comdat $a, section ""abc"", !associated !0; !0 = !{ptr @a}. '``prof``' Metadata; ^^^^^^^^^^^^^^^^^^^. The ``prof`` metadata is used to record profile data in the IR.; The first operand of the metadata node indicates th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318569,variab,variable,318569,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"enable if zlib is found),; and ``FORCE_ON`` (error if zlib is not found). **LLVM_ENABLE_ZSTD**:STRING; Used to decide if LLVM tools should support compression/decompression with; zstd. Allowed values are ``OFF``, ``ON`` (default, enable if zstd is found),; and ``FORCE_ON`` (error if zstd is not found). **LLVM_EXPERIMENTAL_TARGETS_TO_BUILD**:STRING; Semicolon-separated list of experimental targets to build and linked into; llvm. This will build the experimental target without needing it to add to the; list of all the targets available in the LLVM's main CMakeLists.txt. **LLVM_EXTERNAL_{CLANG,LLD,POLLY}_SOURCE_DIR**:PATH; These variables specify the path to the source directory for the external; LLVM projects Clang, lld, and Polly, respectively, relative to the top-level; source directory. If the in-tree subdirectory for an external project; exists (e.g., llvm/tools/clang for Clang), then the corresponding variable; will not be used. If the variable for an external project does not point; to a valid path, then that project will not be built. **LLVM_EXTERNAL_PROJECTS**:STRING; Semicolon-separated list of additional external projects to build as part of; llvm. For each project LLVM_EXTERNAL_<NAME>_SOURCE_DIR have to be specified; with the path for the source code of the project. Example:; ``-DLLVM_EXTERNAL_PROJECTS=""Foo;Bar""; -DLLVM_EXTERNAL_FOO_SOURCE_DIR=/src/foo; -DLLVM_EXTERNAL_BAR_SOURCE_DIR=/src/bar``. **LLVM_EXTERNALIZE_DEBUGINFO**:BOOL; Generate dSYM files and strip executables and libraries (Darwin Only).; Defaults to OFF. **LLVM_FORCE_USE_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler and standard library versions won't be checked. LLVM; may not compile at all, or might fail at runtime due to known bugs in these; toolchains. **LLVM_INCLUDE_BENCHMARKS**:BOOL; Generate build targets for the LLVM benchmarks. Defaults to ON. **LLVM_INCLUDE_EXAMPLES**:BOOL; Generate build targets for the LLVM examples. Defaults to ON. You can use this; option to disable the generat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:27130,variab,variable,27130,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68716,config,configuration,68716,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration']
Modifiability,"endence; -------------------. Kaleidoscope is an example of a ""portable language"": any program written; in Kaleidoscope will work the same way on any target that it runs on.; Many other languages have this property, e.g. lisp, java, haskell,; javascript, python, etc (note that while these languages are portable,; not all their libraries are). One nice aspect of LLVM is that it is often capable of preserving target; independence in the IR: you can take the LLVM IR for a; Kaleidoscope-compiled program and run it on any target that LLVM; supports, even emitting C code and compiling that on targets that LLVM; doesn't support natively. You can trivially tell that the Kaleidoscope; compiler generates target-independent code because it never queries for; any target-specific information when generating code. The fact that LLVM provides a compact, target-independent,; representation for code gets a lot of people excited. Unfortunately,; these people are usually thinking about C or a language from the C; family when they are asking questions about language portability. I say; ""unfortunately"", because there is really no way to make (fully general); C code portable, other than shipping the source code around (and of; course, C source code is not actually portable in general either - ever; port a really old application from 32- to 64-bits?). The problem with C (again, in its full generality) is that it is heavily; laden with target specific assumptions. As one simple example, the; preprocessor often destructively removes target-independence from the; code when it processes the input text:. .. code-block:: c. #ifdef __i386__; int X = 1;; #else; int X = 42;; #endif. While it is possible to engineer more and more complex solutions to; problems like this, it cannot be solved in full generality in a way that; is better than shipping the actual source code. That said, there are interesting subsets of C that can be made portable.; If you are willing to fix primitive types to a fixed si",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:6647,portab,portability,6647,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['portab'],['portability']
Modifiability,"ene Brun, CERN/SFT,\; Philippe Canal, FNAL,\; Olivier Couet, CERN/SFT,\; Gerri Ganis, CERN/SFT,\; Andrei Gheata, CERN/SFT,\; Sergey Linev, GSI, http,\; Pere Mato, CERN/SFT,\; Lorenzo Moneta, CERN/SFT,\; Axel Naumann, CERN/SFT,\; Danilo Piparo, CERN/SFT,\; Fons Rademakers, CERN/SFT,\; Enric Tejedor Saavedra, CERN/SFT,\; Vassil Vassilev, Fermilab/CMS,\; Wouter Verkerke, NIKHEF/Atlas, RooFit. ## Removed interfaces. The following interfaces have been removed, after deprecation in v6.08. ### CINT remnants, dysfunctional for ROOT 6. - `TInterpreter`'s `Getgvp()`, `Getp2f2funcname(void*)`, `Setgvp(Long_t)`, `SetRTLD_NOW()`, `SetRTLD_LAZY()`.; - `SetFCN(void*)` from TVirtualFitter, TFitter, TBackCompFitter, TMinuit; - `TFoam::SetRhoInt(void*)`. ### Core. - The enum constant `TRef::kNotComputed`, `TLink::kObjIsParent` were never used and have been removed.; - The enum constant `TClonesArray::kNoSplit` has not been used since v2.26 and has been removed. ## Interpreter. - Automatic declaration of variables (`h = new TH1F(...)`) is *only* available at the prompt. The side-effects of relying on this in source files is simply too grave. Due to a bug (ROOT-8538), automatically declared variables must currently reside on the top-most scope, i.e. not inside an `if` block etc.; - Improved the stack frame information generated by the JIT. By avoiding interleaving of the memory associated to multiple JIT module, the generation of stack trace involving jitted code and the catching of exception going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:1340,variab,variables,1340,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['variab'],['variables']
Modifiability,"enerally doesn't impact evaluation,; however CMake does have special handling for some variables such as PATH.; You can read more about the special handling in `CMake's set documentation; <https://cmake.org/cmake/help/v3.5/command/set.html#set-cache-entry>`_. Scope; -----. CMake inherently has a directory-based scoping. Setting a variable in a; CMakeLists file, will set the variable for that file, and all subdirectories.; Variables set in a CMake module that is included in a CMakeLists file will be; set in the scope they are included from, and all subdirectories. When a variable that is already set is set again in a subdirectory it overrides; the value in that scope and any deeper subdirectories. The CMake set command provides two scope-related options. PARENT_SCOPE sets a; variable into the parent scope, and not the current scope. The CACHE option sets; the variable in the CMakeCache, which results in it being set in all scopes. The; CACHE option will not set a variable that already exists in the CACHE unless the; FORCE option is specified. In addition to directory-based scope, CMake functions also have their own scope.; This means variables set inside functions do not bleed into the parent scope.; This is not true of macros, and it is for this reason LLVM prefers functions; over macros whenever reasonable. .. note::; Unlike C-based languages, CMake's loop and control flow blocks do not have; their own scopes. Control Flow; ============. CMake features the same basic control flow constructs you would expect in any; scripting language, but there are a few quirks because, as with everything in; CMake, control flow constructs are commands. If, ElseIf, Else; ----------------. .. note::; For the full documentation on the CMake if command go; `here <https://cmake.org/cmake/help/v3.4/command/if.html>`_. That resource is; far more complete. In general CMake if blocks work the way you'd expect:. .. code-block:: cmake. if(<condition>); message(""do stuff""); elseif(<condition>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:6887,variab,variable,6887,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"enerate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note:** this part is not implemented as of Oct 2019. MemTagSanitizer will use :doc:`ScudoHardenedAllocator`; with additional code to update memory tags when. * New memory is obtained from the system.; * An allocation is freed. There is no need to change Allocation Tags for the bulk of the; allocated memory in malloc(), as long as a pointer with the matching; Address Tag is returned. More information; ================. * `LLVM Developer Meeting 2018 talk on Memory Tagging <https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf>`_; * `Memory Tagging Whitepaper <https://arxiv.org/pdf/1802.09517.pdf>`_. .. _Memory Tagging Extension: https://community.arm.com/developer/ip-products",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:2647,variab,variables,2647,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['variab'],['variables']
Modifiability,"eneric`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2703,variab,variables,2703,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,enmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407407,plugin,plugins,407407,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"enough to conclude that along any; particular execution path the number of calls to this function will not be; externally observable. This attribute is only valid on functions; and declarations, not on individual call sites. If a function is; incorrectly marked as speculatable and really does exhibit; undefined behavior, the undefined behavior may be observed even; if the call site is dead code. ``ssp``; This attribute indicates that the function should emit a stack; smashing protector. It is in the form of a ""canary"" --- a random value; placed on the stack before the local variables that's checked upon; return from the function to see if it has been overwritten. A; heuristic is used to determine if a function needs stack protectors; or not. The heuristic used will enable protectors for functions with:. - Character arrays larger than ``ssp-buffer-size`` (default 8).; - Aggregates containing character arrays larger than ``ssp-buffer-size``.; - Calls to alloca() with variable sizes or constant sizes greater than; ``ssp-buffer-size``. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard. If a function with an ``ssp`` attribute is inlined into a calling function,; the attribute is not carried over to the calling function. ``sspstrong``; This attribute indicates that the function should emit a stack smashing; protector. This attribute causes a strong heuristic to be used when; determining if a function needs stack protectors. The strong heuristic; will enable protectors for functions with:. - Arrays of any size and type; - Aggregates containing an array of any size and type.; - Calls to alloca().; - Local variables that have had their address taken. Variables that are identified as requiring a protector will be arranged; on the stack such that they are adjacent to the stack protector guard.; The specific layout rules are:. #. Large arrays and structures containing large arrays; (``>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:103230,variab,variable,103230,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ent and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:8530,config,configured,8530,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configured']
Modifiability,"ent global visualization option; and level, what you need is just call the `Draw()` method of your; interesting volume. You can do this either by interacting with the; expanded tree of volumes in a ROOT browser (where the context menu of; any volume is available), either by getting a pointer to it (e.g. by; name): `gGeoManager->GetVolume(""vol_name"")->Draw();`. \anchor GP04b; ### Visualization Settings and Attributes. Supposing you now understand the basic things to do for drawing the; geometry or parts of it, you still might be not happy and wishing to; have more control on it. We will describe below how you can fine-tune some; settings. Since the corresponding attributes are flags belonging to; volume and node objects, you can change them at any time (even when the; picture is already drawn) and see immediately the result. \anchor GP04ba; #### Colors and Line Styles. We have already described how to change the line colors for volumes. In; fact, volume objects inherit from TAttLine class so the line style or; width can also be changed:. ~~~{.cpp}; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; ~~~. When drawing in solid mode, the color of the drawn volume corresponds to; the line color. \anchor GP04bb; #### Visibility Settings. The way geometry is build forces the definition of several volumes that; does not represent real objects, but just virtual containers used for; grouping and positioning volumes together. One would not want to see; them in the picture. Since every volume is by default visible, one has; to do this sort of tuning by its own:. ~~~{.cpp}; myVolumeContainer->SetVisibility(kFALSE);; ~~~. As described before, the drawing package supports two main global; options: 1 (default) - only final volume leaves; 0 - all volumes down; the drawn one appear on the screen. The global visible level put a; limitation on the maximum applied depth. Combined with visibility; settings per volume, these can tune quite well what",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:102120,inherit,inherit,102120,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['inherit'],['inherit']
Modifiability,"ent is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local computer!; pod://dberzano@cloud-gw-213.to.infn.it [~] >. This she",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9270,config,configuration,9270,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"ent to signal/background: Signal and; background trees can now be assigned individually to training; and test purposes. This is achieved by setting the third; parameter of the Factory::AddSignalTree/AddBackgroundTree(); methods to ""Train"" or ""Test"" (const string). The only; restriction is that either none or all signal (background); trees need to be specified with that option. It is possible to; mix the two modes, for instance one can assign individual; training and test trees for signal, but not for background.; ; Direct tree building: For increased flexibility,; users can also directly input signal and background,; training and test events to TMVA, instead of letting TMVA; interpret user-given trees. Note that either one of the; two approaches must be chosen (no mix). The syntax of the; new calls is described in the macros/TMVAnalysis.C test; macro. --> The User runs the event loop, copies for each; event the input variables into a std:vector, and ""adds""; them to TMVA, using the dedicated calls:; factory->AddSignalTrainingEvent( vars, signalWeight );; (and replacing ""Signal"" by ""Background"", and ""Training"" by; ""Test""). After the event loop, everything continues as in; the standard method.; . Methods:. Simulated Annealing in Cuts,FDA: Entirely new; Simulated Annealing (SA) algorithm for global minimisation; in presence of local minima (optionally used in cut; optimisation (MethodCuts) and the Function Discriminant; (MethodFDA)). The SA algorithm features two approaches,; one starting at minimal temperature (ie, from within a; local minimum), slowly increasing, and another one; starting at high temperature, slowly decreasing into a; minimum. Code developed and written by Kamil Bartlomiej; Kraszewski, Maciej Kruk and Krzysztof Danielowski from IFJ; and AGH/UJ, Krakow, Poland.; ; Cuts: Added printouts, quoting the explicit cut; application for given signal efficiency. In case of; transformations of the input variables, the full expressions; are given. Added warning to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:1206,variab,variables,1206,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['variab'],['variables']
Modifiability,"ent variable ``LIT_OPTS`` after; parsing options from the command line. ``LIT_OPTS`` is primarily useful for; supplementing or overriding the command-line options supplied to :program:`lit`; by ``check`` targets defined by a project's build system. :program:`lit` can also read options from response files which are specified as; inputs using the ``@path/to/file.rsp`` syntax. Arguments read from a file must; be one per line and are treated as if they were in the same place as the; original file referencing argument on the command line. A response file can; reference other response files. Users interested in the :program:`lit` architecture or designing a; :program:`lit` testing implementation should see :ref:`lit-infrastructure`. GENERAL OPTIONS; ---------------. .. option:: -h, --help. Show the :program:`lit` help message. .. option:: -j N, --workers=N. Run ``N`` tests in parallel. By default, this is automatically chosen to; match the number of detected available CPUs. .. option:: --config-prefix=NAME. Search for :file:`{NAME}.cfg` and :file:`{NAME}.site.cfg` when searching for; test suites, instead of :file:`lit.cfg` and :file:`lit.site.cfg`. .. option:: -D NAME[=VALUE], --param NAME[=VALUE]. Add a user defined parameter ``NAME`` with the given ``VALUE`` (or the empty; string if not given). The meaning and use of these parameters is test suite; dependent. .. _output-options:. OUTPUT OPTIONS; --------------. .. option:: -q, --quiet. Suppress any output except for test failures. .. option:: -s, --succinct. Show less output, for example don't show information on tests that pass.; Also show a progress bar, unless ``--no-progress-bar`` is specified. .. option:: -v, --verbose. Show more information on test failures, for example the entire test output; instead of just the test result. Each command is printed before it is executed. This can be valuable for; debugging test failures, as the last printed command is the one that failed.; Moreover, :program:`lit` inserts ``'RUN: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:2580,config,config-prefix,2580,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config-prefix']
Modifiability,ent.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/suppo,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80617,refactor,refactor,80617,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ented as a new plotting option “PARA” in the; `TTree::Draw()method`. To demonstrate how the Parallel Coordinates; works in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97811,variab,variables,97811,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"entptr [128 x i8]* %movetext, i32 0, i32 %172 . ... no stores ...; br i1 %or.cond, label %bb65, label %bb72. bb65: ; preds = %bb62; store i8 0, i8* %173, align 1; br label %bb72. bb72: ; preds = %bb65, %bb62; %trank.1 = phi i32 [ %176, %bb65 ], [ -1, %bb62 ] ; %177 = call i32 @strlen(i8* %movetext11) nounwind readonly align 1. Note that on the bb62->bb72 path, that the %177 strlen call is partially; redundant with the %171 call. At worst, we could shove the %177 strlen call; up into the bb65 block moving it out of the bb62->bb72 path. However, note; that bb65 stores to the string, zeroing out the last byte. This means that on; that path the value of %177 is actually just %171-1. A sub is cheaper than a; strlen!. This pattern repeats several times, basically doing:. A = strlen(P);; P[A-1] = 0;; B = strlen(P);; where it is ""obvious"" that B = A-1. //===---------------------------------------------------------------------===//. 186.crafty has this interesting pattern with the ""out.4543"" variable:. call void @llvm.memcpy.i32(; i8* getelementptr ([10 x i8]* @out.4543, i32 0, i32 0),; i8* getelementptr ([7 x i8]* @""\01LC28700"", i32 0, i32 0), i32 7, i32 1) ; %101 = call@printf(i8* ... @out.4543, i32 0, i32 0)) nounwind . It is basically doing:. memcpy(globalarray, ""string"");; printf(..., globalarray);; ; Anyway, by knowing that printf just reads the memory and forward substituting; the string directly into the printf, this eliminates reads from globalarray.; Since this pattern occurs frequently in crafty (due to the ""DisplayTime"" and; other similar functions) there are many stores to ""out"". Once all the printfs; stop using ""out"", all that is left is the memcpy's into it. This should allow; globalopt to remove the ""stored only"" global. //===---------------------------------------------------------------------===//. This code:. define inreg i32 @foo(i8* inreg %p) nounwind {; %tmp0 = load i8* %p; %tmp1 = ashr i8 %tmp0, 5; %tmp2 = sext i8 %tmp1 to i32; ret i32 %tmp2; }. could ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:41486,variab,variable,41486,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['variab'],['variable']
Modifiability,"entptr float, float addrspace(1)* %A, i32 %id; %ptrB = getelementptr float, float addrspace(1)* %B, i32 %id; %ptrC = getelementptr float, float addrspace(1)* %C, i32 %id. ; Read A, B; %valA = load float, float addrspace(1)* %ptrA, align 4; %valB = load float, float addrspace(1)* %ptrB, align 4. ; Compute C = pow(A, B); %valC = call float @__nv_powf(float %valA, float %valB). ; Store back to C; store float %valC, float addrspace(1)* %ptrC, align 4. ret void; }. !nvvm.annotations = !{!0}; !0 = !{void (float addrspace(1)*,; float addrspace(1)*,; float addrspace(1)*)* @kernel, !""kernel"", i32 1}. To compile this kernel, we perform the following steps:. 1. Link with libdevice; 2. Internalize all but the public kernel function; 3. Run ``NVVMReflect`` and set ``__CUDA_FTZ`` to 0; 4. Optimize the linked module; 5. Codegen the module. These steps can be performed by the LLVM ``llvm-link``, ``opt``, and ``llc``; tools. In a complete compiler, these steps can also be performed entirely; programmatically by setting up an appropriate pass configuration (see; :ref:`libdevice`). .. code-block:: text. # llvm-link t2.bc libdevice.compute_20.10.bc -o t2.linked.bc; # opt -internalize -internalize-public-api-list=kernel -nvvm-reflect-list=__CUDA_FTZ=0 -nvvm-reflect -O3 t2.linked.bc -o t2.opt.bc; # llc -mcpu=sm_20 t2.opt.bc -o t2.ptx. .. note::. The ``-nvvm-reflect-list=_CUDA_FTZ=0`` is not strictly required, as any; undefined variables will default to zero. It is shown here for evaluation; purposes. This gives us the following PTX (excerpt):. .. code-block:: text. //; // Generated by LLVM NVPTX Back-End; //. .version 3.1; .target sm_20; .address_size 64. // .globl kernel; // @kernel; .visible .entry kernel(; .param .u64 kernel_param_0,; .param .u64 kernel_param_1,; .param .u64 kernel_param_2; ); {; .reg .pred %p<30>;; .reg .f32 %f<111>;; .reg .s32 %r<21>;; .reg .s64 %rl<8>;. // %bb.0: // %entry; ld.param.u64 %rl2, [kernel_param_0];; mov.u32 %r3, %tid.x;; ld.param.u64 %rl3, [kernel_param",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:25421,config,configuration,25421,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['config'],['configuration']
Modifiability,"entries in the Index (\< 0 indicates; failure). ## Branches. The organization of branches allows the designer to optimize the data; for the anticipated use. The class for a branch is called **`TBranch`**.; If two variables are independent, and the designer knows the variables; will not be used together, they should be placed on separate branches.; If, however, the variables are related, such as the coordinates of a; point, it is most efficient to create one branch with both coordinates; on it. A variable on a **`TBranch`** is called a leaf (yes -; **`TLeaf`**). Another point to keep in mind when designing trees is that; branches of the same **`TTree`** can be written to separate files. To; add a **`TBranch`** to a **`TTree`** we call the; method **`TTree::Branch()`**. Note that we DO NOT use the `TBranch`; constructor. The `TTree::Branch` method has several signatures. The branch type; differs by what is stored in it. A branch can hold an entire object, a; list of simple variables, contents of a folder, contents of a; **`TList`**, or an array of objects. Let's see some examples. To follow; along you will need the shared library `libEvent.so`. First, check if it; is in `$ROOTSYS/test`. If it is, copy it to your own area. If it is not; there, you have to build it by typing make in `$ROOTSYS/test`. ## Adding a Branch to Hold a List of Variables. As in the very first example (`cernstaff.root.root`); the data we want to save is a list of simple variables, such as integers; or floats. In this case, we use the following `TTree::Branch` signature:. ``` {.cpp}; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; ```. The first parameter is the branch name. The second parameter is the address from which the first variable is to; be read. In the code above, ""event"" is a structure with one float and; three integers and one unsigned integer. You should not assume that the; compiler aligns the elements of a structure without gaps. To avoid; alignment problems,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:18933,variab,variables,18933,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"ents to support; internal multiple selection and highlightning of their sub-parts. Use this in TEveDigitSet and its sub-classes TEveQuadSet and; TEveBoxSet. TEveSecondarySelectable: New secondary base-class for elements; supporting internal multiple selection / highlight.; TEveViewer - Add functions to handle additional mouse-over signals; from TGLViewer.; TEveElement - Add 3 new functions:; virtual TString GetHighlightTooltip();; virtual void UnSelected();; virtual void UnHighlighted();. TEveDigitSet, TEveQuadSet, TEveBoxSet. Sub-class TEveDigitSet from TEveSecondarySelectable.; Implement functions needed for internal selection.; Add common base-class TEveDigitSetGL for quad and box-set GL rendering.; Move anti-flickering controls from TEveQuadSet to TEveDigitSet and; implement it also in TEveBoxSetGL. TEveChunkManager: Add support for restricted iteration.; TEveChunkManager::iterator accepts set<Int_t> for that purpose. TEveElement: Extensions for configurable selection / highlight /; color / transparency propagation between compounds and elements. The; following options can be activated:. ImplySelectAllChildren() - to highlight / imply-select all; children of an compound;; TakeAnyParentAsMaster() - to upwards propagate mouse-selection to; any compound parent;; ApplyMainColorToAllChildren() / ApplyMainColorToMatchingChildren(); to request color propagation to all / matching children of a compound;; ApplyMainTransparencyToAllChildren() / ApplyMainTransparencyToMatchingChildren(); to request transparency propagation to all / matching children of a compound. These flags are stored as bit pattern of CompoundColorSelectionBits enum. TEveElement: propagate transparency to projected replicas. As this; is implemented in the base-class, it works for all projectable classes. TEveVector, TEveVector4 and TEveVector2 are now typedefs to float; specialization of corresponding templates. Double versions use 'D' as; postfix, 'F' postfix is another alias for float versions, e.g.:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:3659,config,configurable,3659,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['config'],['configurable']
Modifiability,"ents`` Whether to align across comments. .. code-block:: c++. true:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; /* A comment. */; default: return """";; }. * ``bool AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:20815,config,configuration,20815,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"enum, function, and record; definitions. .. code-block:: c++. namespace N {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Stroustrup`` (in configuration: ``Stroustrup``); Like ``Attach``, but break before function definitions, ``catch``, and; ``else``. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; }; catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; }; else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Allman`` (in configuration: ``Allman``); Always break before braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Whitesmiths`` (in configuration: ``Whitesmiths``); Like ``Allman`` but always indent braces and line up code with braces. .. code-block:: c++. namespace N; {; enum E; {; E1,; E2,; };. class C; {; public:; C();; };. bool baz(int i); {; try; {; do; {; switch (i); {; case 1:; {; foobar();; break;; }; default:; {; break;; }; }; } while (--i);; return true;; }; catch (...); {; handleError();; return false;; }; }. void foo(bool b); {; if (b); {; baz(2);; }; else; {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_GNU`` (in configura",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:49797,config,configuration,49797,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"enumeration with fixed underlying type; Clang 10. 1602; review; Linkage of specialization vs linkage of template arguments; Not resolved. 1603; CD4; Errors resulting from giving unnamed namespaces internal linkage; Unknown. 1604; C++14; Double temporaries in reference initialization; Unknown. 1605; CD3; Misleading parenthetical comment for explicit destructor call; Unknown. 1606; NAD; sizeof closure class; Unknown. 1607; C++14; Lambdas in template parameters; Unknown. 1608; C++14; Operator lookup in trailing return type; Unknown. 1609; open; Default arguments and function parameter packs; Not resolved. 1610; drafting; Cv-qualification in deduction of reference to array; Not resolved. 1611; C++14; Deleted default constructor for abstract class; Duplicate of 1658. 1612; C++14; Implicit lambda capture and anonymous unions; Unknown. 1613; C++14; Constant expressions and lambda capture; Unknown. 1614; CD4; Address of pure virtual function vs odr-use; Unknown. 1615; CD4; Alignment of types, variables, and members; Unknown. 1616; CD6; Disambiguation parsing and template parameters; Unknown. 1617; open; alignas and non-defining declarations; Not resolved. 1618; C++14; Gratuitously-unsigned underlying enum type; Unknown. 1619; open; Definition of current instantiation; Not resolved. 1620; open; User-defined literals and extended integer types; Not resolved. 1621; C++20; Member initializers in anonymous unions; Unknown. 1622; C++17; Empty aggregate initializer for union; Unknown. 1623; drafting; Deleted default union constructor and member initializers; Not resolved. 1624; NAD; Destruction of union members with member initializers; Unknown. 1625; open; Adding spaces between tokens in stringizing; Not resolved. 1626; open; constexpr member functions in brace-or-equal-initializers; Not resolved. 1627; NAD; Agreement of dependent alignas specifiers; Unknown. 1628; open; Deallocation function templates; Not resolved. 1629; C++14; Can a closure class be a literal type?; Unknown. 1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:109025,variab,variables,109025,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"eoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; ```. ### GDML. Few lines above word GDML was used. GDML stands for **G**eometry; **D**escription **M**arkup **L**anguage. It is an application-independent; geometry description format based on XML. It is mainly used for geometry; interchange between ROOT and Geant4 framework. More details about this; project can be found http://gdml.web.cern.ch. This feature; (importing/exporting from/to gdml file format) is disabled by default in; ROOT installation. To enable this feature add `--enable-gdml` option to; `./configure` script call. ## Navigation Algorithms. This section will describe the main methods and algorithms used for; implementing the navigation features within the geometrical modeller.; This includes navigation queries at shape level, global geometrical; queries and optimization mechanisms. ### Finding the State Corresponding to a Location (x,y,z). For reminder, a geometry state is a ‘touchable' object in the geometry; hierarchy. It is represented by a path like: **/TOP\_1/A\_1/B\_3/C\_1**,; where **B\_3** for instance is a copy of volume **B** positioned inside; volume **A**. A state is always associated to a transformation matrix; **M** of the touchable with respect to the global reference frame; (obtained by piling-up all local transformations of nodes in the branch; with respect to their containers). The current state and the; corresponding global matrix are updated whenever the geometry depth is; modified. The global transformations corresponding to all nodes in the; current branch are k",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:154492,config,configure,154492,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['config'],['configure']
Modifiability,"eoretically have ``.get()``-ed above and the code; could of course break the uniqueness invariant (though we'd probably want it).; The checker can say that ""even if ``*a`` did escape, it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13602,variab,variables,13602,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"eparsed or unserialized. Improve parser reliability and error generation by automatically; or randomly changing the input checking that clang doesn't crash and; that it doesn't generate excessive errors for small input; changes. Manipulating the input at both the text and token levels is; likely to produce interesting test cases. Continue work on C++20, C++23, C++2c, and C23 support:; There are still several C++20 features to complete, and work has begun on; supporting the latest language standards. Please see the; C++ status report page to find out what is; missing.; StringRef'ize APIs: A thankless but incredibly useful project is; StringRef'izing (converting to use llvm::StringRef instead of const; char * or std::string) various clang interfaces. This generally; simplifies the code and makes it more efficient.; Configuration Manager: Clang/LLVM works on a large number of; architectures and operating systems and can cross-compile to a similarly large; number of configurations, but the pitfalls of choosing the command-line; options, making sure the right sub-architecture is chosen and that the correct; optional elements of your particular system can be a pain. A tool that would investigate hosts and targets, and store the configuration; in files that can later be used by Clang itself to avoid command-line options,; especially the ones regarding which target options to use, would greatly alleviate; this problem. A simple tool, with little or no dependency on LLVM itself, that; will investigate a target architecture by probing hardware, software, libraries; and compiling and executing code to identify all properties that would be relevant; to command-line options (VFP, SSE, NEON, ARM vs. Thumb etc), triple settings etc.; The first stage is to build a CFLAGS for Clang that would produce code on the; current Host to the identified Target.; The second stage would be to produce a configuration file (that can be used; independently of the Host) so that Clang can read it and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html:5490,config,configurations,5490,interpreter/llvm-project/clang/www/OpenProjects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/OpenProjects.html,1,['config'],['configurations']
Modifiability,"ependencies with pyproject.toml; * Simplified flow of pointer types for callbacks and cross-derivation; * Pointer-comparing objects performs auto-cast as needed; * Add main dimension for ptr-ptr to builtin returns; * Transparant handling of ptr-ptr to instance returns; * Stricter handling of bool type in overload with int types; * Fix uint64_t template instantiation regression; * Do not filter out enum data for ``__dir__``; * Fix lookup of interpreter-only explicit instantiations; * Fix inconsistent naming of std types with char_traits; * Further hiding of upstream code/dependencies; * Extended documentation. 2020-07-12: 1.8.0; -----------------. * Support mixing of Python and C++ types in global operators; * Capture Cling error messages from cppdef and include in the Python exception; * Add a cppexec method to evalutate statements in Cling's global scope; * Support initialization of ``std::array<>`` from sequences; * Support C++17 style initialization of common STL containers; * Allow base classes with no virtual destructor (with warning); * Support const by-value returns in Python-side method overrides; * Support for cross-language multiple inheritance of C++ bases; * Allow for pass-by-value of ``std::unique_ptr`` through move; * Reduced dependencies on upstream code; * Put remaining upstream code in CppyyLegacy namespace. 2020-06-06: 1.7.1; -----------------. * Expose protected members in Python derived classes; * Support for deep Python-side derived hierarchies; * Do not generate a copy ctor in the Python derived class if private; * include, c_include, and cppdef now raise exceptions on error; * Allow mixing of keywords and default values; * Fix by-ptr return of objects in Python derived classes; * Fix for passing numpy boolean array through ``bool*``; * Fix assignment to ``const char*`` data members; * Support ``__restrict`` and ``__restrict__`` in interfaces; * Allow passing sequence of strings through ``const char*[]`` argument. 2020-04-27: 1.7.0; -----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:12309,inherit,inheritance,12309,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['inherit'],['inheritance']
Modifiability,"equires much less memory. Merging in; one-go (the previous default) can be activated by passing 'H' in the; constructor options.; In ProofBench, add possibility to change the location of the; generated files via the third argument of TProofBench::MakeDataSet.; Several optimizations in the low level PROOF event loop; (TProofPlayer::Process),  allowing to reduce dramatically the; overhead introduced by the operations PROOF needs to perform during the; event loop. A measurement of the overhead can be obtained from a very; light computational task, for example, generating one random number and; filling one histogram; executing this task within a PROOF-Lite session; with 1 worker now takes only 1.8 times the time required by a straight; loop in the parent ROOT session; the same number before was about 13. ; In TDrawFeedback::Feedback, call method Draw() of objects not; identified as TH1 derivation. This allows user-defined objects; implementing Draw to be displayed via this utility class.; In TProof::LoadPackageOnClient, do not create a symlink; 'pack_name' to the package dir, but add directly the package dir to the; include path. This solves the longstanding annoying problem of failure; when a directory or file with the name of the package did already exist; in the local working directory. . Fixes; ; Fix merging issue affecting automatic dataset creation when; only one worker is active.; Fix the realtime reported by TProof::GetRealTime() for masters; (it was overwritten with the ones coming from workers).; Fix serious problem with TProof::Load: additional files were; not copied in the master sandbox but left in the cache. A workaround; for backward compatibility has also been implemented.; Fix a problem preventing actions requiring access to worker; nodes (log file retrieval, reset) to work on workers where the username; is different from the one o the master, e.g. PoD on gLite.; Fix issue with the specification of the working directory; template in 'xpd.multiuser'.; . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html:4783,sandbox,sandbox,4783,proof/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v534/index.html,1,['sandbox'],['sandbox']
Modifiability,"er PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR type as; what the pass runs on. For example, a function pass receives an analysis; manager that only provid",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6668,plugin,plugin,6668,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['plugin'],['plugin']
Modifiability,"er arguments, will; pass the rest as decomposed stack elements? But an argument that will not start; in registers will not be decomposed and will be passed as a non-decomposed; stack value?. The following is not part of the AMDGPU function calling convention but; describes how the AMDGPU implements function calls:. 1. SGPR33 is used as a frame pointer (FP) if necessary. Like the SP it is an; unswizzled scratch address. It is only needed if runtime sized ``alloca``; are used, or for the reasons defined in ``SIFrameLowering``.; 2. Runtime stack alignment is supported. SGPR34 is used as a base pointer (BP); to access the incoming stack arguments in the function. The BP is needed; only when the function requires the runtime stack alignment. 3. Allocating SGPR arguments on the stack are not supported. 4. No CFI is currently generated. See; :ref:`amdgpu-dwarf-call-frame-information`. .. note::. CFI will be generated that defines the CFA as the unswizzled address; relative to the wave scratch base in the unswizzled private address space; of the lowest address stack allocated local variable. ``DW_AT_frame_base`` will be defined as the swizzled address in the; swizzled private address space by dividing the CFA by the wavefront size; (since CFA is always at least dword aligned which matches the scratch; swizzle element size). If no dynamic stack alignment was performed, the stack allocated arguments; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:398689,variab,variable,398689,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variable']
Modifiability,"er be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; commen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135836,flexible,flexible,135836,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['flexible'],['flexible']
Modifiability,"er calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124627,variab,variable,124627,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['variab'],['variable']
Modifiability,"er classes require `mathjax` option in URL; - Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE. ## TTree Libraries. ### TTree Behavior change. #### Merging. Added fast cloning support to TTree::MergeTrees and TTree::Merge(TCollection*,Option_t*). #### TTreeCache. The TTreeCache is now enabled by default. The default size of the TTreeCache; is the estimated size of a cluster size for the TTree. The TTreeCache; prefilling is also enabled by default; when in learning phase rather than; reading each requested branch individually, the TTreeCache will read all the; branches thus trading off the latencies inherent to multiple small reads for; the potential of requesting more data than needed by read from the disk or; server the baskets for too many branches. The default behavior can be changed by either updating one of the rootrc files; or by setting environment variables. The rootrc files, both the global and the; local ones, now support the following the resource variable TTreeCache.Size; which set the default size factor for auto sizing TTreeCache for TTrees. The; estimated cluster size for the TTree and this factor is used to give the cache; size. If option is set to zero auto cache creation is disabled and the default; cache size is the historical one (equivalent to factor 1.0). If set to; non zero auto cache creation is enabled and both auto created and; default sized caches will use the configured factor: 0.0 no automatic cache; and greater than 0.0 to enable cache. This value can be overridden by the; environment variable ROOT_TTREECACHE_SIZE. The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling; type. The prefill type may be: 0 for no prefilling and 1 to prefill all; the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL. In particular the default can be set back to the same as in version 5 by; setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:13258,variab,variable,13258,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['variab'],['variable']
Modifiability,"er not on the list or are used to refer to a different type should be; expanded. ============================ =============; Class name Variable name; ============================ =============; DeterministicFiniteAutomaton dfa; DominatorTree dt; LoopInfo li; MachineFunction mf; MachineInstr mi; MachineRegisterInfo mri; ScalarEvolution se; TargetInstrInfo tii; TargetLibraryInfo tli; TargetRegisterInfo tri; ============================ =============. In some cases renaming acronyms to the full type name will result in overly; verbose code. Unlike most classes, a variable's scope is limited and therefore; some of its purpose can implied from that scope, meaning that fewer words are; necessary to give it a clear name. For example, in an optimization pass the reader; can assume that a variable's purpose relates to optimization and therefore an; ``OptimizationRemarkEmitter`` variable could be given the name ``remarkEmitter``; or even ``remarker``. The following is a list of longer class names and the associated shorter; variable name. ========================= =============; Class name Variable name; ========================= =============; BasicBlock block; ConstantExpr expr; ExecutionEngine engine; MachineOperand operand; OptimizationRemarkEmitter remarker; PreservedAnalyses analyses; PreservedAnalysesChecker checker; TargetLowering lowering; TargetMachine machine; ========================= =============. Transition Options; ==================. There are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [BradburyConcern]_.; The costs are that ``git blame`` will become less usable; and that merging the; changes will be costly for downstream maintainers. See `Big bang`_ f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:6913,variab,variable,6913,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"er overflows on the unsafe stack cannot be used to overwrite anything; on the safe stack. SafeStack is a part of the `Code-Pointer Integrity (CPI) Project; <https://dslab.epfl.ch/research/cpi/>`_. Performance; -----------. The performance overhead of the SafeStack instrumentation is less than 0.1% on; average across a variety of benchmarks (see the `Code-Pointer Integrity; <https://dslab.epfl.ch/pubs/cpi.pdf>`__ paper for details). This is mainly; because most small functions do not have any variables that require the unsafe; stack and, hence, do not need unsafe stack frames to be created. The cost of; creating unsafe stack frames for large functions is amortized by the cost of; executing the function. In some cases, SafeStack actually improves the performance. Objects that end up; being moved to the unsafe stack are usually large arrays or variables that are; used through multiple stack frames. Moving such objects away from the safe; stack increases the locality of frequently accessed values on the stack, such; as register spills, return addresses, and small local variables. Compatibility; -------------. Most programs, static libraries, or individual files can be compiled; with SafeStack as is. SafeStack requires basic runtime support, which, on most; platforms, is implemented as a compiler-rt library that is automatically linked; in when the program is compiled with SafeStack. Linking a DSO with SafeStack is not currently supported. Known compatibility limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Certain code that relies on low-level stack manipulations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:1641,variab,variables,1641,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['variab'],['variables']
Modifiability,"er return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Always break after the return type of function definitions. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int f();; int; f() {; return 1;; }. * ``RTBS_TopLevelDefinitions`` (in configuration: ``TopLevelDefinitions``); Always break after the return type of top-level definitions. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int; f() {; return 1;; }. .. _AlwaysBreakBeforeMultilineStrings:. **AlwaysBreakBeforeMultilineStrings** (``Boolean``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakBeforeMultilineStrings>`; If ``true``, always break before multiline string literals. This flag is mean to make cases where there are multiple multiline strings; in a file look more consistent. Thus, it will only take effect if wrapping; the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:33550,config,configuration,33550,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"er than of generating these functions on the; fly, your only other option is to place these functions in a separate header; file and make them inline. Theoretically, multiple header files can also be used and then mashed; together. > Directory path: [roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h](https://github.com/root-project/root/blob/master/roofit/roofitcore/inc/RooFit/Detail/MathFuncs.h). ### Step 2. Override RooAbsArg::translate(). **translate() Example 1:** Continuing our RooPoisson example:. To translate the `RooPoisson` class, create a translate function and in it; include a call to the updated function. ``` {.cpp}; void RooPoisson::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding); xName = ""std::floor("" + xName + "")"";; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::poissonEvaluate"", xName, mean));; }; ```. Here we can see that the name of the variable `x` (remember that ""x"" is a; member of RooPoisson) is retrieved and stored in the `xName` variable. Next,; there's an `if` condition that does an operation on `x` (may or may not round; it to the nearest integer, depending on the condition). The important part is where the `RooPoisson::addResult()` function helps add; the result of evaluating the Poisson function to the context (`ctx`). It uses; the `RooPoisson::buildCall()` method to construct a function call to the fully; qualified name of `MathFuncs::poissonEvaluate` (which now resides in the; `MathFuncs` file), with arguments `xName` and `mean`. Essentially, the `RooPoisson::translate()` function constructs a function call; to evaluate the Poisson function using 'x' and 'mean' variables, and adds the; result to the context. Helper Functions:. - `getResult()` helps lookup the result of a child node (the string that the; child node previously saved in a variable using the `addResult()` function). - `addResult()` It may include a function call, an expression, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:12554,variab,variable,12554,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,['variab'],['variable']
Modifiability,"er the logical not operator (``!``). .. code-block:: c++. true: false:; ! someExpression(); vs. !someExpression();. .. _SpaceAfterTemplateKeyword:. **SpaceAfterTemplateKeyword** (``Boolean``) :versionbadge:`clang-format 4` :ref:`¶ <SpaceAfterTemplateKeyword>`; If ``true``, a space will be inserted after the 'template' keyword. .. code-block:: c++. true: false:; template <int> void foo(); vs. template<int> void foo();. .. _SpaceAroundPointerQualifiers:. **SpaceAroundPointerQualifiers** (``SpaceAroundPointerQualifiersStyle``) :versionbadge:`clang-format 12` :ref:`¶ <SpaceAroundPointerQualifiers>`; Defines in which cases to put a space before or after pointer qualifiers. Possible values:. * ``SAPQ_Default`` (in configuration: ``Default``); Don't ensure spaces around pointer qualifiers and use PointerAlignment; instead. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Before`` (in configuration: ``Before``); Ensure that there is a space before pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const* x = NULL; vs. void * const *x = NULL;. * ``SAPQ_After`` (in configuration: ``After``); Ensure that there is a space after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void *const *x = NULL;. * ``SAPQ_Both`` (in configuration: ``Both``); Ensure that there is a space both before and after pointer qualifiers. .. code-block:: c++. PointerAlignment: Left PointerAlignment: Right; void* const * x = NULL; vs. void * const *x = NULL;. .. _SpaceBeforeAssignmentOperators:. **SpaceBeforeAssignmentOperators** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpaceBeforeAssignmentOperators>`; If ``false``, spaces will be removed before assignment operators. .. code-block:: c++. true: false:; int a = 5; vs. int a= 5;; a += 42; a+= 42;. .. _SpaceBeforeCaseColon:. **SpaceBeforeCaseColon** (``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:113615,config,configuration,113615,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"er') to break the input up into ""tokens"". Each token returned by; the lexer includes a token code and potentially some metadata (e.g. the; numeric value of a number). First, we define the possibilities:. .. code-block:: c++. // The lexer returns tokens [0-255] if it is an unknown character, otherwise one; // of these for known things.; enum Token {; tok_eof = -1,. // commands; tok_def = -2,; tok_extern = -3,. // primary; tok_identifier = -4,; tok_number = -5,; };. static std::string IdentifierStr; // Filled in if tok_identifier; static double NumVal; // Filled in if tok_number. Each token returned by our lexer will either be one of the Token enum; values or it will be an 'unknown' character like '+', which is returned; as its ASCII value. If the current token is an identifier, the; ``IdentifierStr`` global variable holds the name of the identifier. If; the current token is a numeric literal (like 1.0), ``NumVal`` holds its; value. We use global variables for simplicity, but this is not the; best choice for a real language implementation :). The actual implementation of the lexer is a single function named; ``gettok``. The ``gettok`` function is called to return the next token; from standard input. Its definition starts as:. .. code-block:: c++. /// gettok - Return the next token from standard input.; static int gettok() {; static int LastChar = ' ';. // Skip any whitespace.; while (isspace(LastChar)); LastChar = getchar();. ``gettok`` works by calling the C ``getchar()`` function to read; characters one at a time from standard input. It eats them as it; recognizes them and stores the last character read, but not processed,; in LastChar. The first thing that it has to do is ignore whitespace; between tokens. This is accomplished with the loop above. The next thing ``gettok`` needs to do is recognize identifiers and; specific keywords like ""def"". Kaleidoscope does this with this simple; loop:. .. code-block:: c++. if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst:3149,variab,variables,3149,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.rst,1,['variab'],['variables']
Modifiability,"er(nullptr /*Dump to stdout.*/,; this->ASTDumpFilter);; if (this->ASTPrint.operator _Bool()); return clang::CreateASTPrinter(&llvm::outs(), this->ASTDumpFilter);; return new clang::ASTConsumer();; }. Using Ninja Build System; =======================================. Optionally you can use the `Ninja`_ build system instead of make. It is; aimed at making your builds faster. Currently this step will require; building Ninja from sources. To take advantage of using Clang Tools along with Ninja build you need; at least CMake 2.8.9. Clone the Ninja git repository and build Ninja from sources:. .. code-block:: console. $ git clone git://github.com/martine/ninja.git; $ cd ninja/; $ ./bootstrap.py. This will result in a single binary ``ninja`` in the current directory.; It doesn't require installation and can just be copied to any location; inside ``$PATH``, say ``/usr/local/bin/``:. .. code-block:: console. $ sudo cp ninja /usr/local/bin/; $ sudo chmod a+rx /usr/local/bin/ninja. After doing all of this, you'll need to generate Ninja build files for; LLVM with CMake. You need to make a build directory and run CMake from; it:. .. code-block:: console. $ mkdir your/build/directory; $ cd your/build/directory; $ cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. If you want to use clang instead of GCC, you can add; ``-DCMAKE_C_COMPILER=/path/to/clang -DCMAKE_CXX_COMPILER=/path/to/clang++``.; You can also use ``ccmake``, which provides a curses interface to configure; CMake variables in an interactive manner. As a result, the new ``compile_commands.json`` file should appear in the; current directory. You should link it to the LLVM source tree so that; Clang Tooling is able to use it:. .. code-block:: console. $ ln -s $PWD/compile_commands.json path/to/llvm/source/. Now you are ready to build and test LLVM using Ninja:. .. code-block:: console. $ ninja check-all. Other target names can be used in the same way as with make. .. _Ninja: https://ninja-build.org/; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:8963,config,configure,8963,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,2,"['config', 'variab']","['configure', 'variables']"
Modifiability,"er, there might not exist a; sufficient substitution order. To address such use cases, lit configuration files support; ``config.recursiveExpansionLimit``, which can be set to a non-negative integer; to specify the maximum number of passes through the substitution list. Thus, in; the above example, setting the limit to 2 would cause lit to make a second pass; that expands ``%{inner}`` in the ``RUN:`` line, and the output from the ``echo``; command when then be:. .. code-block:: shell. expanded. To improve performance, lit will stop making passes when it notices the ``RUN:``; line has stopped changing. In the above example, setting the limit higher than; 2 is thus harmless. To facilitate debugging, after reaching the limit, lit will make one extra pass; and report an error if the ``RUN:`` line changes again. In the above example,; setting the limit to 1 will thus cause lit to report an error instead of; producing incorrect output. Options; -------. The llvm lit configuration allows to customize some things with user options:. ``llc``, ``opt``, ...; Substitute the respective llvm tool name with a custom command line. This; allows to specify custom paths and default arguments for these tools.; Example:. % llvm-lit ""-Dllc=llc -verify-machineinstrs"". ``run_long_tests``; Enable the execution of long running tests. ``llvm_site_config``; Load the specified lit configuration instead of the default one. Other Features; --------------. To make RUN line writing easier, there are several helper programs. These; helpers are in the PATH when running tests, so you can just call them using; their name. For example:. ``not``; This program runs its arguments and then inverts the result code from it.; Zero result codes become 1. Non-zero result codes become 0. To make the output more useful, :program:`lit` will scan; the lines of the test case for ones that contain a pattern that matches; ``PR[0-9]+``. This is the syntax for specifying a PR (Problem Report) number; that is related to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:37723,config,configuration,37723,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"er->CreateFCmpULT(L, R, ""cmptmp"");; // Convert bool 0/1 to double 0.0 or 1.0; return Builder->CreateUIToFP(L, Type::getDoubleTy(TheContext),; ""booltmp"");; default:; return LogErrorV(""invalid binary operator"");; }; }. Binary operators start to get more interesting. The basic idea here is; that we recursively emit code for the left-hand side of the expression,; then the right-hand side, then we compute the result of the binary; expression. In this code, we do a simple switch on the opcode to create; the right LLVM instruction. In the example above, the LLVM builder class is starting to show its; value. IRBuilder knows where to insert the newly created instruction,; all you have to do is specify what instruction to create (e.g. with; ``CreateFAdd``), which operands to use (``L`` and ``R`` here) and; optionally provide a name for the generated instruction. One nice thing about LLVM is that the name is just a hint. For instance,; if the code above emits multiple ""addtmp"" variables, LLVM will; automatically provide each one with an increasing, unique numeric; suffix. Local value names for instructions are purely optional, but it; makes it much easier to read the IR dumps. `LLVM instructions <../../LangRef.html#instruction-reference>`_ are constrained by strict; rules: for example, the Left and Right operands of an `add; instruction <../../LangRef.html#add-instruction>`_ must have the same type, and the; result type of the add must match the operand types. Because all values; in Kaleidoscope are doubles, this makes for very simple code for add,; sub and mul. On the other hand, LLVM specifies that the `fcmp; instruction <../../LangRef.html#fcmp-instruction>`_ always returns an 'i1' value (a; one bit integer). The problem with this is that Kaleidoscope wants the; value to be a 0.0 or 1.0 value. In order to get these semantics, we; combine the fcmp instruction with a `uitofp; instruction <../../LangRef.html#uitofp-to-instruction>`_. This instruction converts its; input intege",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:7701,variab,variables,7701,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"er. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/maste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7835,variab,variables,7835,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['variab'],['variables']
Modifiability,"er/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer types are a work in progress, and they should be; considered experimental at this time. LLVM IR optionally allows the frontend to denote poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27293,variab,variable,27293,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"er<UserDefinedLiteral>...; Matches user defined literal operator call. Example match: ""foo""_suffix. Matcher<Stmt>whileStmtMatcher<WhileStmt>...; Matches while statements. Given; while (true) {}; whileStmt(); matches 'while (true) {}'. Matcher<TemplateArgumentLoc>templateArgumentLocMatcher<TemplateArgumentLoc>...; Matches template arguments (with location info). Given; template <typename T> struct C {};; C<int> c;; templateArgumentLoc(); matches 'int' in C<int>. Matcher<TemplateArgument>templateArgumentMatcher<TemplateArgument>...; Matches template arguments. Given; template <typename T> struct C {};; C<int> c;; templateArgument(); matches 'int' in C<int>. Matcher<TemplateName>templateNameMatcher<TemplateName>...; Matches template name. Given; template <typename T> class X { };; X<int> xi;; templateName(); matches 'X' in X<int>. Matcher<TypeLoc>elaboratedTypeLocMatcher<ElaboratedTypeLoc>...; Matches C or C++ elaborated `TypeLoc`s. Given; struct s {};; struct s ss;; elaboratedTypeLoc(); matches the `TypeLoc` of the variable declaration of `ss`. Matcher<TypeLoc>pointerTypeLocMatcher<PointerTypeLoc>...; Matches pointer `TypeLoc`s. Given; int* x;; pointerTypeLoc(); matches `int*`. Matcher<TypeLoc>qualifiedTypeLocMatcher<QualifiedTypeLoc>...; Matches `QualifiedTypeLoc`s in the clang AST. Given; const int x = 0;; qualifiedTypeLoc(); matches `const int`. Matcher<TypeLoc>referenceTypeLocMatcher<ReferenceTypeLoc>...; Matches reference `TypeLoc`s. Given; int x = 3;; int& l = x;; int&& r = 3;; referenceTypeLoc(); matches `int&` and `int&&`. Matcher<TypeLoc>templateSpecializationTypeLocMatcher<TemplateSpecializationTypeLoc>...; Matches template specialization `TypeLoc`s. Given; template <typename T> class C {};; C<char> var;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(typeLoc()))); matches `C<char> var`. Matcher<TypeLoc>typeLocMatcher<TypeLoc>...; Matches TypeLocs in the clang AST. Matcher<Type>arrayTypeMatcher<ArrayType>...; Matches all kinds of arrays. Given; int a[] = { ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:43858,variab,variable,43858,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"erOffset / HashValueBufferLength** - The offset and size within; the TPI Hash Stream of the list of hash values. It should be assumed that; there are either 0 hash values, or a number equal to the number of type; records in the TPI stream (``TypeIndexEnd - TypeEndBegin``). Thus, if; ``HashBufferLength`` is not equal to ``(TypeIndexEnd - TypeEndBegin) *; HashKeySize`` we can consider the PDB malformed. - **IndexOffsetBufferOffset / IndexOffsetBufferLength** - The offset and size; within the TPI Hash Stream of the Type Index Offsets Buffer. This is a list; of pairs of uint32_t's where the first value is a :ref:`Type Index; <type_indices>` and the second value is the offset in the type record data of; the type with this index. This can be used to do a binary search followed by; a linear search to get O(log n) lookup by type index. - **HashAdjBufferOffset / HashAdjBufferLength** - The offset and size within; the TPI hash stream of a serialized hash table whose keys are the hash values; in the hash value buffer and whose values are type indices. This appears to; be useful in incremental linking scenarios, so that if a type is modified an; entry can be created mapping the old hash value to the new type index so that; a PDB file consumer can always have the most up to date version of the type; without forcing the incremental linker to garbage collect and update; references that point to the old version to now point to the new version.; The layout of this hash table is described in :doc:`HashTable`. .. _tpi_records:. CodeView Type Record List; =========================; Following the header, there are ``TypeRecordBytes`` bytes of data that; represent a variable length array of :doc:`CodeView type records; <CodeViewTypes>`. The number of such records (e.g. the length of the array); can be determined by computing the value ``Header.TypeIndexEnd -; Header.TypeIndexBegin``. O(log(n)) access is provided by way of the Type Index Offsets array (if; present) described previously.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:11475,variab,variable,11475,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['variab'],['variable']
Modifiability,"eration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template constructors of the Rotation classes, taking as input any other type; of rotation are missing. Therefore code like the following one will now work in CINT (or Python):. ROOT::Math::Rotation3D r;; ROOT::Math::EulerAngles eulerRot(r);. A possible solution is to use the operator=:. ROOT::Math::EulerAngles eulerRot; eulerRot = r;. In addition the setter methods for the 2D,3D and 4D vector classes have been extended following a suggestion by G. Raven. Functions like SetX instead of returning a void return now a reference to the vector class itself (*this).; Detailed description of the current GenVector release can be found at this location. SMatrix; Fix a bug discovered by Harals Soleng in the addition of two matrix expressions. Remove also some compilation warning found on Windows when compiling matrices instantiated using float types.; Detailed description of the current SMatrix release can be found at this location. Minuit; Two new classes have been added:; ; TMinuitMinimizer: implementation of the ROOT::Math::Minimizer interface with TMinuit. This class is used for example by the new Fitter class.; TLinearMinimizer: implementation of the ROOT::Math::Minimizer interface with the TLinearFitter.; ; In addition, the method TLinearFitter::SetBasisFunction(TObjArray * f) has been added to set directly the linear terms of the fit function. Minuit2. Various fixes have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:11839,extend,extended,11839,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['extend'],['extended']
Modifiability,"erative collectors. * reference counting. We hope that the support built into the LLVM IR is sufficient to support a; broad class of garbage collected languages including Scheme, ML, Java, C#,; Perl, Python, Lua, Ruby, other scripting languages, and more. Note that LLVM **does not itself provide a garbage collector** --- this should; be part of your language's runtime library. LLVM provides a framework for; describing the garbage collectors requirements to the compiler. In particular,; LLVM provides support for generating stack maps at call sites, polling for a; safepoint, and emitting load and store barriers. You can also extend LLVM -; possibly through a loadable :ref:`code generation plugins <plugin>` - to; generate code and data structures which conforms to the *binary interface*; specified by the *runtime library*. This is similar to the relationship between; LLVM and DWARF debugging info, for example. The difference primarily lies in; the lack of an established standard in the domain of garbage collection --- thus; the need for a flexible extension mechanism. The aspects of the binary interface with which LLVM's GC support is; concerned are:. * Creation of GC safepoints within code where collection is allowed to execute; safely. * Computation of the stack map. For each safe point in the code, object; references within the stack frame must be identified so that the collector may; traverse and perhaps update them. * Write barriers when storing object references to the heap. These are commonly; used to optimize incremental scans in generational collectors. * Emission of read barriers when loading object references. These are useful; for interoperating with concurrent collectors. There are additional areas that LLVM does not directly address:. * Registration of global roots with the runtime. * Registration of stack map entries with the runtime. * The functions used by the program to allocate memory, trigger a collection,; etc. * Computation or compilation of type m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:6415,flexible,flexible,6415,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['flexible'],['flexible']
Modifiability,"erator Examples; ===================================. Here is an example illustrating the use of the paste operator in record names. .. code-block:: text. defvar suffix = ""_suffstring"";; defvar some_ints = [0, 1, 2, 3];. def name # suffix {; }. foreach i = [1, 2] in {; def rec # i {; }; }. The first ``def`` does not use the value of the ``suffix`` variable. The; second def does use the value of the ``i`` iterator variable, because it is not a; global name. The following records are produced. .. code-block:: text. def namesuffix {; }; def rec1 {; }; def rec2 {; }. Here is a second example illustrating the paste operator in field value expressions. .. code-block:: text. def test {; string strings = suffix # suffix;; list<int> integers = some_ints # [4, 5, 6];; }. The ``strings`` field expression uses ``suffix`` on both sides of the paste; operator. It is evaluated normally on the left hand side, but taken verbatim; on the right hand side. The ``integers`` field expression uses the value of; the ``some_ints`` variable and a literal list. The following record is; produced. .. code-block:: text. def test {; string strings = ""_suffstringsuffix"";; list<int> ints = [0, 1, 2, 3, 4, 5, 6];; }. Appendix C: Sample Record; =========================. One target machine supported by LLVM is the Intel x86. The following output; from TableGen shows the record that is created to represent the 32-bit; register-to-register ADD instruction. .. code-block:: text. def ADD32rr {	// InstructionEncoding Instruction X86Inst I ITy Sched BinOpRR BinOpRR_RF; int Size = 0;; string DecoderNamespace = """";; list<Predicate> Predicates = [];; string DecoderMethod = """";; bit hasCompleteDecoder = 1;; string Namespace = ""X86"";; dag OutOperandList = (outs GR32:$dst);; dag InOperandList = (ins GR32:$src1, GR32:$src2);; string AsmString = ""add{l}	{$src2, $src1|$src1, $src2}"";; EncodingByHwMode EncodingInfos = ?;; list<dag> Pattern = [(set GR32:$dst, EFLAGS, (X86add_flag GR32:$src1, GR32:$src2))];; list<Regi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:74851,variab,variable,74851,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variable']
Modifiability,"erator support parsing directly Keras `.h5` input files or PyTorch `.pt` files.; In tis case you can convert directly the model to a `RModel` representation which can be used as above to generate the header and the weight file. For parsing a Keras input file you need to do:; ```; SOFIE::RModel model = SOFIE::PyKeras::Parse(""KerasModel.h5"");; ```; See the tutorial [`TMVA_SOFIE_Keras.C`](https://root.cern/doc/master/TMVA__SOFIE__Keras_8C.html).; For parsing a PyTorch input file :; ```; SOFIE::RModel model = SOFIE::PyTorch::Parse(""PyTorchModel.pt"",inputShapes);; ```; where `inputShapes` is a `std::vector<std::vector<size_t>>` defining the inputs shape tensors. This information is required by PyTorch since it is not stored in the model.; A full example for parsing a PyTorch file is in the [`TMVA_SOFIE_PyTorch.C`](https://root.cern/doc/master/TMVA__SOFIE__PyTorch_8C.html) tutorial. For using the Keras and/or the PyTorch parser you need to have installed Keras and/or PyTorch in your Python system and in addition build root with the support for `pymva`, obtained when configuring with `-Dtmva-pymva=On`. Note that the created `SOFIE::RModel` class after parsing can be stored also in a ROOT file, using standard ROOT I/O functionality:; ```; SOFIE::RModel model = SOFIE::PyKeras::Parse(""KerasModel.h5"");; TFile file(""model.root"",""NEW"");; model.Write();; file.Close();; ```. ## 2D Graphics Libraries. - Implement the option `X+` and `Y+` for reverse axis on TGraph. - Offsets for axis titles with absolute-sized fonts (size%10 == 3) are now relative only to the font size (i.e. no longer relative to pad dimensions). - In `TPaletteAxis` when the palette width is bigger than the palette height, the palette; in automatically drawn horizontally. - The `.tex` file produced when saving canvas as `.tex`, needed to be included in an existing; LateX document to be visualized. The new `Standalone` option allows to generate a `.tex`; file which can be directly processed by LateX (for example with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:35416,config,configuring,35416,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['config'],['configuring']
Modifiability,"eratorNamestd::string Name; Matches the operator Name of operator expressions and fold expressions; (binary or unary). Example matches a || b (matcher = binaryOperator(hasOperatorName(""||""))); !(a || b). Example matches `(0 + ... + args)`; (matcher = cxxFoldExpr(hasOperatorName(""+""))); template <typename... Args>; auto sum(Args... args) {; return (0 + ... + args);; }. Matcher<UnresolvedMemberExpr>isArrow; Matches member expressions that are called with '->' as opposed; to '.'. Member calls on the implicit this pointer match as called with '->'. Given; class Y {; void x() { this->x(); x(); Y y; y.x(); a; this->b; Y::b; }; template <class T> void f() { this->f<T>(); f<T>(); }; int a;; static int b;; };; template <class T>; class Z {; void x() { this->m; }; };; memberExpr(isArrow()); matches this->x, x, y.x, a, this->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStatic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124159,variab,variable,124159,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"erbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NTrees No 800 − Number of trees in the forest. MaxDepth No 3 − Max depth of the decision tree allowed. MinNodeSize No 5% − Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%). nCuts No 20 − Number of grid points in variable range used in finding optimal cut in node splitting. BoostType No AdaBoost AdaBoost, RealAdaBoost, Bagging, AdaBoostR2, Grad Boosting type for the trees in the forest . AdaBoostR2Loss No Quadratic Linear, Quadratic, Exponential Type of Loss function in AdaBoostR2. UseBaggedGrad No False − Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost). Shrinkage No 1 − Learning rate for GradBoost algorithm. AdaBoostBeta No 0.5 − Learning rate for AdaBoost algorithm. UseRandomisedTrees No False − Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests). UseNvars No 2 − Size of the subset of variables used with RandomisedTree option. UsePoissonNvars No True − Interpret UseNvars not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option. BaggedSampleFraction No 0.6 − Relative size of bagged event sample to original size of the data sampl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:12142,variab,variable,12142,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"ere are examples of this throughout; the LLVM CMake build system. An example of variable empty expansion is:. .. code-block:: cmake. if(APPLE); set(extra_sources Apple.cpp); endif(); add_executable(HelloWorld HelloWorld.cpp ${extra_sources}). In this example the ``extra_sources`` variable is only defined if you're; targeting an Apple platform. For all other targets the ``extra_sources`` will be; evaluated as empty before add_executable is given its arguments. Lists; -----. In CMake lists are semi-colon delimited strings, and it is strongly advised that; you avoid using semi-colons in lists; it doesn't go smoothly. A few examples of; defining lists:. .. code-block:: cmake. # Creates a list with members a, b, c, and d; set(my_list a b c d); set(my_list ""a;b;c;d""). # Creates a string ""a b c d""; set(my_string ""a b c d""). Lists of Lists; --------------. One of the more complicated patterns in CMake is lists of lists. Because a list; cannot contain an element with a semi-colon to construct a list of lists you; make a list of variable names that refer to other lists. For example:. .. code-block:: cmake. set(list_of_lists a b c); set(a 1 2 3); set(b 4 5 6); set(c 7 8 9). With this layout you can iterate through the list of lists printing each value; with the following code:. .. code-block:: cmake. foreach(list_name IN LISTS list_of_lists); foreach(value IN LISTS ${list_name}); message(${value}); endforeach(); endforeach(). You'll notice that the inner foreach loop's list is doubly dereferenced. This is; because the first dereference turns ``list_name`` into the name of the sub-list; (a, b, or c in the example), then the second dereference is to get the value of; the list. This pattern is used throughout CMake, the most common example is the compiler; flags options, which CMake refers to using the following variable expansions:; CMAKE_${LANGUAGE}_FLAGS and CMAKE_${LANGUAGE}_FLAGS_${CMAKE_BUILD_TYPE}. Other Types; -----------. Variables that are cached or specified on the comm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:4796,variab,variable,4796,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variable']
Modifiability,"ere are three main options for transitioning:. 1. Keep the current coding standard; 2. Laissez faire; 3. Big bang. Keep the current coding standard; --------------------------------. Proponents of keeping the current coding standard (i.e. not transitioning at; all) question whether the cost of transition outweighs the benefit; [EmersonConcern]_ [ReamesConcern]_ [BradburyConcern]_.; The costs are that ``git blame`` will become less usable; and that merging the; changes will be costly for downstream maintainers. See `Big bang`_ for potential; mitigations. Laissez faire; -------------. The coding standard could allow both ``CamelCase`` and ``camelBack`` styles for; variable names [LattnerTransition]_. A code review to implement this is at https://reviews.llvm.org/D57896. Advantages; **********. * Very easy to implement initially. Disadvantages; *************. * Leads to inconsistency [BradburyConcern]_ [AminiInconsistent]_.; * Inconsistency means it will be hard to know at a guess what name a variable; will have [DasInconsistent]_ [CarruthInconsistent]_.; * Some large-scale renaming may happen anyway, leading to its disadvantages; without any mitigations. Big bang; --------. With this approach, variables will be renamed by an automated script in a series; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:8355,variab,variable,8355,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"ere is a distinguished base type termed the generic type, which is an integral; type that has the size of an address in the target architecture default address; space, a target architecture defined endianity, and unspecified signedness. *The generic type is the same as the unspecified type used for stack operations; defined in DWARF Version 4 and before.*. An integral type is a base type that has an encoding of ``DW_ATE_signed``,; ``DW_ATE_signed_char``, ``DW_ATE_unsigned``, ``DW_ATE_unsigned_char``,; ``DW_ATE_boolean``, or any target architecture defined integral encoding in the; inclusive range ``DW_ATE_lo_user`` to ``DW_ATE_hi_user``. .. note::. It is unclear if ``DW_ATE_address`` is an integral type. GDB does not seem to; consider it as integral. .. _amdgpu-dwarf-location-description:. A.2.5.3 DWARF Location Description; ++++++++++++++++++++++++++++++++++. *Debugging information must provide consumers a way to find the location of; program variables, determine the bounds of dynamic arrays and strings, and; possibly to find the base address of a subprogram’s call frame or the return; address of a subprogram. Furthermore, to meet the needs of recent computer; architectures and optimization techniques, debugging information must be able to; describe the location of an object whose location changes over the object’s; lifetime, and may reside at multiple locations simultaneously during parts of an; object's lifetime.*. Information about the location of program objects is provided by location; descriptions. Location descriptions can consist of one or more single location descriptions. A single location description specifies the location storage that holds a; program object and a position within the location storage where the program; object starts. The position within the location storage is expressed as a bit; offset relative to the start of the location storage. A location storage is a linear stream of bits that can hold values. Each; location storage has a size in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:56886,variab,variables,56886,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"ere is a; rotation among queued; sessions. In the case of load-based worker assignment, the max number; of running; queries is determined dynamically.; Add support for repeat functionality in the xrd.worker; directive. To avoid repeating the same line N times; one can just add; 'repeat=N'; in the line; for; example;            ;     xpd.worker worker; proofwrks:2093 repeat=4; will define 4 workers on port 2093 of machine 'proofwrks'.; Add support for port specification via the directive; 'xpd.port'; Enable variable; substitution in 'xpd.' directives using the standard; Scalla mechanism described in; http://xrootd.slac.stanford.edu/doc/dev/Syntax_config.htm .; Build also a binary named 'xproofd' which runs; a xrootd; daemon with only the XrdProofdProtocol (i.e. no data serving).; This simplifies setups when data serving is not needed and also allows; to better disantagle problems related to one specific protocol. The new; binary accepts the same arguments as 'xrootd' and parses the same; directives form the same configuration file, with the exception of; 'xpd.protocol xproofd libXrdProofd.so' which should now be dropped. AN; alternative port can be specified via the new 'xpd.port' directive (see; above).; Add support for 'MasterOnly' mode in starting a PROOF; session. This avoids starting the workers when one wants just to browse; the datasets or retrieve results. To start a session in 'MasterOnly'; mode enter ""masteronly""; as second argument to TProof::Open, e.g.;  ;          root[]; TProof *p = TProof::Open(""<masterurl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:1823,config,configuration,1823,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,1,['config'],['configuration']
Modifiability,"ere no basket is stored with the TTree object.; Fix the axis used for an histogram created by TTree::Draw for a branch of TString or std::string objects.; MakeProxy now correctly support branches that created with a leaflist with more than one leaf; (usually used for C-struct).; TTree::CloneTree and TChain::Merge in fast mode now can recover from some mismatch errors between; the input and output TTrees by falling back to using the 'slow' mode. In particular this allow; a 'fast cloning' to handle files that requires schema evolution (albeit it is of course much slower).; Make sure that the TTreeCache is not attempting to cache (wrongly) the content of branches that are in an auxiliary files.; Make sure that FillBuffer does it work when the learning phase is over even if the entry number is 'low' for the 'current' file of a chain.; If TTree::SetEventList is called, TTree::GetEntryList no longer relinquish ownership of the automatically created TEntryList; Add the ability to see the TTree UserInfo list from the TBrowser; Fix the case of reading a TTree containing an 'old' class layout that contained a std::vector that is no longer part of the current class layout; Implement direct interfaces from TTree to the result of TSelector::Draw; TTree:GetVal(int) and TTree::GetVar(int); In TTree::ReadFile add the possibility to read multiple input files and add support for large/wide Trees definition.; Added support for ""5-D"" plotting.; Added support for std::bitset; Reduce the memory used by the mechanism keeping track of the entry of variables sizes within a basket (fEntryOffset).; The memory used now automatically decrease if the number of entries in the basket is less than 1/4 oflength of fEntryOffset.; Also the default length fEntryOffset can be set via TTree::SetDefaultEntryOffsetLen which can be optionially applied to the; existing branches. Parallel Coordinates. Fix a memory leak. The TParallelCoord destructor was not called; when the canvas used to draw it was closed. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html:1742,variab,variables,1742,tree/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/doc/v524/index.html,1,['variab'],['variables']
Modifiability,"ere only meant as implementation details of other RooFit classes.; Some of these classes are now removed from the public interface:. 1. `RooGenProdProj`, which was an implementation detail of the `RooProdPdf`; 2. `RooScaledFunc`, which was an implementation detail of the plotting in RooFit; In the supposedly very rare case where you used this class in your own; implementations, just multiply the underlying RooAbsReal function with the; scale factor and create a RooRealBinding, e.g.:; ```c++; RooProduct scaledFunc{""scaled_func"", """", func, scaleFactor};; RooRealBinding scaleBind(scaledFunc, x) ;; ```; instead of:; ```c++; RooRealBinding binding(func, x) ;; RooScaledFunc scaledBinding(binding, scaleFactor);; ```; 3. The `RooAbsRootFinder`, which was the base class of `RooBrentRootFinder`.; The `RooAbsRootFinder` was only used as the base class of; `RooBrentRootFinder`, which is an implementation detail of several; RooFit/RooStats functions. However, polymorphism never not relevant for root; finding, so the `RooAbsRootFinder` is removed. In the rare case where you; might have used it, please ROOT's other functionalities: RooFit is not for; root finding.; 4. The `RooFormula` class, which was not meant as a user-facing class, but as a; shared implementation detail of `RooFormulaVar` and `RooGenericPdf`.; 5. The `RooIntegratorBinding`, which was an implementation detail of the; `RooIntegrator2D` and `RooSegmentedIntegrator2D` classes.; 6. The `RooRealAnalytic`, which was an implementation detail of the; `RooRealIntegral` class. ### Consistent default for `Extended()` command in RooAbsPdf::fitTo() and RooAbsPdf::chi2FitTo(). If no `RooFit::Extended()` command argument is passed, `RooAbsPdf::chi2FitTo()`; method now does an extended fit by default if the pdf is extendible. This makes; the behavior consistent with `RooAbsPdf::fitTo()`. Same applies to; `RooAbsPdf::createChi2()`. ## TMVA; ### SOFIE : Code generation for fast inference of Deep Learning models; TMVA SOFIE now su",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:15799,polymorphi,polymorphism,15799,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['polymorphi'],['polymorphism']
Modifiability,"ered data are written into the dest; spectrum. Function parameters:. - **`source`**: pointer to the matrix of source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of source and dest spectra; - **`type`**: type of transform:; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; - `TRANSFORM2_COS_HAAR`; - `TRANSFORM2_SIN_WALSH`; - `TRANSFORM2_SIN_HAAR`; - **`degree`**: applies only for mixed transforms; - **`xmin`**: low limit x of filtered region; - **`xmax`**: high limit x of filtered region; - **`ymin`**: low limit y of filtered region; - **`ymax`**: high limit y of filtered region; - **`filter_coeff`**: value which is set in filtered region. The enhancement function using transforms has a form of. ```{.cpp}; char *Enhance2(const float **source,; float **dest,; int sizex,; int sizey,; int type,; int degree,; int xmin,; int xmax,; int ymin,; int ymax,; float enhance_coeff);; ```. This function transforms the source spectrum. The calling program should; fill in the input parameters. Then it multiplies transformed coefficients in; the given region by the given `enhance_coeff` and transforms it; back. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum, its size should be `sizex`*`sizey`; - **`dest`**: pointer to the matrix of the destination data, its size should be `sizex`*`sizey`; - **`sizex,sizey`**: basic dimensions of the source and dest spectra; - **`type`**: type of transform; - `TRANSFORM2_HAAR`; - `TRANSFORM2_WALSH`; - `TRANSFORM2_COS`; - `TRANSFORM2_SIN`; - `TRANSFORM2_FOURIER`; - `TRANSFORM2_HARTLEY`; - `TRANSFORM2_FOURIER_WALSH`; - `TRANSFORM2_FOURIER_HAAR`; - `TRANSFORM2_WALSH_HAAR`; - `TRANSFORM2_COS_WALSH`; -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:69266,enhance,enhancement,69266,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['enhance'],['enhancement']
Modifiability,"erent dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Math::IGradientFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IGradientFunctionMultiDim* Clone() const; {; return new MyGradientFunction();; }. double DoDerivative(const double* x, unsigned int ipar) const; {; if ( ipar == 0 ); return sin(x[1]);; else; return x[0] + x[1] * cos(x[1]);; }. };; ```. ### Parametric Function Interfaces. These interfaces, for evaluating multi-dimensional functions are used for fitting. These interfaces are defined in the header file; `Math/IParamFunction.h`.; See also the documentation of the `ROOT::Fit` classes in the Fitting chapter for more information. * **`ROOT::Math::IParametricFunctionMultiDim`**: Describes a multi dimensional parametric funct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38927,variab,variable,38927,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['variab'],['variable']
Modifiability,"erexpr; /// ::= identifier; /// ::= identifier '(' expression* ')'; static std::unique_ptr<ExprAST> ParseIdentifierExpr() {; std::string IdName = IdentifierStr;. getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref.; return std::make_unique<VariableExprAST>(IdName);. // Call.; getNextToken(); // eat (; std::vector<std::unique_ptr<ExprAST>> Args;; if (CurTok != ')') {; while (true) {; if (auto Arg = ParseExpression()); Args.push_back(std::move(Arg));; else; return nullptr;. if (CurTok == ')'); break;. if (CurTok != ','); return LogError(""Expected ')' or ',' in argument list"");; getNextToken();; }; }. // Eat the ')'.; getNextToken();. return std::make_unique<CallExprAST>(IdName, std::move(Args));; }. This routine follows the same style as the other routines. (It expects; to be called if the current token is a ``tok_identifier`` token). It; also has recursion and error handling. One interesting aspect of this is; that it uses *look-ahead* to determine if the current identifier is a; stand alone variable reference or if it is a function call expression.; It handles this by checking to see if the token after the identifier is; a '(' token, constructing either a ``VariableExprAST`` or; ``CallExprAST`` node as appropriate. Now that we have all of our simple expression-parsing logic in place, we; can define a helper function to wrap it together into one entry point.; We call this class of expressions ""primary"" expressions, for reasons; that will become more clear `later in the; tutorial <LangImpl06.html#user-defined-unary-operators>`_. In order to parse an arbitrary; primary expression, we need to determine what sort of expression it is:. .. code-block:: c++. /// primary; /// ::= identifierexpr; /// ::= numberexpr; /// ::= parenexpr; static std::unique_ptr<ExprAST> ParsePrimary() {; switch (CurTok) {; default:; return LogError(""unknown token when expecting an expression"");; case tok_identifier:; return ParseIdentifierExpr();; case tok_number:; return ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:10653,variab,variable,10653,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['variab'],['variable']
Modifiability,"erface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6709,variab,variable,6709,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"erface. ~~~{.sh}; install.packages(c('C50','RSNNS','e1071','xgboost')); ~~~. Download code from git repo. ~~~{.sh}; git clone http://root.cern.ch/git/root.git; ~~~. To compile ROOTR lets to create a compilation directory and to activate it use cmake -Dr=ON .. ~~~{.sh}; mkdir compile; cd compile; cmake -Dr=ON ..; make -j 5; ~~~. ## How does it work ?; There is a class called TRInterface which is located at the header TRInterface.h and uses the namespace `ROOT::R`, it is in charge; of making calls to R to give and obtain data. This class has a series of overcharged operators which ease the passing and obtaining of data; and code from R to C++ and vice versa. To create an object of this class the user must use the static methods `ROOT::R::TRInterface::Instance`; and `ROOT::R::TRInterface::InstancePtr` which return a reference object and a pointer object respectively. ~~~{.cxx}; #include<TRInterface.h>; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; ~~~. ## Running R code and passing/getting variables.; We have different ways to run R code and pass/obtain data to/from R environment: using the methods Execute(code) and; Eval(code). ~~~{.cxx}; #include<TRInterface.h>. //creating an instance; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; //executing simple r commands with the operator <<; r<<""print('hello ROOTR')"";; r<<""vec=c(1,2,3)""<<""print(vec)"";. //executing R's code using the method Execute that doesn't return anything; r.Execute(""print('hello ROOTR')"");. //We execute the code using the method Eval which returns an instance of TRObjectProxy; //which can be converted to a ROOTR supported classes; std::vector<Int_t> v=r.Eval(""c(1,2,3)"");; std::cout<<v[0]<<"" ""<<v[1]<<"" ""<<v[2]<<std::endl;. std::vector<Double_t> vd(3);. //obtaining variables from R environment using the operators [] and >>; r[""seq(0,1,0.5)""]>>vd;; std::cout<<vd[0]<<"" ""<<vd[1]<<"" ""<<vd[2]<<std::endl;. std::vector<Int_t> v1(3);; v1[0]=0;; v1[1]=1;; v1[2]=2;. r[""v1""]<<v1;; r<<""print(v1",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:3769,variab,variables,3769,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,1,['variab'],['variables']
Modifiability,"erface.h; Header file defining functions in the namespace ROOT::Fit providing functions required for fitting the data objects of the histogram package. These functions are used for example from other libraries like the FitPanel or the TTreePlayer for performing the fits.; . ROOT::Fit::FitObject: function for fitting the various data objects. The user must pass in addition to a pointer to the fit object, the fit options (via the FOption class and not a string), the minimizer options and the fit data range.; ; ROOT::Fit::FillData: function for filling the fit data from the histogram data objects. Used for fitting an histogram using the ROOT::Fit::Fitter class.; ; ROOT::Fit::UnBinFit:: function for fitting an unbinned data sets, for example obtained from TTree data.; . TBackCompFitter; New class providing a backward compatible implementation of the; TVirtualFitter using the new fitting class. It is wrapping the functionality of the ROOT::Math::Fitter and it; can be used to retrieve the fit information (result and; configuration) via the; TVirtualFitter API from FitConfig and FitResult. A static instance of this class; is created after calling the histograms and graph Fit methods in order to retrieve the full fit information after having fit. This instace will be deleted only when the next fit is executed.; This gives full backward compatibility functionality in fitting.; This class in addition to the TVirtualFitter provides the following functionality:; ; access direct to references to ROOT::Fit::FitResult and ROOT::FitConfig objects via the member functions TBackCompFitter::GetFitResult() and TBackCompFitter::GetFitConfig(); Possibility to set the fit the fit function directly as a function pointer to a muldi-dimensional function interface instead of using the TMinuit FCN style API.; New methods for making in a easy way contour , with TBackCompFitter::Contour, and scan plots of the objective function, with TBackCompFitter::Scan. Both Scan and Contour takes as input a T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html:1454,config,configuration,1454,hist/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v522/index.html,1,['config'],['configuration']
Modifiability,"erge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_AllDefinitions`` (in configuration: ``AllDefinitions``); Alway",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32776,config,configuration,32776,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"erifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; captured value. The syntax of ``<fmtspec>`` is: ``#.<precision><conversion specifier>`` where:. * ``#`` is an optional fl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27705,variab,variables,27705,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"ering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if there is a mismatch in the C++ standard between ROOT and the application. As of v6.28, suchs builds will issue a warning if the C++ standard does not match ROOT's, i.e. if there is a mismatch in the value of the `__cplusplus` preprocessor macro w.r.t. when ROOT was configured. ## PyROOT. - A `.rootlogon.py` file wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32716,config,configured,32716,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configured']
Modifiability,"eriting multiclass. The body of the multiclass; contains a series of statements that define records, using :token:`Def` and; :token:`Defm`. In addition, :token:`Defvar`, :token:`Foreach`, and; :token:`Let` statements can be used to factor out even more common elements.; The :token:`If` and :token:`Assert` statements can also be used. Also as with regular classes, the multiclass has the implicit template; argument ``NAME`` (see NAME_). When a named (non-anonymous) record is; defined in a multiclass and the record's name does not include a use of the; template argument ``NAME``, such a use is automatically *prepended*; to the name. That is, the following are equivalent inside a multiclass::. def Foo ...; def NAME # Foo ... The records defined in a multiclass are created when the multiclass is; ""instantiated"" or ""invoked"" by a ``defm`` statement outside the multiclass; definition. Each ``def`` statement in the multiclass produces a record. As; with top-level ``def`` statements, these definitions can inherit from; multiple parent classes. See `Examples: multiclasses and defms`_ for examples. ``defm`` --- invoke multiclasses to define multiple records; -----------------------------------------------------------. Once multiclasses have been defined, you use the ``defm`` statement to; ""invoke"" them and process the multiple record definitions in those; multiclasses. Those record definitions are specified by ``def``; statements in the multiclasses, and indirectly by ``defm`` statements. .. productionlist::; Defm: ""defm"" [`NameValue`] `ParentClassList` "";"". The optional :token:`NameValue` is formed in the same way as the name of a; ``def``. The :token:`ParentClassList` is a colon followed by a list of at; least one multiclass and any number of regular classes. The multiclasses; must precede the regular classes. Note that the ``defm`` does not have a; body. This statement instantiates all the records defined in all the specified; multiclasses, either directly by ``def`` statem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:36993,inherit,inherit,36993,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability,"erminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24702,variab,variable,24702,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"ermine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword is enabled. C11 atomic operations; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_atomic)`` or ``__has_extension(c_atomic)`` to determine; if support for atomic types using ``_Atomic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:51070,variab,variable,51070,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable']
Modifiability,"erred down the data-invariant expression graph. We can generalize the previous idea and sink the hardening down the expression; graph across as many data-invariant operations as desirable. This can use very; conservative rules for whether something is data-invariant. The primary goal; should be to handle multiple loads with a single hardening instruction:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; addl (%rsi), %edi # Load and accumulate without leaking.; addl 4(%rsi), %edi # Continue without leaking.; addl 8(%rsi), %edi; orl %eax, %edi # Mask out bits from all three loads.; ```. ###### Preserving the flags while hardening loaded values on Haswell, Zen, and newer processors. Sadly, there are no useful instructions on x86 that apply a mask to all 64 bits; without touching the flag registers. However, we can harden loaded values that; are narrower than a word (fewer than 32-bits on 32-bit systems and fewer than; 64-bits on 64-bit systems) by zero-extending the value to the full word size; and then shifting right by at least the number of original bits using the BMI2; `shrx` instruction:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; addl (%rsi), %edi # Load and accumulate 32 bits of data.; shrxq %rax, %rdi, %rdi # Shift out all 32 bits loaded.; ```. Because on x86 the zero-extend is free, this can efficiently harden the loaded; value. ##### Hardening the address of the load. When hardening the loaded value is inapplicable, most often because the; instruction directly leaks information (like `cmp` or `jmpq`), we switch to; hardening the _address_ of the load instead of the loaded value. This avoids; increasing register pressure by unfolding the load or paying some other high; cost. To understand how this works in practice, we need to examine the exact; semantics of the x86 addressing modes which, in its fully general form, looks; like `(%base,%index,scale)offset`. Here `%base` and `%",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:27053,extend,extending,27053,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['extend'],['extending']
Modifiability,"ers come with standard libraries only (like; ``compiler-rt``, ``libcxx``, ``libgcc``, ``libm``, etc), so you'll have to; find and make available to the build system, every other library required; to build your software, that is specific to your target. It's not enough to; have your host's libraries installed. Finally, not all toolchains are the same, and consequently, not every Clang; option will work magically. Some options, like ``--sysroot`` (which; effectively changes the logical root for headers and libraries), assume; all your binaries and libraries are in the same directory, which may not; true when your cross-compiler was installed by the distribution's package; management. So, for each specific case, you may use more than one; option, and in most cases, you'll end up setting include paths (``-I``) and; library paths (``-L``) manually. To sum up, different toolchains can:; * be host/target specific or more flexible; * be in a single directory, or spread out across your system; * have different sets of libraries and headers by default; * need special options, which your build system won't be able to figure; out by itself. General Cross-Compilation Options in Clang; ==========================================. Target Triple; -------------. The basic option is to define the target architecture. For that, use; ``-target <triple>``. If you don't specify the target, CPU names won't; match (since Clang assumes the host triple), and the compilation will; go ahead, creating code for the host platform, which will break later; on when assembling or linking. The triple has the general format ``<arch><sub>-<vendor>-<sys>-<env>``, where:; * ``arch`` = ``x86_64``, ``i386``, ``arm``, ``thumb``, ``mips``, etc.; * ``sub`` = for ex. on ARM: ``v5``, ``v6m``, ``v7a``, ``v7m``, etc.; * ``vendor`` = ``pc``, ``apple``, ``nvidia``, ``ibm``, etc.; * ``sys`` = ``none``, ``linux``, ``win32``, ``darwin``, ``cuda``, etc.; * ``env`` = ``eabi``, ``gnu``, ``android``, ``macho``, ``elf``, etc.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:3143,flexible,flexible,3143,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['flexible'],['flexible']
Modifiability,"ers, and thus there is no need for expensive location; maintenance during regalloc (i.e. `LiveDebugVariables`). Debug instructions are; unlinked from the function, then linked back in after register allocation; completes. The exception is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4327,variab,variable,4327,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,['variab'],['variable']
Modifiability,"erv->Restrict(""/Folder/histo1"", ""allow=all"");; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle"");; ```. One could provide several options for the same item, separating them with '&' sign:. ```cpp; serv->Restrict(""/Folder/histo1"", ""allow_method=GetTitle&hide=guest"");; ```. Complete list of supported options could be found in [TRootSniffer:Restrict()](https://root.cern/doc/master/classTRootSniffer.html#a8af1f11cbfb9c895f968ec0594794120) method documentation. ## Using FastCGI interface. [FastCGI](http://en.wikipedia.org/wiki/FastCGI) is a protocol for interfacing interactive programs with a web server like `Apache`, `lighttpd`, `Microsoft ISS` and many others. When starting THttpServer, one could specify:. ```cpp; serv = new THttpServer(""fastcgi:9000"");; ```. In fact, the FastCGI interface can run in parallel to http server. One can just call:. ```cpp; serv = new THttpServer(""http:8080"");; serv->CreateEngine(""fastcgi:9000"");; ```. One could specify a debug parameter to be able to adjust the FastCGI configuration on the web server:. ```cpp; serv->CreateEngine(""fastcgi:9000?debug=1"");; ```. By default 10 threads are used to process FastCGI requests. This number can be changed with ""thrds"" url parameter:. ```cpp; serv->CreateEngine(""fastcgi:9000?thrds=20"");; ```. If `thrds=0` parameter specified, the only thread will be use to received and process all requests. All user access will be ruled by the main web server. Authorized account names could be used to configure access restriction in THttpServer. ### Configure fastcgi with Apache2. Since Apache version 2.4 FastCGI is directly supported - there is no need to compile and install external modules any more.; One only need to enable `mod_proxy` and `mod_proxy_fcgi` modules and add following line to **Apache2** configuration file:. ```; ProxyPass ""/root.app/"" ""fcgi://localhost:9000/"" enablereuse=on; ```. More information can be found in [FastCGI proxy docu](https://httpd.apache.org/docs/2.4/mod/mod_proxy_fcgi.html).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:10521,config,configuration,10521,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configuration']
Modifiability,"erver into application) can be; implemented in JSON format. There is the [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class,; which is capable to convert any (beside TTree) ROOT object into JSON. Any ROOT application can use such class to; create JSON files for selected objects and write such files in a directory,; which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser. There is a demonstration page showing such functionality: <https://root.cern/js/latest/demo/update_draw.htm>.; This demo page reads in cycle 20 json files and displays them. If one has a web server which already provides such JSON file, one could specify the URL to this file like:. <https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz>. Here the same problem with [Cross-Origin Request](https://developer.mozilla.org/en/http_access_control) can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself. ### Binary file-based monitoring (not recommended). Theoretically, one could use binary ROOT files to implement monitoring.; With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats. First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate. The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol.; There is no http file locking mechanism (at least not for standard web servers),; th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:32069,config,configuration,32069,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configuration']
Modifiability,"ervers. In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. - <https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx>. But one should be aware of [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy),; when the browser blocks requests to files from domains other than current web page.; To enable CORS on Apache web server, hosting ROOT files, one should add following lines to `.htaccess` file:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28411,plugin,plugin,28411,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['plugin'],['plugin']
Modifiability,"es <i_phi>`. LLVM allows an explicit section to be specified for functions. If the; target supports it, it will emit functions to the section specified.; Additionally, the function can be placed in a COMDAT. An explicit alignment may be specified for a function. If not present,; or if the alignment is set to zero, the alignment of the function is set; by the target to whatever it feels convenient. If an explicit alignment; is specified, the function is forced to have at least that much; alignment. All alignments must be a power of 2. If the ``unnamed_addr`` attribute is given, the address is known to not; be significant and two identical functions can be merged. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. If an explicit address space is not given, it will default to the program; address space from the :ref:`datalayout string<langref_datalayout>`. .. _langref_aliases:. Aliases; -------. Aliases, unlike function or variables, don't create any new data. They; are just a new symbol and metadata for an existing position. Aliases have a name and an aliasee that is either a global value or a; constant expression. Aliases may have an optional :ref:`linkage type <linkage>`, an optional; :ref:`runtime preemption specifier <runtime_preemption_model>`, an optional; :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class; <dllstorageclass>` and an optional :ref:`tls model <tls_model>`. Syntax::. @<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>; [, partition ""name""]. The linkage must be one of ``private``, ``internal``, ``linkonce``, ``weak``,; ``linkonce_odr``, ``weak_odr``, ``external``, ``available_externally``. Note; that some system linkers might not correctly handle dropping a weak symbol that; is aliased. Aliases that are not ``unnamed_addr`` are guaranteed to have the sam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:42435,variab,variables,42435,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"es a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matcher<CXXBaseSpecifier>. Matcher<CXXBoolLiteralExpr>equalsbool Value. Matcher<CXXBoolLiteralExpr>equalsconst ValueT Value; Matches literals that are equal to the given value of type ValueT. Given; f('false, 3.14, 42);; characterLiteral(equals(0)); matches 'cxxBoolLiteral(equals(false)) and cxxBoolLiteral(equals(0)); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57351,inherit,inheritance,57351,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"es from the start of the line. .. code-block:: c++. true: false:; aaaa = vs. aaaa = ""bbbb""; ""bbbb"" ""cccc"";; ""cccc"";. .. _AlwaysBreakTemplateDeclarations:. **AlwaysBreakTemplateDeclarations** (``BreakTemplateDeclarationsStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <AlwaysBreakTemplateDeclarations>`; The template declaration breaking style to use. Possible values:. * ``BTDS_No`` (in configuration: ``No``); Do not force break before declaration.; ``PenaltyBreakTemplateDeclaration`` is taken into account. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T> T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_MultiLine`` (in configuration: ``MultiLine``); Force break after template declaration only when the following; declaration spans multiple lines. .. code-block:: c++. template <typename T> T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. * ``BTDS_Yes`` (in configuration: ``Yes``); Always break after template declaration. .. code-block:: c++. template <typename T>; T foo() {; }; template <typename T>; T foo(int aaaaaaaaaaaaaaaaaaaaa,; int bbbbbbbbbbbbbbbbbbbbb) {; }. .. _AttributeMacros:. **AttributeMacros** (``List of Strings``) :versionbadge:`clang-format 12` :ref:`¶ <AttributeMacros>`; A vector of strings that should be interpreted as attributes/qualifiers; instead of identifiers. This can be useful for language extensions or; static analyzer annotations. For example:. .. code-block:: c++. x = (char *__capability)&y;; int function(void) __unused;; void only_writes_to_buffer(char *__output buffer);. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. AttributeMacros: ['__capability', '__output', '__unused']. .. _BinPackArguments:. **BinPackArguments** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <BinPackArguments>`; If ``false``, a function call's arguments will either be all on the; same line or will have on",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:35641,config,configuration,35641,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"es has been spilled to the; stack, and a record of that location has been recorded to the; :ref:`Stack Map section <stackmap-section>`. If the garbage collector; needs to update any of these pointers during the call, it knows; exactly what to change. The relevant parts of the StackMap section for our example are:. .. code-block:: gas. # This describes the call site; # Stack Maps: callsite 2882400000; 	 .quad	2882400000; 	 .long	.Ltmp1-test1; 	 .short	0; # .. 8 entries skipped ..; # This entry describes the spill slot which is directly addressable; # off RSP with offset 0. Given the value was spilled with a pushq,; # that makes sense.; # Stack Maps: Loc 8: Direct RSP [encoding: .byte 2, .byte 8, .short 7, .int 0]; 	 .byte	2; 	 .byte	8; 	 .short	7; 	 .long	0. This example was taken from the tests for the :ref:`RewriteStatepointsForGC`; utility pass. As such, its full StackMap can be easily examined with the; following command. .. code-block:: bash. opt -rewrite-statepoints-for-gc test/Transforms/RewriteStatepointsForGC/basics.ll -S | llc -debug-only=stackmaps. Simplifications for Non-Relocating GCs; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Some of the complexity in the previous example is unnecessary for a; non-relocating collector. While a non-relocating collector still needs the; information about which location contain live references, it doesn't need to; represent explicit relocations. As such, the previously described explicit; lowering can be simplified to remove all of the ``gc.relocate`` intrinsic; calls and leave uses in terms of the original reference value. Here's the explicit lowering for the previous example for a non-relocating; collector:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj); ret i8 addrspace(1)* %obj; }. Recording On",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:11326,rewrite,rewrite-statepoints-for-gc,11326,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['rewrite'],['rewrite-statepoints-for-gc']
Modifiability,"es has been; finished, along with support for the ``/GR`` flag. * C++ Exceptions: :good:`Mostly complete`. Support for; C++ exceptions (``try`` / ``catch`` / ``throw``) have been implemented for; x86 and x64. Our implementation has been well tested but we still get the; odd bug report now and again.; C++ exception specifications are ignored, but this is `consistent with Visual; C++`_. .. _consistent with Visual C++:; https://msdn.microsoft.com/en-us/library/wfa0edys.aspx. * Asynchronous Exceptions (SEH): :partial:`Partial`.; Structured exceptions (``__try`` / ``__except`` / ``__finally``) mostly; work on x86 and x64.; LLVM does not model asynchronous exceptions, so it is currently impossible to; catch an asynchronous exception generated in the same frame as the catching; ``__try``. * Thread-safe initialization of local statics: :good:`Complete`. MSVC 2015; added support for thread-safe initialization of such variables by taking an; ABI break.; We are ABI compatible with both the MSVC 2013 and 2015 ABI for static local; variables. * Lambdas: :good:`Mostly complete`. Clang is compatible with Microsoft's; implementation of lambdas except for providing overloads for conversion to; function pointer for different calling conventions. However, Microsoft's; extension is non-conforming. Template instantiation and name lookup; ======================================. MSVC allows many invalid constructs in class templates that Clang has; historically rejected. In order to parse widely distributed headers for; libraries such as the Active Template Library (ATL) and Windows Runtime Library; (WRL), some template rules have been relaxed or extended in Clang on Windows. The first major semantic difference is that MSVC appears to defer all parsing; an analysis of inline method bodies in class templates until instantiation; time. By default on Windows, Clang attempts to follow suit. This behavior is; controlled by the ``-fdelayed-template-parsing`` flag. While Clang delays; parsing of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst:4577,variab,variables,4577,interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MSVCCompatibility.rst,1,['variab'],['variables']
Modifiability,"es in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32088,config,configuration,32088,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['config'],"['config', 'configuration']"
Modifiability,"es include:. - ""VsPs""; - ""Gs""; - ""Cs""; - ""Ngg""; - ""Tess""; - ""GsTess""; - ""NggTess"". "".internal_pipeline_hash"" sequence of Required Internal compiler hash for this pipeline. Lower; 2 integers 64 bits is the ""stable"" portion of the hash, used; for e.g. shader replacement lookup. Upper 64 bits; is the ""unique"" portion of the hash, used for; e.g. pipeline cache lookup. The value is; implementation defined, and can not be relied on; between different builds of the compiler.; "".shaders"" map Per-API shader metadata. See; :ref:`amdgpu-amdpal-code-object-shader-map-table`; for the definition of the keys included in that; map.; "".hardware_stages"" map Per-hardware stage metadata. See; :ref:`amdgpu-amdpal-code-object-hardware-stage-map-table`; for the definition of the keys included in that; map.; "".shader_functions"" map Per-shader function metadata. See; :ref:`amdgpu-amdpal-code-object-shader-function-map-table`; for the definition of the keys included in that; map.; "".registers"" map Required Hardware register configuration. See; :ref:`amdgpu-amdpal-code-object-register-map-table`; for the definition of the keys included in that; map.; "".user_data_limit"" integer Number of user data entries accessed by this; pipeline.; "".spill_threshold"" integer The user data spill threshold. 0xFFFF for; NoUserDataSpilling.; "".uses_viewport_array_index"" boolean Indicates whether or not the pipeline uses the; viewport array index feature. Pipelines which use; this feature can render into all 16 viewports,; whereas pipelines which do not use it are; restricted to viewport #0.; "".es_gs_lds_size"" integer Size in bytes of LDS space used internally for; handling data-passing between the ES and GS; shader stages. This can be zero if the data is; passed using off-chip buffers. This value should; be used to program all user-SGPRs which have been; marked with ""UserDataMapping::EsGsLdsSize""; (typically only the GS and VS HW stages will ever; have a user-SGPR so marked).; "".nggSubgroupSize"" integer Explicit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:404630,config,configuration,404630,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['config'],['configuration']
Modifiability,"es one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implements a counting semaphore. Use a semaphore; to synchronize threads. The platform depen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3217,config,configures,3217,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['config'],['configures']
Modifiability,"es support this variable and can be used; on Windows to generate a suitable ``compile_commands.json`` that invokes; the MSVC compiler. First, you will need to install `Ninja`_. Once installed, the Ninja; executable will need to be in your search path for CMake to locate it. Next, assuming you already have Visual Studio installed on your machine, you; need to have the appropriate environment variables configured so that CMake; will locate the MSVC compiler for the Ninja generator. The `documentation; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#path_and_environment>`_; describes the necessary environment variable settings, but the simplest thing; is to use a `developer command-prompt window; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_prompt_shortcuts>`_; or call a `developer command file; <https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=msvc-170#developer_command_file_locations>`_; to set the environment variables appropriately. Now you can run CMake with the Ninja generator to export a compilation; database:. .. code-block:: console. C:\> mkdir build-ninja; C:\> cd build-ninja; C:\build-ninja> cmake -G Ninja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON path/to/llvm/sources. It is best to keep your Visual Studio IDE build folder separate from the; Ninja build folder. This prevents the two build systems from negatively; interacting with each other. Once the ``compile_commands.json`` file has been created by Ninja, you can; use that compilation database with Clang Tooling. One caveat is that because; there are indirect settings obtained through the environment variables,; you may need to run any Clang Tooling executables through a command prompt; window created for use with Visual Studio as described above. An; alternative, e.g. for using the Visual Studio debugger on a Clang Tooling; executable, is to ensure that the environment variables are also ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst:3360,variab,variables,3360,interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HowToSetupToolingForLLVM.rst,1,['variab'],['variables']
Modifiability,"es the following functions::. cppyy_add_bindings - Generate a set of bindings from a set of header files.; cppyy_find_pips - Return a list of available pip programs. cppyy_add_bindings; ^^^^^^^^^^^^^^^^^^. Generate a set of bindings from a set of header files. Somewhat like CMake's; add_library(), the output is a compiler target. In addition ancillary files; are also generated to allow a complete set of bindings to be compiled,; packaged and installed::. cppyy_add_bindings(; pkg; pkg_version; author; author_email; [URL url]; [LICENSE license]; [LANGUAGE_STANDARD std]; [LINKDEFS linkdef...]; [IMPORTS pcm...]; [GENERATE_OPTIONS option...]; [COMPILE_OPTIONS option...]; [INCLUDE_DIRS dir...]; [LINK_LIBRARIES library...]; [H_DIRS H_DIRSectory]; H_FILES h_file...). The bindings are based on https://cppyy.readthedocs.io/en/latest/, and can be; used as per the documentation provided via the cppyy.gbl namespace. First add; the directory of the <pkg>.rootmap file to the LD_LIBRARY_PATH environment; variable, then ""import cppyy; from cppyy.gbl import <some-C++-entity>"". Alternatively, use ""import <pkg>"". This convenience wrapper supports; ""discovery"" of the available C++ entities using, for example Python 3's command; line completion support. The bindings are complete with a setup.py, supporting Wheel-based; packaging, and a test.py supporting pytest/nosetest sanity test of the bindings. The bindings are generated/built/packaged using 3 environments:. - One compatible with the header files being bound. This is used to; generate the generic C++ binding code (and some ancillary files) using; a modified C++ compiler. The needed options must be compatible with the; normal build environment of the header files.; - One to compile the generated, generic C++ binding code using a standard; C++ compiler. The resulting library code is ""universal"" in that it is; compatible with both Python2 and Python3.; - One to package the library and ancillary files into standard Python2/3; wheel forma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst:4393,variab,variable,4393,bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/cmake_interface.rst,1,['variab'],['variable']
Modifiability,"es the operator.; class X { operator int() const; };. Matcher<Decl>cxxDeductionGuideDeclMatcher<CXXDeductionGuideDecl>...; Matches user-defined and implicitly generated deduction guide. Example matches the deduction guide.; template<typename T>; class X { X(int) };; X(int) -> X<int>;. Matcher<Decl>cxxDestructorDeclMatcher<CXXDestructorDecl>...; Matches explicit C++ destructor declarations. Example matches Foo::~Foo(); class Foo {; public:; virtual ~Foo();; };. Matcher<Decl>cxxMethodDeclMatcher<CXXMethodDecl>...; Matches method declarations. Example matches y; class X { void y(); };. Matcher<Decl>cxxRecordDeclMatcher<CXXRecordDecl>...; Matches C++ class declarations. Example matches X, Z; class X;; template<class T> class Z {};. Matcher<Decl>declMatcher<Decl>...; Matches declarations. Examples matches X, C, and the friend declaration inside C;; void X();; class C {; friend X;; };. Matcher<Decl>declaratorDeclMatcher<DeclaratorDecl>...; Matches declarator declarations (field, variable, function; and non-type template parameter declarations). Given; class X { int y; };; declaratorDecl(); matches int y. Matcher<Decl>decompositionDeclMatcher<DecompositionDecl>...; Matches decomposition-declarations. Examples matches the declaration node with foo and bar, but not; number.; (matcher = declStmt(has(decompositionDecl()))). int number = 42;; auto [foo, bar] = std::make_pair{42, 42};. Matcher<Decl>enumConstantDeclMatcher<EnumConstantDecl>...; Matches enum constants. Example matches A, B, C; enum X {; A, B, C; };. Matcher<Decl>enumDeclMatcher<EnumDecl>...; Matches enum declarations. Example matches X; enum X {; A, B, C; };. Matcher<Decl>fieldDeclMatcher<FieldDecl>...; Matches field declarations. Given; class X { int m; };; fieldDecl(); matches 'm'. Matcher<Decl>friendDeclMatcher<FriendDecl>...; Matches friend declarations. Given; class X { friend void foo(); };; friendDecl(); matches 'friend void foo()'. Matcher<Decl>functionDeclMatcher<FunctionDecl>...; Matches function declara",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:12387,variab,variable,12387,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"es to both conform to current language standards (up to C11; and C++11) and also to implement many widely-used extensions available; in other compilers, so that most correct code will ""just work"" when; compiled with Clang. However, Clang is more strict than other; popular compilers, and may reject incorrect code that other; compilers allow. This page documents common compatibility and; portability issues with Clang to help you understand and fix the; problem in your code when Clang emits an error message. C compatibility. C99 inline functions; ""missing"" vector __builtin functions; Lvalue casts; Jumps to within __block variable scope; Non-initialization of __block variables; Inline assembly. Objective-C compatibility. Cast of super; Size of interfaces; Internal Objective-C types; C variables in @class or @protocol. C++ compatibility. Variable-length arrays; Unqualified lookup in templates; Unqualified lookup into dependent bases of class templates; Incomplete types in templates; Templates with no valid instantiations; Default initialization of const; variable of a class type requires user-defined default; constructor; Parameter name lookup. C++11 compatibility. Deleted special member; functions. Objective-C++ compatibility. Implicit downcasts. Using class as a property name. C compatibility. C99 inline functions. By default, Clang builds C code in GNU C17 mode, so it uses standard C99; semantics for the inline keyword. These semantics are different; from those in GNU C89 mode, which is the default mode in versions of GCC; prior to 5.0. For example, consider the following code:. inline int add(int i, int j) { return i + j; }. int main() {; int i = add(4, 5);; return i;; }. In C99, inline means that a function's definition is; provided only for inlining, and that there is another definition; (without inline) somewhere else in the program. That; means that this program is incomplete, because if add; isn't inlined (for example, when compiling without optimization), then; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:1127,variab,variable,1127,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability,"es with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer curren",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3420,config,config,3420,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"es(CGAM);; PB.registerFunctionAnalyses(FAM);; PB.registerLoopAnalyses(LAM);; PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);. // Create the pass manager.; // This one corresponds to a typical -O2 optimization pipeline.; ModulePassManager MPM = PB.buildPerModuleDefaultPipeline(OptimizationLevel::O2);. // Optimize the IR!; MPM.run(MyModule, MAM);. The C API also supports most of this, see ``llvm-c/Transforms/PassBuilder.h``. Adding Passes to a Pass Manager; ===============================. For how to write a new PM pass, see :doc:`this page <WritingAnLLVMNewPMPass>`. To add a pass to a new PM pass manager, the important thing is to match the; pass type and the pass manager type. For example, a ``FunctionPassManager``; can only contain function passes:. .. code-block:: c++. FunctionPassManager FPM;; // InstSimplifyPass is a function pass; FPM.addPass(InstSimplifyPass());. If you want to add a loop pass that runs on all loops in a function to a; ``FunctionPassManager``, the loop pass must be wrapped in a function pass; adaptor that goes through all the loops in the function and runs the loop; pass on each one. .. code-block:: c++. FunctionPassManager FPM;; // LoopRotatePass is a loop pass; FPM.addPass(createFunctionToLoopPassAdaptor(LoopRotatePass()));. The IR hierarchy in terms of the new PM is Module -> (CGSCC ->) Function ->; Loop, where going through a CGSCC is optional. .. code-block:: c++. FunctionPassManager FPM;; // loop -> function; FPM.addPass(createFunctionToLoopPassAdaptor(LoopFooPass()));. CGSCCPassManager CGPM;; // loop -> function -> cgscc; CGPM.addPass(createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> cgscc; CGPM.addPass(createCGSCCToFunctionPassAdaptor(FunctionFooPass()));. ModulePassManager MPM;; // loop -> function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionFooPass(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:2076,adapt,adaptor,2076,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['adapt'],['adaptor']
Modifiability,"es, can not be instantiated, but their concrete; implementations can.; As the output of ``help`` showed, the ``Concrete`` constructor takes; an integer argument, that by default is 42. `Cross-inheritance`; -------------------. Python classes that derive from C++ classes can override virtual methods as; long as those methods are declared on class instantiation (adding methods to; the Python class after the fact will not provide overrides on the C++ side,; only on the Python side).; Example:. .. code-block:: python. >>> from cppyy.gbl import Abstract, call_abstract_method; >>> class PyConcrete(Abstract):; ... def abstract_method(self):; ... return ""Hello, Python World!\n""; ... def concrete_method(self):; ... pass; ...; >>> pc = PyConcrete(); >>> call_abstract_method(pc); Hello, Python World!; >>>. Note that it is not necessary to provide a constructor (``__init__``), but; if you do, you *must* call the base class constructor through the ``super``; mechanism. `Multiple cross-inheritance`; ----------------------------. Python requires that any multiple inheritance (also in pure Python) has an; unambiguous method resolution order (mro), including for classes and thus; also for meta-classes.; In Python2, it was possible to resolve any mro conflicts automatically, but; meta-classes in Python3, although syntactically richer, have functionally; become far more limited.; In particular, the mro is checked in the builtin class builder, instead of; in the meta-class of the meta-class (which in Python3 is the builtin ``type``; rather than the meta-class itself as in Python2, another limitation, and; which actually checks the mro a second time for no reason).; The upshot is that a helper is required (``cppyy.multi``) to resolve the mro; to support Python3.; The helper is written to also work in Python2.; Example:. .. code-block:: python. >>> class PyConcrete(cppyy.multi(cppyy.gbl.Abstract1, cppyy.gbl.Abstract2)):; ... def abstract_method1(self):; ... return ""first message""; ... de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:5346,inherit,inheritance,5346,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['inherit'],['inheritance']
Modifiability,"es. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; alignment. * ``UT_Always`` (in configuration: ``Always``); Use tabs whenever we need to fill whitespace that spans at least from; one tab stop to the next one. .. _VerilogBreakBetweenInstancePorts:. **VerilogBreakBetweenInstancePorts** (``Boolean``) :versionbadge:`clang-format 17` :ref:`¶ <VerilogBreakBetweenInstancePorts>`; For Verilog, put each port on its own line in module instantiations. .. code-block:: c++. true:; ffnand ff1(.q(),; .qbar(out1),; .clear(in1),; .preset(in2));. false:; ffnand ff1(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:132111,config,configuration,132111,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"es. It takes three; arguments: the pattern, the edit, and (optionally) an explanatory note. In our; example, the pattern (``functionDecl(...)``) identifies the declaration of the; function ``MkX``. Since we're just diagnosing the problem, but not suggesting a; fix, our edit is an no-op. But, it contains an *anchor* for the diagnostic; message: ``node(""fun"")`` says to associate the message with the source range of; the AST node bound to ""fun""; in this case, the ill-named function declaration.; Finally, we use ``cat`` to build a message that explains the change. Regarding the; name ``cat`` -- we'll discuss it in more detail below, but suffice it to say that; it can also take multiple arguments and concatenate their results. Note that the result of ``makeRule`` is a value of type; ``clang::transformer::RewriteRule``, but most users don't need to care about the; details of this type. Example: renaming a function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Now, let's extend this example to a *transformation*; specifically, the second; example above:. .. code-block:: c++. makeRule(declRefExpr(to(functionDecl(hasName(""MkX"")))),; 	 changeTo(cat(""MakeX"")),; 	 cat(""MkX has been renamed MakeX""));. In this example, the pattern (``declRefExpr(...)``) identifies any *reference* to; the function ``MkX``, rather than the declaration itself, as in our previous; example. Our edit (``changeTo(...)``) says to *change* the code matched by the; pattern *to* the text ""MakeX"". Finally, we use ``cat`` again to build a message; that explains the change. Here are some example changes that this rule would make:. +--------------------------+----------------------------+; | Original | Result |; +==========================+============================+; | ``X x = MkX(3);`` | ``X x = MakeX(3);`` |; +--------------------------+----------------------------+; | ``CallFactory(MkX, 3);`` | ``CallFactory(MakeX, 3);`` |; +--------------------------+----------------------------+; | ``auto f = MkX;`` | ``auto f = MakeX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:4431,extend,extend,4431,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['extend'],['extend']
Modifiability,"es: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39629,config,configuration,39629,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"es; int fFirstEntry = 0, fLastEntry = 10;; char tmp[20];; TGListBox *fListBox = new TGListBox(parent, 90);; for (i = fFirstEntry; i < fLastEntry; i++) {; sprintf(tmp, ""Entry %i"", i+1);; fListBox->AddEntry(tmp, i);; }; fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81136,flexible,flexible,81136,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['flexible'],['flexible']
Modifiability,"ese variables; was removed from MethodBase and MethodLikelihood. This also allows improved ; (full) PDF configuration of MVA output via the ""CreateMvaPdf"" option.; (Work by Or Cohen, CERN & Weizmann); ; New generalisation methods:. ; MethodCompositeBase: combines more than one; classifier within one. MethodBoost: boosts/bags any classifier; type. A special booking procedure for it was added to; Factory class. MethodDT: a classifier composed of a single; decision tree, boosted using MethodBoost. Results are; compatible with BDT, but BDT remains the default for boosted; decision trees, because it has pruning (among other; additional features). . Other improvements . Improved handling of small Likelihood values such that; Likelihood performance increases in analyses with many variables; (~>10). Thanks to Ralph Schaefer (Bonn U.) for reporting this. Nicer plotting: custom variable titles and units can be; assigned in ""AddVariable"" call. Introduced the inverse transformation InverseTransform for; the variable transformations into the framework. While this is; not necessary for classification, it is necessary for; regression. The inverse transformation of the normalization; transformation has been implemented. Started to extend the variable transformations to the; regression targets as well. MethodCuts now produces the 'optimal-cut' histograms needed; by macro mvaeffs.C. (macro 5a of TMVAGui.C); ; MsgLogger can be silenced in order to prevent excess output; during boosting. Third dataset type added centrally (Training, Validation; and Testing). The validation data is split off the original; training data set. Update of GUI and other Macros according to the new; features of PDF and the addition of MethodBoost.; ; Updates in TMVA 4.0.1. ""Spectator"" variables can be defined now which are computed; just as the input variables and which are written out into the; TestTree, but which don't participate in any MVA calculation; (useful for correlation studies).; ; New booking option",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:5381,variab,variable,5381,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,1,['variab'],['variable']
Modifiability,"ese, the fix is simple: switch to the *mmintrin.h functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5406,variab,variable,5406,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability,"esent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ``MemorySSA``; can infer. Changes made by different passes may make MemorySSA either ""overly; optimized"" (it can provide a more accurate result than if it were recomputed; from scratch), or ""under optimized"" (it could infer more if it were recomputed).; This can lead to challenges to reproduced results in isolation with a single pass; when the result relies on the state acquired by ``MemorySSA`` due to being updated by; multiple subsequent passes.; Passes that use and update ``MemorySSA`` should do so through the APIs provided by the; ``MemorySSAUpdater``, or through calls on the Walker.; Direct optimizations to ``MemorySSA`` are not permitted.; There is currently a single, narrowly scoped e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:18445,variab,variable,18445,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variable']
Modifiability,"eses. Possible values:. * ``SBPO_Never`` (in configuration: ``Never``); This is **deprecated** and replaced by ``Custom`` below, with all; ``SpaceBeforeParensOptions`` but ``AfterPlacementOperator`` set to; ``false``. * ``SBPO_ControlStatements`` (in configuration: ``ControlStatements``); Put a space before opening parentheses only after control statement; keywords (``for/if/while...``). .. code-block:: c++. void f() {; if (true) {; f();; }; }. * ``SBPO_ControlStatementsExceptControlMacros`` (in configuration: ``ControlStatementsExceptControlMacros``); Same as ``SBPO_ControlStatements`` except this option doesn't apply to; ForEach and If macros. This is useful in projects where ForEach/If; macros are treated as function calls instead of control statements.; ``SBPO_ControlStatementsExceptForEachMacros`` remains an alias for; backward compatibility. .. code-block:: c++. void f() {; Q_FOREACH(...) {; f();; }; }. * ``SBPO_NonEmptyParentheses`` (in configuration: ``NonEmptyParentheses``); Put a space before opening parentheses only if the parentheses are not; empty i.e. '()'. .. code-block:: c++. void() {; if (true) {; f();; g (x, y, z);; }; }. * ``SBPO_Always`` (in configuration: ``Always``); Always put a space before opening parentheses, except when it's; prohibited by the syntax rules (in function-like macro definitions) or; when determined by other style rules (after unary operators, opening; parentheses, etc.). .. code-block:: c++. void f () {; if (true) {; f ();; }; }. * ``SBPO_Custom`` (in configuration: ``Custom``); Configure each individual space before parentheses in; ``SpaceBeforeParensOptions``. .. _SpaceBeforeParensOptions:. **SpaceBeforeParensOptions** (``SpaceBeforeParensCustom``) :versionbadge:`clang-format 14` :ref:`¶ <SpaceBeforeParensOptions>`; Control of individual space before parentheses. If ``SpaceBeforeParens`` is set to ``Custom``, use this to specify; how each individual space before parentheses case should be handled.; Otherwise, this is ignored",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:117464,config,configuration,117464,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,esolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and def,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116142,inherit,inherited,116142,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inherited']
Modifiability,"espace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:174018,variab,variables,174018,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"esponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12520,config,config,12520,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"esponds to a developers’ intuitions, allowing them to make changes in; their code, and to see the result of these changes without interrupting the; running program. Interactive programming gives programmers the freedom to; explore different scenarios while developing software, writing one expression; at a time, figuring out what to do next at each step, and enabling them to; quickly identify and fix bugs whenever they arise. As an example, the; High-Energy Physics community includes professionals with a variety of; backgrounds, including physicists, nuclear engineers, and software; engineers. Cling allows for interactive data analysis in `ROOT; <https://root.cern/>`_ by giving researchers a way to prototype their C++ code,; allowing them to tailor it to the particular scope of the analysis they want to; pursue on a particular set of data before being added to the main framework. **Interpreted language** is a way to achieve interactive programming. In; statically compiled language, all source code is converted into native machine; code and then executed by the processor before being run. An interpreted; language instead runs through source programs line by line, taking an; executable segment of source code, turning it into machine code, and then; executing it. With this approach, when a change is made by the programmer, the; interpreter will convey it without the need for the entire source code to be; manually compiled. Interpreted languages are flexible, and offer features like; dynamic typing and smaller program size. **Cling** is not an interpreter, it is a Just-In-Time (JIT) compiler that feels; like an interpreter, and allows C++, a language designed to be compiled, to be; interpreted. When using Cling, the programmer benefits from both the power of; C++ language, such as high-performance, robustness, fastness, efficiency,; versatility, and the capability of an interpreter, which allows for interactive; exploration and on-the-fly inspection of the source-code.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst:1704,flexible,flexible,1704,interpreter/cling/docs/chapters/interactivity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/interactivity.rst,1,['flexible'],['flexible']
Modifiability,"ession's implicit object argument either; matches the InnerMatcher, or is a pointer to a type that matches the; InnerMatcher. Given; class Y { public: void m(); };; class X : public Y { void g(); };; void z() { Y y; y.m(); Y *p; p->m(); X x; x.m(); x.g(); }; cxxMemberCallExpr(thisPointerType(hasDeclaration(; cxxRecordDecl(hasName(""Y""))))); matches `y.m()`, `p->m()` and `x.m()`.; cxxMemberCallExpr(thisPointerType(hasDeclaration(; cxxRecordDecl(hasName(""X""))))); matches `x.g()`. Matcher<CXXMethodDecl>forEachOverriddenMatcher<CXXMethodDecl> InnerMatcher; Matches each method overridden by the given method. This matcher may; produce multiple matches. Given; class A { virtual void f(); };; class B : public A { void f(); };; class C : public B { void f(); };; cxxMethodDecl(ofClass(hasName(""C"")),; forEachOverridden(cxxMethodDecl().bind(""b""))).bind(""d""); matches once, with ""b"" binding ""A::f"" and ""d"" binding ""C::f"" (Note; that B::f is not overridden by C::f). The check can produce multiple matches in case of multiple inheritance, e.g.; class A1 { virtual void f(); };; class A2 { virtual void f(); };; class C : public A1, public A2 { void f(); };; cxxMethodDecl(ofClass(hasName(""C"")),; forEachOverridden(cxxMethodDecl().bind(""b""))).bind(""d""); matches twice, once with ""b"" binding ""A1::f"" and ""d"" binding ""C::f"", and; once with ""b"" binding ""A2::f"" and ""d"" binding ""C::f"". Matcher<CXXMethodDecl>ofClassMatcher<CXXRecordDecl> InnerMatcher; Matches the class declaration that the given method declaration; belongs to. FIXME: Generalize this for other kinds of declarations.; FIXME: What other kind of declarations would we need to generalize; this to?. Example matches A() in the last line; (matcher = cxxConstructExpr(hasDeclaration(cxxMethodDecl(; ofClass(hasName(""A"")))))); class A {; public:; A();; };; A a = A();. Matcher<CXXNewExpr>hasAnyPlacementArgMatcher<Expr> InnerMatcher; Matches any placement new expression arguments. Given:; MyClass *p1 = new (Storage) MyClass();; cxxNewExpr(hasAnyP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:160840,inherit,inheritance,160840,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"essor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4165,variab,variable,4165,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"est of Clang, the; analyzer is implemented as a C++ library that can be used by other tools and; applications.; Download. Mac OS X. Latest build (10.8+):. Release notes; This build can be used both from the command line and from within Xcode; Installation and usage. Other Platforms; For other platforms, please follow the instructions for building the analyzer from; source code. Viewing static analyzer results in Xcode. Viewing static analyzer results in a web browser. What is Static Analysis?; The term ""static analysis"" is conflated, but here we use it to mean; a collection of algorithms and techniques used to analyze source code in order; to automatically find bugs. The idea is similar in spirit to compiler warnings; (which can be useful for finding coding errors) but to take that idea a step; further and find bugs that are traditionally found using run-time debugging; techniques such as testing.; Static analysis bug-finding tools have evolved over the last several decades; from basic syntactic checkers to those that find deep bugs by reasoning about; the semantics of code. The goal of the Clang Static Analyzer is to provide a; industrial-quality static analysis framework for analyzing C, C++, and; Objective-C programs that is freely available, extensible, and has a high quality of implementation.; Part of Clang and LLVM; As its name implies, the Clang Static Analyzer is built on top of Clang and LLVM.; Strictly speaking, the analyzer is part of Clang, as Clang consists of a set of; reusable C++ libraries for building powerful source-level tools. The static; analysis engine used by the Clang Static Analyzer is a Clang library, and has; the capability to be reused in different contexts and by different clients.; Important Points to Consider; While we believe that the static analyzer is already very useful for finding; bugs, we ask you to bear in mind a few points when using it.; Work-in-Progress; The analyzer is a continuous work-in-progress. There are many planned; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/index.html:1383,evolve,evolved,1383,interpreter/llvm-project/clang/www/analyzer/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/index.html,1,['evolve'],['evolved']
Modifiability,"est, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; ```. Here argument ""multi"" identifies, that server response should be parsed with `parseMulti()` function, which correctly interprets JSON code, produced by `multi.json` request. When sending such request to the server, one should provide list of objects names and not forget ""?number=N"" parameter in the request URL string. ## Using unix sockets. Starting from ROOT version 6.28, one can start server with unix socket. Just do:. Just call:; ```cpp; [root] new THttpServer(""socket:/tmp/root.socket""); ```; Name of socket should be unique and not match any existing files. Most easy way to access `THttpServer` running via unix socket is to configure ssh tunnel:; ```; [shell] ssh -L 7654:/tmp/root.socket localhost; ```. Once such tunnel is configured one can open following URL in web browser:; ```; [shell] xdg-open http://localhost:7654; ```. ## Websockets supports. Websockets support available starting from ROOT v6.12.; Minimal example provided in [$ROOTSYS/tutorials/http/ws.C](https://root.cern/doc/master/ws_8C.html) macro. To work with websockets, subclass of [THttpWSHandler](https://root.cern/doc/master/classTHttpWSHandler.html) should be created and registered to THttpServer:. ```cpp; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; ```. Central method is `TUserHandler::ProcessWS(THttpCallArg *arg)`, where four kinds o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:24595,config,configure,24595,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['config'],['configure']
Modifiability,"esult in a Python ``ReferenceError`` exception. `Inheritance`; -------------. The output of help shows the inheritance hierarchy, constructors, public; methods, and public data.; For example, ``Concrete`` inherits from ``Abstract`` and it has; a constructor that takes an ``int`` argument, with a default value of 42.; Consider:. .. code-block:: python. >>> from cppyy.gbl import Abstract; >>> issubclass(Concrete, Abstract); True; >>> a = Abstract(); Traceback (most recent call last):; File ""<console>"", line 1, in <module>; TypeError: cannot instantiate abstract class 'Abstract'; >>> c = Concrete(); >>> isinstance(c, Concrete); True; >>> isinstance(c, Abstract); True; >>> d = Concrete(13); >>>. Just like in C++, interface classes that define pure virtual methods, such; as ``Abstract`` does, can not be instantiated, but their concrete; implementations can.; As the output of ``help`` showed, the ``Concrete`` constructor takes; an integer argument, that by default is 42. `Cross-inheritance`; -------------------. Python classes that derive from C++ classes can override virtual methods as; long as those methods are declared on class instantiation (adding methods to; the Python class after the fact will not provide overrides on the C++ side,; only on the Python side).; Example:. .. code-block:: python. >>> from cppyy.gbl import Abstract, call_abstract_method; >>> class PyConcrete(Abstract):; ... def abstract_method(self):; ... return ""Hello, Python World!\n""; ... def concrete_method(self):; ... pass; ...; >>> pc = PyConcrete(); >>> call_abstract_method(pc); Hello, Python World!; >>>. Note that it is not necessary to provide a constructor (``__init__``), but; if you do, you *must* call the base class constructor through the ``super``; mechanism. `Multiple cross-inheritance`; ----------------------------. Python requires that any multiple inheritance (also in pure Python) has an; unambiguous method resolution order (mro), including for classes and thus; also for meta-classes.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:4551,inherit,inheritance,4551,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['inherit'],['inheritance']
Modifiability,"et ${target}; COMMENT ""Performing ${target} for '${NEXT_CLANG_STAGE}'""; DEPENDEES configure; ALWAYS ${step_always}; EXCLUDE_FROM_MAIN ON; USES_TERMINAL 1; ). if(target MATCHES ""^stage[0-9]*""); add_custom_target(${target} DEPENDS ${NEXT_CLANG_STAGE}-${target}); endif(). ExternalProject_Add_StepTargets(${NEXT_CLANG_STAGE} ${target}); endforeach(); endif(). if (CLANG_BOLT_INSTRUMENT AND NOT LLVM_BUILD_INSTRUMENTED); set(CLANG_PATH ${LLVM_RUNTIME_OUTPUT_INTDIR}/clang); set(CLANG_INSTRUMENTED ${CLANG_PATH}-bolt.inst); set(BOLT_FDATA ${CMAKE_CURRENT_BINARY_DIR}/utils/perf-training/prof.fdata). # Instrument clang with BOLT; add_custom_target(clang-instrumented; DEPENDS ${CLANG_INSTRUMENTED}; ); add_custom_command(OUTPUT ${CLANG_INSTRUMENTED}; DEPENDS clang llvm-bolt; COMMAND llvm-bolt ${CLANG_PATH} -o ${CLANG_INSTRUMENTED}; -instrument --instrumentation-file-append-pid; --instrumentation-file=${BOLT_FDATA}; COMMENT ""Instrumenting clang binary with BOLT""; VERBATIM; ). # Optimize original (pre-bolt) Clang using the collected profile; set(CLANG_OPTIMIZED ${CMAKE_CURRENT_BINARY_DIR}/clang.bolt); add_custom_target(clang-bolt; DEPENDS ${CLANG_OPTIMIZED}; ); add_custom_command(OUTPUT ${CLANG_OPTIMIZED}; DEPENDS clang-bolt-profile; COMMAND llvm-bolt ${CLANG_PATH}; -o ${CLANG_OPTIMIZED}; -data ${BOLT_FDATA}; -reorder-blocks=ext-tsp -reorder-functions=hfsort+ -split-functions; -split-all-cold -split-eh -dyno-stats -icf=1 -use-gnu-stack; COMMAND ${CMAKE_COMMAND} -E rename ${CLANG_OPTIMIZED} $<TARGET_FILE:clang>; COMMENT ""Optimizing Clang with BOLT""; VERBATIM; ); endif(). if (LLVM_ADD_NATIVE_VISUALIZERS_TO_SOLUTION); add_subdirectory(utils/ClangVisualizers); endif(); add_subdirectory(utils/hmaptool). if(CLANG_BUILT_STANDALONE); llvm_distribution_add_targets(); process_llvm_pass_plugins(); endif(). set(CLANG_INSTALL_LIBDIR_BASENAME ""lib${CLANG_LIBDIR_SUFFIX}""). configure_file(; ${CLANG_SOURCE_DIR}/include/clang/Config/config.h.cmake; ${CLANG_BINARY_DIR}/include/clang/Config/config.h); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:32162,config,config,32162,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,2,['config'],['config']
Modifiability,"et int undef"". Instead, LLVM; produces ""ret int 0"":. int f() {; int x = 4;; int y;; if (x == 3) y = 0;; return y;; }. //===---------------------------------------------------------------------===//. The loop unroller should partially unroll loops (instead of peeling them); when code growth isn't too bad and when an unroll count allows simplification; of some code within the loop. One trivial example is:. #include <stdio.h>; int main() {; int nRet = 17;; int nLoop;; for ( nLoop = 0; nLoop < 1000; nLoop++ ) {; if ( nLoop & 1 ); nRet += 2;; else; nRet -= 1;; }; return nRet;; }. Unrolling by 2 would eliminate the '&1' in both copies, leading to a net; reduction in code size. The resultant code would then also be suitable for; exit value computation. //===---------------------------------------------------------------------===//. We miss a bunch of rotate opportunities on various targets, including ppc, x86,; etc. On X86, we miss a bunch of 'rotate by variable' cases because the rotate; matching code in dag combine doesn't look through truncates aggressively ; enough. Here are some testcases reduces from GCC PR17886:. unsigned long long f5(unsigned long long x, unsigned long long y) {; return (x << 8) | ((y >> 48) & 0xffull);; }; unsigned long long f6(unsigned long long x, unsigned long long y, int z) {; switch(z) {; case 1:; return (x << 8) | ((y >> 48) & 0xffull);; case 2:; return (x << 16) | ((y >> 40) & 0xffffull);; case 3:; return (x << 24) | ((y >> 32) & 0xffffffull);; case 4:; return (x << 32) | ((y >> 24) & 0xffffffffull);; default:; return (x << 40) | ((y >> 16) & 0xffffffffffull);; }; }. //===---------------------------------------------------------------------===//. This (and similar related idioms):. unsigned int foo(unsigned char i) {; return i | (i<<8) | (i<<16) | (i<<24);; } . compiles into:. define i32 @foo(i8 zeroext %i) nounwind readnone ssp noredzone {; entry:; %conv = zext i8 %i to i32; %shl = shl i32 %conv, 8; %shl5 = shl i32 %conv, 16; %shl9 = shl i3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:16646,variab,variable,16646,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['variab'],['variable']
Modifiability,"et or RooDataSet instances, please consider using the new `RooArgSet::uniqueId()` or `RooAbsData::uniqueId()`. ### Introducing binned likelihood fit optimization in HistFactory. In a binned likelihood fit, it is possible to skip the PDF normalization when; the unnormalized binned PDF can be interpreted directly in terms of event; yields. This is now done by default for HistFactory models, which; results in great speedups for binned fits with many channels. Some RooFit users; like ATLAS were already using this for a long time. To disable this optimization when using the `hist2workspace` executable, add the `-disable_binned_fit_optimization` command line argument.; Directly in C++, you can also set the `binnedFitOptimization` to `false` in the; HistFactory configuration as follows:; ```C++; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, {.binnedFitOptimization=false});; ```; If your compiler doesn't support aggregate initialization with designators, you; need to create and edit the configuration struct explicitely:; ```C++; RooStats::HistFactory::HistoToWorkspaceFactoryFast::Configuration hfCfg;; hfCfg.binnedFitOptimization = false;; RooStats::HistFactory::MakeModelAndMeasurementFast(measurement, hfCfg);; ```. ### Disable copy assignment for RooAbsArg and derived types. Copy assignment for RooAbsArgs was implemented in an unexpected and; inconsistent way. While one would expect that the copy assignment is copying; the object, it said in the documentation of `RooAbsArg::operator=` that it will; ""assign all boolean and string properties of the original bject. Transient; properties and client-server links are not assigned."" This contradicted with; the implementation, where the server links were actually copied too.; Furthermore, in `RooAbsRealLValue`, the assigment operator was overloaded by a; function that only assigns the value of another `RooAbsReal`. With all these inconsistencies, it was deemed safer to disable copy assignment; of RooAbsArgs from no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:20985,config,configuration,20985,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['config'],['configuration']
Modifiability,"et tessellation. The **`TGraph2D`** class has the following constructors:. - With an arrays' dimension `n` and three arrays `x`, `y`, and `z`; (can be arrays of doubles, floats, or integers):. ``` {.cpp}; TGraph2D *g = new TGraph2D(n,x,y,z);; ```. - With an array dimension only:. ``` {.cpp}; TGraph2D *g = new TGraph2D(n);; ```. - Internal arrays are filled with the method `SetPoint` at the; position ""`i`"" with the values `x`, `y`, `z`:. ``` {.cpp}; g->SetPoint(i,x,y,z);; ```. - Without parameters; the method `SetPoint` must be used to fill the; internal arrays. ``` {.cpp}; TGraph2D *g = new TGraph2D();; ```. - From a file:. ``` {.cpp}; TGraph2D *g = new TGraph2D(""graph.dat"");; ```. The arrays are read from the ASCII file ""`graph.dat`"" according to a; specified format. The format's default value is ""`%lg %lg %lg`"". Note; that in any of last three cases, the `SetPoint` method can be used to; change a data point or to add a new one. If the data point index (`i`); is greater than the size of the internal arrays, they are; automatically extended. Specific drawing options can be used to paint a **`TGraph2D`**:. - ""`TRI`"" the Delaunay triangles are drawn using filled area. A; hidden surface drawing technique is used. The surface is painted; with the current fill area color. The edges of the triangles are; painted with the current line color;. - ""`TRIW`""the Delaunay triangles are drawn as wire frame;. - ""`TRI1`"" the Delaunay triangles are painted with color levels. The; edges of the triangles are painted with the current line color;. - ""`TRI2`"" the Delaunay triangles are painted with color levels;. - ""`P`""draws a marker at each vertex;. - ""`P0`"" draws a circle at each vertex. Each circle background is; white. A **`TGraph2D`** can be also drawn with ANY options valid for 2D; histogram drawing. In this case, an intermediate 2D histogram is; filled using the Delaunay triangles technique to interpolate the data; set. **`TGraph2D`** linearly interpolate a `Z` value for any `(X,Y",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md:18277,extend,extended,18277,documentation/users-guide/Graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphs.md,1,['extend'],['extended']
Modifiability,"et your system up to; execute LLVM bitcode files directly. To do this, use commands like this (the; first command may not be required if you are already using the module):. .. code-block:: console. % mount -t binfmt_misc none /proc/sys/fs/binfmt_misc; % echo ':llvm:M::BC::/path/to/lli:' > /proc/sys/fs/binfmt_misc/register; % chmod u+x hello.bc (if needed); % ./hello.bc. This allows you to execute LLVM bitcode files directly. On Debian, you can also; use this command instead of the 'echo' command above:. .. code-block:: console. % sudo update-binfmts --install llvm /path/to/lli --magic 'BC'. .. _Program Layout:; .. _general layout:. Directory Layout; ================. One useful source of information about the LLVM source base is the LLVM `doxygen; <http://www.doxygen.org/>`_ documentation available at; `<https://llvm.org/doxygen/>`_. The following is a brief introduction to code; layout:. ``llvm/cmake``; --------------; Generates system build files. ``llvm/cmake/modules``; Build configuration for llvm user defined options. Checks compiler version and; linker flags. ``llvm/cmake/platforms``; Toolchain configuration for Android NDK, iOS systems and non-Windows hosts to; target MSVC. ``llvm/examples``; -----------------. - Some simple examples showing how to use LLVM as a compiler for a custom; language - including lowering, optimization, and code generation. - Kaleidoscope Tutorial: Kaleidoscope language tutorial run through the; implementation of a nice little compiler for a non-trivial language; including a hand-written lexer, parser, AST, as well as code generation; support using LLVM- both static (ahead of time) and various approaches to; Just In Time (JIT) compilation.; `Kaleidoscope Tutorial for complete beginner; <https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/index.html>`_. - BuildingAJIT: Examples of the `BuildingAJIT tutorial; <https://llvm.org/docs/tutorial/BuildingAJIT1.html>`_ that shows how LLVM’s; ORC JIT APIs interact with other parts of LLVM. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:34210,config,configuration,34210,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['config'],['configuration']
Modifiability,"et(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8926,variab,variable,8926,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['variab'],['variable']
Modifiability,"et. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_unittest`` in; the subdirectories of *unittests* for a complete list of unit tests.) It is; possible to build all unit tests with the target *UnitTests*. **LLVM_BUILD_TOOLS**:BOOL; Build LLVM tools. Defaults to ON. Targets for building each tool are generated; in any case. You can build a tool separately by invoking its target. For; example, you can build *llvm-as* with a Makefile-based system by executing *make; llvm-as* at the root of your build directory. **LLVM_CCACHE_BUILD**:BOOL; If enabled and the ``ccache`` program is available, then LLVM will be; built using ``ccache`` to speed up rebuilds of LLVM and its components.; Defaults to OFF. The size and location of the cache maintained; by ``ccache`` can be adjusted via the LLVM_CCACHE_MAXSIZE and LLVM_CCACHE_DIR; options, which are passed to the CCACHE_MAXSIZE and CCACHE_DIR environment; variables, respectively. **LLVM_CREATE_XCODE_TOOLCHAIN**:BOOL; macOS Only: If enabled CMake will generate a target named; 'install-xcode-toolchain'. This target will create a directory at; $CMAKE_INSTALL_PREFIX/Toolchains containing an xctoolchain directory which can; be used to override the default system tools. **LLVM_<target>_LINKER_FLAGS**:STRING; Defines the set of linker flags that should be applied to a <target>. **LLVM_DEFAULT_TARGET_TRIPLE**:STRING; LLVM target to use for code generation when no target is explicitly specified.; It defaults to ""host"", meaning that it shall pick the architecture; of the machine where LLVM is being built. If you are building a cross-compiler,; set it to the target triple of your desired architecture. **LLVM_DOXYGEN_QCH_FILENAME**:STRING; The filename of the Qt Compressed Help file that will be generated when; ``-DLLVM_ENABLE_DOXYGEN=ON`` and; ``-DLLVM_ENABLE_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:17820,variab,variables,17820,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,et_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/ve/src/rtl.cpp; openmp/libomptarget/src/api.cpp; openmp/libomptarget/src/interface.cpp; openmp/libomptarget/src/interop.cpp; openmp/libomptarget/src/omptarget.cpp; openmp/libomptarget/src/private.h; openmp/libomptarget/src/rtl.cpp; openmp/libomptarget/tools/deviceinfo/llvm-omp-device-info.cpp; openmp/runtime/doc/doxygen/libomp_interface.h; openmp/runtime/src/extractExternal.cpp; openmp/runtime/src/kmp.h; openmp/runtime/src/kmp_affinity.h; openmp/runtime/src/kmp_alloc.cpp; openmp/runtime/src/kmp_atomic.cpp; openmp/runtime/src/kmp_atomic.h; openmp/runtime/src/kmp_barrier.h; openmp/runtime/src/kmp_cancel.cpp; openmp/runtime/src/kmp_debug.cpp; openmp/runtime/src/kmp_debug.h; openmp/runtime/src/kmp_debugger.cpp; openmp/runtim,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407969,plugin,plugins,407969,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"etadata). This intrinsic provides information when a user source variable is set to a new; value. The first argument is the new value (wrapped as metadata). The second; argument is a `local variable <LangRef.html#dilocalvariable>`_ containing a; description of the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.value` intrinsic describes the *value* of a source variable; directly, not its address. Note that the value operand of this intrinsic may; be indirect (i.e, a pointer to the source variable), provided that interpreting; the complex expression derives the direct value. ``llvm.dbg.assign``; ^^^^^^^^^^^^^^^^^^^; .. toctree::; :hidden:. AssignmentTracking. .. code-block:: llvm. void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression). This intrinsic marks the position in IR where a source assignment occurred. It; encodes the value of the variable. It references the store, if any, that; performs the assignment, and the destination address. The first three arguments are the same as for an ``llvm.dbg.value``. The fourth; argument is a ``DIAssignID`` used to reference a store. The fifth is the; destination of the store (wrapped as metadata), and the sixth is a `complex; expression <LangRef.html#diexpression>`_ that modifies it. The formal LLVM-IR signature is:. .. code-block:: llvm. void @llvm.dbg.assign(metadata, metadata, metadata, metadata, metadata, metadata). See :doc:`AssignmentTracking` for more info. Object lifetimes and scoping; ============================. In many languages, the local variables in functions can have their lifetimes or; scopes limited to a subset of a function. In the C family of languages, for; example, variables are only live (readable and writable) within the source; block that they are defined in. In functional languages, values are only; readable after they have been defined. Thoug",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:11267,variab,variable,11267,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"etail::RooFit::Detail::CodeSquashContext &ctx) const; {; std::string xName = ctx.getResult(x);; if (!_noRounding); xName = ""std::floor("" + xName + "")"";; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::poissonEvaluate"", xName, mean));; }; ```. Here we can see that the name of the variable `x` (remember that ""x"" is a; member of RooPoisson) is retrieved and stored in the `xName` variable. Next,; there's an `if` condition that does an operation on `x` (may or may not round; it to the nearest integer, depending on the condition). The important part is where the `RooPoisson::addResult()` function helps add; the result of evaluating the Poisson function to the context (`ctx`). It uses; the `RooPoisson::buildCall()` method to construct a function call to the fully; qualified name of `MathFuncs::poissonEvaluate` (which now resides in the; `MathFuncs` file), with arguments `xName` and `mean`. Essentially, the `RooPoisson::translate()` function constructs a function call; to evaluate the Poisson function using 'x' and 'mean' variables, and adds the; result to the context. Helper Functions:. - `getResult()` helps lookup the result of a child node (the string that the; child node previously saved in a variable using the `addResult()` function). - `addResult()` It may include a function call, an expression, or something; more complicated. For a specific class, it will add whatever is represented on; the right-hand side to the result of that class, which can then be propagated; in the rest of the compute graph. \note For each `translate()` function, it is important to call `addResult()` since this is what enables the squashing to happen. **translate() Example 2:** Following is a code snippet from `RooGaussian.cxx`; *after* it has AD support. ``` {.cpp}; void RooGaussian::translate(RooFit::Detail::RooFit::Detail::CodeSquashContext &ctx) const; {; ctx.addResult(this, ctx.buildCall(""RooFit::Detail::MathFuncs::gaussianEvaluate"", x, mean, sigma));; }; ```. Here we can see",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:13304,variab,variables,13304,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['variab'],['variables']
Modifiability,"ete; language that can calculate a wide variety of numeric functions. Next up; we'll add another useful expression that is familiar from non-functional; languages... 'for' Loop Expression; =====================. Now that we know how to add basic control flow constructs to the; language, we have the tools to add more powerful things. Let's add; something more aggressive, a 'for' expression:. ::. extern putchard(char);; def printstar(n); for i = 1, i < n, 1.0 in; putchard(42); # ascii 42 = '*'. # print 100 '*' characters; printstar(100);. This expression defines a new variable (""i"" in this case) which iterates; from a starting value, while the condition (""i < n"" in this case) is; true, incrementing by an optional step value (""1.0"" in this case). If; the step value is omitted, it defaults to 1.0. While the loop is true,; it executes its body expression. Because we don't have anything better; to return, we'll just define the loop as always returning 0.0. In the; future when we have mutable variables, it will get more useful. As before, let's talk about the changes that we need to Kaleidoscope to; support this. Lexer Extensions for the 'for' Loop; -----------------------------------. The lexer extensions are the same sort of thing as for if/then/else:. .. code-block:: c++. ... in enum Token ...; // control; tok_if = -6, tok_then = -7, tok_else = -8,; tok_for = -9, tok_in = -10. ... in gettok ...; if (IdentifierStr == ""def""); return tok_def;; if (IdentifierStr == ""extern""); return tok_extern;; if (IdentifierStr == ""if""); return tok_if;; if (IdentifierStr == ""then""); return tok_then;; if (IdentifierStr == ""else""); return tok_else;; if (IdentifierStr == ""for""); return tok_for;; if (IdentifierStr == ""in""); return tok_in;; return tok_identifier;. AST Extensions for the 'for' Loop; ---------------------------------. The AST node is just as simple. It basically boils down to capturing the; variable name and the constituent expressions in the node. .. code-block:: c++. /// ForEx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:15965,variab,variables,15965,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,eted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; Unknown. 1856; open; Indirect nested classes of class templates; Not resolved. 1857; CD5; Additional questions about bits; Unknown. 1858; CD4; Comparing pointers to union members; Unknown. 1859; CD5; UTF-16 in char16_t string literals; Unknown. 1860; C++17; What is a “direct member?,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125313,variab,variable,125313,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"eter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; line",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:7778,variab,variable,7778,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"etermine that distinct different path names for the same; hard linked file actually are equal. This is an intentional tradeoff in a; bug fix, where the bug used to cause distinct files to be considered; equivalent on some file systems. This change fixed the issues; https://github.com/llvm/llvm-project/issues/61401 and; https://github.com/llvm/llvm-project/issues/22079. Changes to the X86 Backend; --------------------------. * The ``i128`` type now matches GCC and clang's ``__int128`` type. This mainly; benefits external projects such as Rust which aim to be binary compatible; with C, but also fixes code generation where LLVM already assumed that the; type matched and called into libgcc helper functions.; * Support ISA of ``USER_MSR``.; * Support ISA of ``AVX10.1-256`` and ``AVX10.1-512``.; * ``-mcpu=pantherlake`` and ``-mcpu=clearwaterforest`` are now supported.; * ``-mapxf`` is supported.; * Marking global variables with ``code_model = ""small""/""large""`` in the IR now; overrides the global code model to allow 32-bit relocations or require 64-bit; relocations to the global variable.; * The medium code model's code generation was audited to be more similar to the; small code model where possible. Changes to the OCaml bindings; -----------------------------. Changes to the Python bindings; ------------------------------. * The python bindings have been removed. Changes to the C API; --------------------. * Added ``LLVMGetTailCallKind`` and ``LLVMSetTailCallKind`` to; allow getting and setting ``tail``, ``musttail``, and ``notail``; attributes on call instructions.; * The following functions for creating constant expressions have been removed,; because the underlying constant expressions are no longer supported. Instead,; an instruction should be created using the ``LLVMBuildXYZ`` APIs, which will; constant fold the operands if possible and create an instruction otherwise:. * ``LLVMConstAnd``; * ``LLVMConstOr``; * ``LLVMConstLShr``; * ``LLVMConstAShr``; * ``LLVMConstZEx",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:9931,variab,variables,9931,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"eters like one do it in URL string:. ```html; <div id=""simpleGUI"" path=""files/path"" files=""userfile1.root;subdir/usefile2.root"">; loading scripts ...; </div>; ```. ## Reading local ROOT files. JSROOT can read files from local file system using HTML5 FileReader functionality.; Main limitation here - user should interactively select files for reading.; There is button __""...""__ on the main JSROOT page, which starts file selection dialog.; If valid ROOT file is selected, JSROOT will be able to normally read content of such file. ## JSROOT with THttpServer. THttpServer provides http access to objects from running ROOT application.; JSROOT is used to implement the user interface in the web browsers. The layout of the main page coming from THttpServer is very similar to normal JSROOT page.; One could browse existing items and display them. A snapshot of running; server can be seen on the [demo page](https://root.cern/js/latest/httpserver.C/). One could also specify similar URL parameters to configure the displayed items and drawing options. It is also possible to display one single item from the THttpServer server like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hpxpy/draw.htm?opt=colz>. ## Data monitoring with JSROOT. ### Monitoring with http server. The best possibility to organize the monitoring of data from a running application; is to use THttpServer. In such case the client can always access the latest; changes and request only the items currently displayed in the browser.; To enable monitoring, one should activate the appropriate checkbox or; provide __monitoring__ parameter in the URL string like:. <https://root.cern/js/latest/httpserver.C/Files/job1.root/hprof/draw.htm?monitoring=1000>. The parameter value is the update interval in milliseconds. ### JSON file-based monitoring. Solid file-based monitoring (without integration of THttpServer into application) can be; implemented in JSON format. There is the [TBufferJSON](https://root.cern/doc/master",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:30212,config,configure,30212,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"etrieve it in the callback:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr(to(; varDecl(hasType(isInteger())).bind(""incrementVariable"")))))). We can add this code to the definition of ``LoopMatcher`` and make sure; that our program, outfitted with the new matcher, only prints out loops; that declare a single variable initialized to zero and have an increment; step consisting of a unary increment of some variable. Now, we just need to add a matcher to check if the condition part of the; ``for`` loop compares a variable against the size of the array. There is; only one problem - we don't know which array we're iterating over; without looking at the body of the loop! We are again restricted to; approximating the result we want with matchers, filling in the details; in the callback. So we start with:. .. code-block:: c++. hasCondition(binaryOperator(hasOperatorName(""<""))). It makes sense to ensure that the left-hand side is a reference to a; variable, and that the right-hand side has integer type. .. code-block:: c++. hasCondition(binaryOperator(; hasOperatorName(""<""),; hasLHS(declRefExpr(to(varDecl(hasType(isInteger()))))),; hasRHS(expr(hasType(isInteger()))))). Why? Because it doesn't work. Of the three loops provided in; ``test-files/simple.cpp``, zero of them have a matching condition. A; quick look at the AST dump of the first for loop, produced by the; previous iteration of loop-convert, shows us the answer:. ::. (ForStmt 0x173b240; (DeclStmt 0x173afc8; 0x173af50 ""int i =; (IntegerLiteral 0x173afa8 'int' 0)""); <<>>; (BinaryOperator 0x173b060 '_Bool' '<'; (ImplicitCastExpr 0x173b030 'int'; (DeclRefExpr 0x173afe0 'int' lvalue Var 0x173af50 'i' 'int')); (ImplicitCastExpr 0x173b048 'int'; (DeclRefExpr 0x173b008 'const int' lvalue Var 0x170fa80 'N' 'const int'))); (UnaryOperator 0x173b0b0 'int' lvalue prefix '++'; (DeclRefExpr 0x173b088 'int' lvalue Var 0x173af50 'i' 'int')); (CompoundStatement ... We already know ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:13711,variab,variable,13711,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"etry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done like:. ``` {.cpp}; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; ```. ### Initializing the Direction. In order to move inside geometry starting with the current point, the; modeller needs to know the current ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103578,variab,variables,103578,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variables']
Modifiability,"ets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names - or a TFileCollection: the output; of TFileCollection::GetFilesPerServer() can be directly passed as files; map). Workers are first assigned files belonging to; the list with host name matching the worker name. The map is; distributed to the master via the input list.Add support for; automatic setting of pointer data members to the relevant object in the; output list. The use of fOutputList->FindObject(""name"") in; TSelector::Terminate is not needed anymore for pointer data members,; e.g. histograms.; Add the possibility to define an external list of environment; variables to be transmitted to the master and workers. This is done via; the environment variable PROOF_ENVVARS. This addition allows to change; the variables wthout changing the macro or application running; TProof::Open.; Add the possibility to save the perfomance information shown; by the dialog into a small ntuple included in the output list. The; ntuple contains 5 floats (processing time, number of active workers,; event rate, MBytes read, number of effective sessions on the cluster); and it is filled each time the number of active workers changes or at; max 100 regular intervals at least 5 secs apart; in this way the ntuple; has at most O(100 entries + number of workers). To enable the saving of; the ntuple execute the following:;         proof->SetParameter(""PROOF_SaveProgressPerf"", ""yes"");; before running the query. The ntuple is called 'PROOF_ProgressPerfNtuple'.; Add support for worker autodiscovery in PROOF using the; Avahi/Bonjour technology. The new functionality is supported on Mac; (MacOsX >= 10.4; no need of additional installs) and linux (requires; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:2880,variab,variable,2880,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,1,['variab'],['variable']
Modifiability,"etters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float 8 bytes. - **`Double32_t`** Double 8 bytes in memory, written as a Float 4; bytes. - **`Bool_t`** Boolean (0=false, 1=true). If you do not want to save a variable on disk, you can use `int` or; `Int_t`, the result will be the same and the interpreter or the; compiler will treat them in exactly the same way. ### TObject. In ROOT, almost all classes inherit from a common base class called; **`TObject`**. This kind of architecture is also used in the Java; language. The **`TObject`** class provides default behavior and; protocol for all objects in the ROOT system. The main advantage of; this approach is that it enforces the common behavior of the derived; classes and consequently it ensures the consistency of the whole; system. See ""The Role of TObject"". **`TObject`** provides protocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:30973,variab,variable,30973,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variable']
Modifiability,"etting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_BUILD*, *LLVM_ENABLE_PROJECTS*,; *LLVM_ENABLE_RUNTIMES*, *LLVM_BUILD_LLVM_DYLIB*, and *LLVM_LINK_LLVM_DYLIB*. **LLVM_ENABLE_RUNTIMES**:STRING; When building a distribution that includes LLVM runtime projects (i.e. libcxx,; compiler-rt, libcxxabi, libunwind...), it is important to build those projects; with the just-built compiler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:11512,variab,variable,11512,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"etting up the; code, to compiling, loading, and executing it. After the basics are down, more; advanced features are discussed. .. warning::; This document deals with the legacy pass manager. LLVM uses the new pass; manager for the optimization pipeline (the codegen pipeline; still uses the legacy pass manager), which has its own way of defining; passes. For more details, see :doc:`WritingAnLLVMNewPMPass` and; :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""Hello"" pass is; designed to simply print out the name of non-external functions that exist in; the program being compiled. It does not modify the program at all, it just; inspects it. The source code and files for this pass are available in the LLVM; source tree in the ``lib/Transforms/Hello`` directory. .. _writing-an-llvm-pass-makefile:. Setting up the build environment; --------------------------------. First, configure and build LLVM. Next, you need to create a new directory; somewhere in the LLVM source base. For this example, we'll assume that you; made ``lib/Transforms/Hello``. Finally, you must set up a build script; that will compile the source code for the new pass. To do this,; copy the following into ``CMakeLists.txt``:. .. code-block:: cmake. add_llvm_library( LLVMHello MODULE; Hello.cpp. PLUGIN_TOOL; opt; ). and the following line into ``lib/Transforms/CMakeLists.txt``:. .. code-block:: cmake. add_subdirectory(Hello). (Note that there is already a directory named ``Hello`` with a sample ""Hello""; pass; you may play with it -- in which case you don't need to modify any; ``CMakeLists.txt`` files -- or, if you want to create everything from scratch,; use another name.). This build script specifies that ``Hello.cpp`` file in the current directory; is to be compiled and linked into a shared object ``$(LEVEL)/lib/LLVMHello.so`` that; can be dynamically loaded by the :program:`opt` tool via its :o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:2482,config,configure,2482,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['config'],['configure']
Modifiability,"etup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1684,config,configuration,1684,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,3,"['config', 'variab']","['configuration', 'configurations', 'variables']"
Modifiability,"eturn adr[0] | (adr[1] << 8);; }; unsigned short read_16_be(const unsigned char *adr) {; return (adr[0] << 8) | adr[1];; }. //===---------------------------------------------------------------------===//. -instcombine should handle this transform:; icmp pred (sdiv X / C1 ), C2; when X, C1, and C2 are unsigned. Similarly for udiv and signed operands. . Currently InstCombine avoids this transform but will do it when the signs of; the operands and the sign of the divide match. See the FIXME in ; InstructionCombining.cpp in the visitSetCondInst method after the switch case ; for Instruction::UDiv (around line 4447) for more details. The SingleSource/Benchmarks/Shootout-C++/hash and hash2 tests have examples of; this construct. . //===---------------------------------------------------------------------===//. [LOOP OPTIMIZATION]. SingleSource/Benchmarks/Misc/dt.c shows several interesting optimization; opportunities in its double_array_divs_variable function: it needs loop; interchange, memory promotion (which LICM already does), vectorization and; variable trip count loop unrolling (since it has a constant trip count). ICC; apparently produces this very nice code with -ffast-math:. ..B1.70: # Preds ..B1.70 ..B1.69; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; mulpd %xmm0, %xmm1 #108.2; addl $8, %edx #; cmpl $131072, %edx #108.2; jb ..B1.70 # Prob 99% #108.2. It would be better to count down to zero, but this is a lot better than what we; do. //===---------------------------------------------------------------------===//. Consider:. typedef unsigned U32;; typedef unsigned long long U64;; int test (U32 *inst, U64 *regs) {; U64 effective_addr2;; U32 temp = *inst;; int r1 = (temp >> 20) & 0xf;; int b2 = (temp >> 16) & 0xf;; effective_addr2 = temp & 0xfff;; if (b2) effective_addr2 += regs[b2];; b2 = (temp >> 12) & 0xf;; if (b2) effective_addr2 += regs[b2];; effective_addr2 &= regs[4];; if ((effective_addr2 & 3) == 0); return 1;; return 0;; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt:8488,variab,variable,8488,interpreter/llvm-project/llvm/lib/Target/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/README.txt,1,['variab'],['variable']
Modifiability,"etween ""text"" and \#lambda were ignored. ``` {.cpp}; TLatex t; t.DrawLatex( 0.1,0.1,""text \#Lambda"" ); ```. - Implement `#backslash`.; - Implement `DrawLatexNDC`.; - Implement `#minus` and `#plus` typographically better than the; standard `""-""` and `""+""`.; - Make sure all greek and math symbols are printed correctly by `TTexDump`.; - Implement dummy operators `#mbox` and `#hbox` to improve the compatibility; between `TLatex`, `TMathText` and `TTexDump`.; - Some operators like `#minus`, `#plus`, `#mp`, `#hbar` etc ...; ignored the color defined by the operator `#color`.; - With the Cocoa backend on Mac the text string were a bit too large; compared to the TTF rendering. ### TPave. - Implement `SetX1()` etc ... for `TPave` and inherited classes to make sure the; NDC coordinates are also defined. ### TLinearGradient and TRadialGradient. - Two new classes to support color gradient: `TLinearGradient` and `TRadialGradient`.; Both classes inherit from `TColor` and can be used the same way as ROOT's; standard colors in `TAttFill` (`SetFillColor(newColorIndex)`).; Gradient fill can be created using either RGBA values directly, or from; color indices (colors from the ROOT's color table).; - TRadialGradient supports a simple radial gradient (center + radius); and an ""extended"" radial gradient (starting/ending points + two radii).; - The new gradient fill option is available either with OpenGL (""gl-in-pad""); or with a Cocoa backend (OS X only).; - Please note, at the moment, a color gradient can not be saved; in a ROOT file or a pdf/ps file. It can be saved as an image (png/jpg etc.).; - There are several demos in the tutorials/cocoa and tutorials/gl sub-directories; explaining how to use these new classes:; * grad.C; * grad2.C; * radialgradients.C. ![TRadialGradient example](ellipses.png ""TEllipse objects with a radial gradient fill""). ![TLinearGradient example](lingrad.png ""Two histograms with a linear gradient fill and transparency""). ![Gradient example](mixgrad.png ""TPie wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md:7773,inherit,inherit,7773,graf2d/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v600/index.md,1,['inherit'],['inherit']
Modifiability,"event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22070,adapt,adaptive,22070,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['adapt'],['adaptive']
Modifiability,"ever written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to write a streamer for a class that ROOT cannot handle, the user may need; to explicitly code the decomposition and composition of the object to its members.; In this case, th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8740,variab,variable,8740,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['variab'],['variable']
Modifiability,eviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openmp/runtime/src/thirdparty/ittnotify/legacy; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/archer/tests/ompt; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/tools/multiplex/tests; - `1`; - `1`; - `0`; - :good,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122601,plugin,plugins,122601,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"evious value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in the symbol table,; we evaluate the body of the var/in expression:. .. code-block:: c++. // Codegen the body, now that all vars are in scope.; Value *BodyVal = Body->codegen();; if (!BodyVal); return nullptr;. Finally, before returning, we restore the previous variable bindings:. .. code-block:: c++. // Pop all our variables from scope.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i); NamedValues[VarNames[i].first] = OldBindings[i];. // Return the body computation.; return BodyVal;; }. The end result of all of this is that we get properly scoped variable; definitions, and we even (trivially) allow mutation of them :). With this, we completed what we set out to do. Our nice iterative fib; example from the intro compiles and runs just fine. The mem2reg pass; optimizes all of our stack variables into SSA registers, inserting PHI; nodes where needed, and our front-end remains simple: no ""iterated; dominance frontier"" computation anywhere in sight. Full Code Listing; =================. Here is th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:28037,variab,variables,28037,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variables']
Modifiability,"ew TLatex(0.01, 0.3, ""Font styles: #^{}bf{#bf{bold}}, #^{}it{#it{italic}}, #^{}bf{#^{}it{#bf{#it{bold italic}}}}, #^{}bf{#^{}bf{#bf{#bf{unbold}}}}""))->Draw();; (new TLatex(0.01, 0.1, ""Font styles: abc#alpha#beta#gamma, #^{}it{#it{abc#alpha#beta#gamma}}, #^{}it{#^{}it{#it{#it{abc#alpha#beta#gamma}}}}""))->Draw();; }. Done by: Oleksandr Grebenyuk <ogrebenyuk@lbl.gov>.; Two new characters: #forall and #exists. TText. New method GetTextAdvance to return the text advance for string; text taking the kerning into account or not. TGaxis. In case of horizontal axis with the font size in pixel (font precision = 3); the labels were not visible.; Alpha numeric labels are not scaled anymore in case of text precision 3; (size in pixels). They are in the other precisions.; Fix a precision issue on Mac. With the following lines the last label; (10^3) did not show:; ; t1 = new TH1F(""test"",""test"", 100,1,1000);; t1.Draw();; gPad->SetLogx(1);; . TPaveStats. The stats painting assumed that the stats position was always defined with; Y2>Y1 and X2>X1. This is true when the stats is created automatically but; might not true if the stats position is given by user. This is now; protected. The stats are correctly drawn whatever the orders of X and Y; coordinates are. ; Saving canvas as a .C macro discarded white title and stat box; background. Same thing with TPaveText. TCutG. IsInside(x,y) is now inherited from TGraph. TCanvas and TPad. In case of Canvas.MoveOpaque = true in $ROOTSYS/etc/system.rootrc; the rubberband was not visible during the zooming along axis.; TPad::SaveAs now takes care of the extensions .pdf],; .pdf[, .pad( and .pdf) to avoid the PS and PDF; mixing when a multiple pages PDF files is generated. To work around this; problem it was enough to specify the option ""pdf"" in SaveAs.; c->BuildLegend() created the legend in the current pad,; not in c (as it should). ; A square TCanvas saved in batch mode in a ROOT file was not square anymore; when displayed in interactive mode. . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html:6722,inherit,inherited,6722,graf2d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v528/index.html,1,['inherit'],['inherited']
Modifiability,"ew algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been included: for a M(x,a,b) = f*F(x,a)+(1-f)G(x,b) ; it is e.g. not needed to recalculate G(x,b) if only parameter a has changed w.r.t to the previous likelihood; calculation. This optimization is now implemented by extending the value caching originally designed; for constant terms to be usable for non-constant terms, with a check executed at the beginning of each; likelihood evaluation if selected columns need to be updated because parameters have changed. The speed gain; of this optimization depends much on the structure of the pdf: in models with many free parameters most of the; likelihood evaluations are executed when MINUIT calculates numerical likelihood derivatives which vary ; one parameter at a time and the speedup is potentially larger. In models with few free parameters the; effect will be smaller. The new per-component caching strategy is enabled by default for all pdfs that are a component of; a RooAddPdf or a RooRealSumPdf, unless that component is a RooProdPdf or a RooProduct, in that; case the components of the product are cached instead of the product itself. You can disable this; new optimization by adding Optimize(1) to the RooAbsPdf::fitTo() command line (0 = no caching,; 1 = cache constant terms only, 2 = cache also variable terms according to above mentioned strategy (DEFAUL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:2578,extend,extending,2578,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,1,['extend'],['extending']
Modifiability,"ex, and VariableIndex(name) to return the index of a variable given a name.; Set a status code in Minuit2Minimizer according to the following convention:; status = minimizeStatus + 10 * minosStatus + 100 * hesseStatus.; See the Minuit2Minimizer reference documentation for the possible values of minimizeStatus , minosStatus and hesseStatus.; In MnHesse. when the inversion of the hessian matrix failed, return MnInvertFailed instead of MnHesseFailed. Mathcore Fitting classes. Fix the fitting with the integral option in multi-dimensions.; Force the gradient calculation when requested in the minimizer; classes and avoid to perform the check when using TMinuit. This was; already the case in Minuit2.; Add new class ROOT::Fit::SparseData for dealing with binned sparse data. This class automatically merges the empty region, so they can be considered, whenever possible as a larger single bin. This improves the performances when doing likelihood fits on the sparse data.; Fix the likelihood fits for variable bin histograms. Now a correct normalization is applied according to the bin volume.; Add new methods in Minimizer class :. Minimizer::SetPrecision(double eps) to change in the minimizer the precision on which the objective functions are evaluated. By default the numerical double precision is used inside the minimizers. This method should be used only if the precision in the function evaluation is worse than the double precision.; std::string Minimizer::VariableName (unsigned int index) to return a name of the minimizer variable (i.e. a fitting parameter) given the integer index. Return an empty string if the variable is not found or of the minimizer does not re-implement this method.; int Minimizer::VariableIndex(const std::string & name) to return the index of a variable given a name. Return -1 if the variable is not found or if the specific minimizer does not re-implement this function. ROOT::Fit::FitResult: fix a problem in the I/O, the function pointer is now made tempo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html:3200,variab,variable,3200,math/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v526/index.html,1,['variab'],['variable']
Modifiability,"example we will copy an entire canvas to a new one with; `DrawClonePad`. Run the script `draw2dopt.C`. ``` {.cpp}; root[] .x tutorials/hist/draw2dopt.C; ```. This creates a canvas with 2D histograms. To make a copy of the canvas; follow the steps:. - Right-click on it to bring up the context menu. - Select `DrawClonePad`. This copies the entire canvas and all its sub-pads to a new canvas. The; copied canvas is a deep clone, and all the objects on it are copies and; independent of the original objects. For instance, change the fill on; one of the original histograms, and the cloned histogram retains its; attributes. `DrawClonePad` will copy the canvas to the active pad; the; target does not have to be a canvas. It can also be a pad on a canvas. ![Different draw options](pictures/030000D7.png). If you want to copy and paste a graphic object from one canvas or pad to; another canvas or pad, you can do so with `DrawClone` method inherited; from **`TObject`**. All graphics objects inherit the; `TObject::DrawClone` method. In this example, we create a new canvas; with one histogram from each of the canvases from the script; `draw2dopt.C`. - Start a new ROOT session and execute the script `draw2dopt.C`. - Select a canvas displayed by the script, and create a new canvas; `c1` from the File menu. - Make sure that the target canvas (`c1`) is the active one by middle; clicking on it. If you do this step right after step 2, c1 will be; active. - Select the pad with the first histogram you want to copy and paste. - Right click on it to show the context menu, and select `DrawClone`. - Leave the option blank and hit OK. Repeat these steps for one histogram on each of the canvases created by; the script, until you have one pad from each type. If you wanted to put; the same annotation on each of the sub pads in the new canvas, you could; use `DrawClone` to do so. Here we added the date to each pad. The steps; to this are:. - Create the label in on of the pads with the graphics editor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:87133,inherit,inherit,87133,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inherit']
Modifiability,"example, SimpleStreamChecker should highlight; the event of opening the file when reporting a file descriptor leak. If the check tracks anything in the program state, it needs to implement the; checkDeadSymbolscallback to clean the state up.; The check should conservatively assume that the program is correct when a tracked symbol; is passed to a function that is unknown to the analyzer.; checkPointerEscape callback could help you handle that case.; Use safe and convenient APIs!. Always use CheckerContext::generateErrorNode and; CheckerContext::generateNonFatalErrorNode for emitting bug reports.; Most importantly, never emit report against CheckerContext::getPredecessor.; Prefer checkPreCall and checkPostCall to; checkPreStmt<CallExpr> and checkPostStmt<CallExpr>.; Use CallDescription to detect hardcoded API calls in the program.; Simplify C.getState()->getSVal(E, C.getLocationContext()) to C.getSVal(E). Common sources of crashes:. CallEvent::getOriginExpr is nullable - for example, it returns null for an; automatic destructor of a variable. The same applies to some values generated while the; call was modeled, eg. SymbolConjured::getStmt is nullable.; CallEvent::getDecl is nullable - for example, it returns null for a; call of symbolic function pointer.; addTransition, generateSink, generateNonFatalErrorNode,; generateErrorNode are nullable because you can transition to a node that you have already visited.; Methods of CallExpr/FunctionDecl/CallEvent that; return arguments crash when the argument is out-of-bounds. If you checked the function name,; it doesn't mean that the function has the expected number of arguments!; Which is why you should use CallDescription.; Nullability of different entities within different kinds of symbols and regions is usually; documented via assertions in their constructors.; NamedDecl::getName will fail if the name of the declaration is not a single token,; e.g. for destructors. You could use NamedDecl::getNameAsString for those cases.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:24650,variab,variable,24650,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,1,['variab'],['variable']
Modifiability,"example,; the ""add missing switch cases"" refactoring operation typically adds missing; cases to one switch at a time. However, it could be useful to have a; refactoring that works on all switches that operate on a particular enum, as; one could then automatically update all of them after adding a new enum; constant. To achieve that, we can create two different rules that will use one; ``clang-refactor`` subcommand. The first rule will describe a local operation; that's initiated when the user selects a single switch. The second rule will; describe a global operation that works across translation units and is initiated; when the user provides the name of the enum to clang-refactor (or the user could; select the enum declaration instead). The clang-refactor tool will then analyze; the selection and other options passed to the refactoring action, and will pick; the most appropriate rule for the given selection and other options. Rule Types; ^^^^^^^^^^. Clang's refactoring engine supports several different refactoring rules:. - ``SourceChangeRefactoringRule`` produces source replacements that are applied; to the source files. Subclasses that choose to implement this rule have to; implement the ``createSourceReplacements`` member function. This type of; rule is typically used to implement local refactorings that transform the; source in one translation unit only. - ``FindSymbolOccurrencesRefactoringRule`` produces a ""partial"" refactoring; result: a set of occurrences that refer to a particular symbol. This type; of rule is typically used to implement an interactive renaming action that; allows users to specify which occurrences should be renamed during the; refactoring. Subclasses that choose to implement this rule have to implement; the ``findSymbolOccurrences`` member function. The following set of quick checks might help if you are unsure about the type; of rule you should use:. #. If you would like to transform the source in one translation unit and if; you don't nee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst:3674,refactor,refactoring,3674,interpreter/llvm-project/clang/docs/RefactoringEngine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/RefactoringEngine.rst,2,['refactor'],['refactoring']
Modifiability,"example`` GC strategy uses to distinguish references from; non references. This is controlled via GCStrategy::isGCManagedPointer. The; ``statepoint-example`` and ``coreclr`` strategies (the only two default; strategies that support statepoints) both use addrspace(1) to determine which; pointers are references, however custom strategies don't have to follow this; convention. This pass can be used an utility function by a language frontend that doesn't; want to manually reason about liveness, base pointers, or relocation when; constructing IR. As currently implemented, RewriteStatepointsForGC must be; run after SSA construction (i.e. mem2ref). RewriteStatepointsForGC will ensure that appropriate base pointers are listed; for every relocation created. It will do so by duplicating code as needed to; propagate the base pointer associated with each pointer being relocated to; the appropriate safepoints. The implementation assumes that the following; IR constructs produce base pointers: loads from the heap, addresses of global; variables, function arguments, function return values. Constant pointers (such; as null) are also assumed to be base pointers. In practice, this constraint; can be relaxed to producing interior derived pointers provided the target; collector can find the associated allocation from an arbitrary interior; derived pointer. By default RewriteStatepointsForGC passes in ``0xABCDEF00`` as the statepoint; ID and ``0`` as the number of patchable bytes to the newly constructed; ``gc.statepoint``. These values can be configured on a per-callsite; basis using the attributes ``""statepoint-id""`` and; ``""statepoint-num-patch-bytes""``. If a call site is marked with a; ``""statepoint-id""`` function attribute and its value is a positive; integer (represented as a string), then that value is used as the ID; of the newly constructed ``gc.statepoint``. If a call site is marked; with a ``""statepoint-num-patch-bytes""`` function attribute and its; value is a positive integer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:27744,variab,variables,27744,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['variab'],['variables']
Modifiability,"exception reporting detailing; * Mapped C++ exception cleanup bug fix; * STL vector constructor passes the CPython sequence construction; * STL vector slicing passes the CPython sequence slicing tests; * Extended documentation. 2019-12-23: 1.6.0; -----------------. * Classes derived from ``std::exception`` can be used as Python exceptions; * Template handling detailing (for Eigen); * Support keyword arguments; * Added add_library_path at module level; * Extended documentation; * Fix regression bugs: #176, #179, #180, #182. 2019-11-07: 1.5.7; -----------------. * Allow implicit converions for move arguments; * Choose vector over initializer_list if part of the template argument list. 2019-11-03: 1.5.6; -----------------. * Added public C++ API for some CPyCppyy core functions (CPython only); * Support for char16_t/char16_t* and char32_t/char32_t*; * Respect ``std::hash`` in ``__hash__``; * Fix iteration over vector of shared_ptr; * Length checking on global variables of type 'signed char[N]'; * Properly support overloaded templated with non-templated ``__setitem__``; * Support for array of const char* as C-strings; * Enable type resolution of clang's builtin ``__type_pack_element``; * Fix for inner class type naming when it directly declares a variable. 2019-10-16: 1.5.5; -----------------. * Added signal -> exception support in cppyy.ll; * Support for lazily combining overloads of operator*/+-; * No longer call trivial destructors; * Support for free function unary operators; * Refactored and optimized operator==/!= usage; * Refactored converters/executors for lower memory usage; * Bug fixes in rootcling and _cppyy_generator.py. 2019-09-25: 1.5.4; -----------------. * operator+/* now respect C++-side associativity; * Fix potential crash if modules are reloaded; * Fix some portability issues on Mac/Windows of cppyy-cling. 2019-09-15: 1.5.3; -----------------. * Performance improvements; * Support for anonymous/unnamed/nested unions; * Extended documentation. 2019-09-0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:15797,variab,variables,15797,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"expected name and returns it. Because all values in; Kaleidoscope are doubles, there is no need to pass in a type to use. With this in place, the first functionality change we want to make belongs to; variable references. In our new scheme, variables live on the stack, so; code generating a reference to them actually needs to produce a load; from the stack slot:. .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; AllocaInst *A = NamedValues[Name];; if (!A); return LogErrorV(""Unknown variable name"");. // Load the value.; return Builder->CreateLoad(A->getAllocatedType(), A, Name.c_str());; }. As you can see, this is pretty straightforward. Now we need to update; the things that define the variables to set up the alloca. We'll start; with ``ForExprAST::codegen()`` (see the `full code listing <#id1>`_ for; the unabridged code):. .. code-block:: c++. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:14506,variab,variable,14506,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63811,variab,variables,63811,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"explicit template specializations of function, class, or; static member variable template instantiations. Given; template<typename T> void A(T t) { }; template<> void A(int N) { }; functionDecl(isExplicitTemplateSpecialization()); matches the specialization A<int>(). Usable as: Matcher<FunctionDecl>, Matcher<VarDecl>, Matcher<CXXRecordDecl>. Matcher<VarDecl>isExternC; Matches extern ""C"" function or variable declarations. Given:; extern ""C"" void f() {}; extern ""C"" { void g() {} }; void h() {}; extern ""C"" int x = 1;; extern ""C"" int y = 2;; int z = 3;; functionDecl(isExternC()); matches the declaration of f and g, but not the declaration of h.; varDecl(isExternC()); matches the declaration of x and y, but not the declaration of z. Matcher<VarDecl>isInitCapture; Matches a variable serving as the implicit variable for a lambda init-; capture. Example matches x (matcher = varDecl(isInitCapture())); auto f = [x=3]() { return x; };. Matcher<VarDecl>isInline; Matches functions, variables and namespace declarations that are marked with; the inline keyword. Given; inline void f();; void g();; namespace n {; inline namespace m {}; }; inline int Foo = 5;; functionDecl(isInline()) will match ::f().; namespaceDecl(isInline()) will match n::m.; varDecl(isInline()) will match Foo;. Matcher<VarDecl>isStaticLocal; Matches a static variable with local scope. Example matches y (matcher = varDecl(isStaticLocal())); void f() {; int x;; static int y;; }; static int z;. Matcher<VarDecl>isStaticStorageClass; Matches variable/function declarations that have ""static"" storage; class specifier (""static"" keyword) written in the source. Given:; static void f() {}; static int i = 0;; extern int j;; int k;; functionDecl(isStaticStorageClass()); matches the function declaration f.; varDecl(isStaticStorageClass()); matches the variable declaration i. Matcher<VarDecl>isTemplateInstantiation; Matches template instantiations of function, class, or static; member variable template instantiations. Given; t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:127987,variab,variables,127987,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variables']
Modifiability,expressions; No. 1969; CD6; Missing exclusion of ~S as an ordinary function name; Unknown. 1970; NAD; Ambiguity resolution for (T())*x; Unknown. 1971; CD4; Unclear disambiguation of destructor and operator~; Unknown. 1972; CD6; Identifier character restrictions in non-identifiers; Unknown. 1973; DRWP; Which parameter-declaration-clause in a lambda-expression?; Unknown. 1974; NAD; Redundant specification of non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:134656,extend,extending,134656,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['extend'],['extending']
Modifiability,"ext i32 257 to i64 ; yields i64:257; %Y = zext i1 true to i32 ; yields i32:1; %Z = zext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. %a = zext nneg i8 127 to i16 ; yields i16 127; %b = zext nneg i8 -1 to i16 ; yields i16 poison. .. _i_sext:. '``sext .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = sext <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``sext``' sign extends ``value`` to the type ``ty2``. Arguments:; """""""""""""""""""". The '``sext``' instruction takes a value to cast, and a type to cast it; to. Both types must be of :ref:`integer <t_integer>` types, or vectors of; the same number of integers. The bit size of the ``value`` must be; smaller than the bit size of the destination type, ``ty2``. Semantics:; """""""""""""""""""". The '``sext``' instruction performs a sign extension by copying the sign; bit (highest order bit) of the ``value`` until it reaches the bit size; of the type ``ty2``. When sign extending from i1, the extension always results in -1 or 0. Example:; """""""""""""""". .. code-block:: llvm. %X = sext i8 -1 to i16 ; yields i16 :65535; %Y = sext i1 true to i32 ; yields i32:-1; %Z = sext <2 x i16> <i16 8, i16 7> to <2 x i32> ; yields <i32 8, i32 7>. '``fptrunc .. to``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = fptrunc <ty> <value> to <ty2> ; yields ty2. Overview:; """""""""""""""""". The '``fptrunc``' instruction truncates ``value`` to type ``ty2``. Arguments:; """""""""""""""""""". The '``fptrunc``' instruction takes a :ref:`floating-point <t_floating>`; value to cast and a :ref:`floating-point <t_floating>` type to cast it to.; The size of ``value`` must be larger than the size of ``ty2``. This; implies that ``fptrunc`` cannot be used to make a *no-op cast*. Semantics:; """""""""""""""""""". The '``fptrunc``' instruction casts a ``value`` from a larger; :ref:`floating-point <t_floating>` type to a smaller :ref:`floating-point; <t_floating>` type.; This instruction is assumed to execute in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:445217,extend,extending,445217,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extending']
Modifiability,"f RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65346,variab,variables,65346,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"f a variable is declared in the condition of an Objective-C fast enumeration; loop, and the variable has no explicit ownership qualifier, then it is; implicitly :ref:`externally-retained <arc.misc.externally_retained>` so that; objects encountered during the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96412,variab,variable,96412,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,3,['variab'],['variable']
Modifiability,"f allocations are known to the runtime system. ""Exterior derived pointers"" are outside the bounds of the associated object;; they may even fall within *another* allocations address range. As a result,; there is no way for a garbage collector to determine which allocation they; are associated with at runtime and compiler support is needed. The ``gc.relocate`` intrinsic supports an explicit operand for describing the; allocation associated with a derived pointer. This operand is frequently; referred to as the base operand, but does not strictly speaking have to be; a base pointer, but it does need to lie within the bounds of the associated; allocation. Some collectors may require that the operand be an actual base; pointer rather than merely an internal derived pointer. Note that during; lowering both the base and derived pointer operands are required to be live; over the associated call safepoint even if the base is otherwise unused; afterwards. If we extend our previous example to include a pointless derived pointer,; we get:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; %gep = getelementptr i8, i8 addrspace(1)* %obj, i64 20000; %token = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 0, i32 0, i32 0, i8 addrspace(1)* %obj, i8 addrspace(1)* %gep); %obj.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 7); %gep.relocated = call i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %token, i32 7, i32 8); %p = getelementptr i8, i8 addrspace(1)* %gep, i64 -20000; ret i8 addrspace(1)* %p; }. Note that in this example %p and %obj.relocate are the same address and we; could replace one with the other, potentially removing the derived pointer; from the live set at the safepoint entirely. .. _gc_transition_args:. GC Transitions; ^^^^^^^^^^^^^^^^^^. As a practical consideration, many g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:15282,extend,extend,15282,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['extend'],['extend']
Modifiability,"f command line options. .. option:: -o <filename>. Specify the output filename. .. option:: -S. Write output in LLVM intermediate language (instead of bitcode). .. option:: -{passname}. :program:`opt` provides the ability to run any of LLVM's optimization or; analysis passes in any order. The :option:`-help` option lists all the passes; available. The order in which the options occur on the command line are the; order in which they are executed (within pass constraints). .. option:: -strip-debug. This option causes opt to strip debug information from the module before; applying other optimizations. It is essentially the same as `-strip`; but it ensures that stripping of debug information is done first. .. option:: -verify-each. This option causes opt to add a verify pass after every pass otherwise; specified on the command line (including `-verify`). This is useful; for cases where it is suspected that a pass is creating an invalid module but; it is not clear which pass is doing it. .. option:: -stats. Print statistics. .. option:: -time-passes. Record the amount of time needed for each pass and print it to standard; error. .. option:: -debug. If this is a debug build, this option will enable debug printouts from passes; which use the ``LLVM_DEBUG()`` macro. See the `LLVM Programmer's Manual; <../ProgrammersManual.html>`_, section ``#DEBUG`` for more information. .. option:: -load=<plugin>. Load the dynamic object ``plugin``. This object should register new; optimization or analysis passes. Once loaded, the object will add new command; line options to enable various optimizations or analyses. To see the new; complete list of optimizations, use the :option:`-help` and :option:`-load`; options together. For example:. .. code-block:: sh. opt -load=plugin.so -help. .. option:: -print-passes. Print all available passes and exit. EXIT STATUS; -----------. If :program:`opt` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst:2665,plugin,plugin,2665,interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/opt.rst,3,['plugin'],['plugin']
Modifiability,"f course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters; is 5, and the number of internal parameters is 3. This is the number; which determines, for example, the size of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6803,variab,variable,6803,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"f events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve the desired configuration. **Example** of an error that is now caught at compile time: confusing the [RooAbsPdf::fitTo()]() function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:31072,inherit,inheriting,31072,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['inherit'],['inheriting']
Modifiability,"f foo { // Value; bit isMod = 1;; bit isRef = 0;; }; def snork { // Value; bit isMod = 1;; bit isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`* ""}""; :| ""let"" `LetList` ""in"" `Statement`; LetList: `LetItem` ("","" `LetItem`)*; LetItem: `TokIdentifier` [""<"" `RangeList` "">""] ""="" `Value`. The ``let`` statement establishes a scope, which is a sequence of statements; in braces or a single statement with no braces. The bindings in the; :token:`LetList` apply to the statements in that scope. The field names in the :token:`LetList` must name fields in classes inherited by; the classes and records defined in the statements. The field values are; applied to the classes and records *after* the records inherit all the fields from; their parent classes. So the ``let`` acts to override inherited field; values. A ``let`` cannot override the value of a template argument. Top-level ``let`` statements are often useful when a few fields need to be; overridden in several records. Here are two examples. Note that ``let``; statements can be nested. .. code-block:: text. let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in; def RET : I<0xC3, RawFrm, (outs), (ins), ""ret"", [(X86retflag 0)]>;. let isCall = true in; // All calls clobber the non-callee saved registers...; let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,; MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,; XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {; def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),; ""call\t${dst:call}"", []>;; def CALL32r : I<0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),; ""call\t{*}$dst"", [(X86call GR32:$dst)]>;; def C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:33579,inherit,inherit,33579,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherit']
Modifiability,"f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65470,variab,variables,65470,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"f its two operands.; * mul - Returns the product of its two operands.; * sub - Returns the difference of its two operands. * ``<arguments>`` is a comma separated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK: load r[[#REG+1]], [r1]; ; CHECK: Loading from 0x[[#%x,ADDR:]]; ; CHECK-SAME: to 0x[[#ADDR + 7]]. The above example would match the text:. .. code-block:: gas. load r5, [r0]; load r6, [r1]; Loading from 0xa0463440 to 0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line numbers of the; match file, e.g. when testing compiler diagnostics. This introduces a certain; fragility of the match file structure, as ""``CHECK:``"" lines contain absolute; line numbers in the same file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:32891,variab,variable,32891,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"f scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler is extremely compatible with GAS, but there are a couple of; minor places where it is more picky, particularly due to outright GAS bugs.; One specific example is that the assembler rejects ambiguous X86 instructions; that don't have suffixes. For example:. asm(""add %al, (%rax)"");; asm(""addw $4, (%rax)"");; asm(""add $4, (%rax)"");. Both clang and GAS accept the first ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:7048,variab,variables,7048,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,2,['variab'],['variables']
Modifiability,"f specifying user credentials on a per-file; basis or for all S3 files via environment variables.; - honor the ""NOPROXY"" option when specified in the constructor.; - exploit the capability of the S3 file server to provide partial; content responses to multi-range HTTP requests. Here are some examples of usages from the end user perspective:. ``` {.cpp}; TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"", ""AUTH=<accessKey>:<secretKey> NOPROXY""); TFile* f = TFile::Open(""s3://s3.amazonaws.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:808",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:1863,config,configuring,1863,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,3,['config'],"['configurable', 'configuration', 'configuring']"
Modifiability,"f the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]. Block literal expressions may occur within Block literal expressions; (nest) and all variables captured by any nested blocks are implicitly; also captured in the scopes of their enclosing Blocks. A Block literal expression may be used as the initialization value for; Block variables at global or local static scope. The Invoke Operator; ===================. Blocks are :block-term:`invoked` using function call syntax with a; list of expression parameters of types corresponding to the; declaration and returning a result type also according to the; declaration. Given:. .. code-block:: c. int (^x)(char);; void (^z)(void);; int (^(*y))(char) = &x;. the following are all legal Block invocations:. .. code-block:: c. x('a');; (*y)('a');; (true ? x : *y)('a'). The Copy and Release Operations; ===============================. The compiler and runtime provide :block-term:`copy` and; :block-term:`release` operations for Block references that create and,; in matched use, release allocated storage for referenced Blocks. The copy operation ``Block_copy()`` is styled as a function that takes; an arbitrary Block reference and returns a Block reference of the same; type. The release operation, ``Block_release()``, is styled as a; function that takes an ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:5737,variab,variables,5737,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"f the current C++ interpreter in the ROOT project - CINT. The backward-compatibility with CINT is major priority during the development.; ; How to use it; You can start typing not only C++ top level declaratons but statements, too. ; **** Welcome to the cling prototype! ****; * Type C code and press enter to run it *; * Type .q, exit or ctrl+D to quit *; *****************************************; [cling]$. Statements and expressions could take more than one input line. The interactive prompt changes from ""[cling]$"" to ""[cling]$ ?"".; ; [cling]$ #include ""math.h""; [cling]$ #include ""stdio.h""; [cling]$ for (unsigned i = 0; i < 5; ++i) {; [cling]$ ? printf(""%f\n"", sin(i));; [cling]$ ? }; 0.000000; 0.841471; 0.909297; 0.141120; -0.756802; Grammar; Cling is able to parse everything that clang can. Current clang status can be found here. At the moment, there are use cases only for C++ that's why cling is best in working with C++. Clang has support of C, objC, objC++ and we are looking forward to having more use-cases and extend our tool in that direction.; Cling has internal commands, which can change its behavior at runtime. Those commands usually start with dot (.):; .I <path> - Adds an include path;; .x <filename> - #include-s the filename; and calls function called filename(); ; .L <libname> - Loads libname or #include-s the libname if libname is file;; .@ - Cancels the multiline input;; .printAST - (DEBUG ONLY) Turns on the printing of the compiler's abstract syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:2029,extend,extend,2029,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,1,['extend'],['extend']
Modifiability,"f the current supported ONNX operator is the following:; - Gemm; - Conv (in 1D,2D and 3D); - RNN, GRU, LSTM; - Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu; - BatchNormalization; - MaxPool, AveragePool, GlobalAverage; - ConvTranspose; - Gather; - Expand, Reduce; - Neg, Exp, Sqrt, Reciprocal; - Add, Sum, Mul, Div; - Reshape, Flatten, Transpose; - Squeeze, Unsqueeze, Slice; - Concat, Reduce; - Identity; - Shape. In addition a Custom (user defined) operator is supported. An example of using a Custom operator is the program `tmva/pymva/test/EmitCustomModel.cxx`. The ONNX parser supports also the fusing of the operators MatMul + Add in a Gemm operator and fusing Conv + Add and ConvTranspose + Add. #### SOFIE Keras Parser. The Keras parser supports now model with input batch size not defined (e.g `bathsize=-1`), and by default the model is generated with `batchsize=1`.; The Keras parser supports now in addition to the Dense layer the Conv2D layer, several activation functions (Relu, Selu, Sigmoid, Softmax, Tanh, LeakyRelu) and these other layers: BatchNormalization, Reshape, Convatenate, Add, Subtract, Multiply.; Models with Dropout layers are supported in case the Dropout is used only during training and not inference. For model having operators not yet supported in the Keras parser it is then reccomended to convert the Keras model to `ONNX` using the python `tf2onnx` tool. #### SOFIE PyTorch Parser. If using PyTorch it is recommended to save the model directly in `ONNX` format instad of the native `.pt` format by using the `torch.onnx.export` function of PyTorch. The support for parsing directly `.pt` files is limited to the Gemm, Conv, Relu, Selu, Sigmoid and Transpose operators. #### SOFIE RDataFrame Integration. The SOFIE inference is now integrated with RDataFrame, where a model can be evaluated on the columns of an input `TTree` with `RDataFrame` using the adapter functor class `SofieFunctor`.; Examples of using SOFIE with `RDataFrame` are the new tutorials (in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:28470,layers,layers,28470,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['layers'],['layers']
Modifiability,"f the enclosing module. .. parsed-literal::. *config-macros-declaration*:; ``config_macros`` *attributes*:sub:`opt` *config-macro-list*:sub:`opt`. *config-macro-list*:; *identifier* (',' *identifier*)*. Each *identifier* in the *config-macro-list* specifies the name of a macro. The compiler is required to maintain different variants of the given module for differing definitions of any of the named macros. A *config-macros-declaration* shall only be present on a top-level module, i.e., a module that is not nested within an enclosing module. The ``exhaustive`` attribute specifies that the list of macros in the *config-macros-declaration* is exhaustive, meaning that no other macro definition is intended to have an effect on the API of that module. .. note::. The ``exhaustive`` attribute implies that any macro definitions; for macros not listed as configuration macros should be ignored; completely when building the module. As an optimization, the; compiler could reduce the number of unique module variants by not; considering these non-configuration macros. This optimization is not; yet implemented in Clang. A translation unit shall not import the same module under different definitions of the configuration macros. .. note::. Clang implements a weak form of this requirement: the definitions; used for configuration macros are fixed based on the definitions; provided by the command line. If an import occurs and the definition; of any configuration macro has changed, the compiler will produce a; warning (under the control of ``-Wconfig-macros``). **Example:** A logging library might provide different API (e.g., in the form of different definitions for a logging macro) based on the ``NDEBUG`` macro setting:. .. parsed-literal::. module MyLogger {; umbrella header ""MyLogger.h""; config_macros [exhaustive] NDEBUG; }. Conflict declarations; ~~~~~~~~~~~~~~~~~~~~~; A *conflict-declaration* describes a case where the presence of two different modules in the same translation unit is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:47412,config,configuration,47412,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['config'],['configuration']
Modifiability,"f the subexpressions and types within your expression,; using ``getDerived().TransformYYY``. If all of the subexpressions and; types transform without error, it will then call the ``RebuildXXX``; function, which will in turn call ``getSema().BuildXXX`` to perform; semantic analysis and build your expression.; * To test template instantiation, take those tests you wrote to make sure; that you were type checking with type-dependent expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154129,extend,extend,154129,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['extend'],['extend']
Modifiability,"f the; variables are not used. This includes ``const`` imports as well as ``__block``; variables. Objective C Extensions to ``Blocks``; ====================================. Importing Objects; -----------------. Objects should be treated as ``__attribute__((NSObject))`` variables; all; ``copy_helper``, ``dispose_helper``, ``byref_keep``, and ``byref_dispose``; helper functions should use ``_Block_object_assign`` and; ``_Block_object_dispose``. There should be no code generated that uses; ``*-retain`` or ``*-release`` methods. ``Blocks`` as Objects; ---------------------. The compiler will treat ``Blocks`` as objects when synthesizing property setters; and getters, will characterize them as objects when generating garbage; collection strong and weak layout information in the same manner as objects, and; will issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BL",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:19512,variab,variables,19512,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"f:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"",; ""gApplication->Terminate()"");; ```. You will have the following the two lines:. ``` {.cpp}; TGTextButton *exit = new TGTextButton(hframe,""&Exit"");; exit->SetCommand(""gApplication->Terminate()"");; ```. The method `IsEnabled()` - returns `kTRUE` if the widget has flag; `kWidgetIsEnabled` and it accepts user events. This method is very; important for creating a good user interface because it allows you to; disable or enable a widget depending on the situation of your; application. As a standard all disabled widgets are displayed ""grayed; out"". `HasFocus()` - returns `kTRUE` if the widget has the input focus; (i.e. flag `kWidgetHasFocus` is set). Remember that only one item in a; complex widget as a dialog can have the value of `HasFocus()` sets as; true. `WantFocus()` - returns `kTRUE` if the flag `kWidgetWantFocus` is; set. ### TGWindow. **`TGWindow`** is a ROOT GUI window base class. It inherits from; **`TGObject`** and **`TGFrame`** derives from it. The application does; not use it directly. It creates and registers a new window within the; system. This window has common characteristics: existing parent,; location, size in height and width (it has a default minimum size 1, 1; under which it cannot shrink), border with particular view, state,; specific attributes. If there are no specified arguments their values; will be taken from the parent. It receives events from the window system; and can paint a representation of itself on the screen. ![](pictures/02000205.jpg). ### Frames. Most of the frame classes are mainly created for arranging widgets in a; window. The class **`TGFrame`** is a subclass of **`TGWindow`**; providing additional window characteristics and overriding some methods; of **`TGWindow`**. It is a base class for the simple widgets as buttons,; labels, etc. Its only purpose is to draw a frame around widgets that do; not have a frame of their own. The main groups of **`TGFrame`** mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:23654,inherit,inherits,23654,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inherits']
Modifiability,"f:`DISubprogram`. .. code-block:: text. !0 = !DILocation(line: 2900, column: 42, scope: !1, inlinedAt: !2). .. _DILocalVariable:. DILocalVariable; """""""""""""""""""""""""""""". ``DILocalVariable`` nodes represent local variables in the source language. If; the ``arg:`` field is set to non-zero, then this variable is a subprogram; parameter, and it will be included in the ``retainedNodes:`` field of its; :ref:`DISubprogram`. .. code-block:: text. !0 = !DILocalVariable(name: ""this"", arg: 1, scope: !3, file: !2, line: 7,; type: !3, flags: DIFlagArtificial); !1 = !DILocalVariable(name: ""x"", arg: 2, scope: !4, file: !2, line: 7,; type: !3); !2 = !DILocalVariable(name: ""y"", scope: !5, file: !2, line: 7, type: !3). .. _DIExpression:. DIExpression; """""""""""""""""""""""". ``DIExpression`` nodes represent expressions that are inspired by the DWARF; expression language. They are used in :ref:`debug intrinsics<dbg_intrinsics>`; (such as ``llvm.dbg.declare`` and ``llvm.dbg.value``) to describe how the; referenced LLVM variable relates to the source language variable. Debug; intrinsics are interpreted left-to-right: start by pushing the value/address; operand of the intrinsic onto a stack, then repeatedly push and evaluate; opcodes from the DIExpression until the final variable description is produced. The current supported opcode vocabulary is limited:. - ``DW_OP_deref`` dereferences the top of the expression stack.; - ``DW_OP_plus`` pops the last two entries from the expression stack, adds; them together and appends the result to the expression stack.; - ``DW_OP_minus`` pops the last two entries from the expression stack, subtracts; the last entry from the second last entry and appends the result to the; expression stack.; - ``DW_OP_plus_uconst, 93`` adds ``93`` to the working expression.; - ``DW_OP_LLVM_fragment, 16, 8`` specifies the offset and size (``16`` and ``8``; here, respectively) of the variable fragment from the working expression. Note; that contrary to DW_OP_bit_piece, the offset is desc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:261151,variab,variable,261151,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"fListBox->Resize(150, 80);; parent->AddFrame(fListBox,new TGLayoutHints(kLHintsTop|kLHintsLeft,; 5, 5, 5, 5));; ```. We create the list box widget passing the parent window pointer and; giving an ID number. Next we add entries with specified string and ID to; the list box. Before adding the list box to its parent widget, it should; be resized via `Resize(width, height)` method. The list box width and; height are in pixels. The default entry layout hints are; `kLHintsExpandX | kLHintsTop`. If you want to add entries using; different ones, call the method:. ``` {.cpp}; TGListBox::AddEntry(TGLBEntry *lbe, TGLayoutHints *lhints);; ```. It adds the specified **`TGLBEntry`** and **`TGLayoutHints`** to the; list box. There are several methods providing a flexible entry; manipulation: you can insert, add or remove list box items dynamically.; The list box entry IDs are used in these methods and also in event; processing routines. In our example the integer variables `fFirstEntry`; and `fLastEntry` contain the information about the first and last entry; IDs. You can add or remove a list box entry using them in the following; way:. ``` {.cpp}; // adding an entry; fLastEntry++;; sprintf(tmp, ""Entry %i"", fLastEntry);; fListBox->AddEntry(tmp, fLastEntry);; fListBox->MapSubwindows();; fListBox->Layout();; . . .; // removing an entry; if (fFirstEntry < fLastEntry) {; fListBox->RemoveEntry(fFirstEntry);; fListBox->Layout();; fFirstEntry++;; }; ```. A single-selection list box is used for selecting only one item in a; list. A multiple-selection list box permits selection of more than one item.; The selected choices should be visible - you have several choices to do; this:. - to mark selected choices with a check mark or highlight them. - to provide a summary list box to the right of the list box,; containing the selected choices. - to provide a display-only text control indicating the number of; selected choices (its position should be justified upper-right above; the list box). - i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:81341,variab,variables,81341,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['variab'],['variables']
Modifiability,"f``, ``CFArrayRef``,; etc. When used from C, however, these are still really objects and are the; second case where that requires copy and dispose helper functions to be; generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11366,variab,variables,11366,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"fect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of the optimized program and undermining their; trust in the debugger. Sometimes perfectly preserving variable locations is not possible, often when a; redundant calculation is optimized out. In such cases, a ``llvm.dbg.value``; with operand ``poison`` should be used, to terminate earlier variable locations; and let the debugger present ``optimized out`` to the developer. Withholding; these potentially stale variable values from the developer diminishes the; amount of available debug information, but increases the reliability of the; remaining information. To illustrate some potential issues, consider the following example:. .. code-block:: llvm. define i32 @foo(i32 %bar, i1 %cond) {; entry:; call @llvm.dbg.value(metadata i32 0, metadata !1, metadata !2); br i1 %cond, label %truebr, label %falsebr; truebr:; %tval = add i32 %bar, 1; call @llvm.dbg.value(metadata i32 %tval, metadata !1, metadata !2); %g1 = call i32 @gazonk(); br label %exit; falsebr:; %fval = add i32 %bar, 2; call @llvm.dbg.value(metadata i32 %fval, metadata !1, metadata !2); %g2 = call i32 @gazonk(); br label %exit; exit:; %merge = phi [ %tval, %tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:19389,variab,variable,19389,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"fer to the tree (or chain) containing the data by using the; string '`This`'. You can also call any **`TTree`** methods. Next example; will display the name of the first '`user info`' object:. `tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");`. 46. **`tree->Draw(""mybr.mystring"");`**. **`TString`** and `std::string` object are plotted directly. The example; 45 draws the same results - i.e. an histogram whose labels are the; string value of '`mystring`':. `tree->Draw(""mybr.mystring.c_str()"");`. or. `tree->Draw(""mybr.mytstring.Data()"");`. 47. **`tree->Draw(""myTimeStamp"");`**. You can plot plot objects of any class which has either `AsDouble` or; `AsString` (`AsDouble` has priority). For such a class (for example; **`TTimeStamp`**), the line 46 will plot the same as:. `tree->Draw(""myTimeStamp.AsDouble"");`. `AsString` can be returning either a `char*`, or a **`TString`** or an; `std::string`. ### Multiple variables visualisation. This section presents the visualization technique available in ROOT; to represent multiple variables (>4) data sets. #### Spider (Radar) Plots. Spider plots (sometimes called “web-plots” or “radar plots”) are used; to compare series of data points (events). They use the human ability; to spot un-symmetry. ![Example of spider plot.](pictures/spider1.png). Variables are represented on individual axes displayed along a circle.; For each variable the minimum value sits on the circle’s center, and; the maximum on the circle’s radius. Spider plots are not suitable for; an accurate graph reading since, by their nature, it can be difficult; to read out very detailed values, but they give quickly a global view; of an event in order to compare it with the others. In ROOT the spider; plot facility is accessed from the tree viewer GUI. The variables to; be visualized are selected in the tree viewer and can be scanned using; the spider plot button. ![The tree viewer Graphical User Interface and the Spider Plot Editor.](pictures/spider2.png). The spider pl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:94093,variab,variables,94093,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"ference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `libRFIO.so` to RFIO), and the constructor to be called (e.g.; ""`TRFIOFile()`""). This can be specified in the `.rootrc` which already; contains many plugin definitions, or by calls to; `gROOT->GetPluginManager()->AddHandler()`. #### Library AutoLoading. When using a class in Cling, e.g. in an interpreted source file, ROOT; will automatically load the library that defines this class. On; start-up, ROOT parses all files ending on `.rootmap` rootmap that are; in one of the `$LD_LIBRARY_PATH` (or `$DYLD_LIBRARY_PATH` for `MacOS`,; or `$PATH` for `Windows`). They contain class names and the library; names that the class depends on. After reading them, ROOT knows which; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:19142,plugin,plugins,19142,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['plugin'],['plugins']
Modifiability,"ferences to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that ``buf`` has ``count`` number of elements available. This; relationship must hold even after any of these related variables are updated. To; this end, the model requires that assignments to ``buf`` and ``count`` must be; side by side, with no side effects between them. This prevents ``buf`` and; ``count`` from temporarily falling out of sync due to updates happening at a; distance. The example below shows a function ``alloc_buf`` that initializes a struct that; members that use the ``__counted_by`` annotation. The compiler allows these; assignments because ``sbuf->buf`` and ``sbuf->count`` are updated side by side; without any side effects in between the assignments. Furthermore, the compiler inserts additional run-time checks to ensure the new; ``buf`` has at least as many elements as the new ``count`` indicates as shown in; the transformed pseudo code of function ``alloc_buf()`` in the example below. .. code-block:: c. typedef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35976,variab,variables,35976,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variables']
Modifiability,"ffect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64276,extend,extended,64276,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['extend'],['extended']
Modifiability,"fferent file formats may limit; this to a subset of the local symbols. For example, file and section symbols in; ELF objects will not be discarded. Additionally, remove all debug sections. .. option:: --enable-deterministic-archives, -D. Enable deterministic mode when stripping archives, i.e. use 0 for archive member; header UIDs, GIDs and timestamp fields. On by default. .. option:: --help, -h. Print a summary of command line options. .. option:: --no-strip-all. Disable :option:`--strip-all`. .. option:: -o <file>. Write output to <file>. Multiple input files cannot be used in combination; with -o. .. option:: --only-keep-debug. Produce a debug file as the output that only preserves contents of sections; useful for debugging purposes. For ELF objects, this removes the contents of `SHF_ALLOC` sections that are not; `SHT_NOTE` by making them `SHT_NOBITS` and shrinking the program headers where; possible. .. option:: --regex. If specified, symbol and section names specified by other switches are treated; as extended POSIX regular expression patterns. .. option:: --remove-section <section>, -R. Remove the specified section from the output. Can be specified multiple times; to remove multiple sections simultaneously. .. option:: --strip-all-gnu. Remove all symbols, debug sections and relocations from the output. This option; is equivalent to GNU :program:`strip`'s ``--strip-all`` switch. .. option:: --strip-all, -s. For ELF objects, remove from the output all symbols and non-alloc sections not; within segments, except for .gnu.warning, .ARM.attribute sections and the; section name table. For COFF objects, remove all symbols, debug sections, and relocations from the; output. .. option:: --strip-debug, -d, -g, -S. Remove all debug sections from the output. .. option:: --strip-symbol <symbol>, -N. Remove all symbols named ``<symbol>`` from the output. Can be specified; multiple times to remove multiple symbols. .. option:: --strip-unneeded. Remove from the output all local o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst:2154,extend,extended,2154,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-strip.rst,1,['extend'],['extended']
Modifiability,"fferent; program location ranges. But if supporting for some then should be for; all. It seems odd this attribute is not the same as; ``DW_AT_data_member_location`` in having an initial stack with the; location description of the object since the expression has to need it. A.6 Other Debugging Information; -------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 6 sections. A.6.1 Accelerated Access; ~~~~~~~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-lookup-by-name:. A.6.1.1 Lookup By Name; ++++++++++++++++++++++. A.6.1.1.1 Contents of the Name Index; ####################################. .. note::. The following provides changes to DWARF Version 5 section 6.1.1.1. The rule for debugger information entries included in the name index in the; optional ``.debug_names`` section is extended to also include named; ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_LLVM_form_aspace_address`` operation. The name index must contain an entry for each debugging information entry that; defines a named subprogram, label, variable, type, or namespace, subject to the; following rules:. * ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_addr``, ``DW_OP_LLVM_form_aspace_address``,; or ``DW_OP_form_tls_address`` operation are included; otherwise, they are; excluded. A.6.1.1.4 Data Representation of the Name Index; ###############################################. .. _amdgpu-dwarf-name-index-section-header:. A.6.1.1.4.1 Section Header; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item; 14 ``augmentation_string``. A null-terminated UTF-8 vendor specific augmentation string, which provides; additional information about the contents of this index. If provided, the; recomme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:186116,extend,extended,186116,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extended']
Modifiability,"ffloading entry is an entry; to a target region it can have one of the following :ref:`entry flags; <table-offload_entry_flags>`. .. table:: Target Region Entry Flags; :name: table-offload_entry_flags. +----------------------------------+-------+-----------------------------------------+; | Name | Value | Description |; +==================================+=======+=========================================+; | OMPTargetRegionEntryTargetRegion | 0x00 | Mark the entry as generic target region |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryCtor | 0x02 | Mark the entry as a global constructor |; +----------------------------------+-------+-----------------------------------------+; | OMPTargetRegionEntryDtor | 0x04 | Mark the entry as a global destructor |; +----------------------------------+-------+-----------------------------------------+. If the offloading entry is a global variable, indicated by a non-zero size, it; will instead have one of the following :ref:`global; <table-offload_global_flags>` flags. .. table:: Target Region Global; :name: table-offload_global_flags. +-----------------------------+-------+---------------------------------------------------------------+; | Name | Value | Description |; +=============================+=======+===============================================================+; | OMPTargetGlobalVarEntryTo | 0x00 | Mark the entry as a 'to' attribute (w.r.t. the to clause) |; +-----------------------------+-------+---------------------------------------------------------------+; | OMPTargetGlobalVarEntryLink | 0x01 | Mark the entry as a 'link' attribute (w.r.t. the link clause) |; +-----------------------------+-------+---------------------------------------------------------------+. The target offload entries are used by the runtime to access the device kernels; and globals that will be provided by the final device image. Each offloading; entry is set to use the ``omp_off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:5866,variab,variable,5866,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variable']
Modifiability,"ffset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit offset B that is a multiple of 8, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107617,extend,extends,107617,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['extend'],['extends']
Modifiability,fiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61875,config,configuration,61875,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"fies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n``, is optional, and if not specified,; denotes the default address space 0. The value of ``n`` must be; in the range [1,2^24).; ``i<size>:<abi>[:<pref>]``; This specifies the alignment for an integer type of a given bit; ``<size>``. The value ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132677,variab,variable,132677,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"figuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(bu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1880,config,configuration,1880,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['config'],['configuration']
Modifiability,"file content, for file types; not supported you will get a generic window showing some basic file info. The idea of QL is that file content can be shown without the heavy application; startup process. Generating a QL view of a ROOT file depends on the size of the; file, but generally it is a quick operation. Get the binary for the ROOTQL plugin from:. ftp://root.cern.ch/root/ROOTQL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTQL.qlgenerator to /Library/QuickLook (global, i.e. for all users on a; system) or to ~/Library/QuickLook (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootql rootql. Open the ROOTQL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook directory. SpotLight plugin for MacOS X. This is a Spotlight plugin that allows ROOT files to be indexed by SL.; Once indexed SL can find ROOT files based on the names and titles of the; objects in the files. Spotlight is available on MacOS X since version 10.4 (Tiger). To use SL; select the SL icon on the top right of the menubar and type in a search text. Get the binary for the ROOTSL plugin from:. ftp://root.cern.ch/root/ROOTSL.tgz. To install the plugin, after untarring the above file, just drag the bundle; ROOTSL.mdimporter to /Library/Spotlight (global, i.e. for all users on a; system) or to ~/Library/Spotlight (local, this user only) directory.; You may need to create that folder if it doesn't already exist. To build from source, get it from svn using:. svn co http://root.cern.ch/svn/root/trunk/misc/rootsl rootsl. Open the ROOTSL project in Xcode and click on ""Build"" (make sure the Active; Build Configuration is set the ""Release""). Copy the resulting; plugin from build/Release to the desired QuickLook d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html:1321,plugin,plugin,1321,misc/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/misc/doc/v524/index.html,1,['plugin'],['plugin']
Modifiability,"file(dlfcn.h CLANG_HAVE_DLFCN_H); if( CLANG_HAVE_DLFCN_H ); include(CheckLibraryExists); include(CheckSymbolExists); check_library_exists(dl dlopen """" HAVE_LIBDL); if( HAVE_LIBDL ); list(APPEND CMAKE_REQUIRED_LIBRARIES dl); endif(); list(APPEND CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); check_symbol_exists(dladdr dlfcn.h CLANG_HAVE_DLADDR); list(REMOVE_ITEM CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE); if( HAVE_LIBDL ); list(REMOVE_ITEM CMAKE_REQUIRED_LIBRARIES dl); endif(); endif(). set(CLANG_RESOURCE_DIR """" CACHE STRING; ""Relative directory from the Clang binary to its resource files.""). set(C_INCLUDE_DIRS """" CACHE STRING; ""Colon separated list of directories clang will search for headers.""). set(GCC_INSTALL_PREFIX """" CACHE PATH ""Directory where gcc is installed."" ); set(DEFAULT_SYSROOT """" CACHE STRING; ""Default <path> to all compiler invocations for --sysroot=<path>."" ); if(GCC_INSTALL_PREFIX); message(WARNING ""GCC_INSTALL_PREFIX is deprecated and will be removed. Use ""; ""configuration files (https://clang.llvm.org/docs/UsersManual.html#configuration-files)""; ""to specify the default --gcc-install-dir= or --gcc-triple=. --gcc-toolchain= is discouraged. ""; ""See https://github.com/llvm/llvm-project/pull/77537 for detail.""); endif(). set(ENABLE_LINKER_BUILD_ID OFF CACHE BOOL ""pass --build-id to ld""). set(ENABLE_X86_RELAX_RELOCATIONS ON CACHE BOOL; ""enable x86 relax relocations by default""). set(PPC_LINUX_DEFAULT_IEEELONGDOUBLE OFF CACHE BOOL; ""Enable IEEE binary128 as default long double format on PowerPC Linux.""). set(CLANG_SPAWN_CC1 OFF CACHE BOOL; ""Whether clang should use a new process for the CC1 invocation""). option(CLANG_DEFAULT_PIE_ON_LINUX ""Default to -fPIE and -pie on linux-gnu"" ON). set(CLANG_DEFAULT_LINKER """" CACHE STRING; ""Default linker to use (linker name or absolute path, empty for platform default)""). set(CLANG_DEFAULT_CXX_STDLIB """" CACHE STRING; ""Default C++ stdlib to use (\""libstdc++\"" or \""libc++\"", empty for platform default""); if (NOT(CLANG_DEFAULT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt:6937,config,configuration,6937,interpreter/llvm-project/clang/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/CMakeLists.txt,1,['config'],['configuration']
Modifiability,"file. MultiTargetRegression No False − Do regression with multiple targets. Nmin No 100 − Number of events in cell required to split cell. MaxDepth No 0 − Maximum depth of cell tree (0=unlimited). FillFoamWithOrigWeights No False − Fill foam with original or boost weights. UseYesNoCell No False − Return -1 or 1 for bkg or signal like events. DTLogic No None None, GiniIndex, MisClassificationError, CrossEntropy, GiniIndexWithLaplace, SdivSqrtSplusB Use decision tree algorithm to split cells. Kernel No None None, Gauss, LinNeighbors Kernel type used. TargetSelection No Mean Mean, Mpv Target selection method. Configuration options for MVA method :. Configuration options reference for MVA method: TMlpANN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 200 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture (N stands for number of variables; any integers may also be used). ValidationFraction No 0.5 − Fraction of events in training tree used for cross validation. LearningMethod No Stochastic Stochastic, Batch, SteepestDescent, RibierePolak, FletcherReeves, BFGS Learning method. Configuration options for setup an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:28129,variab,variable,28129,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"file; ``<buildbot-worker-root-directory>/worker/twistd.log``. If your settings; are correct you will see a refused connection. This is good and expected,; as the credentials have not been established on both ends. Now stop the; worker and proceed to the next steps. #. Fill the buildbot-worker description and admin name/e-mail. Here is an; example of the buildbot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x86. See `here <http://docs.buildbot.net/current/manual/installation/worker.html>`_; for which files to edit. #. Send a patch which adds your build worker and your builder to; `zorg <https://github.com/llvm/llvm-zorg>`_. Use the typical LLVM; `workflow <https://llvm.org/docs/Contributing.html#how-to-submit-a-patch>`_. * workers are added to ``buildbot/osuosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:5404,config,config,5404,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['config']
Modifiability,files.; Large benchmarks and whole applications go here. - `MicroBenchmarks/`. Programs using the [google-benchmark](https://github.com/google/benchmark); library. The programs define functions that are run multiple times until the; measurement results are statistically significant. - `External/`. Contains descriptions and test data for code that cannot be directly; distributed with the test-suite. The most prominent members of this; directory are the SPEC CPU benchmark suites.; See [External Suites](#external-suites). - `Bitcode/`. These tests are mostly written in LLVM bitcode. - `CTMark/`. Contains symbolic links to other benchmarks forming a representative sample; for compilation performance measurements. ### Benchmarks. Every program can work as a correctness test. Some programs are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:3765,config,configuration,3765,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['config'],['configuration']
Modifiability,"filing tests are very limited, and generating the profile takes a; significant amount of time, but it can result in a significant improvement in; the performance of the generated binaries. In addition to PGO profiling we also have limited support in-tree for generating; linker order files. These files provide the linker with a suggested ordering for; functions in the final binary layout. This can measurably speed up clang by; physically grouping functions that are called temporally close to each other.; The current tooling is only available on Darwin systems with ``dtrace(1)``. It; is worth noting that dtrace is non-deterministic, and so the order file; generation using dtrace is also non-deterministic. Options for Reducing Size; =========================. .. warning::; Any steps taken to reduce the binary size will come at a cost of runtime; performance in the generated binaries. The simplest and least significant way to reduce binary size is to set the; *CMAKE_BUILD_TYPE* variable to ``MinSizeRel``, which will set the compiler; optimization level to ``-Os`` which optimizes for binary size. This will have; both the least benefit to size and the least impact on performance. The most impactful way to reduce binary size is to dynamically link LLVM into; all the tools. This reduces code size by decreasing duplication of common code; between the LLVM-based tools. This can be done by setting the following two; CMake options to ``On``: *LLVM_BUILD_LLVM_DYLIB* and *LLVM_LINK_LLVM_DYLIB*. .. warning::; Distributions should never be built using the *BUILD_SHARED_LIBS* CMake; option. (:ref:`See the warning above for more explanation <shared_libs>`.). Relevant CMake Options; ======================. This section provides documentation of the CMake options that are intended to; help construct distributions. This is not an exhaustive list, and many; additional options are documented in the :doc:`CMake` page. Some key options; that are already documented include: *LLVM_TARGETS_TO_B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:10122,variab,variable,10122,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"final device image. Each offloading; entry is set to use the ``omp_offloading_entries`` section. When the final; application is created the linker will provide the; ``__start_omp_offloading_entries`` and ``__stop_omp_offloading_entries`` symbols; which are used to create the :ref:`final image <Device Binary Wrapping>`. This information is used by the device compilation stage to determine which; symbols need to be exported from the device. We use the ``omp_offload.info``; metadata node to pass this information device compilation stage. Accessing Entries on the Device; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Accessing the entries in the device is done using the address field in the; :ref:`offload entry<table-tgt_offload_entry_structure>`. The runtime will set; the address to the pointer associated with the device image during runtime; initialization. This is used to call the corresponding kernel function when; entering a ``#pragma omp target`` region. For variables, the runtime maintains a; table mapping host pointers to device pointers. Global variables inside a; ``#pragma omp target declare`` directive are first initialized to the host's; address. Once the device address is initialized we insert it into the table to; map the host address to the device address. Debugging Information; ^^^^^^^^^^^^^^^^^^^^^. We generate structures to hold debugging information that is passed to; ``libomptarget``. This allows the front-end to generate information the runtime; library uses for more informative error messages. This is done using the; standard :ref:`identifier structure <table-ident_t_structure>` used in; ``libomp`` and ``libomptarget``. This is used to pass information and source; locations to the runtime. .. table:: ident_t Structure; :name: table-ident_t_structure. +---------+------------+-----------------------------------------------------------------------------+; | Type | Identifier | Description |; +=========+============+==================================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst:7805,variab,variables,7805,interpreter/llvm-project/clang/docs/OffloadingDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OffloadingDesign.rst,1,['variab'],['variables']
Modifiability,"final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13940,config,configuration,13940,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configuration']
Modifiability,"fined behavior.; Source: C++03 27.4.3.2p3; C++11 27.5.4.2p3. #include <fstream>. class my_streambuf : public std::streambuf {; void f() {; seekpos(-1); // warn; }; };. #include <fstream>. void test() {; std::filebuf fb;; std::istream in(&fb);; std::filebuf::off_type pos(-1);; in.seekg(pos); // warn; }. different. Name, DescriptionExampleProgress. different.SuccessiveAssign; (C); Successive assign to a variable. int test() {; int i;; i=1;; i=2; // warn; return i;; }. different.NullDerefStmtOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {; int x;; };. struct S* f();. void test() {; struct S *p1 = f();; int x1 = p1->x; // warn; if (p1) {};. struct S *p2 = f();; int x2 = p2->x; // ok; }. different.NullDerefCondOrder; (C); Dereferencing of the null pointer might take place. Checking the pointer for; null should be performed first.; Note: possibly an enhancement to ; core.NullDereference. struct S {int i;};. struct S* f();. void test() {; struct S *p = f();; if (p->i && p) {}; // warn; }. different.MultipleAccessors; (C++); Identical accessor bodies. Possibly a misprint. class A {; int i;; int j;; public:; int getI() { return i; }; int getJ() { return i; } // warn; };. class A {; int i;; int j;; public:; void setI(int& ii) { i = ii; }; void setJ(int& jj) { i = jj; } // warn; };. different.AccessorsForPublic; (C++); Accessors exist for a public class field. Should this field really be; public?. class A {; public:; int i; // warn; int getI() { return i; }; void setI(int& ii) { i = ii; }; };. different.LibFuncResultUnised; (C, C++); Calling a function ignoring its return value is of no use (create the list of; known system/library/API functions falling into this category). #include <vector>. void test() {; std::vector<int> v;; v.empty(); // warn; }. different.WrongVarForStmt; (C, C++); Wrong variable is possibly used in the loop/cond-e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:20323,enhance,enhancement,20323,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,1,['enhance'],['enhancement']
Modifiability,"first tree as a friend; t3->AddFriend(""t3f"",""tree3f.root"");; // Draw pz which is in the first tree and use pt; // in the condition. pt is in the friend tree.; t3->Draw(""pz"",""pt>3"");; }. // This is executed when typing .x tree3.C; void tree3() {; tree3w();; tree3r();; }; ```. ## Example 4: A Tree with an Event Class. This example is a simplified version of `$ROOTSYS/test/MainEvent.cxx`; and where Event objects are saved in a tree. The full definition of; `Event` is in `$ROOTSYS/test`/`Event.h`. To execute this macro, you will; need the library `$ROOTSYS/test/libEvent.so`. If it does not exist you; can build the test directory applications by following the instruction; in the `$ROOTSYS/test/README` file. In this example we will show. - the difference in splitting or not splitting a branch; - how to read selected branches of the tree,; - how to print a selected entry. ### The Event Class. `Event` is a descendent of **`TObject`**. As such it inherits the data; members of **`TObject`** and its methods such as `Dump()` and; `Inspect() `and` Write()`. In addition, because it inherits from; **`TObject`** it can be a member of a collection. To summarize, the; advantages of inheriting from a **`TObject`** are:. - Inherit the `Write`, `Inspect`, and `Dump` methods; - Enables a class to be a member of a ROOT collection; - Enables RTTI. Below is the list of the `Event` data members. It contains a character; array, several integers, a floating-point number, and an `EventHeader`; object. The `EventHeader` class is described in the following paragraph.; `Event` also has two pointers, one to a **`TClonesArray`** of tracks and; one to a histogram. The string ""`->`"" in the comment field of the; members `*fTracks` and `*fH` instructs the automatic `Streamer` to; assume that the objects `*fTracks` and `*fH` are never null pointers and; that `fTracks->Streamer` can be used instead of the more time consuming; form `R__b << fTracks`. ``` {.cpp}; class Event : public TObject {; private:; ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:58630,inherit,inherits,58630,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['inherit'],['inherits']
Modifiability,"floating point type, if one is supported on the target. Other types may be supported in the future. Matrix Type Attribute; ---------------------. Matrix types can be declared by adding the ``matrix_type`` attribute to the; declaration of a *typedef* (or a C++ alias declaration). The underlying type; of the *typedef* must be a valid matrix element type. The; attribute takes two arguments, both of which must be integer constant; expressions that evaluate to a value greater than zero. The first specifies the; number of rows, and the second specifies the number of columns. The underlying; type of the *typedef* becomes a matrix type with the given dimensions and an; element type of the former underlying type. If a declaration of a *typedef-name* has a ``matrix_type`` attribute, then all; declaration of that *typedef-name* shall have a matrix_type attribute with the; same element type, number of rows, and number of columns. Standard Conversions; --------------------. The standard conversions are extended as follows. Note that these conversions; are intentionally not listed as satisfying the constraints for assignment,; which is to say, they are only permitted as explicit casts, not as implicit; conversions. A value of matrix type can be converted to another matrix type if the number of; rows and columns are the same and the value's elements can be converted to the; element type of the result type. The result is a matrix where each element is; the converted corresponding element. A value of any real type (as in C23 6.2.5p14) can be converted to a matrix type; if it can be converted to the element type of the matrix. The result is a; matrix where all elements are the converted original value. If the number of rows or columns differ between the original and resulting; type, the program is ill-formed. Arithmetic Conversions; ----------------------. The usual arithmetic conversions are extended as follows. Insert at the start:. * If both operands are of matrix type, no arithme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:2237,extend,extended,2237,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['extend'],['extended']
Modifiability,"floating-point operation must treat any input denormal value as; zero. In some situations, if an instruction does not respect this; mode, the input may need to be converted to 0 as if by; ``@llvm.canonicalize`` during lowering for correctness. ``""denormal-fp-math-f32""``; Same as ``""denormal-fp-math""``, but only controls the behavior of; the 32-bit float type (or vectors of 32-bit floats). If both are; are present, this overrides ``""denormal-fp-math""``. Not all targets; support separately setting the denormal mode per type, and no; attempt is made to diagnose unsupported uses. Currently this; attribute is respected by the AMDGPU and NVPTX backends. ``""thunk""``; This attribute indicates that the function will delegate to some other; function with a tail call. The prototype of a thunk should not be used for; optimization purposes. The caller is expected to cast the thunk prototype to; match the thunk target prototype. ``""tls-load-hoist""``; This attribute indicates that the function will try to reduce redundant; tls address calculation by hoisting tls variable. ``uwtable[(sync|async)]``; This attribute indicates that the ABI being targeted requires that; an unwind table entry be produced for this function even if we can; show that no exceptions passes by it. This is normally the case for; the ELF x86-64 abi, but it can be disabled for some compilation; units. The optional parameter describes what kind of unwind tables; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:108607,variab,variable,108607,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,floating-point.h; flang/include/flang/Decimal/decimal.h; flang/include/flang/Evaluate/call.h; flang/include/flang/Evaluate/characteristics.h; flang/include/flang/Evaluate/check-expression.h; flang/include/flang/Evaluate/common.h; flang/include/flang/Evaluate/complex.h; flang/include/flang/Evaluate/constant.h; flang/include/flang/Evaluate/expression.h; flang/include/flang/Evaluate/fold-designator.h; flang/include/flang/Evaluate/fold.h; flang/include/flang/Evaluate/formatting.h; flang/include/flang/Evaluate/initial-image.h; flang/include/flang/Evaluate/integer.h; flang/include/flang/Evaluate/intrinsics-library.h; flang/include/flang/Evaluate/intrinsics.h; flang/include/flang/Evaluate/logical.h; flang/include/flang/Evaluate/real.h; flang/include/flang/Evaluate/rounding-bits.h; flang/include/flang/Evaluate/shape.h; flang/include/flang/Evaluate/static-data.h; flang/include/flang/Evaluate/tools.h; flang/include/flang/Evaluate/traverse.h; flang/include/flang/Evaluate/type.h; flang/include/flang/Evaluate/variable.h; flang/include/flang/Frontend/CompilerInstance.h; flang/include/flang/Frontend/FrontendAction.h; flang/include/flang/Frontend/FrontendActions.h; flang/include/flang/Frontend/FrontendOptions.h; flang/include/flang/Frontend/FrontendPluginRegistry.h; flang/include/flang/Frontend/PreprocessorOptions.h; flang/include/flang/Frontend/TargetOptions.h; flang/include/flang/Frontend/TextDiagnostic.h; flang/include/flang/Frontend/TextDiagnosticBuffer.h; flang/include/flang/Frontend/TextDiagnosticPrinter.h; flang/include/flang/FrontendTool/Utils.h; flang/include/flang/Lower/AbstractConverter.h; flang/include/flang/Lower/Allocatable.h; flang/include/flang/Lower/BoxAnalyzer.h; flang/include/flang/Lower/Bridge.h; flang/include/flang/Lower/CallInterface.h; flang/include/flang/Lower/Coarray.h; flang/include/flang/Lower/ComponentPath.h; flang/include/flang/Lower/ConvertExpr.h; flang/include/flang/Lower/ConvertType.h; flang/include/flang/Lower/ConvertVariable.h; flang/include/flang/L,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:110392,variab,variable,110392,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['variab'],['variable']
Modifiability,"foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be writte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:28300,variab,variables,28300,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Librar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26275,variab,variable,26275,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"for a higher level source language constructs for building a compiler?; --------------------------------------------------------------------------------------------; Currently, there isn't much. LLVM supports an intermediate representation; which is useful for code representation but will not support the high level; (abstract syntax tree) representation needed by most compilers. There are no; facilities for lexical nor semantic analysis. I don't understand the ``GetElementPtr`` instruction. Help!; -----------------------------------------------------------; See `The Often Misunderstood GEP Instruction <GetElementPtr.html>`_. Using the C and C++ Front Ends; ==============================. Can I compile C or C++ code to platform-independent LLVM bitcode?; -----------------------------------------------------------------; No. C and C++ are inherently platform-dependent languages. The most obvious; example of this is the preprocessor. A very common way that C code is made; portable is by using the preprocessor to include platform-specific code. In; practice, information about other platforms is lost after preprocessing, so; the result is inherently dependent on the platform that the preprocessing was; targeting. Another example is ``sizeof``. It's common for ``sizeof(long)`` to vary; between platforms. In most C front-ends, ``sizeof`` is expanded to a; constant immediately, thus hard-wiring a platform-specific detail. Also, since many platforms define their ABIs in terms of C, and since LLVM is; lower-level than C, front-ends currently must emit platform-specific IR in; order to have the result conform to the platform ABI. Questions about code generated by the demo page; ===============================================. What is this ``llvm.global_ctors`` and ``_GLOBAL__I_a...`` stuff that happens when I ``#include <iostream>``?; -------------------------------------------------------------------------------------------------------------; If you ``#include`` the ``<iostre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst:5908,portab,portable,5908,interpreter/llvm-project/llvm/docs/FAQ.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FAQ.rst,1,['portab'],['portable']
Modifiability,"for all entries; Int_t nentries = (Int_t)t2->GetEntries();; for (Int_t i=0;i<nentries;i++) {; b_destep->GetEntry(i);; // fill the histogram with the destep entry; hdestep->Fill(destep);; }. // we do not close the file; we want to keep the generated histograms;; // we fill a 3-d scatter plot with the particle step coordinates; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,800);; c1->SetFillColor(42);; c1->Divide(1,2);. c1->cd(1);; hdestep->SetFillColor(45);; hdestep->Fit(""gaus"");. c1->cd(2);; gPad->SetFillColor(37); // continued...; t2->SetMarkerColor(kRed);; t2->Draw(""vect[0]:vect[1]:vect[2]"");; if (gROOT->IsBatch()) return;. // invoke the x3d viewer; gPad->GetViewer3D(""x3d"");; }; ```. ## Example 3: Adding Friends to Trees. In this example, we will show how to extend a tree with a branch from; another tree with the Friends feature. ### Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example, if one; variable in the tree was computed with a certain algorithm, you may want; to try another algorithm and compare the results. One solution is to add; a new branch, fill it, and save the tree. The code below adds a simple; branch to an existing tree. Note that the `kOverwrite` option in the; `Write` method overwrites the existing tree. If it is not specified, two; copies of the tree headers are saved. ``` {.cpp}; void tree3AddBranch() {; TFile f(""tree3.root"",""update"");; Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3-> Branch(""new_v"",&new_v,""new_v/F"");; //read the number of entries in the t3; Int_t nentries = (Int_t)t3->GetEntries();; for (Int_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0,1);; newBranch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:51095,variab,variable,51095,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"for any function that has complex argument-based behaviors or optional; arguments. CMake's official documentation for the module is in the; ``cmake-modules`` manpage, and is also available at the; `cmake-modules online documentation; <https://cmake.org/cmake/help/v3.4/module/CMakeParseArguments.html>`_. .. note::; As of CMake 3.5 the cmake_parse_arguments command has become a native command; and the CMakeParseArguments module is empty and only left around for; compatibility. Functions Vs Macros; -------------------. Functions and Macros look very similar in how they are used, but there is one; fundamental difference between the two. Functions have their own scope, and; macros don't. This means variables set in macros will bleed out into the calling; scope. That makes macros suitable for defining very small bits of functionality; only. The other difference between CMake functions and macros is how arguments are; passed. Arguments to macros are not set as variables, instead dereferences to; the parameters are resolved across the macro before executing it. This can; result in some unexpected behavior if using unreferenced variables. For example:. .. code-block:: cmake. macro(print_list my_list); foreach(var IN LISTS my_list); message(""${var}""); endforeach(); endmacro(). set(my_list a b c d); set(my_list_of_numbers 1 2 3 4); print_list(my_list_of_numbers); # prints:; # a; # b; # c; # d. Generally speaking this issue is uncommon because it requires using; non-dereferenced variables with names that overlap in the parent scope, but it; is important to be aware of because it can lead to subtle bugs. LLVM Project Wrappers; =====================. LLVM projects provide lots of wrappers around critical CMake built-in commands.; We use these wrappers to provide consistent behaviors across LLVM components; and to reduce code duplication. We generally (but not always) follow the convention that commands prefaced with; ``llvm_`` are intended to be used only as building blocks for ot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst:12434,variab,variables,12434,interpreter/llvm-project/llvm/docs/CMakePrimer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMakePrimer.rst,1,['variab'],['variables']
Modifiability,"for debugging; or program visualization purposes. Transform passes can use (or invalidate); the analysis passes. Transform passes all mutate the program in some way.; Utility passes provides some utility but don't otherwise fit categorization.; For example passes to extract functions to bitcode or write a module to bitcode; are neither analysis nor transform passes. The table of contents above; provides a quick summary of each pass and links to the more complete pass; description later in the document. Analysis Passes; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; ----------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:1510,adapt,adapted,1510,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['adapt'],['adapted']
Modifiability,"for the loop is set up, we switch to emitting; code for the loop body. To begin with, we move the insertion point and; create the PHI node for the loop induction variable. Since we already; know the incoming value for the starting value, we add it to the Phi; node. Note that the Phi will eventually get a second value for the; backedge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23032,variab,variables,23032,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"fore you should add an offset of one or two compile jobs ; to be sure its not terminated in your memory restricted environment. On ELF; platforms also consider ``LLVM_USE_SPLIT_DWARF`` in Debug build. **LLVM_PROFDATA_FILE**:PATH; Path to a profdata file to pass into clang's -fprofile-instr-use flag. This; can only be specified if you're building with clang. **LLVM_REVERSE_ITERATION**:BOOL; If enabled, all supported unordered llvm containers would be iterated in; reverse order. This is useful for uncovering non-determinism caused by; iteration of unordered containers. **LLVM_STATIC_LINK_CXX_STDLIB**:BOOL; Statically link to the C++ standard library if possible. This uses the flag; ""-static-libstdc++"", but a Clang host compiler will statically link to libc++; if used in conjunction with the **LLVM_ENABLE_LIBCXX** flag. Defaults to OFF. **LLVM_TABLEGEN**:STRING; Full path to a native TableGen executable (usually named ``llvm-tblgen``). This is; intended for cross-compiling: if the user sets this variable, no native; TableGen will be created. **LLVM_TARGET_ARCH**:STRING; LLVM target to use for native code generation. This is required for JIT; generation. It defaults to ""host"", meaning that it shall pick the architecture; of the machine where LLVM is being built. If you are cross-compiling, set it; to the target architecture name. **LLVM_TARGETS_TO_BUILD**:STRING; Semicolon-separated list of targets to build, or *all* for building all; targets. Case-sensitive. Defaults to *all*. Example:; ``-DLLVM_TARGETS_TO_BUILD=""X86;PowerPC""``.; The full list, as of March 2023, is:; ``AArch64;AMDGPU;ARM;AVR;BPF;Hexagon;Lanai;LoongArch;Mips;MSP430;NVPTX;PowerPC;RISCV;Sparc;SystemZ;VE;WebAssembly;X86;XCore``. **LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN**:BOOL; If enabled, the compiler version check will only warn when using a toolchain; which is about to be deprecated, instead of emitting an error. **LLVM_UBSAN_FLAGS**:STRING; Defines the set of compile flags used to enable UBSan. Only used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:34101,variab,variable,34101,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"foreBinaryOperators>`; The way to wrap binary operators. Possible values:. * ``BOS_None`` (in configuration: ``None``); Break after operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &&; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa >; ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_NonAssignment`` (in configuration: ``NonAssignment``); Break before operators that aren't assignments. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable =; someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. * ``BOS_All`` (in configuration: ``All``); Break before operators. .. code-block:: c++. LooooooooooongType loooooooooooooooooooooongVariable; = someLooooooooooooooooongFunction();. bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; && aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa; > ccccccccccccccccccccccccccccccccccccccccc;. .. _BreakBeforeBraces:. **BreakBeforeBraces** (``BraceBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <BreakBeforeBraces>`; The brace breaking style to use. Possible values:. * ``BS_Attach`` (in configuration: ``Attach``); Always attach braces to surrounding context. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i) {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b) {; if (b) {; baz(2);; } else {; baz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:47122,config,configuration,47122,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"format 15` :ref:`¶ <RequiresClausePosition>`; The position of the ``requires`` clause. Possible values:. * ``RCPS_OwnLine`` (in configuration: ``OwnLine``); Always put the ``requires`` clause on its own line. .. code-block:: c++. template <typename T>; requires C<T>; struct Foo {... template <typename T>; requires C<T>; void bar(T t) {... template <typename T>; void baz(T t); requires C<T>; {... * ``RCPS_WithPreceding`` (in configuration: ``WithPreceding``); Try to put the clause together with the preceding part of a declaration.; For class templates: stick to the template declaration.; For function templates: stick to the template declaration.; For function declaration followed by a requires clause: stick to the; parameter list. .. code-block:: c++. template <typename T> requires C<T>; struct Foo {... template <typename T> requires C<T>; void bar(T t) {... template <typename T>; void baz(T t) requires C<T>; {... * ``RCPS_WithFollowing`` (in configuration: ``WithFollowing``); Try to put the ``requires`` clause together with the class or function; declaration. .. code-block:: c++. template <typename T>; requires C<T> struct Foo {... template <typename T>; requires C<T> void bar(T t) {... template <typename T>; void baz(T t); requires C<T> {... * ``RCPS_SingleLine`` (in configuration: ``SingleLine``); Try to put everything in the same line if possible. Otherwise normal; line breaking rules take over. .. code-block:: c++. // Fitting:; template <typename T> requires C<T> struct Foo {... template <typename T> requires C<T> void bar(T t) {... template <typename T> void bar(T t) requires C<T> {... // Not fitting, one possible example:; template <typename LongName>; requires C<LongName>; struct Foo {... template <typename LongName>; requires C<LongName>; void bar(LongName ln) {. template <typename LongName>; void bar(LongName ln); requires C<LongName> {. .. _RequiresExpressionIndentation:. **RequiresExpressionIndentation** (``RequiresExpressionIndentationKind``) :versionbadg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:105215,config,configuration,105215,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"format 3.7` :ref:`¶ <BinPackParameters>`; If ``false``, a function declaration's or function definition's; parameters will either all be on the same line or will have one line each. .. code-block:: c++. true:; void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. false:; void f(int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaa,; int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) {}. .. _BitFieldColonSpacing:. **BitFieldColonSpacing** (``BitFieldColonSpacingStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BitFieldColonSpacing>`; The BitFieldColonSpacingStyle to use for bitfields. Possible values:. * ``BFCS_Both`` (in configuration: ``Both``); Add one space on each side of the ``:``. .. code-block:: c++. unsigned bf : 2;. * ``BFCS_None`` (in configuration: ``None``); Add no space around the ``:`` (except when needed for; ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf:2;. * ``BFCS_Before`` (in configuration: ``Before``); Add space before the ``:`` only. .. code-block:: c++. unsigned bf :2;. * ``BFCS_After`` (in configuration: ``After``); Add space after the ``:`` only (space may be added before if; needed for ``AlignConsecutiveBitFields``). .. code-block:: c++. unsigned bf: 2;. .. _BraceWrapping:. **BraceWrapping** (``BraceWrappingFlags``) :versionbadge:`clang-format 3.8` :ref:`¶ <BraceWrapping>`; Control of individual brace wrapping cases. If ``BreakBeforeBraces`` is set to ``BS_Custom``, use this to specify how; each individual brace case should be handled. Otherwise, this is ignored. .. code-block:: yaml. # Example of usage:; BreakBeforeBraces: Custom; BraceWrapping:; AfterEnum: true; AfterStruct: false; SplitEmptyFunction: false. Nested configuration flags:. Precise control over the wrapping of braces. .. code-block:: c++. # Should be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:37995,config,configuration,37995,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"formation about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The nam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14535,config,config-prefix,14535,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['config'],['config-prefix']
Modifiability,"formation for the variable ``Z``. .. code-block:: text. !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18). Here ``!19`` indicates that ``Z`` is declared at line number 5 and column; number 11 inside of lexical scope ``!18``. The lexical scope itself resides; inside of subprogram ``!4`` described above. The scope information attached with each instruction provides a straightforward; way to find instructions covered by a scope. Object lifetime in optimized code; =================================. In the example above, every variable assignment uniquely corresponds to a; memory store to the variable's position on the stack. However in heavily; optimized code LLVM promotes most variables into SSA values, which can; eventually be placed in physical registers or memory locations. To track SSA; values through compilation, when objects are promoted to SSA values an; ``llvm.dbg.value`` intrinsic is created for each assignment, recording the; variable's new location. Compared with the ``llvm.dbg.declare`` intrinsic:. * A dbg.value terminates the effect of any preceding dbg.values for (any; overlapping fragments of) the specified variable.; * The dbg.value's position in the IR defines where in the instruction stream; the variable's value changes.; * Operands can be constants, indicating the variable is assigned a; constant value. Care must be taken to update ``llvm.dbg.value`` intrinsics when optimization; passes alter or move instructions and blocks -- the developer could observe such; changes reflected in the value of variables when debugging the program. For any; execution of the optimized program, the set of variable values presented to the; developer by the debugger should not show a state that would never have existed; in the execution of the unoptimized program, given the same input. Doing so; risks misleading the developer by reporting a state that does not exist,; damaging their understanding of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:18310,variab,variable,18310,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBuilder_8h_source.html>`_; class template keep track of the current place to insert instructions; and has methods to create new instructions. ``TheModule`` is an LLVM construct that contains functions and global; variables. In many ways, it is the top-level structure that the LLVM IR; uses to contain code. It will own the memory for all of the IR that we; generate, which is why the codegen() method returns a raw Value\*,; rather than a unique_ptr<Value>. The ``NamedValues`` map keeps track of which values are defined in the; current scope and what their LLVM representation is. (In other words, it; is a symbol table for the code). In this form of Kaleidoscope, the only; things that can be referenced are function parameters. As such, function; parameters will be in this map when generating code for their function; body. With these basics in place, we can start talking about how to generate; code for each expression. Note that this assumes that the ``Builder``; has been set up to generate code *into* something. For now, we'll assume; that this has already been done, and we'll just use it to emit code. Expression Code Generation; ==========================. Generating",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:3810,variab,variables,3810,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"free to contact us on `the Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_ or file `a GitHub issue; <https://github.com/llvm/llvm-project/issues/new>`_. .. _opencl_experimental_cxxlibs:. C++ libraries for OpenCL; ------------------------. There is ongoing work to support C++ standard libraries from `LLVM's libcxx; <https://libcxx.llvm.org/>`_ in OpenCL kernel code using C++ for OpenCL mode. It is currently possible to include `type_traits` from C++17 in the kernel; sources when the following clang extensions are enabled; ``__cl_clang_function_pointers`` and ``__cl_clang_variadic_functions``,; see :doc:`LanguageExtensions` for more details. The use of non-conformant; features enabled by the extensions does not expose non-conformant behavior; beyond the compilation i.e. does not get generated in IR or binary.; The extension only appear in metaprogramming; mechanism to identify or verify the properties of types. This allows to provide; the full C++ functionality without a loss of portability. To avoid unsafe use; of the extensions it is recommended that the extensions are disabled directly; after the header include. **Example of Use**:. The example of kernel code with `type_traits` is illustrated here. .. code-block:: c++. #pragma OPENCL EXTENSION __cl_clang_function_pointers : enable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable; #include <type_traits>; #pragma OPENCL EXTENSION __cl_clang_function_pointers : disable; #pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable. using sint_type = std::make_signed<unsigned int>::type;. __kernel void foo() {; static_assert(!std::is_same<sint_type, unsigned int>::value);; }. The possible clang invocation to compile the example is as follows:. .. code-block:: console. $ clang -I<path to libcxx checkout or installation>/include test.clcpp. Note that `type_traits` is a header only library and therefore no extra; linking step against the standard libraries is require",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:23595,portab,portability,23595,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['portab'],['portability']
Modifiability,"from HybridCalculator to; HybridCalculatorOriginal; Note also that with the new class no HybridResult is; returned but directly the base class HypoTestResult which; has been improved for this release.; The plot class, HybridPlot is not returned, but; the user can create an HypoTestPlot object from the; HypoTestResult.; The classes HybridResult and HybridPlot work only; with the HybridCalculatorOriginal and remain for maintaining; a backward compatibility. ; Given a ModelConfig, the tool will attempt to form the posterior pdf ; for the nuisance parameters based on the prior and the constraint terms ; in the pdf. However, this is not yet implemented. In order to keep; logical consistency with other tools, the distribution being used; to smear the nuisance parameters should NOT be considered the prior in ; the model config. Instead, one should use HybridCalculator's; ForcePriorNuisanceNull and ForcePriorNuisanceAlt. HybridCalculatorOriginal. Apply a fix for test statistic = 3 (profile likelihood); Apply a fix for using non-extended pdf. TestStatSampler and TestStatistics. Cleanup of the interfaces.; TestStatistics now have a method PValueIsRightTail to specify the sign conventions for the test statistic. This is used when making plots and calculating p-values.; make clear that TestStatistic::Evaluate should take data and values of the parameters that define the null.; Add method TestStatSampler::SetParametersForTestStat that ; allows for greater control of parameters used for generating toy data; and parameters used for evaluating the test statistic.; ProfileLikelihoodTestStatUsing the raw profile likelihood while reviewing the old algorithm used to provide robustness in situations with local minima.; New test statistic classes:; ; SimpleLikelihoodRatioTestStat : log L_1 / L_0; RatioOfProfiledLikelihoodsTestStat: log L(mu_1, hat(nu_1))/L(mu_0,hat(nu_0)); MaxLikelihoodEstimateTestStat: the MLE of a specified parameter. ToyMCSampler. New version of ToyMCSampler which can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:6405,extend,extended,6405,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,1,['extend'],['extended']
Modifiability,"from the context menu and that method; has options, the user will be asked for numerical values or strings to; fill in the option. For example, `TAxis::SetTitle` will prompt you for a; string to use for the axis title. ![Context menus of different objects in a canvas](pictures/030000A0.png). #### Structure of the Context Menus. The curious reader will have noticed that each entry in the context menu; corresponds to a method of the class. Look for example to the menu named; `TAxis::xaxis`. `xaxis` is the name of the object and **`TAxis`** the; name of its class. If we look at the list of **`TAxis`** methods, for; example in <https://root.cern/doc/master/classTAxis.html>, we see the; methods `SetTimeDisplay()` and` UnZoom()`, which appear also in the; context menu. There are several divisions in the context menu, separated by lines. The; top division is a list of the class methods; the second division is a; list of the parent class methods. The subsequent divisions are the; methods other parent classes in case of multiple inheritance. For; example, see the `TPaveText::title context; menu.` A **`TPaveText`** inherits from **`TAttLine`**, which has the; method `SetLineAttributes()`. #### Adding Context Menus for a Class. For a method to appear in the context menu of the object it has to be; marked by `// *MENU*` in the header file. Below is the line from; `TAttLine.h` that adds the `SetLineAttribute` method to the context; menu. ``` {.cpp}; virtual void SetLineAttributes(); // *MENU*; ```. Nothing else is needed, since Cling knows the classes and their methods.; It takes advantage of that to create the context menu on the fly when; the object is clicking on. If you click on an axis, ROOT will ask the; interpreter what are the methods of the **`TAxis`** and which ones are; set for being displayed in a context menu. Now, how does the interpreter know this? Remember, when you build a; class that you want to use in the ROOT environment, you use `rootcling`; that builds the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:5762,inherit,inheritance,5762,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['inherit'],['inheritance']
Modifiability,"from those superclasses. ``Init``; --------. The ``Init`` class is used to represent TableGen values. The name derives; from *initialization value*. This class should not be confused with the; ``RecordVal`` class, which represents record fields, both their names and; values. The ``Init`` class is the base class for a series of subclasses, one; for each of the available value types. The primary data member of ``Init``; is an enumerated type that represents the specific type of the value. The ``Init`` class provides a few useful functions. * A function to get the type enumerator. * A boolean virtual function to determine whether a value is completely; specified; that is, has no uninitialized subvalues. * Virtual functions to get the value as a string. * Virtual functions to cast the value to other types, implement the bit; range feature of TableGen, and implement the list slice feature. * A virtual function to get a particular bit of the value. The subclasses that inherit directly from ``Init`` are; ``UnsetInit`` and ``TypedInit``. An ``Init`` instance can be printed to an output stream with the ``<<``; operator. .. warning::; It is not specified whether two separate initialization values with; the same underlying type and value (e.g., two strings with the value; ""Hello"") are represented by two ``Init``\ s or share the same ``Init``. ``UnsetInit``; ~~~~~~~~~~~~~. This class, a subclass of ``Init``, represents the unset (uninitialized); value. The static function ``get()`` can be used to obtain the singleton; ``Init`` of this type. ``TypedInit``; ~~~~~~~~~~~~~. This class, a subclass of ``Init``, acts as the parent class of the classes; that represent specific value types (except for the unset value). These; classes include ``BitInit``, ``BitsInit``, ``DagInit``, ``DefInit``,; ``IntInit``, ``ListInit``, and ``StringInit``. (There are additional derived; types used by the TableGen parser.). This class includes a data member that specifies the ``RecTy`` type of the; value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:9699,inherit,inherit,9699,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['inherit'],['inherit']
Modifiability,"fter collapsing a loop nest via the; collapse clause by replacing the expensive remainder operation with; multiplications and additions. - When using the collapse clause on a loop nest the default behavior; is to automatically extend the representation of the loop counter to; 64 bits for the cases where the sizes of the collapsed loops are not; known at compile time. To prevent this conservative choice and use; at most 32 bits, compile your program with the; `-fopenmp-optimistic-collapse`. GPU devices support; ===================. Data-sharing modes; ------------------. Clang supports two data-sharing models for Cuda devices: `Generic` and `Cuda`; modes. The default mode is `Generic`. `Cuda` mode can give an additional; performance and can be activated using the `-fopenmp-cuda-mode` flag. In; `Generic` mode all local variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:1885,variab,variables,1885,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"ftware and method performance; validation has been implemented.; . Methods. BDT Automatic parameter optimisation for building the; tree architecture: The optimisation procedure uses the; performance of the trained classifier on the ""test sample"" for; finding the set of optimal parameters. Two different methods to; traverse the parameter space are available (scanning, genetic; algorithm). Currently parameter optimization is implemented only; for these three parameters that influence the tree architectur:; the maximum depth of a tree, MaxDepth, the minimum; number of events in each node, NodeMinEvents, and; the number of tress, NTrees. Optimization can; is invoked by calling; factory->OptimizeAllMethods(); prior to the call; factory->TrainAllMethods();. Automated and configurable parameter optimization is soon to; be enabled for all methods (for those parameters where; optimization is applicable).; . BDT node splitting: While Decision Trees; typically have only univariate splits, in TMVA one can now; also opt for multivariate splits that use a ""Fisher; Discriminant"" (option: UseFisherCuts), built from all; observables that show correlations larger than some threshold; (MinLinCorrForFisher). The training will then test at each; split a cut on this fisher discriminant in addition to all; univariate cuts on the variables (or only on those variables; that have not been used in the Fisher discriminant, option; UseExcusiveVars). No obvious improvement betwen very simple; decision trees after boosting has been observed so far, but; only a limited number of studies has been performed concerning; potiential benenfit of these simple multivariate splits.; . Bug fixes. A problem in the BDTG has been fixed, leading to a much; improved regression performance.; A problem in the TMVA::Reader has been fixed.; With the new test framework and the coverity checks of ROOT; a number of bugs were discovered and fixed. They mainly concerned; memory leaks, and did not affect the performance. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html:2809,variab,variables,2809,tmva/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v528/index.html,2,['variab'],['variables']
Modifiability,"ful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointer on selected; architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of; work is needed to support other registers and even more so, allocatable; registers. .. _int_stacksave:. '``llvm.stacksave``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.stacksave.p0(); declare ptr addrspace(5) @llvm.stacksave.p5(). Overview:; """""""""""""""""". The '``llvm.stacksave``' intrinsic is used to remember the current state; of the function stack, for use with; :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for; implementing language features like scoped automatic variable sized; arrays in C99. Semantics:; """""""""""""""""""". This intrinsic returns an opaque pointer value that can be passed to; :ref:`llvm.stackrestore <int_stackrestore>`. When an; ``llvm.stackrestore`` intrinsic is executed with a value saved from; ``llvm.stacksave``, it effectively restores the state of the stack to; the state it was in when the ``llvm.stacksave`` intrinsic executed. In; practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack; that were allocated after the ``llvm.stacksave`` was executed. The; address space should typically be the; :ref:`alloca address space <alloca_addrspace>`. .. _int_stackrestore:. '``llvm.stackrestore``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.stackrestore.p0(ptr %ptr); declare void @llvm.stackrestore.p5(ptr addrspace(5) %ptr). Overview:; """""""""""""""""". The '``llvm.stackrestore``' intrinsic is used to restore the state of; the function stack to the state it was in when ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:519887,variab,variable,519887,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass())));; // function -> module; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionFooPass()));. // loop -> function -> cgscc -> module; MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(createCGSCCToFunctionPassAdaptor(createFunctionToLoopPassAdaptor(LoopFooPass()))));; // function -> cgscc -> module; MPM.addPass(createModuleToPostOrderCGSCCPassAdaptor(createCGSCCToFunctionPassAdaptor(FunctionFooPass())));. A pass manager of a specific IR unit is also a pass of that kind. For; example, a ``FunctionPassManager`` is a function pass, meaning it can be; added to a ``ModulePassManager``:. .. code-block:: c++. ModulePassManager MPM;. FunctionPassManager FPM;; // InstSimplifyPass is a function pass; FPM.addPass(InstSimplifyPass());. MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));. Generally you want to group CGSCC/function/loop passes together in a pass; manager, as opposed to adding adaptors for each pass to the containing upper; level pass manager. For example,. .. code-block:: c++. ModulePassManager MPM;; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionPass1()));; MPM.addPass(createModuleToFunctionPassAdaptor(FunctionPass2()));; MPM.run();. will run ``FunctionPass1`` on each function in a module, then run; ``FunctionPass2`` on each function in the module. In contrast,. .. code-block:: c++. ModulePassManager MPM;. FunctionPassManager FPM;; FPM.addPass(FunctionPass1());; FPM.addPass(FunctionPass2());. MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));. will run ``FunctionPass1`` and ``FunctionPass2`` on the first function in a; module, then run both passes on the second function in the module, and so on.; This is better for cache locality around LLVM data structures. This similarly; applies for the other IR types, and in some cases can even affect the quality; of optimization. For example, running all loop passes on a loop may",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:3865,adapt,adaptors,3865,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['adapt'],['adaptors']
Modifiability,"function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove them if the test doesn't depend on; them. - Alias Analysis is performed on IR values. These are referenced by memory; operands in MIR. Example: `:: (load 8 from %ir.foobar, !alias.scope !9)`.; If the test doesn't depend on (good) alias analysis the references can be; dropped: `:: (load 8)`. - MIR blocks can reference IR blocks for debug printing, profile information; or debug locations. Example: `bb.42.myblock` in MIR references the IR block; `myblock`. It is usually possible to drop the `.myblock` reference and simply; use `bb.42`. - If there are no memory operands or blocks referencing the IR then the; IR function can be replaced by a parameterless dummy function like; `define @func() { ret void }`. - It is possible to drop the whole IR section of the MIR file if it only; contains dummy functions (see above). The .mir loader will cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:4196,variab,variables,4196,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variables']
Modifiability,"function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83767,variab,variable,83767,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"functions and the dictionary. These; functions and the dictionary contain the knowledge of the used classes.; To do this, `rootcling` parses all the header files. ROOT has defined; some special syntax to inform Cling of certain things, this is done in; the comments so that the code still compiles with a C++ compiler. For example, you have a class with a `Draw()` method, which will display; itself. You would like a context menu to appear when on clicks on the; image of an object of this class. The recipe is the following:. - The class has to contain the `ClassDef/ClassImp` macros. - For each method you want to appear in the context menu, put a; comment after the declaration containing `*MENU*` or `*TOGGLE*`; depending on the behavior you expect. One usually uses Set methods; (setters). The `*TOGGLE*` comment is used to toggle a `boolean` data; field. In that case, it is safe to call the data field `fMyBool`; where `MyBool` is the name of the setter `SetMyBool`. Replace; `MyBool` with your own `boolean` variable. - You can specify arguments and the data members in which to store the; arguments. For example:. ``` {.cpp}; class MyClass : public TObject {; private:; int fV1; // first variable; double fV2; // second variable; public:; int GetV1() {return fV1;}; double GetV2() {return fV2;}; void SetV1(int x1) { fV1 = x1;} // *MENU*; void SetV2(double d2) { fV2 = d2;} // *MENU*; void SetBoth(int x1, double d2) {fV1 = x1; fV2 = d2;}. ClassDef (MyClass,1); }; ```. To specify arguments:. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fV1}; ```. This statement is in the comment field, after the \*MENU\*. If there is; more than one argument, these arguments are separated by commas, where; fX1 and fY2 are data fields in the same class. ``` {.cpp}; void SetXXX(Int_t x1, Float_t y2); //*MENU* *ARGS={x1=>fX1,y2=>fY2}; ```. If the arguments statement is present, the option dialog displayed when; selecting `SetXXX field` will show the values of variables. We indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:7758,variab,variable,7758,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['variab'],['variable']
Modifiability,"functions.; The same issue occurs for NEON and Altivec for the ARM and PowerPC; architectures respectively. For these, make sure to use the <arm_neon.h>; and <altivec.h> headers.; For x86 architectures this script should help with; the manual migration process. It will rewrite your source files in place to; use the APIs instead of builtin function calls. Just call it like this:. builtins.py *.c *.h. and it will rewrite all of the .c and .h files in the current directory to; use the API calls instead of calls like __builtin_ia32_paddw128. Lvalue casts. Old versions of GCC permit casting the left-hand side of an assignment to a; different type. Clang produces an error on similar code, e.g.,. lvalue.c:2:3: error: assignment to cast is illegal, lvalue casts are not supported; (int*)addr = val;; ^~~~~~~~~~ ~. To fix this problem, move the cast to the right-hand side. In this; example, one could use:. addr = (float *)val;. Jumps to within __block variable scope. Clang disallows jumps into the scope of a __block; variable. Variables marked with __block require special; runtime initialization. A jump into the scope of a __block; variable bypasses this initialization, leaving the variable's metadata; in an invalid state. Consider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:5473,variab,variable,5473,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability,"fuzzer is good for stressing the surface layers of a; program, and is good at testing things like lexers, parsers, or binary; protocols. Some of the in-tree fuzzers that use this type of mutator are `clang-fuzzer`_,; `clang-format-fuzzer`_, `llvm-as-fuzzer`_, `llvm-dwarfdump-fuzzer`_,; `llvm-mc-assemble-fuzzer`_, and `llvm-mc-disassemble-fuzzer`_. .. _fuzzing-llvm-protobuf:. Structured Fuzzing using ``libprotobuf-mutator``; ------------------------------------------------. We can use libprotobuf-mutator_ in order to perform structured fuzzing and; stress deeper layers of programs. This works by defining a protobuf class that; translates arbitrary data into structurally interesting input. Specifically, we; use this to work with a subset of the C++ language and perform mutations that; produce valid C++ programs in order to exercise parts of clang that are more; interesting than parser error handling. To build this kind of fuzzer you need `protobuf`_ and its dependencies; installed, and you need to specify some extra flags when configuring the build; with :doc:`CMake <CMake>`. For example, `clang-proto-fuzzer`_ can be enabled by; adding ``-DCLANG_ENABLE_PROTO_FUZZER=ON`` to the flags described in; :ref:`building-fuzzers`. The only in-tree fuzzer that uses ``libprotobuf-mutator`` today is; `clang-proto-fuzzer`_. .. _libprotobuf-mutator: https://github.com/google/libprotobuf-mutator; .. _protobuf: https://github.com/google/protobuf. .. _fuzzing-llvm-ir:. Structured Fuzzing of LLVM IR; -----------------------------. We also use a more direct form of structured fuzzing for fuzzers that take; :doc:`LLVM IR <LangRef>` as input. This is achieved through the ``FuzzMutate``; library, which was `discussed at EuroLLVM 2017`_. The ``FuzzMutate`` library is used to structurally fuzz backends in; `llvm-isel-fuzzer`_. .. _discussed at EuroLLVM 2017: https://www.youtube.com/watch?v=UBbQ_s6hNgg. Building and Running; ====================. .. _building-fuzzers:. Configuring LLVM to Build",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst:7021,config,configuring,7021,interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FuzzingLLVM.rst,1,['config'],['configuring']
Modifiability,"fy must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7306,config,configuration,7306,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configuration']
Modifiability,"g and testing LLVM/Clang on ARM. :doc:`HowToBuildWithPGO`; Notes on building LLVM/Clang with PGO. :doc:`HowToCrossCompileLLVM`; Notes on cross-building and testing LLVM/Clang. `How to build the C, C++, ObjC, and ObjC++ front end`__; Instructions for building the clang front-end from source. .. __: https://clang.llvm.org/get_started.html. :doc:`CoverageMappingFormat`; This describes the format and encoding used for LLVM’s code coverage mapping. :doc:`CFIVerify`; A description of the verification tool for Control Flow Integrity. LLVM Builds and Distributions; -----------------------------. :doc:`BuildingADistribution`; A best-practices guide for using LLVM's CMake build system to package and; distribute LLVM-based tools. :doc:`CMake`; An addendum to the main Getting Started guide for those using the `CMake; build system <http://www.cmake.org>`_. :doc:`Docker`; A reference for using Dockerfiles provided with LLVM. :doc:`Support Library <SupportLibrary>`; This document describes the LLVM Support Library (``lib/Support``) and; how to keep LLVM source code portable. :doc:`AdvancedBuilds`; This document describes more advanced build configurations. Optimizations; -------------. :doc:`WritingAnLLVMPass`; Information on how to write LLVM transformations and analyses. :doc:`WritingAnLLVMNewPMPass`; Information on how to write LLVM transformations under the new pass; manager. :doc:`Passes`; A list of optimizations and analyses implemented in LLVM. :doc:`StackSafetyAnalysis`; This document describes the design of the stack safety analysis of local; variables. :doc:`MergeFunctions`; Describes functions merging optimization. :doc:`AliasAnalysis`; Information on how to write a new alias analysis implementation or how to; use existing analyses. :doc:`MemorySSA`; Information about the MemorySSA utility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:2507,portab,portable,2507,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['portab'],['portable']
Modifiability,"g as the `CMakeCache.txt` file is not removed. Remember that after building a tarball or a binary package you should remove the copied files using:. ```bash; make purge; ```. Otherwise git shows the file as untracked, unless you explicitly remove their tracking yourself with a .gitignore file. ## Building a tarball. Minuit2 standalone also has support for CPack to make installers for different platforms. To build a source package:. ```bash; make package_source; ```. This will create a source file in several formats that you can distribute. Reminder: You **must** have used `-Dminuit2_standalone=ON` when you configured CMake, or many of the files will be missing. ## Building a binary. To build a binary package (add other generators with `-G`):; ```bash; make; make package; ```. ## Maintenance. If new files are needed by Minuit2 due to additions to [ROOT], they should be added to the source files lists in `src/Math/CMakeLists.txt` and `src/Minuit2/CMakeLists.txt` (depending on if it's a new Math or Minuit2 requirement). For testing, the main `test/CMakeLists.txt` is used by ROOT, and the `test/*/CMakeLists.txt` files are used by the standalone build. ## How it works. Extracting from the ROOT sources is made possible through a few careful design features:. * A CMake variable `minuit2_inroot` lets the build system know we are inside ROOT (it looks for `../../build/version_info`); * All files that are not part of the minuit2 directory are passed into `copy_standalone`, and that handles selecting the correct location; * `copy_standalone` copies the files into the minuit2 source directory if `minuit2_standalone` is `ON`. After this happens, all the standard CMake machinery can produce the source distribution. And, CMake correctly builds and installs in either mode, since all source and header files are explicitly listed. [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md:2112,variab,variable,2112,math/minuit2/DEVELOP.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/DEVELOP.md,1,['variab'],['variable']
Modifiability,"g can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can mode",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2844,variab,variables,2844,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['variab'],['variables']
Modifiability,"g from the old instruction number /; operand pair to new instruction number / operand pair. Consider if we replace; a three-address add instruction with a two-address add:. ```text; %2:gr32 = ADD32rr %0, %1, debug-instr-number 1; ```. becomes. ```text; %2:gr32 = ADD32rr %0(tied-def 0), %1, debug-instr-number 2; ```. With a substitution from ""instruction number 1 operand 0"" to ""instruction number; 2 operand 0"" recorded in the `MachineFunction`. In `LiveDebugValues`,; `DBG_INSTR_REF`s will be mapped through the substitution table to find the most; recent instruction number / operand number of the value it refers to. Use `MachineFunction::substituteDebugValuesForInst` to automatically produce; substitutions between an old and new instruction. It assumes that any operand; that is a def in the old instruction is a def in the new instruction at the; same operand position. This works most of the time, for example in the example; above. If operand numbers do not line up between the old and new instruction, use; `MachineInstr::getDebugInstrNum` to acquire the instruction number for the new; instruction, and `MachineFunction::makeDebugValueSubstitution` to record the; mapping between register definitions in the old and new instructions. If some; values computed by the old instruction are no longer computed by the new; instruction, record no substitution -- `LiveDebugValues` will safely drop the; now unavailable variable value. Should your target clone instructions, much the same as the `TailDuplicator`; optimisation pass, do not attempt to preserve the instruction numbers or; record any substitutions. `MachineFunction::CloneMachineInstr` should drop the; instruction number of any cloned instruction, to avoid duplicate numbers; appearing to `LiveDebugValues`. Dealing with duplicated instructions is a; natural extension to instruction referencing that's currently unimplemented. [LiveDebugValues]: project:SourceLevelDebugging.rst#LiveDebugValues expansion of variable locations; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:8722,variab,variable,8722,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,2,['variab'],['variable']
Modifiability,"g name;; }. void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; } else {; c->name = ...;; }; }; ```. We would like to refactor this code into:. ```c++; Customer GetCustomer() {; Customer c;; c.account_id = ...;; if (...) {; c.name = ...;; } else {; c.name = ...;; }; return c;; }; ```. However, in the function below the parameter `c` is not an output parameter; because its field `name` is not overwritten on every path through the function. ```c++; void GetCustomer(Customer *c) {; c->account_id = ...;; if (...) {; c->name = ...;; }; }; ```. The code also cannot read the value of the parameter before overwriting it:. ```c++; void GetCustomer(Customer *c) {; use(c->account_id);; c->name = ...;; c->account_id = ...;; }; ```. Functions that escape the pointer also block the refactoring:. ```c++; Customer* kGlobalCustomer;. void GetCustomer(Customer *c) {; c->name = ...;; c->account_id = ...;; kGlobalCustomer = c;; }; ```. To identify a candidate function for refactoring, we need to do the following:. * Find a function with a non-const pointer or reference parameter. * Find the definition of that function. * Prove that the function completely overwrites the pointee on all paths; before returning. * Prove that the function reads the pointee only after overwriting it. * Prove that the function does not persist the pointer in a data structure; that is live after the function returns. There are also requirements that all usage sites of the candidate function must; satisfy, for example, that function arguments do not alias, that users are not; taking the address of the function, and so on. Let's consider verifying usage; site conditions to be a separate static analysis problem. ### Lattice design. To analyze the function body we can use a lattice which consists of normal; states and failure states. A normal state describes program points where we are; sure that no behaviors that block the refactoring have occurred. Normal states; keep track of all",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:16140,refactor,refactoring,16140,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactoring']
Modifiability,"g of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts names, core scripts name now `JSRoot.core.js`; - unify function/methods naming conventions, many changes in method names; - provide central code loader via `JSROOT.require`, supporting 4 different loading engines; - many nice features and many bug fixes; see JSROOT v6 release notes. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - a new cmake variable, `CMAKE_INSTALL_PYTHONDIR`, has been added: it allows customization of the installation directory of ROOT's python modules; - the developer build option `asserts` is introduced to enable/disable asserts via the `NDEBUG` C/CXX flag. Asserts are always enabled for `CMAKE_BUILD_TYPE=Debug` and `dev=ON`. The previous behavior of the builds set via the `CMAKE_BUILD_TYPE` variable has not changed.; - `CMAKE_CXX_STANDARD`, i.e. the C++ standard ROOT is built with, now defaults to the compiler default (or C++11 if the compiler default is older than that) rather than always defaulting to C++11. In turn this means that v6.24 is the first ROOT release for which ROOT's pre-compiled binaries are not compiled with C++11 but with the default standard in use by the default system compiler. On Ubuntu 20.04, for example, the v6.24 pre-compiled binaries are now compiled with C++14 rather than C++11 as it happened for previous ROOT versions. Also see [ROOT-10692](https://sft.its.cern.ch/jira/browse/ROOT-10692). The following builtins have been updated:. - VecCore 0.7.0. ## PyROOT. - Deprecate `TTree.AsMatri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:27957,variab,variable,27957,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"g standard input or a file that doesn't have the; extension corresponding to its language, ``-assume-filename=`` option can be; used to override the file name :program:`clang-format` uses to detect the; language. An example of a configuration file for multiple languages:. .. code-block:: yaml. ---; # We'll use defaults from the LLVM style, but with 4 columns indentation.; BasedOnStyle: LLVM; IndentWidth: 4; ---; Language: Cpp; # Force pointers to the type for C++.; DerivePointerAlignment: false; PointerAlignment: Left; ---; Language: JavaScript; # Use 100 columns for JS.; ColumnLimit: 100; ---; Language: Proto; # Don't format .proto files.; DisableFormat: true; ---; Language: CSharp; # Use 100 columns for C#.; ColumnLimit: 100; ... An easy way to get a valid ``.clang-format`` file containing all configuration; options of a certain predefined style is:. .. code-block:: console. clang-format -style=llvm -dump-config > .clang-format. When specifying configuration in the ``-style=`` option, the same configuration; is applied for all input files. The format of the configuration is:. .. code-block:: console. -style='{key1: value1, key2: value2, ...}'. Disabling Formatting on a Piece of Code; =======================================. Clang-format understands also special comments that switch formatting in a; delimited range. The code between a comment ``// clang-format off`` or; ``/* clang-format off */`` up to a comment ``// clang-format on`` or; ``/* clang-format on */`` will not be formatted. The comments themselves will be; formatted (aligned) normally. Also, a colon (``:``) and additional text may; follow ``// clang-format off`` or ``// clang-format on`` to explain why; clang-format is turned off or back on. .. code-block:: c++. int formatted_code;; // clang-format off; void unformatted_code ;; // clang-format on; void formatted_code_again;. Configuring Style in Code; =========================. When using ``clang::format::reformat(...)`` functions, the format is specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:3523,config,configuration,3523,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],['configuration']
Modifiability,"g the analysis; state. The analyzer engine talks to them via a visitor interface.; For example, the PreVisitCallExpr() method is called by ExprEngine; to tell the Checker that we are about to analyze a CallExpr, and the; checker is asked to check for any preconditions that might not be; satisfied. The checker can do nothing, or it can generate a new; ProgramState and ExplodedNode which contains updated checker state. If it; finds a bug, it can tell the BugReporter object about the bug,; providing it an ExplodedNode which is the last node in the path that; triggered the problem. = Notes about C++ =. Since now constructors are seen before the variable that is constructed; in the CFG, we create a temporary object as the destination region that; is constructed into. See ExprEngine::VisitCXXConstructExpr(). In ExprEngine::processCallExit(), we always bind the object region to the; evaluated CXXConstructExpr. Then in VisitDeclStmt(), we compute the; corresponding lazy compound value if the variable is not a reference, and; bind the variable region to the lazy compound value. If the variable; is a reference, just use the object region as the initializer value. Before entering a C++ method (or ctor/dtor), the 'this' region is bound; to the object region. In ctors, we synthesize 'this' region with; CXXRecordDecl*, which means we do not use type qualifiers. In methods, we; synthesize 'this' region with CXXMethodDecl*, which has getThisType(); taking type qualifiers into account. It does not matter we use qualified; 'this' region in one method and unqualified 'this' region in another; method, because we only need to ensure the 'this' region is consistent; when we synthesize it and create it directly from CXXThisExpr in a single; method call. = Working on the Analyzer =. If you are interested in bringing up support for C++ expressions, the; best place to look is the visitation logic in ExprEngine, which; handles the simulation of individual expressions. There are plenty of; exam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt:4174,variab,variable,4174,interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/README.txt,2,['variab'],['variable']
Modifiability,"g the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23230,variab,variable,23230,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['variab'],['variable']
Modifiability,"g the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing trees with a selector script ###. Another very general and powerful way of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5376,variab,variable,5376,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variable']
Modifiability,"g to select a directory to INSTALL to; once compiling is complete, although installation is not mandatory for; using LLVM. Another important option is ``LLVM_TARGETS_TO_BUILD``,; which controls the LLVM target architectures that are included on the; build.; * CMake generates project files for all build types. To select a specific; build type, use the Configuration manager from the VS IDE or the; ``/property:Configuration`` command line option when using MSBuild.; * By default, the Visual Studio project files generated by CMake use the; 32-bit toolset. If you are developing on a 64-bit version of Windows and; want to use the 64-bit toolset, pass the ``-Thost=x64`` flag when; generating the Visual Studio solution. This requires CMake 3.8.0 or later. 13. Start Visual Studio and select configuration:. In the directory you created the project files will have an ``llvm.sln``; file, just double-click on that to open Visual Studio. The default Visual; Studio configuration is **Debug** which is slow and generates a huge amount; of debug information on disk. For now, we recommend selecting **Release**; configuration for the LLVM project which will build the fastest or; **RelWithDebInfo** which is also several time larger than Release.; Another technique is to build all of LLVM in Release mode and change; compiler flags, disabling optimization and enabling debug information, only; for specific libraries or source files you actually need to debug. 14. Test LLVM in Visual Studio:. You can run LLVM tests by merely building the project ""check-all"". The test; results will be shown in the VS output window. Once the build succeeds, you; have verified a working LLVM development environment!. You should not see any unexpected failures, but will see many unsupported; tests and expected failures:. ::. 114>Testing Time: 1124.66s; 114> Skipped : 39; 114> Unsupported : 21649; 114> Passed : 51615; 114> Expectedly Failed: 93; ========== Build: 114 succeeded, 0 failed, 321 up-to-date, 0 skipped",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:6932,config,configuration,6932,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['config'],['configuration']
Modifiability,"g to the caller""; Unknown. 2792; DR; Clean up specification of noexcept operator; Unknown. 2793; DR; Block-scope declaration conflicting with parameter name; Unknown. 2794; open; Uniqueness of lambdas in alias templates; Not resolved. 2795; DR; Overlapping empty subobjects with different cv-qualification; Unknown. 2796; DR; Function pointer conversions for relational operators; Unknown. 2797; open; Meaning of ""corresponds"" for rewritten operator candidates; Not resolved. 2798; DR; Manifestly constant evaluation of the static_assert message; Clang 17. 2799; drafting; Inheriting default constructors; Not resolved. 2800; review; Instantiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:194566,rewrite,rewrite,194566,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['rewrite'],['rewrite']
Modifiability,"g transparent volumes; For different geometries different methods can be applied. In any case, all opaque volumes rendered first. ## Reading ROOT files from other servers. In principle, one could open any ROOT file placed in the web, providing the full URL to it like:. - <https://jsroot.gsi.de/latest/?file=https://root.cern/js/files/hsimple.root&item=hpx>. But one should be aware of [Same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy),; when the browser blocks requests to files from domains other than current web page.; To enable CORS on Apache web server, hosting ROOT files, one should add following lines to `.htaccess` file:. <IfModule mod_headers.c>; <FilesMatch ""\.root"">; Header set Access-Control-Allow-Origin ""*""; Header set Access-Control-Allow-Headers ""range""; Header set Access-Control-Expose-Headers ""content-range,content-length,accept-ranges""; Header set Access-Control-Allow-Methods ""GET""; </FilesMatch>; </IfModule>. More details about configuring of CORS headers can be found [here](https://developer.mozilla.org/en/http_access_control). Alternative - enable CORS requests in the browser. It can be easily done with [CORS Everywhere plugin](https://addons.mozilla.org/de/firefox/addon/cors-everywhere/) for the Firefox browser or [Allow CORS plugin](https://chrome.google.com/webstore/detail/allow-control-allow-origi/nlfbmbojpeacfghkpbjhddihlkkiljbi?hl=en) for the Chrome browser. Next solution - install JSROOT on the server hosting ROOT files. In such configuration JSROOT does not issue CORS requests, therefore server and browsers can be used with their default settings. A simplified variant of such solution - copy only the top index.htm file from JSROOT package and specify the full path to `modules/gui.mjs` script like:. ```javascript; <script type=""module"">; import { openFile, draw } from 'https://root.cern/js/latest/modules/gui.mjs';; // ...; </script>; ```. In the main `<div>` element one can specify many custom parameters like one do it in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:28213,config,configuring,28213,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configuring']
Modifiability,"g will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31301,config,config,31301,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['config']
Modifiability,"g with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; --------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:10241,variab,variable,10241,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,1,['variab'],['variable']
Modifiability,"g"" which block; control came from. The Phi operation takes on the value corresponding to; the input control block. In this case, if control comes in from the; ""then"" block, it gets the value of ""calltmp"". If control comes from the; ""else"" block, it gets the value of ""calltmp1"". At this point, you are probably starting to think ""Oh no! This means my; simple and elegant front-end will have to start generating SSA form in; order to use LLVM!"". Fortunately, this is not the case, and we strongly; advise *not* implementing an SSA construction algorithm in your; front-end unless there is an amazingly good reason to do so. In; practice, there are two sorts of values that float around in code; written for your average imperative programming language that might need; Phi nodes:. #. Code that involves user variables: ``x = 1; x = x + 1;``; #. Values that are implicit in the structure of your AST, such as the; Phi node in this case. In `Chapter 7 <LangImpl07.html>`_ of this tutorial (""mutable variables""),; we'll talk about #1 in depth. For now, just believe me that you don't; need SSA construction to handle this case. For #2, you have the choice; of using the techniques that we will describe for #1, or you can insert; Phi nodes directly, if convenient. In this case, it is really; easy to generate the Phi node, so we choose to do it directly. Okay, enough of the motivation and overview, let's generate code!. Code Generation for If/Then/Else; --------------------------------. In order to generate code for this, we implement the ``codegen`` method; for ``IfExprAST``:. .. code-block:: c++. Value *IfExprAST::codegen() {; Value *CondV = Cond->codegen();; if (!CondV); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; CondV = Builder->CreateFCmpONE(; CondV, ConstantFP::get(*TheContext, APFloat(0.0)), ""ifcond"");. This code is straightforward and similar to what we saw before. We emit; the expression for the condition, then compare that value to zero to get;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:8695,variab,variables,8695,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:158909,variab,variables,158909,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['variab'],['variables']
Modifiability,"g-format 5` :ref:`¶ <BreakConstructorInitializers>`; The break constructor initializers style to use. Possible values:. * ``BCIS_BeforeColon`` (in configuration: ``BeforeColon``); Break constructor initializers before the colon and after the commas. .. code-block:: c++. Constructor(); : initializer1(),; initializer2(). * ``BCIS_BeforeComma`` (in configuration: ``BeforeComma``); Break constructor initializers before the colon and commas, and align; the commas with the colon. .. code-block:: c++. Constructor(); : initializer1(); , initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVery",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55169,config,configuration,55169,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,"g-llvm/build/; ninja loop-convert; vim ~/test-files/simple-loops.cc; bin/loop-convert ~/test-files/simple-loops.cc. Step 3.5: More Complicated Matchers; ===================================. Our simple matcher is capable of discovering for loops, but we would; still need to filter out many more ourselves. We can do a good portion; of the remaining work with some cleverly chosen matchers, but first we; need to decide exactly which properties we want to allow. How can we characterize for loops over arrays which would be eligible; for translation to range-based syntax? Range based loops over arrays of; size ``N`` that:. - start at index ``0``; - iterate consecutively; - end at index ``N-1``. We already check for (1), so all we need to add is a check to the loop's; condition to ensure that the loop's index variable is compared against; ``N`` and another check to ensure that the increment step just; increments this same variable. The matcher for (2) is straightforward:; require a pre- or post-increment of the same variable declared in the; init portion. Unfortunately, such a matcher is impossible to write. Matchers contain; no logic for comparing two arbitrary AST nodes and determining whether; or not they are equal, so the best we can do is matching more than we; would like to allow, and punting extra comparisons to the callback. In any case, we can start building this sub-matcher. We can require that; the increment step be a unary increment like this:. .. code-block:: c++. hasIncrement(unaryOperator(hasOperatorName(""++""))). Specifying what is incremented introduces another quirk of Clang's AST:; Usages of variables are represented as ``DeclRefExpr``'s (""declaration; reference expressions"") because they are expressions which refer to; variable declarations. To find a ``unaryOperator`` that refers to a; specific declaration, we can simply add a second condition to it:. .. code-block:: c++. hasIncrement(unaryOperator(; hasOperatorName(""++""),; hasUnaryOperand(declRefExpr())",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:11397,variab,variable,11397,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"g. Let us go through it in detail:. Lines *7-18* define the necessary functions in `C++` code, split into; three separate functions, as suggested by the problem considered. The; full interference pattern is given by the product of a function; depending on the ratio of the width and distance of the slits, and a; second one depending on the number of slits. More important for us here; is the definition of the interface of these functions to make them; usable for the ROOT class `TF1`: the first argument is the pointer to; *x*, the second one points to the array of parameters. The main program starts at line 21 with the definition of a function; `slits()` of type `void`. After asking for user input, a ROOT function; is defined using the C-type function given in the beginning. We can now; use all methods of the `TF1` class to control the behaviour of our; function -- nice, isn't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:7063,extend,extend,7063,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['extend'],['extend']
Modifiability,"g. To be specific, it is preferred to write the code like; this:. .. code-block:: c++. assert(V.size() > 42 && ""Vector smaller than it should be"");. bool NewToSet = Myset.insert(Value); (void)NewToSet;; assert(NewToSet && ""The value shouldn't be in the set yet"");. Do Not Use ``using namespace std``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In LLVM, we prefer to explicitly prefix all identifiers from the standard; namespace with an ""``std::``"" prefix, rather than rely on ""``using namespace; std;``"". In header files, adding a ``'using namespace XXX'`` directive pollutes the; namespace of any source file that ``#include``\s the header, creating; maintenance issues. In implementation files (e.g. ``.cpp`` files), the rule is more of a stylistic; rule, but is still important. Basically, using explicit namespace prefixes; makes the code **clearer**, because it is immediately obvious what facilities; are being used and where they are coming from. And **more portable**, because; namespace clashes cannot occur between LLVM code and other namespaces. The; portability rule is important because different standard library implementations; expose different symbols (potentially ones they shouldn't), and future revisions; to the C++ standard will add more symbols to the ``std`` namespace. As such, we; never use ``'using namespace std;'`` in LLVM. The exception to the general rule (i.e. it's not an exception for the ``std``; namespace) is for implementation files. For example, all of the code in the; LLVM project implements code that lives in the 'llvm' namespace. As such, it is; ok, and actually clearer, for the ``.cpp`` files to have a ``'using namespace; llvm;'`` directive at the top, after the ``#include``\s. This reduces; indentation in the body of the file for source editors that indent based on; braces, and keeps the conceptual context cleaner. The general form of this rule; is that any ``.cpp`` file that implements code in any namespace may use that; namespace (and its parents'),",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:49452,portab,portable,49452,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['portab'],['portable']
Modifiability,"g., member functions with ``&`` or ``&&``; applied to ``*this``) is enabled. C++11 range-based ``for`` loop; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_range_for)`` or ``__has_extension(cxx_range_for)`` to; determine if support for the range-based for loop is enabled. C++11 raw string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_raw_string_literals)`` to determine if support for raw; string literals (e.g., ``R""x(foo\bar)x""``) is enabled. C++11 rvalue references; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_rvalue_references)`` or; ``__has_extension(cxx_rvalue_references)`` to determine if support for rvalue; references is enabled. C++11 ``static_assert()``; ^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_static_assert)`` or; ``__has_extension(cxx_static_assert)`` to determine if support for compile-time; assertions using ``static_assert`` is enabled. C++11 ``thread_local``; ^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_thread_local)`` to determine if support for; ``thread_local`` variables is enabled. C++11 type inference; ^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_auto_type)`` or ``__has_extension(cxx_auto_type)`` to; determine C++11 type inference is supported using the ``auto`` specifier. If; this is disabled, ``auto`` will instead be a storage class specifier, as in C; or C++98. C++11 strongly typed enumerations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_strong_enums)`` or; ``__has_extension(cxx_strong_enums)`` to determine if support for strongly; typed, scoped enumerations is enabled. C++11 trailing return type; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_trailing_return)`` or; ``__has_extension(cxx_trailing_return)`` to determine if support for the; alternate function declaration syntax with trailing return type is enabled. C++11 Unicode string literals; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_unicode_literals)`` to determine if support for Unicode; string literals is enabled. C+",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:46581,variab,variables,46581,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,g.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/support/ThreadCrashReporter.cpp; clang-tools-extra/clangd/support/Thread,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80679,refactor,refactor,80679,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,g/Syntax/Pseudo/LRGraph.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTable.cpp; clang/lib/Tooling/Syntax/Pseudo/LRTableBuild.cpp; clang/lib/Tooling/Syntax/Pseudo/Preprocess.cpp; clang/lib/Tooling/Syntax/Pseudo/Token.cpp; clang/lib/Tooling/Transformer/Parsing.cpp; clang/lib/Tooling/Transformer/SourceCodeBuilders.cpp; clang/lib/Tooling/Transformer/Stencil.cpp; clang/lib/Tooling/Transformer/Transformer.cpp; clang/tools/amdgpu-arch/AMDGPUArch.cpp; clang/tools/apinotes-test/APINotesTest.cpp; clang/tools/clang-format/ClangFormat.cpp; clang/tools/clang-fuzzer/ClangFuzzer.cpp; clang/tools/clang-fuzzer/DummyClangFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLLVMProtoFuzzer.cpp; clang/tools/clang-fuzzer/ExampleClangLoopProtoFuzzer.cpp; clang/tools/clang-fuzzer/handle-llvm/handle_llvm.h; clang/tools/clang-linker-wrapper/ClangLinkerWrapper.cpp; clang/tools/clang-linker-wrapper/OffloadWrapper.cpp; clang/tools/clang-pseudo/ClangPseudo.cpp; clang/tools/clang-refactor/ClangRefactor.cpp; clang/tools/clang-refactor/TestSupport.cpp; clang/tools/clang-refactor/TestSupport.h; clang/tools/clang-refactor/ToolRefactoringResultConsumer.h; clang/tools/clang-rename/ClangRename.cpp; clang/tools/clang-repl/ClangRepl.cpp; clang/tools/clang-scan-deps/ClangScanDeps.cpp; clang/tools/clang-shlib/clang-shlib.cpp; clang/tools/driver/cc1gen_reproducer_main.cpp; clang/tools/libclang/CIndex.cpp; clang/tools/libclang/CIndexUSRs.cpp; clang/tools/libclang/CursorVisitor.h; clang/tools/libclang/CXCursor.cpp; clang/tools/libclang/CXCursor.h; clang/tools/scan-build-py/tests/functional/src/include/clean-one.h; clang/unittests/Analysis/CFGBuildResult.h; clang/unittests/Analysis/MacroExpansionContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowAnalysisContextTest.cpp; clang/unittests/Analysis/FlowSensitive/DataflowEnvironmentTest.cpp; clang/unittests/Analysis/FlowSensitive/MapLatticeTest.cpp; clang/unittests/Analysis/FlowSensitive/MatchSwitchTest.cpp; clang/unittests/Analysis/FlowSensitive/MultiVarConstan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:28029,refactor,refactor,28029,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,g/lib/Semantics/check-purity.cpp; flang/lib/Semantics/check-purity.h; flang/lib/Semantics/check-return.cpp; flang/lib/Semantics/check-return.h; flang/lib/Semantics/check-select-rank.cpp; flang/lib/Semantics/check-select-rank.h; flang/lib/Semantics/check-select-type.cpp; flang/lib/Semantics/check-select-type.h; flang/lib/Semantics/check-stop.cpp; flang/lib/Semantics/check-stop.h; flang/lib/Semantics/compute-offsets.cpp; flang/lib/Semantics/compute-offsets.h; flang/lib/Semantics/data-to-inits.cpp; flang/lib/Semantics/mod-file.h; flang/lib/Semantics/pointer-assignment.cpp; flang/lib/Semantics/pointer-assignment.h; flang/lib/Semantics/program-tree.cpp; flang/lib/Semantics/program-tree.h; flang/lib/Semantics/resolve-directives.cpp; flang/lib/Semantics/resolve-directives.h; flang/lib/Semantics/resolve-labels.cpp; flang/lib/Semantics/resolve-labels.h; flang/lib/Semantics/resolve-names-utils.cpp; flang/lib/Semantics/resolve-names-utils.h; flang/lib/Semantics/resolve-names.h; flang/lib/Semantics/rewrite-parse-tree.cpp; flang/lib/Semantics/rewrite-parse-tree.h; flang/lib/Semantics/runtime-type-info.cpp; flang/lib/Semantics/scope.cpp; flang/lib/Semantics/semantics.cpp; flang/lib/Semantics/tools.cpp; flang/lib/Semantics/unparse-with-symbols.cpp; flang/module/omp_lib.h; flang/runtime/allocatable.cpp; flang/runtime/assign.cpp; flang/runtime/buffer.cpp; flang/runtime/buffer.h; flang/runtime/character.cpp; flang/runtime/command.cpp; flang/runtime/complex-reduction.h; flang/runtime/connection.cpp; flang/runtime/connection.h; flang/runtime/copy.cpp; flang/runtime/copy.h; flang/runtime/derived-api.cpp; flang/runtime/derived.h; flang/runtime/descriptor-io.cpp; flang/runtime/descriptor-io.h; flang/runtime/descriptor.cpp; flang/runtime/dot-product.cpp; flang/runtime/edit-input.cpp; flang/runtime/edit-input.h; flang/runtime/edit-output.cpp; flang/runtime/edit-output.h; flang/runtime/environment.cpp; flang/runtime/environment.h; flang/runtime/extensions.cpp; flang/runtime/extrema.cpp; flan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:123879,rewrite,rewrite-parse-tree,123879,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['rewrite'],['rewrite-parse-tree']
Modifiability,"g/posts/2020-11-30-interactive-cpp-with-cling/>`_; - *Vassil Vassilev* 2020 The LLVM Project Blog; - This blog page briefly discusses the concept of interactive C++ by presenting Cling’s main features, such as wrapper functions, entity redefinition, error recovery. ; * - `Using the Cling C++ Interpreter on the Bela Platform <https://gist.github.com/jarmitage/6e411ae8746c04d6ecbee1cbc1ebdcd4>`_; - Jack Armitage 2019; - Cling has been installed on a BeagleBoard to bring live coding to the Bela interactive audio platform.; * - `Implementation of GlobalModuleIndex in ROOT and Cling <https://indico.cern.ch/event/840376/contributions/3525646/attachments/1895398/3127159/GSoC_Presentation__GMI.pdf>`_; - *Arpitha Raghunandan* 2012 Google Summer of Code GSoC; - GlobalModuleIndex can be used for improving ROOT’s and Cling’s performance ; * - `Example project using cling as library <https://github.com/root-project/cling/tree/master/tools/demo>`_; - *Axel Naumann* 2016 GitHub; - This video showcases how to use Cling as a library, and shows how to set up a simple CMake configuration that uses Cling.; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - *Mika* 2015 Youtube; - In this tutorial, a developer tries Cling for the first time by uploading a few simple C++ user-cases onto Cling, involving also the loading of external files; * - `Building an Order Book in C++ <https://www.youtube.com/watch?v=fxN4xEZvrxI>`_; - *Dimitri Nesteruk* 2015 Youtube; - This demo shows how to build a simple order book using C++, CLion, Google Test and, of course, Cling. ; * - `Cling C++ interpreter testdrive <https://www.youtube.com/watch?v=1IGTHusaJ18>`_; - Dimitri Nesteruk 2015 Youtube; - This tutorial describes Cling’s general features. You will learn how to start Cling on Ubuntu, how to write a simple expression (N=5, N++) and how to define a Class for calculating body mass index. ; * - `Cling Interactive OpenGL Demo <https://www.youtube.com/watch?v=eoIuqLNvzFs>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst:4594,config,configuration,4594,interpreter/cling/docs/chapters/references.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/references.rst,1,['config'],['configuration']
Modifiability,g; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Inclusions; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring; - `15`; - `12`; - `3`; - :part:`80%`; * - clang/include/clang/Tooling/Refactoring/Extract; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Refactoring/Rename; - `6`; - `5`; - `1`; - :part:`83%`; * - clang/include/clang/Tooling/Syntax; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Syntax/Pseudo; - `5`; - `5`; - `0`; - :good:`100%`; * - clang/include/clang/Tooling/Transformer; - `8`; - `6`; - `2`; - :part:`75%`; * - clang/include/clang-c; - `10`; - `3`; - `7`; - :part:`30%`; * - clang/INPUTS; - `2`; - `0`; - `2`; - :none:`0%`; * - clang/lib/Analysis; - `28`; - `3`; - `25`; - :part:`10%`; * - clang/lib/Analysis/FlowSensitive; - `7`; - `7`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerDependencyHandling; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/Analysis/plugins/CheckerOptionHandling; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/Analysis/plugins/SampleAnalyzer; - `1`; - `1`; - `0`; - :good:`100%`; * - clang/lib/APINotes; - `3`; - `3`; - `0`; - :good:`100%`; * - clang/lib/ARCMigrate; - `22`; - `0`; - `22`; - :none:`0%`; * - clang/lib/AST; - `81`; - `2`; - `79`; - :part:`2%`; * - clang/lib/AST/Interp; - `44`; - `18`; - `26`; - :part:`40%`; * - clang/lib/ASTMatchers; - `3`; - `1`; - `2`; - :part:`33%`; * - clang/lib/ASTMatchers/Dynamic; - `6`; - `1`; - `5`; - :part:`16%`; * - clang/lib/Basic; - `39`; - `13`; - `26`; - :part:`33%`; * - clang/lib/Basic/Targets; - `50`; - `25`; - `25`; - :part:`50%`; * - clang/lib/CodeGen; - `87`; - `9`; - `78`; - :part:`10%`; * - clang/lib/CrossTU; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher; - `2`; - `2`; - `0`; - :good:`100%`; * - clang/lib/DirectoryWatcher/default; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/lib/DirectoryWatcher/linux; - `1`; - `0`; - `1`; - :none:`0%`; * - clang/l,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:6792,plugin,plugins,6792,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"g; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2780,config,configure,2780,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['config'],['configure']
Modifiability,"g; `llvm.dbg.assign` intrinsics after the resultant PHIs generated during; promotion. `mem2reg` already has to do this (with `llvm.dbg.value`) for; `llvm.dbg.declare`s. Where a store has no linked intrinsic, the store is; assumed to represent an assignment for variables stored at the destination; address. #### Debug intrinsic updates. **Moving** a debug intrinsic: avoid moving `llvm.dbg.assign` intrinsics where; possible, as they represent a source-level assignment, whose position in the; program should not be affected by optimization passes. **Deleting** a debug intrinsic: Nothing new to do. Just like for conventional; debug intrinsics, unless it is unreachable, it’s almost always incorrect to; delete a `llvm.dbg.assign` intrinsic. ### Lowering `llvm.dbg.assign` to MIR. To begin with only SelectionDAG ISel will be supported. `llvm.dbg.assign`; intrinsics are lowered to MIR `DBG_INSTR_REF` instructions. Before this happens; we need to decide where it is appropriate to use memory locations and where we; must use a non-memory location (or no location) for each variable. In order to; make those decisions we run a standard fixed-point dataflow analysis that makes; the choice at each instruction, iteratively joining the results for each block. ### TODO list. As this is an experimental work in progress so there are some items we still need; to tackle:. * As mentioned in test llvm/test/DebugInfo/assignment-tracking/X86/diamond-3.ll,; the analysis should treat escaping calls like untagged stores. * The system expects locals to be backed by a local alloca. This isn't always; the case - sometimes a pointer to storage is passed into a function; (e.g. sret, byval). We need to be able to handle those cases. See; llvm/test/DebugInfo/Generic/assignment-tracking/track-assignments.ll and; clang/test/CodeGen/assignment-tracking/assignment-tracking.cpp for examples. * `trackAssignments` doesn't yet work for variables that have their; `llvm.dbg.declare` location modified by a `DIExpres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:9187,variab,variable,9187,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"gConstraint<""$dst.reg = $ea_res"">, NoEncode<""$ea_res"">;. def : Pat<(pre_store GPRC:$rS, ptr_rc:$ptrreg, iaddroff:$ptroff),; (STWU GPRC:$rS, iaddroff:$ptroff, ptr_rc:$ptrreg)>;. Here, the pair of ``ptroff`` and ``ptrreg`` operands is matched onto the; complex operand ``dst`` of class ``memri`` in the ``STWU`` instruction. * While the system does automate a lot, it still allows you to write custom C++; code to match special cases if there is something that is hard to; express. While it has many strengths, the system currently has some limitations,; primarily because it is a work in progress and is not yet finished:. * Overall, there is no way to define or match SelectionDAG nodes that define; multiple values (e.g. ``SMUL_LOHI``, ``LOAD``, ``CALL``, etc). This is the; biggest reason that you currently still *have to* write custom C++ code; for your instruction selector. * There is no great way to support matching complex addressing modes yet. In; the future, we will extend pattern fragments to allow them to define multiple; values (e.g. the four operands of the `X86 addressing mode`_, which are; currently matched with custom C++ code). In addition, we'll extend fragments; so that a fragment can match multiple different patterns. * We don't automatically infer flags like ``isStore``/``isLoad`` yet. * We don't automatically generate the set of supported registers and operations; for the `Legalizer`_ yet. * We don't have a way of tying in custom legalized nodes yet. Despite these limitations, the instruction selector generator is still quite; useful for most of the binary and logical operations in typical instruction; sets. If you run into any problems or can't figure out how to do something,; please let Chris know!. .. _Scheduling and Formation:; .. _SelectionDAG Scheduling and Formation:. SelectionDAG Scheduling and Formation Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The scheduling phase takes the DAG of target instructions from the selection; phase and assign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:52623,extend,extend,52623,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['extend'],['extend']
Modifiability,"gance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make expli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2898,extend,extend,2898,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extend']
Modifiability,gd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/suppo,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80220,refactor,refactor,80220,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ge patterns and a number of special cases. In; the case of Verilog, it doesn't affect a comment right after the opening; parenthesis in the port or parameter list in a module header, because it; is probably for the port on the following line instead of the parenthesis; it follows. .. code-block:: c++. SpacesBeforeTrailingComments: 3; void f() {; if (true) { // foo1; f(); // bar; } // foo; }. .. _SpacesInAngles:. **SpacesInAngles** (``SpacesInAnglesStyle``) :versionbadge:`clang-format 3.4` :ref:`¶ <SpacesInAngles>`; The SpacesInAnglesStyle to use for template argument lists. Possible values:. * ``SIAS_Never`` (in configuration: ``Never``); Remove spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast<int>(arg);; std::function<void(int)> fct;. * ``SIAS_Always`` (in configuration: ``Always``); Add spaces after ``<`` and before ``>``. .. code-block:: c++. static_cast< int >(arg);; std::function< void(int) > fct;. * ``SIAS_Leave`` (in configuration: ``Leave``); Keep a single space after ``<`` and before ``>`` if any spaces were; present. Option ``Standard: Cpp03`` takes precedence. .. _SpacesInCStyleCastParentheses:. **SpacesInCStyleCastParentheses** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInCStyleCastParentheses>`; If ``true``, spaces may be inserted into C style casts.; This option is **deprecated**. See ``InCStyleCasts`` of; ``SpacesInParensOptions``. .. _SpacesInConditionalStatement:. **SpacesInConditionalStatement** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <SpacesInConditionalStatement>`; If ``true``, spaces will be inserted around if/for/switch/while; conditions.; This option is **deprecated**. See ``InConditionalStatements`` of; ``SpacesInParensOptions``. .. _SpacesInContainerLiterals:. **SpacesInContainerLiterals** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <SpacesInContainerLiterals>`; If ``true``, spaces are inserted inside container literals (e.g. ObjC and; Javascript array and dict literals). For J",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:123658,config,configuration,123658,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ge, but we can't set it up yet (because it doesn't exist!). .. code-block:: c++. // Within the loop, the variable is defined equal to the PHI node. If it; // shadows an existing variable, we have to restore it, so save it now.; Value *OldVal = NamedValues[VarName];; NamedValues[VarName] = Variable;. // Emit the body of the loop. This, like any other expr, can change the; // current BB. Note that we ignore the value computed by the body, but don't; // allow an error.; if (!Body->codegen()); return nullptr;. Now the code starts to get more interesting. Our 'for' loop introduces a; new variable to the symbol table. This means that our symbol table can; now contain either function arguments or loop variables. To handle this,; before we codegen the body of the loop, we add the loop variable as the; current value for its name. Note that it is possible that there is a; variable of the same name in the outer scope. It would be easy to make; this an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:23399,variab,variables,23399,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variables']
Modifiability,"ge, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_EN",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84172,config,configuration,84172,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *src);; void (*byref_dispose)(void *);; typeof(marked_variable) marked_variable;; };. The str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11520,variab,variables,11520,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"generator names at the end of the help text. Generators' names are case-sensitive, and may contain spaces. For this reason,; you should enter them exactly as they are listed in the ``cmake --help``; output, in quotes. For example, to generate project files specifically for; Visual Studio 12, you can execute:. .. code-block:: console. $ cmake -G ""Visual Studio 12"" path/to/llvm/source/root. For a given development platform there can be more than one adequate; generator. If you use Visual Studio, ""NMake Makefiles"" is a generator you can use; for building with NMake. By default, CMake chooses the most specific generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:5695,variab,variables,5695,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"generator; supported by your development environment. If you want an alternative generator,; you must tell this to CMake with the ``-G`` option. .. todo::. Explain variables and cache. Move explanation here from #options section. .. _Options and variables:. Options and variables; =====================. Variables customize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6334,variab,variable,6334,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variable']
Modifiability,"geometry vectors and points, while the 4D space-time is used for; physics vectors representing relativistic particles. These 3D and 4D; vectors are different from vectors of the linear algebra package, which; describe generic N-dimensional vectors. Similar functionality is; currently provided by the CLHEP <Vector> and <Geometry> packages and the; ROOT Physics vector classes (See ""Physics Vectors""). It also re-uses; concepts and ideas from the CMS; [Common Vector package](Common Vector package). In contrast to CLHEP or; the ROOT physics libraries, `GenVector` provides class templates for; modeling the vectors. The user can control how the vector is internally; represented. This is expressed by a choice of coordinate system, which; is supplied as a template parameter when the vector is constructed.; Furthermore, each coordinate system is itself a template, so that the; user can specify the underlying scalar type. The `GenVector` classes do not inherit from **`TObject`**, therefore; cannot be used as in the case of the physics vector classes in ROOT; collections. In addition, to optimize performances, no virtual destructors are; provided. In the following paragraphs, the main characteristics of; `GenVector` are described. A more detailed description of all the; `GenVector` classes is available also at; <http://seal.cern.ch/documents/mathlib/GenVector.pdf>. ### Main Characteristics. #### Optimal Runtime Performances. We try to minimize any overhead in the run-time performance. We have; deliberately avoided the use of any virtual function and even virtual; destructors in the classes. In addition, as much as possible functions; are defined as inline. For this reason, we have chosen to use template; classes to implement the `GenVector` concepts instead of abstract or; base classes and virtual functions. It is then recommended to avoid; using the `GenVector` classes polymorphically and developing classes; inheriting from them. #### Points and Vector Concept. Mathematically ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:68439,inherit,inherit,68439,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['inherit'],['inherit']
Modifiability,"get entry 0, and print the number of tracks (594).; Then we get entry 1 and print the number of tracks (597). ``` {.cpp}; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; ```. Now we can call the `Loop` method, which will build and display the two; histograms. ``` {.cpp}; root[] m.Loop(); ```. You should now see a canvas that looks like this. ![](pictures/03000106.png). To conclude the discussion on `MakeClass` let us lists the steps that; got us here. - Call `TTree::MakeClass`, which automatically creates a class to loop; over the tree. - Modify the `MyClass::Loop()` method in `MyClass.C` to fit your task. - Load and instantiate `MyClass`, and run `MyClass::Loop()`. ## Using TTree::MakeSelector; \index{tree!MakeSelector}. With a **`TTree`** we can make a selector and use it to process a; limited set of entries. This is especially important in a parallel; processing configuration where the analysis is distributed over several; processors and we can specify which entries to send to each processor.; The `TTree::Process` method is used to specify the selector and the; entries. Before we can use **`TTree::Process`** we need to make a; selector. We can call the `TTree::MakeSelector` method. It creates; two files similar to `TTree::MakeClass`. In the resulting files is a class that is a descendent of; **`TSelector`** and implements the following methods:. - `TSelector::Begin()` `-` this method is called every time a loop; over the tree starts. This is a convenient place to create your; histograms. - `TSelector::Notify()` `-` it is called at the first entry of a new; tree in a chain. - `TSelector::Process()` `-` it is called to process an event. It is; the user's responsibility to read the corresponding entry in memory; (may be just a partial read). Once the entry is in memory one can; apply a selection and if the event is selected histograms can be; filled. Processing stops when this functi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:131223,config,configuration,131223,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['config'],['configuration']
Modifiability,"get(test-depends; DEPENDS ${LLVM_ALL_LIT_DEPENDS} ${LLVM_ALL_ADDITIONAL_TEST_DEPENDS}); set_target_properties(test-depends PROPERTIES FOLDER ""Tests""); add_dependencies(check-all test-depends); endif(). if (LLVM_INCLUDE_DOCS); add_subdirectory(docs); endif(). add_subdirectory(cmake/modules). # Do this last so that all lit targets have already been created.; if (LLVM_INCLUDE_UTILS); add_subdirectory(utils/llvm-lit); endif(). if (NOT LLVM_INSTALL_TOOLCHAIN_ONLY); install(DIRECTORY include/llvm include/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.td""; PATTERN ""*.inc""; PATTERN ""LICENSE.TXT""; ). install(DIRECTORY ${LLVM_INCLUDE_DIR}/llvm ${LLVM_INCLUDE_DIR}/llvm-c; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""*.def""; PATTERN ""*.h""; PATTERN ""*.gen""; PATTERN ""*.inc""; # Exclude include/llvm/CMakeFiles/intrinsics_gen.dir, matched by ""*.def""; PATTERN ""CMakeFiles"" EXCLUDE; PATTERN ""config.h"" EXCLUDE; ). if (LLVM_INSTALL_MODULEMAPS); install(DIRECTORY include; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; FILES_MATCHING; PATTERN ""module.modulemap""; ); install(FILES include/module.install.modulemap; DESTINATION ""${CMAKE_INSTALL_INCLUDEDIR}""; COMPONENT llvm-headers; RENAME ""module.extern.modulemap""; ); endif(LLVM_INSTALL_MODULEMAPS). # Installing the headers needs to depend on generating any public; # tablegen'd headers.; add_custom_target(llvm-headers DEPENDS intrinsics_gen omp_gen); set_target_properties(llvm-headers PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-headers; DEPENDS llvm-headers; COMPONENT llvm-headers); endif(). # Custom target to install all libraries.; add_custom_target(llvm-libraries); set_target_properties(llvm-libraries PROPERTIES FOLDER ""Misc""). if (NOT LLVM_ENABLE_IDE); add_llvm_install_targets(install-llvm-libraries; DEPENDS llvm-libraries; COMPONENT llvm-lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:52143,config,config,52143,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config']
Modifiability,"get_property(LLVM_LIT_CONFIG_FILES GLOBAL PROPERTY LLVM_LIT_CONFIG_FILES); list(LENGTH LLVM_LIT_CONFIG_FILES file_len); math(EXPR file_last ""${file_len} - 1""). get_llvm_lit_path(LIT_BASE_DIR LIT_FILE_NAME). set(LLVM_SOURCE_DIR ${LLVM_MAIN_SRC_DIR}). # LLVM_LIT_CONFIG_FILES contains interleaved main config (in the source tree); # and site config (in the build tree) pairs. Make them relative to; # llvm-lit and then convert them to map_config() calls.; if(""${CMAKE_CFG_INTDIR}"" STREQUAL "".""); make_paths_relative(; LLVM_LIT_CONFIG_FILES ""${LIT_BASE_DIR}"" ""${LLVM_LIT_CONFIG_FILES}""); make_paths_relative(; LLVM_SOURCE_DIR ""${LIT_BASE_DIR}"" ""${LLVM_SOURCE_DIR}""); endif(). set(LLVM_LIT_CONFIG_MAP ""${LLVM_LIT_PATH_FUNCTION}\n""); if (${file_last} GREATER -1); foreach(i RANGE 0 ${file_last} 2); list(GET LLVM_LIT_CONFIG_FILES ${i} main_config); math(EXPR i1 ""${i} + 1""); list(GET LLVM_LIT_CONFIG_FILES ${i1} site_out); set(map ""map_config(path(r'${main_config}'), path(r'${site_out}'))""); set(LLVM_LIT_CONFIG_MAP ""${LLVM_LIT_CONFIG_MAP}\n${map}""); endforeach(); endif(). if(NOT ""${CMAKE_CFG_INTDIR}"" STREQUAL "".""); foreach(BUILD_MODE ${CMAKE_CONFIGURATION_TYPES}); string(REPLACE ${CMAKE_CFG_INTDIR} ${BUILD_MODE} bi ${LIT_BASE_DIR}); set(bi ""${bi}/${LIT_FILE_NAME}""); configure_file(; llvm-lit.in; ${bi}; ); endforeach(); else(); set(BUILD_MODE .); configure_file(; llvm-lit.in; ${LIT_BASE_DIR}/${LIT_FILE_NAME}; ); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt:300,config,config,300,interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/llvm-lit/CMakeLists.txt,2,['config'],['config']
Modifiability,"gets (nD).; ; Not all transformation of input variables are available; (only ""Norm"" so far). Regression requires specific evaluation tools:. ; During the training we provide a ranking of input; variables, using various criteria: correlations, transposed; correlation, correlation ratio, and ""mutual information"" between; input variables and regression target. (Correlation ratio and; mutual information implmentations provided by Moritz Backes,; Geneva U); ; After the training, the trained MVA methods are ranked wrt.; the deviations between regression target and estimate.; ; Macros plot various deviation and correlation quantities.; A new GUI (macros/TMVARegGui.C) collects these macros.; . Improvements of / new features for MVA methods . Linear Discriminant:; Re-implementation of ""Fisher"" method as general linear discriminant (""LD""),; which is also regression capable (so far: single-target only). PDEFoam:; PDE-Foam is a variation of the PDE-RS method using a self-adapting binning; method to divide the multi-dimensional variable space into a finite number; of hyper-rectangles (cells). The binning algorithm adjusts the size and; position of a predefined number of cells such that the variance of the; signal and background densities inside the cells reaches a minimum. BDT:; Introduced gradient boosting and stochastic gradient boosting for ; classification with BDT (as desribed by Friedman 1999). See ""BDTG"" ; example in TMVAClassification.C/cxx. A new option allows to restrict the maximum tree depth. This may be used to; avoid overtraining and often gives better performance than pruning. (The; pruning mechanism needs to be revisited). MLP:; Introduced recognition of convergence via general ConvergenceTest-class for; interrupting computations when convergence is reached. This feature has is; used now in MethodMLP. Improved treatment of event-weights in BFGS training. Implemented random and importance sampling of events in DataSet. Implemented; the usage of this feature for MLP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html:2435,adapt,adapting,2435,tmva/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v524/index.html,2,"['adapt', 'variab']","['adapting', 'variable']"
Modifiability,"gging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, before the optional; ``debug-location`` attachment. The value defined in ``$rbp`` in the code; above would be identified by the pair ``<1, 0>``. The 3rd operand of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26350,variab,variable,26350,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"gh ARC destroys instance variables automatically, there are still; legitimate reasons to write a ``dealloc`` method, such as freeing; non-retainable resources. Failing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:88926,variab,variables,88926,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"gin(), a.end(), [](int x, int y) { return x < y; });. * ``SLS_All`` (in configuration: ``All``); Merge all lambdas fitting on a single line. .. code-block:: c++. auto lambda = [](int a) {};; auto lambda2 = [](int a) { return a; };. .. _AllowShortLoopsOnASingleLine:. **AllowShortLoopsOnASingleLine** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <AllowShortLoopsOnASingleLine>`; If ``true``, ``while (true) continue;`` can be put on a single; line. .. _AlwaysBreakAfterDefinitionReturnType:. **AlwaysBreakAfterDefinitionReturnType** (``DefinitionReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <AlwaysBreakAfterDefinitionReturnType>`; The function definition return type breaking style to use. This; option is **deprecated** and is retained for backwards compatibility. Possible values:. * ``DRTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. * ``DRTBS_All`` (in configuration: ``All``); Always break after the return type. * ``DRTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. _AlwaysBreakAfterReturnType:. **AlwaysBreakAfterReturnType** (``ReturnTypeBreakingStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlwaysBreakAfterReturnType>`; The function declaration return type breaking style to use. Possible values:. * ``RTBS_None`` (in configuration: ``None``); Break after return type automatically.; ``PenaltyReturnTypeOnItsOwnLine`` is taken into account. .. code-block:: c++. class A {; int f() { return 0; };; };; int f();; int f() { return 1; }. * ``RTBS_All`` (in configuration: ``All``); Always break after the return type. .. code-block:: c++. class A {; int; f() {; return 0;; };; };; int; f();; int; f() {; return 1;; }. * ``RTBS_TopLevel`` (in configuration: ``TopLevel``); Always break after the return types of top-level functions. .. code-block:: c++. class A {; int f() { return 0; };; };; int; f();;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:32690,config,configuration,32690,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ginal size of the data sample (used whenever bagging is used). Boost_MethodWeightType No ByError ByError, Average, ByROC, ByOverlap, LastMethod How to set the final weight of the boosted classifiers. Boost_RecalculateMVACut No True − Recalculate the classifier MVA Signallike cut at every boost iteration. Boost_AdaBoostBeta No 1 − The ADA boost parameter that sets the effect of every boost step on the events' weights. Boost_Transform No step step, linear, log, gauss Type of transform applied to every boosted method linear, log, step. Boost_RandomSeed No 0 − Seed for random number generator used for bagging. Configuration options for MVA method :. Configuration options reference for MVA method: RuleFit. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). GDTau No -1 − Gradient-directed (GD) path: default fit cut-off. GDTauPrec No 0.01 − GD path: precision of tau. GDStep No 0.01 − GD path: step size. GDNSteps No 10000 − GD path: number of steps. GDErrScale No 1.1 − Stop scan when error > scale*errmin. LinQuantile No 0.025 − Quantile of linear terms (removes outliers). GDPathEveFrac No 0.5 − Fraction of events used for the path search. GDValidEveFrac No 0.5 − Fraction ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:17975,variab,variable,17975,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,"gister a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be instrumented, to preserve instruction; numbers. ## Target hooks. `TargetInstrInfo::isCopyInstrImpl` must be implemented to recognise any; instructions that are copy-like -- `LiveDebugValues` uses this to identify when; values move between registers. `TargetInstrInfo::isLoadFromStackSlotPostFE` and; `TargetInstrInfo::isStoreToStackSlotPostFE` are needed to identify spill and; restore instructions. Each",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4938,variab,variables,4938,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variables']
Modifiability,"gister allocation, the; VirtRegRewriter pass re-inserts DBG_VALUE instructions in their original; positions, translating virtual register references into their physical; machine locations. To avoid encoding incorrect variable locations, in this; pass any DBG_VALUE of a virtual register that is not live, is replaced by; the undefined location. The LiveDebugVariables may insert redundant DBG_VALUEs; because of virtual register rewriting. These will be subsequently removed by; the RemoveRedundantDebugValues pass. LiveDebugValues expansion of variable locations; -----------------------------------------------. After all optimizations have run and shortly before emission, the; LiveDebugValues pass runs to achieve two aims:. * To propagate the location of variables through copies and register spills,; * For every block, to record every valid variable location in that block. After this pass the DBG_VALUE instruction changes meaning: rather than; corresponding to a source-level assignment where the variable may change value,; it asserts the location of a variable in a block, and loses effect outside the; block. Propagating variable locations through copies and spills is; straightforwards: determining the variable location in every basic block; requires the consideration of control flow. Consider the following IR, which; presents several difficulties:. .. code-block:: text. define dso_local i32 @foo(i1 %cond, i32 %input) !dbg !12 {; entry:; br i1 %cond, label %truebr, label %falsebr. bb1:; %value = phi i32 [ %value1, %truebr ], [ %value2, %falsebr ]; br label %exit, !dbg !26. truebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 1, metadata !23, metadata !DIExpression()), !dbg !24; %value1 = add i32 %input, 1; br label %bb1. falsebr:; call void @llvm.dbg.value(metadata i32 %input, metadata !30, metadata !DIExpression()), !dbg !24; call void @llvm.dbg.value(metadata i32 2, metadata !23",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:36926,variab,variable,36926,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"github.com/mozilla/dxr>`_; ""DXR is a source code cross-reference tool that uses static analysis; data collected by instrumented compilers."". `<https://github.com/eschulte/clang-mutate>`_; ""This tool performs a number of operations on C-language source files."". `<https://github.com/gmarpons/Crisp>`_; ""A coding rule validation add-on for LLVM/clang. Crisp rules are written; in Prolog. A high-level declarative DSL to easily write new rules is under; development. It will be called CRISP, an acronym for *Coding Rules in; Sugared Prolog*."". `<https://github.com/drothlis/clang-ctags>`_; ""Generate tag file for C++ source code."". `<https://github.com/exclipy/clang_indexer>`_; ""This is an indexer for C and C++ based on the libclang library."". `<https://github.com/holtgrewe/linty>`_; ""Linty - C/C++ Style Checking with Python & libclang."". `<https://github.com/axw/cmonster>`_; ""cmonster is a Python wrapper for the Clang C++ parser."". `<https://github.com/rizsotto/Constantine>`_; ""Constantine is a toy project to learn how to write clang plugin.; Implements pseudo const analysis. Generates warnings about variables,; which were declared without const qualifier."". `<https://github.com/jessevdk/cldoc>`_; ""cldoc is a Clang based documentation generator for C and C++.; cldoc tries to solve the issue of writing C/C++ software documentation; with a modern, non-intrusive and robust approach."". `<https://github.com/AlexDenisov/ToyClangPlugin>`_; ""The simplest Clang plugin implementing a semantic check for Objective-C.; This example shows how to use the ``DiagnosticsEngine`` (emit warnings,; errors, fixit hints). See also `<http://l.rw.rw/clang_plugin>`_ for; step-by-step instructions."". `<https://phabricator.kde.org/source/clazy>`_; ""clazy is a compiler plugin which allows clang to understand Qt semantics.; You get more than 50 Qt related compiler warnings, ranging from unneeded; memory allocations to misusage of API, including fix-its for automatic; refactoring."". `<https://gerrit.libreo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst:2875,plugin,plugin,2875,interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ExternalClangExamples.rst,1,['plugin'],['plugin']
Modifiability,"given in Attr.td. This definition is used to automatically generate; functionality used for the implementation of the attribute, such as a class; derived from ``clang::Attr``, information for the parser to use, automated; semantic checking for some attributes, etc. ``include/clang/Basic/Attr.td``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The first step to adding a new attribute to Clang is to add its definition to; `include/clang/Basic/Attr.td; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/Attr.td>`_.; This tablegen definition must derive from the ``Attr`` (tablegen, not; semantic) type, or one of its derivatives. Most attributes will derive from the; ``InheritableAttr`` type, which specifies that the attribute can be inherited by; later redeclarations of the ``Decl`` it is associated with.; ``InheritableParamAttr`` is similar to ``InheritableAttr``, except that the; attribute is written on a parameter instead of a declaration. If the attribute; applies to statements, it should inherit from ``StmtAttr``. If the attribute is; intended to apply to a type instead of a declaration, such an attribute should; derive from ``TypeAttr``, and will generally not be given an AST representation.; (Note that this document does not cover the creation of type attributes.) An; attribute that inherits from ``IgnoredAttr`` is parsed, but will generate an; ignored attribute diagnostic when used, which may be useful when an attribute is; supported by another vendor but not supported by clang. The definition will specify several key pieces of information, such as the; semantic name of the attribute, the spellings the attribute supports, the; arguments the attribute expects, and more. Most members of the ``Attr`` tablegen; type do not require definitions in the derived definition as the default; suffice. However, every attribute must specify at least a spelling list, a; subject list, and a documentation list. Spellings; ~~~~~~~~~; All attributes are required to specify",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:128126,inherit,inherit,128126,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inherit'],['inherit']
Modifiability,"given tag in an NSIS; installer (.exe); --dmg-tag DMG_TAG Package the snapshot of a given tag in a DMG package; (.dmg); --with-llvm-url WITH_LLVM_URL; Specify an alternate URL of LLVM repo; --with-clang-url WITH_CLANG_URL; Specify an alternate URL of Clang repo; --with-cling-url WITH_CLING_URL; Specify an alternate URL of Cling repo; --no-test Do not run test suite of Cling; --create-dev-env CREATE_DEV_ENV; Set up a release/debug environment; --with-workdir WITH_WORKDIR; Specify an alternate working directory for CPT; --make-proper MAKE_PROPER; Internal option to support calls from build system. ```; If you want CPT to build a package by detecting your platform automatically,; use the value 'pkg'.; ```sh; ./cpt.py --current-dev=pkg; ```; or; ```sh; ./cpt.py --last-stable=pkg; ```; ### Overriding Default Variables; There are a select number of variables which can be set to make CPT work; differently. This eliminates the need to manually edit the script.; You can overrride variables by using the following syntax:; ```$ ./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --current-dev=tar```. List of variables in CPT which can be overridden:; - **CLING_GIT_URL**; * Specify the URL of the Git repository of Cling to be used by CPT; * **Default value:** ""http://root.cern.ch/git/cling.git""; * **Usage:** ```./cpt.py --with-cling-url=""http://github.com/ani07nov/cling"" --last-stable=deb```. - **CLANG_GIT_URL**; * Specify the URL of the Git repository of Clang to be used by CPT; * **Default value:** ""http://root.cern.ch/git/clang.git""; * **Usage:** ```./cpt.py --with-clang-url=""http://github.com/ani07nov/clang"" --last-stable=tar```. - **LLVM_GIT_URL**; * Specify the URL of the Git repository of LLVM to be used by CPT; * **Default value:** ""http://root.cern.ch/git/llvm.git""; * **Usage:** ```./cpt.py --with-llvm-url=""http://github.com/ani07nov/llvm"" --current-dev=tar```. - **workdir**; * Specify the working directory of CPT. All sources will be cloned, built; and instal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:8408,variab,variables,8408,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variables']
Modifiability,"gnal, which `b` will receive, i.e. `b->SetValue(79)` is invoked. It is executed immediately, just like a normal function call. `b` will in turn emit the same signal, which nobody receives, since no slot has been connected to it, so it disappears into hyperspace. This example illustrates that objects can work together without knowing about each other, as long as there is someone around to set up a connection between them. ## Features of the ROOT implementation. * The ROOT implementation **does not require the** *moc* preprocessor and the `signal:` and `slot:` keywords in the class declaration. Signals and slots are normal class methods. * The class which corresponds to **Qt's** **QObject** is [TQObject](https://root.cern/doc/master/classTQObject.html). It reproduces the general features of the QObject class and has the `Connect()`, `Disconnect()` and `Emit()` methods. The [TQObject](https://root.cern/doc/master/classTQObject.html) class does not derive from any class which makes it possible to have multiple inheritance from [TObject](https://root.cern/doc/master/classTQObject.html) derived classes and [TQObject](https://root.cern/doc/master/classTQObject.html). * By placing the [`RQ_OBJECT()`](https://root.cern/doc/master/RQ__OBJECT_8h.html) macro inside a class body you can use signals and slots with classes not inheriting from [TQObject](https://root.cern/doc/master/classTQObject.html), like interpreted classes which can not derive from compiled classes. This makes it possible to apply the **Object Communication Mechanism** between compiled and interpreted classes in an interactive ROOT session. * The ROOT implementation allows to make connections to any object known to the ROOT C++ interpreter. The following line makes a connection between signal `Pressed()` from `button` and method/slot `Draw()` from object `hist` of class (compiled or interpreted) `TH1`. ``` {.cpp}; Connect(button, ""Pressed()"", ""TH1"", hist, ""Draw()"");; ```. To connect to a stand-alone function (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md:4051,inherit,inheritance,4051,documentation/users-guide/SignalSlot.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/SignalSlot.md,1,['inherit'],['inheritance']
Modifiability,"gnatureArgument foo) {; return;; }));. .. _Language:. **Language** (``LanguageKind``) :versionbadge:`clang-format 3.5` :ref:`¶ <Language>`; Language, this format style is targeted at. Possible values:. * ``LK_None`` (in configuration: ``None``); Do not use. * ``LK_Cpp`` (in configuration: ``Cpp``); Should be used for C, C++. * ``LK_CSharp`` (in configuration: ``CSharp``); Should be used for C#. * ``LK_Java`` (in configuration: ``Java``); Should be used for Java. * ``LK_JavaScript`` (in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84009,config,configuration,84009,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"gned for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated to that task in the Clang driver. While compatibility; with GNU would bring benefits, the cost in this case is deemed too high. Avoid re-inventing feature detection in the configuration; ---------------------------------------------------------. A large amount of logic in the Clang driver is dedicated to inferring which; architectural features are available based on the given command line options.; It is neither desirable nor practical to repeat such logic in each multilib; configuration. Instead the configuration should be able to benefit from the; heavy lifting Clang already does to detect features. Low maintenance; ---------------. Multilib is a relatively small feature in the scheme of things so supporting it; should accordingly take little time. Where possible this should be achieved by; implementing it in terms of existing features in the LLVM codebase. Minimal additional API surface; ------------------------------. The greater the API surface, the greater the difficulty of keeping it stable.; Where possible the additional API surface should be kept small by defining it; in relation to existing APIs. An example of this is keeping a simple; relationship between flag names and command line options where possible.; Since the command line options are part of a stable API they are unlikely; to change, and therefore the flag names get the same stability. Low compile-time overhead; -------------------------. If the process of selecting multilib directories must be done on every; invocation of the Clang driver then it must have",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:12405,config,configuration,12405,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"gnment information provided by the frontend for a non-integral pointer; (typically using attributes or metadata) must be valid for every possible ; representation of the pointer. .. _globalvars:. Global Variables; ----------------. Global variables define regions of memory allocated at compilation time; instead of run-time. Global variable definitions must be initialized. Global variables in other translation units can also be declared, in which; case they don't have an initializer. Global variables can optionally specify a :ref:`linkage type <linkage>`. Either global variable definitions or declarations may have an explicit section; to be placed in and may have an optional explicit alignment specified. If there; is a mismatch between the explicit or inferred section information for the; variable declaration and its definition the resulting behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31033,variab,variable,31033,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['variab'],['variable']
Modifiability,"gnment; 2. Many improvements in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. A",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66420,extend,extend,66420,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['extend'],['extend']
Modifiability,"gold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:4511,plugin,plugin,4511,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"gory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arrays with histogram counts and bin edges (static method); - `RooDataHist.to_numpy`: Export a RooDataHist to numpy arrays with histogram counts and bin edges; - `RooRealVar.bins`: Get bin boundaries for a `RooRealVar` as a NumPy array. For more details, consult the tutor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22486,variab,variables,22486,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['variab'],['variables']
Modifiability,"gram state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. hea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13972,variab,variables,13972,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"gram to adjust; the scale of the function. In case of extended p.d.f.s, the adjustment is made with the expected; number of events, rather than the observed number of events. Tutorial macro rf602_chi2fit.C has been updated to use this new interface. Chi-squared fits to X-Y datasets now possible; In addition to the ability to perform chi-squared fits to histograms it is now also possible; to perform chi-squared fits to unbinned datasets containing a series of X and Y values; with associated errors on Y and optionally on X. These 'X-Y' chi-squared fits are interfaced through newly added method; RooAbsReal::chi2FitTo(const RooDataSet&,...). By default the event weight is; interpreted as the 'Y' value, but an YVar() argument can designate any other; dataset column as Y value. If X errors are defined, one can choose to integrate the fitted; function over the range of the X errors, rather than taking the central value by adding; an Integrate(true) argument to chi2FitTo(); Two new arguments, StoreError(const RooArgSet&) and StoreAsymError(const RooArgSet&); have been added to the RooDataSet constructor to simplify the process of storing the errors; of X and Y variables along with their values in a dataset. The newly added tutorial macro rf609_xychi2fit.C illustrates the use of all this; new functionality. Uniform interface for creation of (profile likelihoods) and chi-squared from p.d.f.s; It is now recommended to use the method RooAbsPdf::createNLL(RooAbsData&,...) to; create a likelihood from a p.d.f and a dataset rather than constructing a RooNLLVar; object directly. This is because part of the likelihood construction functionality such a using; multiple Range()s, or the inclusion for constraint terms are only available through; createNLL(). To promote the consistency of this interface, a similar method RooAbsReal::createChi2(); has been added to construct chi-squared functions of a dataset and a function or p.d.f. Along the same lines, it is recommended to use RooAbsRe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:9074,variab,variables,9074,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['variab'],['variables']
Modifiability,grams are unsuitable for; performance measurements. Setting the `TEST_SUITE_BENCHMARKING_ONLY` CMake; option to `ON` will disable them. Configuration; -------------. The test-suite has configuration options to customize building and running the; benchmarks. CMake can print a list of them:. ```bash; % cd test-suite-build; # Print basic options:; % cmake -LH; # Print all options:; % cmake -LAH; ```. ### Common Configuration Options. - `CMAKE_C_FLAGS`. Specify extra flags to be passed to C compiler invocations. The flags are; also passed to the C++ compiler and linker invocations. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SU,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:4577,variab,variable,4577,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"gration; ==================. :program:`clang-format` cannot be used as a text filter with BBEdit, but works; well via a script. The AppleScript to do this integration can be found at; `clang/tools/clang-format/clang-format-bbedit.applescript`; place a copy in; `~/Library/Application Support/BBEdit/Scripts`, and edit the path within it to; point to your local copy of :program:`clang-format`. With this integration you can select the script from the Script menu and; :program:`clang-format` will format the selection. Note that you can rename the; menu item by renaming the script, and can assign the menu item a keyboard; shortcut in the BBEdit preferences, under Menus & Shortcuts. CLion Integration; =================. :program:`clang-format` is integrated into `CLion <https://www.jetbrains; .com/clion/>`_ as an alternative code formatter. CLion turns it on; automatically when there is a ``.clang-format`` file under the project root.; Code style rules are applied as you type, including indentation,; auto-completion, code generation, and refactorings. :program:`clang-format` can also be enabled without a ``.clang-format`` file.; In this case, CLion prompts you to create one based on the current IDE settings; or the default LLVM style. Visual Studio Integration; =========================. Download the latest Visual Studio extension from the `alpha build site; <https://llvm.org/builds/>`_. The default key-binding is Ctrl-R,Ctrl-F. Visual Studio Code Integration; ==============================. Get the latest Visual Studio Code extension from the `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=xaver.clang-format>`_. The default key-binding is Alt-Shift-F. Git integration; ===============. The script `clang/tools/clang-format/git-clang-format` can be used to; format just the lines touched in git commits:. .. code-block:: console. % git clang-format -h; usage: git clang-format [OPTIONS] [<commit>] [<commit>|--staged] [--] [<file>...]. If zero or o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst:9512,refactor,refactorings,9512,interpreter/llvm-project/clang/docs/ClangFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormat.rst,1,['refactor'],['refactorings']
Modifiability,gregate initialization with parenthesized string literal; Unknown. 1498; dup; Lifetime of temporaries in range-based for; Unknown. 1499; drafting; Missing case for deleted move assignment operator; Not resolved. 1500; CD6; Name lookup of dependent conversion function; Unknown. 1501; NAD; Nested braces in list-initialization; Unknown. 1502; CD3; Value initialization of unions with member initializers; Unknown. 1503; CD3; Exceptions during copy to exception object; Unknown. 1504; CD3; Pointer arithmetic after derived-base conversion; Unknown. 1505; dup; Direct binding of reference to temporary in list-initialization; Unknown. 1506; CD3; Value category of initializer_list object; Unknown. 1507; CD3; Value initialization with trivial inaccessible default constructor; Unknown. 1508; C++14; Template initializer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Arr,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:101617,variab,variables,101617,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"gression; performance. Presently, the Category method works for; classification only, but regression will follow soon. Please; contact us if urgently needed. An example scripts and data files illustrating how the new; Category method is configured and used. Please check the macros; test/TMVAClassificationCategory.C and; test/TMVAClassificationCategoryApplication.C or the; corresponding executables.; Regression functionality for gradient boosted trees using a Huber loss function. Comments. On Input Data: . New TMVA event vector building. The code for splitting the input; data into training and test samples for all classes and the; mixing of those samples to one training and one test sample has; been rewritten completely. The new code is more performant and; has a clearer structure. This fixes several bugs which have been; reported by the TMVA users. On Minimization: . Variables, targets and spectators are now checked if they are; constant. (The execution of TMVA is stopped for variables and; targets, a warning is given for spectators.). On Regression:; ; The analysis type is no longer defined by calling a dedicated; TestAllMethods-member-function of the Factory, but with the; option ""AnalysisType"" in the Factory. The default value is; ""Auto"" where TMVA tries to determine the most suitable analysis; type from the targets and classes the user has defined. Other; values are ""regression"", ""classification"" and ""multiclass"" for; the forthcoming multiclass classification.; Missing regression evaluation plots for training sample were; added. On Cut method:. Removed obsolete option ""FVerySmart"" from Cuts method. On MLP method:; ; Display of convergence information in the progress bar for MLP during training. Creation of animated gifs for MLP convergence monitoring (please; contact authors if you want to do this). On Datasets: . Checks are performed if events are unvoluntarily cut by using a; non-filled array entry (e.g. ""arr[4]"" is used, when the array; has not always at least",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html:1791,variab,variables,1791,tmva/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v526/index.html,1,['variab'],['variables']
Modifiability,"gs: ""``-f``"" to force writing binary output to a; terminal, ""``--quiet``"" to enable quiet mode, and ""``-q``"" for backwards; compatibility with some of our users. We can support these by declaring options; of boolean type like this:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Enable binary output on terminals""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::opt<bool> Quiet2(""q"", cl::desc(""Don't print informational messages""), cl::Hidden);. This does what you would expect: it declares three boolean variables; (""``Force``"", ""``Quiet``"", and ""``Quiet2``"") to recognize these options. Note; that the ""``-q``"" option is specified with the ""`cl::Hidden`_"" flag. This; modifier prevents it from being shown by the standard ""``-help``"" output (note; that it is still shown in the ""``-help-hidden``"" output). The CommandLine library uses a `different parser`_ for different data types.; For example, in the string case, the argument passed to the option is copied; literally into the content of the string variable... we obviously cannot do that; in the boolean case, however, so we must use a smarter parser. In the case of; the boolean parser, it allows no options (in which case it assigns the value of; true to the variable), or it allows the values ""``true``"" or ""``false``"" to be; specified, allowing any of the following inputs:. ::. compiler -f # No value, 'Force' == true; compiler -f=true # Value specified, 'Force' == true; compiler -f=TRUE # Value specified, 'Force' == true; compiler -f=FALSE # Value specified, 'Force' == false. ... you get the idea. The `bool parser`_ just turns the string values into; boolean values, and rejects things like '``compiler -f=foo``'. Similarly, the; `float`_, `double`_, and `int`_ parsers work like you would expect, using the; '``strtol``' and '``strtod``' C library calls to parse the string value into the; specified data type. With the declarations above, ""``compiler -help``"" emits this:. ::. USA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:9991,variab,variable,9991,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69496,variab,variable,69496,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['variab'],['variable']
Modifiability,"guage mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --------------------------. To run a plugin, the dynamic library containing the plugin registry must be; loaded via the `-load` command line option. This will load all plugins; that are registered, and you can select the plugins to run by specifying the; `-plugin` option. Additional parameters for the plugins can be passed with; `-plugin-arg-<plugin-name>`. Note that those options must reach clang's cc1 process. There are two; ways to do so:. * Directly call the parsing process by using the `-cc1` option; this; has the downside of not configuring the default header search paths, so; you'll need to specify t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4722,plugin,plugin,4722,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,2,['plugin'],['plugin']
Modifiability,"guration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name where to submit PoD jobs. If no queue has been given, the default one configured on your RMS; will be used. ### Remote environment configuration. All the PoD commands sent to the VAF master will live in the environment; loaded via us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:3527,variab,variable,3527,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['variab'],['variable']
Modifiability,"guration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1925,config,configurations,1925,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,1,['config'],['configurations']
Modifiability,"gy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note:** this part is not implemented as of Oct 2019. MemTagSanitizer will use :doc:`ScudoHardenedAllocator`; with additional code to update memory tags when. * New memory is obtained from the system.; * An allocation is freed. There is no need to change Allocation Tags for the bulk of the; allocated memory in malloc(), as long as a pointer with the matching; Address Tag is returned. More information; ================. * `LLV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:2258,variab,variable,2258,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"h 256 threads due to reduced lock contention. ## I/O Libraries. - Exclusive use of the global lock is reduced or migrated to finer grained read and write locks in a few hotspots that occur during file opening/closing or task initialization in RDataFrame. This can lead to O(100x) improvements for some typical RDataFrame scenarios with 256 threads due to massively reduced lock contention. ## TTree Libraries. - `TTree` now supports the inclusion of leaves of types `long` and `unsigned long` (and therefore also `std::size_t` on most systems) also for branches in ""leaflist mode"". The corresponding leaflist letters are 'G' and 'g'.; - when looping over a `TTree` with a friend with a larger number of entries, `TTreeReader` now ends the event loop when the entries in the _main_ `TTree` are exhausted, consistently with other interfaces. See [#6518](https://github.com/root-project/root/issues/6518) for more details.; - `TTreeProcessorMT::SetMaxTasksPerFilePerWorker` is now deprecated in favor of the more flexible and newly introduced `TTreeProcessorMT::SetTasksPerWorkerHint`. See the relevant entries in our reference guide for more information.; - The name of the sub-branches of a split collection no longer have 2 consecutive dots if the top level branche name has a trailing dot. The name of the collection's index leaf also no longer include the dot. For example for ""t."" the names where ""t._"" and ""t..fValue"" and are now ""t_"" and ""t.fValue"". . ## RDataFrame. ### New features. - Introduce `ROOT::RDF::RunGraphs`, which allows to compute the results of multiple `RDataFrame`s (or better, multiple independent computation graphs) concurrently while sharing the same thread pool. The computation may be more efficient than running the `RDataFrame`s sequentially if an analysis consists of several computation graphs that individually do not fully utilize the available resources. See e.g. [this tutorial](https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html) for an example usage.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:5241,flexible,flexible,5241,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['flexible'],['flexible']
Modifiability,"h as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library have been added in MathCore. These originate mainly from methods present previously in the implementation of the TF1 class. Now they can be used also outside this class. In addition, in order to have a c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5221,plug-in,plug-in,5221,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['plug-in'],['plug-in']
Modifiability,"h as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will not match loops whose; variables are initialized to ``'\0'``, ``0.0``, ``NULL``, or any form of; zero besides the integer 0. The last step is giving the matcher a name and binding the ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7573,variab,variable,7573,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"h basic block is a node in the graph, and each node contains the instructions; in the block. Similarly, there also exists ``Function::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ==============",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53797,config,configuring,53797,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['config'],['configuring']
Modifiability,"h function pointers,; object pointers, and pointer offsets, into the intermediate representation; (IR) as generated by Numba.; A future version may integrate Cling-generated IR directly into Numba IR (or; vice versa), e.g. if the C++ code is exposed from (precompiled) headers.; This would allow inlining of C++ code into Numba traces, for further; expected speedups. Why Numba?; ----------. The advertised premise of Numba is that it ""makes Python code fast.""; However, there is a much more compelling reason: Numba allows developers to; stay in their chosen ecosystem, be it Python or C++, in mixed environments,; without paying for their choice in lost performance.; For example, a Python developer using Numba does not need to rewrite a kernel; into C++ just to run performantly in a C++ framework.; Similarly, a C++ developer can use Numba to compile and create function; pointers to Python code for easy, performant, access.; This becomes even more compelling if the deployment target is a GPU, which; would otherwise certainly require a rewrite of the Python code.; Add that Numba, as a JIT-compiler, is fully run-time just like ``cppyy``,; and the use case for integration is clear.; (Numba does not currently provide support for C++.). Usage; -------. ``cppyy`` does not use Numba extension hooks to minimize accidental; dependencies.; Instead, it requires that the extensions are loaded explicitly by any code; that uses it::. import cppyy.numba_ext. After that, Numba is able to trace ``cppyy`` bound code when applying the; usual ``numba.njit`` decorator. Numba type declarations are done lazily, with the ``numba_ext`` module only; initially registering hooks on proxy base classes, to keep overheads in; Numba's type-resolution to a minimum.; On use in a JITed trace, each C++ type or function call is refined to the; actual, concrete types and type-specific overloads, with templates; instantiated as-needed.; Where possible, lowering is kept generic to reduce the number of callbacks; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst:2033,rewrite,rewrite,2033,bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/numba.rst,1,['rewrite'],['rewrite']
Modifiability,"h names or identical; branch names. By default collections have a name equal to the; corresponding class name, e.g. the default name of **`TList`** is; ""`TList`"". ## Examples for Writing and Reading Trees. The following sections are examples of writing and reading trees; increasing in complexity from a simple tree with a few variables to a; tree containing folders and complex Event objects. Each example has a; named script in the `$ROOTSYS/tutorials/tree` directory. They are called; tree1.C to tree4.C. The examples are:. - `tree1.C`: a tree with several simple (integers and floating point); variables. - `tree2.C`: a tree built from a C structure (`struct`). This example; uses the `Geant3` C wrapper as an example of a FORTRAN common block; ported to C with a C structure. - `tree3.C:` in this example, we will show how to extend a tree with a; branch from another tree with the Friends feature. These trees have; branches with variable length arrays. Each entry has a variable; number of tracks, and each track has several variables. - `tree4.C:` a tree with a class (`Event`). The class Event is defined; in `$ROOTSYS/test`. In this example we first encounter the impact of; splitting a branch. Each script contains the main function, with the same name as the file; (i.e. `tree1`), the function to write - `tree1w`, and the function to; read - `tree1r`. If the script is not run in batch mode, it displays the; tree in the browser and tree viewer. To study the example scripts, you; can either execute the main script, or load the script and execute a; specific function. For example:. ``` {.cpp}; // execute the function that writes, reads, shows the tree; root[] x tree1.C; // use ACLiC to build shared library, check syntax, execute; root[] x tree1.C++; // Load the script and select a function to execute; root[] L tree1.C; root[] tree1w(); root[] tree1r(); ```. ## Example 1: A Tree with Simple Variables. This example shows how to write, view, and read a tree with several; simple (in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:33916,variab,variable,33916,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,2,['variab'],"['variable', 'variables']"
Modifiability,"h operand; specifies how many of the following variable operands are considered; function call arguments. The remaining variable number of operands are; the ``live values`` for which locations will be recorded in the stack; map. Semantics:; """""""""""""""""""". The patch point intrinsic generates a stack map. It also emits a; function call to the address specified by ``<target>`` if the address; is not a constant null. The function call and its arguments are; lowered according to the calling convention specified at the; intrinsic's callsite. Variants of the intrinsic with non-void return; type also return a value according to calling convention. On PowerPC, note that ``<target>`` must be the ABI function pointer for the; intended target of the indirect call. Specifically, when compiling for the; ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as; the C/C++ function-pointer representation. Requesting zero patch point arguments is valid. In this case, all; variable operands are handled just like; ``llvm.experimental.stackmap.*``. The difference is that space will; still be reserved for patching, a call will be emitted, and a return; value is allowed. The location of the arguments are not normally recorded in the stack; map because they are already fixed by the calling convention. The; remaining ``live values`` will have their location recorded, which; could be a register, stack location, or constant. A special calling; convention has been introduced for use with stack maps, anyregcc,; which forces the arguments to be loaded into registers but allows; those register to be dynamically allocated. These argument registers; will have their register locations recorded in the stack map in; addition to the remaining ``live values``. The patch point also emits nops to cover at least ``<numBytes>`` of; instruction encoding space. Hence, the client must ensure that; ``<numBytes>`` is enough to encode a call to the target address on the; supported targets. If the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:9056,variab,variable,9056,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"h this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9895,variab,variable,9895,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"h two deviations. LLVM uses a PC relative; (PIC) or static addressing for accessing global values, so no TOC (r2) is; used. Second, r31 is used as a frame pointer to allow dynamic growth of a stack; frame. LLVM takes advantage of having no TOC to provide space to save the frame; pointer in the PowerPC linkage area of the caller frame. Other details of; PowerPC ABI can be found at `PowerPC ABI; <http://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI/Articles/32bitPowerPC.html>`_\; . Note: This link describes the 32 bit ABI. The 64 bit ABI is similar except; space for GPRs are 8 bytes wide (not 4) and r13 is reserved for system use. Frame Layout; ^^^^^^^^^^^^. The size of a PowerPC frame is usually fixed for the duration of a function's; invocation. Since the frame is fixed size, all references into the frame can be; accessed via fixed offsets from the stack pointer. The exception to this is; when dynamic alloca or variable sized arrays are present, then a base pointer; (r31) is used as a proxy for the stack pointer and stack pointer is free to grow; or shrink. A base pointer is also used if llvm-gcc is not passed the; -fomit-frame-pointer flag. The stack pointer is always aligned to 16 bytes, so; that space allocated for altivec vectors will be properly aligned. An invocation frame is laid out as follows (low memory at top):. :raw-html:`<table border=""1"" cellspacing=""0"">`; :raw-html:`<tr>`; :raw-html:`<td>Linkage<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Parameter area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Dynamic area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Locals area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Saved registers area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr style=""border-style: none hidden none hidden;"">`; :raw-html:`<td><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Previous Frame<br><br></td>`; :ra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:95450,variab,variable,95450,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['variab'],['variable']
Modifiability,"h) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent background for the histogram title. Misc. In the root executable, auto-detect command line arguments that are local root files even if their name does not end with "".root"". If home directory is not correctly set in pw file or user is not known, use the HOME shell variable to find the desired home directory. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:4332,variab,variable,4332,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,1,['variab'],['variable']
Modifiability,"h/phpBB3/viewtopic.php?f=3&t=16937&p=72314#p72314). ### TPaletteAxis. - The histogram Z axis title is now painted along the palette axis. ### TAxis. - The Axis has a new public bit `TAxis::kCanExtend`, which control the axis extensions (for example in case of time axis) and used to; replace the old bit `TH1::kCanRebin` (see below).; Note that this bit is automatically set when the axis has labels associated to each bin. In this case the axis becomes alphanumeric and; there is no more relation to the observed quantities. Note that when an axis is alphanumeric the mean and the rms of the histograms are not anymore; coputed and they are set to zero. ### TH1. - The bit `TH1::kCanRebin` used to extend the histogram axes is now deprecated. The bit exists still in ROOT 6.0 but it has no effect.; One should use now the new function `TH1::SetCanExtend(..)` passing the axis (using the appropriate enumeration), which needs to be extended.; In addition to extend each axis individually, the function can be used also to enable/disable extension for all axes.; For example `TH1::SetCanExtend(TH1::kXaxis)` will make extendable only the X axis; `TH1::SetCanExtend(TH1::kAllAxes)` will; make extendable all the axes (this is the same functionality of the previous function `SetBit(TH1::kCanRebin)` and; `TH1::SetCanExtend(TH1::kNoAxis)` will remove the extendable functionality to all the axes (equivalent to the old `ResetBit(TH1::kCanRebin)`).; The functionality of `TestBit(TH1::kCanRebin)` is now replaced by `TH1::CanExtendAllAxis()`. - An histogram filled with weights different than one has now automatically the sum of the weight squared stored inside, without the need to call anymore; `TH1::Sumw2()`. As a consequences an histogram filled with weights will always draw the errors by default. If one desire to continue having the histogram drawn; without the errors, one should use the `hist` option: `h.Draw(""hist"")`.; If, for memory reason, one does not want to remove the internal array sto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md:7376,extend,extend,7376,hist/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v600/index.md,1,['extend'],['extend']
Modifiability,"h/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4176,plugin,plugin-opt,4176,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin-opt']
Modifiability,h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-tools-extra/clangd/support/Shutdown.cpp; clang-tools-extra/clangd/support/Shutdown.h; clang-tools-extra/clangd/support/ThreadCrashReporter.cpp; clang-tools-extra/clangd/support/ThreadCrashReporter.h; clang-tools-extra/clangd/support/Threading.cpp; clang,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80751,refactor,refactor,80751,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"h; the dictionaries are to be created. In addition, it allows to specify; properties of classes or data members, without the need to add comments in; the source code. This is of primary importance when dictionaries must be; created for classes residing in code which cannot be modified.; For a complete description of the structure of the *selection XML files*; and the way in which attributes can be set, refer to the `genreflex --help`; command. It is important to observe that *selection XML files* can be used in presence; of `rootcling` invocations instead of `LinkDef` files. ### The `ROOT::Meta::Selection` namespace. Not only `LinkDef` and `selection` files allow to select the classes for which; the dictionaries must be created: a third method is available. This is; represented by the `ROOT::Meta::Selection` namespace. The idea behind this; technique is that all the classes which are located in this special namespace; are automatically selected for dictionary generation. All the properties and; annotations allowed by `LinkDef` and `selection XML` files are possible.; For a detailed documentation of the features of the `ROOT::Meta::Selection`; namespace, refer to its online documentation. ## Adding a Class with ACLiC. \index{adding a class!ACLiC}; **Step 1:** Define your class. ``` {.cpp}; #include ""TObject.h"". // define the ABC class and make it inherit from TObject so that; // we can write ABC to a ROOT file; class ABC : public TObject {. public:; Float_t a, b, c, p;; ABC() : a(0), b(0), c(0), p(0){};. // Define the class for the dictionary; ClassDef (ABC,1); };. // Call the ClassImp macro to give the ABC class RTTI and; // full I/O capabilities. #if !defined(__CLING__); ClassImp(ABC);; #endif; ```. **Step 2:** Load the ABC class in the script. ``` {.cpp}; // Check if ABC is already loaded; if (!TClass::GetDict(""ABC"")) {; gROOT->ProcessLine("".L ABCClass.C++"");; }. // Use the Class; ABC *v = new ABC;; v->p = (sqrt((v->a * v->a)+ (v->b * v->b)+(v->c * v->c)));; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:36028,inherit,inherit,36028,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inherit']
Modifiability,"h; up the control flow for it. This code remembers the end block (for the; phi node), then creates the block for the loop exit (""afterloop""). Based; on the value of the exit condition, it creates a conditional branch that; chooses between executing the loop again and exiting the loop. Any; future code is emitted in the ""afterloop"" block, so it sets the; insertion position to it. .. code-block:: c++. // Add a new entry to the PHI node for the backedge.; Variable->addIncoming(NextVar, LoopEndBB);. // Restore the unshadowed variable.; if (OldVal); NamedValues[VarName] = OldVal;; else; NamedValues.erase(VarName);. // for expr always returns 0.0.; return Constant::getNullValue(Type::getDoubleTy(*TheContext));; }. The final code handles various cleanups: now that we have the ""NextVar""; value, we can add the incoming value to the loop PHI node. After that,; we remove the loop variable from the symbol table, so that it isn't in; scope after the for loop. Finally, code generation of the for loop; always returns 0.0, so that is what we return from; ``ForExprAST::codegen()``. With this, we conclude the ""adding control flow to Kaleidoscope"" chapter; of the tutorial. In this chapter we added two control flow constructs,; and used them to motivate a couple of aspects of the LLVM IR that are; important for front-end implementors to know. In the next chapter of our; saga, we will get a bit crazier and add `user-defined; operators <LangImpl06.html>`_ to our poor innocent language. Full Code Listing; =================. Here is the complete code listing for our running example, enhanced with; the if/then/else and for expressions. To build this example, use:. .. code-block:: bash. # Compile; clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy; # Run; ./toy. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter5/toy.cpp; :language: c++. `Next: Extending the language: user-defined operators <LangImpl06.html>`_. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:26823,enhance,enhanced,26823,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,2,"['config', 'enhance']","['config', 'enhanced']"
Modifiability,"h``, but break before functions. .. code-block:: c++. namespace N {; enum E {; E1,; E2,; };. class C {; public:; C();; };. bool baz(int i); {; try {; do {; switch (i) {; case 1: {; foobar();; break;; }; default: {; break;; }; }; } while (--i);; return true;; } catch (...) {; handleError();; return false;; }; }. void foo(bool b); {; if (b) {; baz(2);; } else {; baz(5);; }; }. void bar() { foo(true); }; } // namespace N. * ``BS_Custom`` (in configuration: ``Custom``); Configure each individual brace in ``BraceWrapping``. .. _BreakBeforeConceptDeclarations:. **BreakBeforeConceptDeclarations** (``BreakBeforeConceptDeclarationsStyle``) :versionbadge:`clang-format 12` :ref:`¶ <BreakBeforeConceptDeclarations>`; The concept declaration style to use. Possible values:. * ``BBCDS_Never`` (in configuration: ``Never``); Keep the template declaration line together with ``concept``. .. code-block:: c++. template <typename T> concept C = ...;. * ``BBCDS_Allowed`` (in configuration: ``Allowed``); Breaking between template declaration and ``concept`` is allowed. The; actual behavior depends on the content and line breaking rules and; penalties. * ``BBCDS_Always`` (in configuration: ``Always``); Always break before ``concept``, putting it in the line after the; template declaration. .. code-block:: c++. template <typename T>; concept C = ...;. .. _BreakBeforeInlineASMColon:. **BreakBeforeInlineASMColon** (``BreakBeforeInlineASMColonStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakBeforeInlineASMColon>`; The inline ASM colon style to use. Possible values:. * ``BBIAS_Never`` (in configuration: ``Never``); No break before inline ASM colon. .. code-block:: c++. asm volatile(""string"", : : val);. * ``BBIAS_OnlyMultiline`` (in configuration: ``OnlyMultiline``); Break before inline ASM colon if the line length is longer than column; limit. .. code-block:: c++. asm volatile(""string"", : : val);; asm(""cmoveq %1, %2, %[result]""; : [result] ""=r""(result); : ""r""(test), ""r""(new), ""[result]""(old)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:52414,config,configuration,52414,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ha.core.PointerSub; (C); Check for pointer subtractions on two pointers pointing to different memory; chunks. void test() {; int x, y;; int d = &y - &x; // warn; }. alpha.core.SizeofPtr; (C); Warn about unintended use of sizeof() on pointer; expressions. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. alpha.core.StackAddressAsyncEscape; (C); Check that addresses to stack memory do not escape the function that involves; dispatch_after or dispatch_async. This checker is; a part of core.StackAddressEscape, but is; temporarily disabled until some; false positives are fixed. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. alpha.core.TestAfterDivZero; (C, C++, ObjC); Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. C++ Alpha Checkers. Name, DescriptionExample. alpha.cplusplus.ArrayDelete; (C++); Reports destructions of arrays of polymorphic objects that are destructed as; their base class. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void sink(Base *x) {; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' undefined; }. alpha.cplusplus.DeleteWithNonVirtualDtor; (C++); Reports destructions of polymorphic objects with a non-virtual destructor in; their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.Inval",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:4113,variab,variable,4113,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,1,['variab'],['variable']
Modifiability,"hanges.; set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); # Otherwise assume it's a library name we need to link with.; if(IS_ABSOLUTE ${l}); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""${l}""); else(); set(SYSTEM_LIBS ${SYSTEM_LIBS} ""-l${l}""); endif(); endif(); endif(); endforeach(). string(REPLACE "";"" "" "" SYSTEM_LIBS ""${SYSTEM_LIBS}""). # Fetch target specific compile options, e.g. RTTI option; get_property(COMPILE_FLAGS TARGET llvm-config PROPERTY COMPILE_FLAGS). # NOTE: We don't want to start extracting any random C/CXX flags that the; # user may add that could affect the ABI. We only want to extract flags; # that have been added by the LLVM build system.; string(REGEX MATCH ""-stdlib=[^ ]+"" LLVM_CXX_STDLIB_FLAG ${CMAKE_CXX_FLAGS}); string(REGEX MATCH ""-std=[^ ]+"" LLVM_C_STD_FLAG ${CMAKE_C_FLAGS}). # Use configure_file to create BuildVariables.inc.; set(LLVM_SRC_ROOT ${LLVM_MAIN_SRC_DIR}); set(LLVM_OBJ_ROOT ${LLVM_BINARY_DIR}); set(LLVM_CPPFLAGS ""${LLVM_DEFINITIONS}""); set(LLVM_CFLAGS ""${LLVM_C_STD_FLAG} ${LLVM_DEFINITIONS}""); # The language standard potentially affects the ABI/API of LLVM, so we want; # to make sure it is reported by llvm-config.; set(LLVM_CXXFLAGS ""${CMAKE_CXX${CMAKE_CXX_STANDARD}_STANDARD_COMPILE_OPTION} ${LLVM_CXX_STDLIB_FLAG} ${COMPILE_FLAGS} ${LLVM_DEFINITIONS}""); set(LLVM_BUILD_SYSTEM cmake); set(LLVM_HAS_RTTI ${LLVM_CONFIG_HAS_RTTI}); set(LLVM_DYLIB_VERSION ""${LLVM_VERSION_MAJOR}${LLVM_VERSION_SUFFIX}""). # Use the C++ link flags, since they should be a superset of C link flags.; set(LLVM_LDFLAGS ""${CMAKE_CXX_LINK_FLAGS}""); set(LLVM_BUILDMODE ${CMAKE_BUILD_TYPE}); set(LLVM_SYSTEM_LIBS ${SYSTEM_LIBS}); string(REPLACE "";"" "" "" LLVM_TARGETS_BUILT ""${LLVM_TARGETS_TO_BUILD}""); llvm_canonicalize_cmake_booleans(; LLVM_BUILD_LLVM_DYLIB; LLVM_LINK_LLVM_DYLIB; LLVM_HAS_RTTI; BUILD_SHARED_LIBS); llvm_expand_pseudo_components(LLVM_DYLIB_COMPONENTS_expanded ""${LLVM_DYLIB_COMPONENTS}""); configure_file(${BUILDVARIABLES_SRCPATH} ${BUILDVARIABLES_OBJPATH} @ONLY). # Set bui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt:2308,config,config,2308,interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/CMakeLists.txt,1,['config'],['config']
Modifiability,"has no; effect beyond ``standard``. The ``_Float16`` type is an interchange floating type specified in; ISO/IEC TS 18661-3:2015 (""Floating-point extensions for C""). It will; be supported on more targets as they define ABIs for it. The ``__bf16`` type is a non-standard extension, but it generally follows; the rules for arithmetic interchange floating types from ISO/IEC TS; 18661-3:2015. In previous versions of Clang, it was a storage-only type; that forbade arithmetic operations. It will be supported on more targets; as they define ABIs for it. The ``__fp16`` type was originally an ARM extension and is specified; by the `ARM C Language Extensions <https://github.com/ARM-software/acle/releases>`_.; Clang uses the ``binary16`` format from IEEE 754-2008 for ``__fp16``,; not the ARM alternative format. Operators that expect arithmetic operands; immediately promote ``__fp16`` operands to ``float``. It is recommended that portable code use ``_Float16`` instead of ``__fp16``,; as it has been defined by the C standards committee and has behavior that is; more familiar to most programmers. Because ``__fp16`` operands are always immediately promoted to ``float``, the; common real type of ``__fp16`` and ``_Float16`` for the purposes of the usual; arithmetic conversions is ``float``. A literal can be given ``_Float16`` type using the suffix ``f16``. For example,; ``3.14f16``. Because default argument promotion only applies to the standard floating-point; types, ``_Float16`` values are not promoted to ``double`` when passed as variadic; or untyped arguments. As a consequence, some caution must be taken when using; certain library facilities with ``_Float16``; for example, there is no ``printf`` format; specifier for ``_Float16``, and (unlike ``float``) it will not be implicitly promoted to; ``double`` when passed to ``printf``, so the programmer must explicitly cast it to; ``double`` before using it with an ``%f`` or similar specifier. Messages on ``deprecated`` and ``unavailable`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:34631,portab,portable,34631,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['portab'],['portable']
Modifiability,"has three integers called; `ntrack`, `nseg`, and `nvtex`. ``` {.cpp}; ""ntrack/I:nseg:nvtex""; ```. There is one more rule: when no type is given for the very first leaf,; it becomes a `float` (F). This leaf list has three floats called `temp`,; `mass`, and `px`. ``` {.cpp}; ""temp:mass:px""; ```. The symbols used for the type are:. - `C`: a character string terminated by the 0 character; - `B`: an 8 bit signed integer; - `b`: an 8 bit unsigned integer; - `S`: a 16 bit signed integer; - `s`: a 16 bit unsigned integer; - `I`: a 32 bit signed integer; - `i`: a 32 bit unsigned integer; - `L`: a 64 bit signed integer; - `l`: a 64 bit unsigned integer; - `G`: a long signed integer, stored as 64 bit; - `g`: a long unsigned integer, stored as 64 bit; - `F`: a 32 bit floating point; - `D`: a 64 bit floating point; - `O`: [the letter 'o', not a zero] a boolean (Bool\_t). The type is used for a byte count to decide how much space to allocate.; The variable written is simply the block of bytes starting at the; starting address given in the second parameter. It may or may not match; the leaf list depending on whether or not the programmer is being; careful when choosing the leaf address, name, and type. By default, a variable will be copied with the number of bytes specified; in the type descriptor symbol. However, if the type consists of two; characters, the number specifies the number of bytes to be used when; copying the variable to the output buffer. The line below describes; `ntrack` to be written as a 16-bit integer (rather than a 32-bit; integer). ``` {.cpp}; ""ntrack/I2""; ```. With this Branch method, you can also add a leaf that holds an entire; array of variables. To add an array of floats use the `f[n]` notation; when describing the leaf. ``` {.cpp}; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; ```. You can also add an array of variable length:. ``` {.cpp}; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:21762,variab,variable,21762,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"hasLHS(integerLiteral(equals(0)))). Shockingly, it will match against addition expressions whose left hand; side is exactly the literal 0. It will not match against other forms of; 0, such as ``'\0'`` or ``NULL``, but it will match against macros that; expand to 0. The matcher will also not match against calls to the; overloaded operator ``'+'``, as there is a separate ``operatorCallExpr``; matcher to handle overloaded operators. There are AST matchers to match all the different nodes of the AST,; narrowing matchers to only match AST nodes fulfilling specific criteria,; and traversal matchers to get from one kind of AST node to another. For; a complete list of AST matchers, take a look at the `AST Matcher; References <LibASTMatchersReference.html>`_. All matcher that are nouns describe entities in the AST and can be; bound, so that they can be referred to whenever a match is found. To do; so, simply call the method ``bind`` on these matchers, e.g.:. .. code-block:: c++. variable(hasType(isInteger())).bind(""intvar""). Step 2: Using AST matchers; ==========================. Okay, on to using matchers for real. Let's start by defining a matcher; which will capture all ``for`` statements that define a new variable; initialized to zero. Let's start with matching all ``for`` loops:. .. code-block:: c++. forStmt(). Next, we want to specify that a single variable is declared in the first; portion of the loop, so we can extend the matcher to. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl())))). Finally, we can add the condition that the variable is initialized to; zero. .. code-block:: c++. forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(; hasInitializer(integerLiteral(equals(0)))))))). It is fairly easy to read and understand the matcher definition (""match; loops whose init portion declares a single variable which is initialized; to the integer literal 0""), but deciding that every piece is necessary; is more difficult. Note that this matcher will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst:7338,variab,variable,7338,interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersTutorial.rst,1,['variab'],['variable']
Modifiability,"hat allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return that. Otherwise it will construct a; new result by calling the analysis's ``run()`` method, cache it, and return it.; You can also ask the analysis manager to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6588,plugin,plugins,6588,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['plugin'],['plugins']
Modifiability,"hat ignores the type of ``s``. That is, it will modify *any* method call; where the method is named ""size"":. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr().bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. We express the pattern with the given AST matcher, which binds the method call's; target to ``s`` [#f1]_. For the edit, we again use ``changeTo``, but this; time we construct the term from multiple parts, which we compose with ``cat``. The; second part of our term is ``node(s)``, which selects the source code; corresponding to the AST node ``s`` that was bound when a match was found in the; AST for our rule's pattern. ``node(s)`` constructs a ``RangeSelector``, which, when; used in ``cat``, indicates that the selected source should be inserted in the; output at that point. Now, we probably don't want to rewrite *all* invocations of ""size"" methods, just; those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:6816,rewrite,rewrite,6816,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"hat it is functional makes it ""too easy"" to generate LLVM IR for it. In; particular, a functional language makes it very easy to build LLVM IR; directly in `SSA; form <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_.; Since LLVM requires that the input code be in SSA form, this is a very; nice property and it is often unclear to newcomers how to generate code; for an imperative language with mutable variables. The short (and happy) summary of this chapter is that there is no need; for your front-end to build SSA form: LLVM provides highly tuned and; well tested support for this, though the way it works is a bit; unexpected for some. Why is this a hard problem?; ===========================. To understand why mutable variables cause complexities in SSA; construction, consider this extremely simple C example:. .. code-block:: c. int G, H;; int test(_Bool Condition) {; int X;; if (Condition); X = G;; else; X = H;; return X;; }. In this case, we have the variable ""X"", whose value depends on the path; executed in the program. Because there are two different possible values; for X before the return instruction, a PHI node is inserted to merge the; two values. The LLVM IR that we want for this example looks like this:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next:; %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]; ret i32 %X.2; }. In this example, the loads from the G and H global variables are; explicit in the LLVM IR, and they live in the then/else branches of the; if statement (cond\_true/cond\_false). In order to merge the incoming; values, the X.2 phi node in the cond\_next block selects the right value; to use based on where control flow is coming from: if",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:1725,variab,variable,1725,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"hat make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values are ""tiny"", ""small"", ""kernel"", ""medium"", ""large"".; This may be extended in the future to specify global data layout that; doesn't cleanly fit into a specific code model. By default, global initializers are optimized by assuming that global; variables defined within the module are not modified from their; initial values before the start of the global initializer. This is; true even for variables potentially accessible from outside the; module, including those with external linkage or appearing in; ``@llvm.used`` or dllexported variables. This assumption may be suppressed; by marking the variable with ``externally_initialized``. An explicit alignment may be specified for a global, which must be a; power of 2. If not present, or if the alignment is set to zero, the; alignment of the global is set by the target to whatever it feels; convenient. If an explicit alignment is specified, the global is forced; to have exactly that alignment. Targets and optimizers are not allowed; to over-align the global if the global has an assigned section. In this; case, the extra alignment could be observable: for example, code could; assume that the globals are densely packed in their section and try to; iterate over them as an array, alignment padding would break this; iteration. For TLS variables, the module flag ``MaxTLSAlign``, if present,; limits the alignment to the given value. Optimizers are not allowed to; impose a stronger alignment on these variables. The maximum alignment; is ``1 << 32``. For global variable d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:34281,variab,variables,34281,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"hat only appear when the; experimental target is enabled, caused by changes unrelated to the target, are; the responsibility of the community behind the target to fix. The basic rules for a back-end to be upstreamed in **experimental** mode are:. * Every target must have a :ref:`code owner<code owners>`. The `CODE_OWNERS.TXT`; file has to be updated as part of the first merge. The code owner makes sure; that changes to the target get reviewed and steers the overall effort. * There must be an active community behind the target. This community; will help maintain the target by providing buildbots, fixing; bugs, answering the LLVM community's questions and making sure the new; target doesn't break any of the other targets, or generic code. This; behavior is expected to continue throughout the lifetime of the; target's code. * The code must be free of contentious issues, for example, large; changes in how the IR behaves or should be formed by the front-ends,; unless agreed by the majority of the community via refactoring of the; (:doc:`IR standard<LangRef>`) **before** the merge of the new target changes,; following the :ref:`IR backwards compatibility`. * The code conforms to all of the policies laid out in this developer policy; document, including license, patent, and coding standards. * The target should have either reasonable documentation on how it; works (ISA, ABI, etc.) or a publicly available simulator/hardware; (either free or cheap enough) - preferably both. This allows; developers to validate assumptions, understand constraints and review code; that can affect the target. In addition, the rules for a back-end to be promoted to **official** are:. * The target must have addressed every other minimum requirement and; have been stable in tree for at least 3 months. This cool down; period is to make sure that the back-end and the target community can; endure continuous upstream development for the foreseeable future. * The target's code must have been completely ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:40579,refactor,refactoring,40579,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['refactor'],['refactoring']
Modifiability,"hat operands which are constants also use; the relative encoding, while operands like basic block labels; do not use the relative encoding. Forward references will result in a negative value.; This can be inefficient, as operands are normally encoded; as unsigned VBRs. However, forward references are rare, except in the; case of phi instructions. For phi instructions, operands are encoded as; `Signed VBRs`_ to deal with forward references. In version 2, the meaning of module records ``FUNCTION``, ``GLOBALVAR``,; ``ALIAS``, ``IFUNC`` and ``COMDAT`` change such that the first two operands; specify an offset and size of a string in a string table (see `STRTAB_BLOCK; Contents`_), the function name is removed from the ``FNENTRY`` record in the; value symbol table, and the top-level ``VALUE_SYMTAB_BLOCK`` may only contain; ``FNENTRY`` records. MODULE_CODE_TRIPLE Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[TRIPLE, ...string...]``. The ``TRIPLE`` record (code 2) contains a variable number of values representing; the bytes of the ``target triple`` specification string. MODULE_CODE_DATALAYOUT Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DATALAYOUT, ...string...]``. The ``DATALAYOUT`` record (code 3) contains a variable number of values; representing the bytes of the ``target datalayout`` specification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:25436,variab,variable,25436,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"hat the builtins can be linked; into a binary and execute the tests correctly but it will not catch if the; builtins use instructions that are supported on Armv7-A but not Armv6-M,; Armv7-M and Armv7E-M. To get the cmake compile test to pass you will need to pass the libraries; needed to successfully link the cmake test via ``CMAKE_CFLAGS``. It is; strongly recommended that you use version 3.6 or above of cmake so you can use; ``CMAKE_TRY_COMPILE_TARGET=STATIC_LIBRARY`` to skip the link step. * ``-DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY``; * ``-DCOMPILER_RT_OS_DIR=""baremetal""``; * ``-DCOMPILER_RT_BUILD_BUILTINS=ON``; * ``-DCOMPILER_RT_BUILD_SANITIZERS=OFF``; * ``-DCOMPILER_RT_BUILD_XRAY=OFF``; * ``-DCOMPILER_RT_BUILD_LIBFUZZER=OFF``; * ``-DCOMPILER_RT_BUILD_PROFILE=OFF``; * ``-DCMAKE_C_COMPILER=${host_install_dir}/bin/clang``; * ``-DCMAKE_C_COMPILER_TARGET=""your *-none-eabi target""``; * ``-DCMAKE_ASM_COMPILER_TARGET=""your *-none-eabi target""``; * ``-DCMAKE_AR=/path/to/llvm-ar``; * ``-DCMAKE_NM=/path/to/llvm-nm``; * ``-DCMAKE_RANLIB=/path/to/llvm-ranlib``; * ``-DCOMPILER_RT_BAREMETAL_BUILD=ON``; * ``-DCOMPILER_RT_DEFAULT_TARGET_ONLY=ON``; * ``-DLLVM_CONFIG_PATH=/path/to/llvm-config``; * ``-DCMAKE_C_FLAGS=""build-c-flags""``; * ``-DCMAKE_ASM_FLAGS=""build-c-flags""``; * ``-DCOMPILER_RT_EMULATOR=""qemu-arm -L /path/to/armv7-A/sysroot""``; * ``-DCOMPILER_RT_INCLUDE_TESTS=ON``; * ``-DCOMPILER_RT_TEST_COMPILER=""/path/to/clang""``; * ``-DCOMPILER_RT_TEST_COMPILER_CFLAGS=""test-c-flags""``. The Armv6-M builtins will use the soft-float ABI. When compiling the tests for; Armv7-A we must include ``""-mthumb -mfloat-abi=soft -mfpu=none""`` in the; test-c-flags. We must use an Armv7-A soft-float abi sysroot for ``qemu-arm``. Depending on the linker used for the test cases you may encounter BuildAttribute; mismatches between the M-profile objects from compiler-rt and the A-profile; objects from the test. The lld linker does not check the profile; BuildAttribute so it can be used to lin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst:11522,config,config,11522,interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToCrossCompileBuiltinsOnArm.rst,1,['config'],['config']
Modifiability,"have `Query` which lists all the queries we defined. ```python; print(full_json[""anonymous_0""][""!superclasses""]); ```. ['Query']. On each def there is also a `!superclasses` that gives you the same information. Meaning you could use `!instanceof` to get a list of keys to lookup, or you could walk all keys and check `!superclasses`. ```python; print(full_json[""anonymous_0""][""Fields""]); ```. {'args': [], 'kind': 'dag', 'operator': {'def': 'all', 'kind': 'def', 'printable': 'all'}, 'printable': '(all)'}. From a def object you can find its attributes. Here we have the fields we want the query to show, which is all of them. # The Backend. The core of a backend is looping over all defs of a certain class and outputting some text based on their properties. Here we're going to loop over all defs of type `Query` and emit SQL queries for them. ```python; def find_all_queries(j):; queries = []; for key in j:; # ! means it is some metadata, not a def.; if not key.startswith(""!""):; value = full_json[key]; # If we inherit from Query.; if ""Query"" in value[""!superclasses""]:; queries.append(value); return queries. queries = find_all_queries(full_json); ; print([q[""!name""] for q in queries]); ```. ['anonymous_0', 'anonymous_1', 'anonymous_2', 'anonymous_3', 'anonymous_4']. Why are the names `anonymous_...`? When we defined them we did `def :` and missed out the name. This is allowed and `llvm-tblgen` just came up with a name for us. For this purpose the names are irrelevant. Now we have the relevant classes we need to ""emit"" them. Meaning produce something from them, in this case a SQL query. ```python; def emit_operator(operator):; return {; 'gt': ' > ',; 'ge': ' >= ',; 'lt': ' < ',; 'le': ' <= ',; 'ne': ' <> ',; 'eq': ' = ',; 'or': ' OR ',; 'and': ' AND '; }[operator]. print(emit_operator('and')); ```. AND . The maps our TableGen constants to the equivalent SQL logical operation. ```python; def emit_fields(args):; # Return a comma separated list of arg names.; return "", "".join([arg[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md:11157,inherit,inherit,11157,interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,1,['inherit'],['inherit']
Modifiability,"having the same value in two; threads refer to the same data. Also, if any thread changes one of the; shared system resources, all threads within the process are affected.; For example, if a thread closes a file, the file is closed for all; threads. ### The Initial Thread. When a process is created, one thread is automatically created. This; thread is called the initial thread or the main thread. The initial; thread executes the main routine in multi-threaded programs. Note: At the end of this chapter is a glossary of thread specific terms. ## Implementation of Threads in ROOT. The **`TThread`** class has been developed to provide a platform; independent interface to threads for ROOT. ### Installation. For the time being, it is still necessary to compile a threaded version; of ROOT to enable some very special treatments of the canvas operations.; We hope that this will become the default later. To compile ROOT, just do (for example on a debian Linux):. ```; ./configure linuxdeb2 --with-thread=/usr/lib/libpthread.so; gmake depend; gmake; ```. This configures and builds ROOT using `/usr/lib/libpthread.so` as the; `Pthread` library, and defines `R__THREAD`. This enables the thread specific treatment of *`gPad`*, and creates; `$ROOTSYS/lib/libThread.so.`. Note: The parameter linuxdeb2 has to be replaced with the appropriate; ROOT keyword for your platform. ### Classes. **`TThread`** class implements threads . The platform dependent; implementation is in the **`TThreadImp`** class and its descendant; classes (e.g. **`TPosixThread`** ). **`TMutex`** class implements `mutex` locks. A mutex is a mutually; exclusive lock. The platform dependent implementation is in the; **`TMutexImp`** class and its descendant classes (e.g.; **`TPosixMutex`**). **`TCondition`** class implements a condition variable. Use a condition; variable to signal threads. The platform dependent implementation is in; the **`TConditionImp`** and **`TPosixCondition`** classes . **`TSemaphore`** class implem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:3128,config,configure,3128,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['config'],['configure']
Modifiability,"he Basics; ^^^^^^^^^^^. #. Make sure that your Modules contain both a data layout specification and; target triple. Without these pieces, non of the target specific optimization; will be enabled. This can have a major effect on the generated code quality. #. For each function or global emitted, use the most private linkage type; possible (private, internal or linkonce_odr preferably). Doing so will; make LLVM's inter-procedural optimizations much more effective. #. Avoid high in-degree basic blocks (e.g. basic blocks with dozens or hundreds; of predecessors). Among other issues, the register allocator is known to; perform badly with confronted with such structures. The only exception to; this guidance is that a unified return block with high in-degree is fine. Use of allocas; ^^^^^^^^^^^^^^. An alloca instruction can be used to represent a function scoped stack slot,; but can also represent dynamic frame expansion. When representing function; scoped variables or locations, placing alloca instructions at the beginning of; the entry block should be preferred. In particular, place them before any; call instructions. Call instructions might get inlined and replaced with; multiple basic blocks. The end result is that a following alloca instruction; would no longer be in the entry basic block afterward. The SROA (Scalar Replacement Of Aggregates) and Mem2Reg passes only attempt; to eliminate alloca instructions that are in the entry basic block. Given; SSA is the canonical form expected by much of the optimizer; if allocas can; not be eliminated by Mem2Reg or SROA, the optimizer is likely to be less; effective than it could be. Avoid loads and stores of large aggregate type; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. LLVM currently does not optimize well loads and stores of large :ref:`aggregate; types <t_aggregate>` (i.e. structs and arrays). As an alternative, consider; loading individual fields from memory. Aggregates that are smaller than the largest (performan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:2305,variab,variables,2305,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,1,['variab'],['variables']
Modifiability,"he C++Now! 2012 talk; describing this technique in more detail.; #. `Sean Parent's Papers and Presentations; <http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations>`_; - A GitHub project full of links to slides, video, and sometimes code. When deciding between creating a type hierarchy (with either tagged or virtual; dispatch) and using templates or concepts-based polymorphism, consider whether; there is some refinement of an abstract base class which is a semantically; meaningful type on an interface boundary. If anything more refined than the; root abstract interface is meaningless to talk about as a partial extension of; the semantic model, then your use case likely fits better with polymorphism and; you should avoid using virtual dispatch. However, there may be some exigent; circumstances that require one technique or the other to be used. If you do need to introduce a type hierarchy, we prefer to use explicitly; closed type hierarchies with manual tagged dispatch and/or RTTI rather than the; open inheritance model and virtual dispatch that is more common in C++ code.; This is because LLVM rarely encourages library consumers to extend its core; types, and leverages the closed and tag-dispatched nature of its hierarchies to; generate significantly more efficient code. We have also found that a large; amount of our usage of type hierarchies fits better with tag-based pattern; matching rather than dynamic dispatch across a common interface. Within LLVM we; have built custom helpers to facilitate this design. See this document's; section on :ref:`isa and dyn_cast <isa>` and our :doc:`detailed document; <HowToSetUpLLVMStyleRTTI>` which describes how you can implement this; pattern for use with the LLVM helpers. .. _abi_breaking_checks:. ABI Breaking Checks; -------------------. Checks and asserts that alter the LLVM C++ ABI are predicated on the; preprocessor symbol `LLVM_ENABLE_ABI_BREAKING_CHECKS` -- LLVM; libraries built with `LLVM_ENAB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:132444,inherit,inheritance,132444,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['inherit'],['inheritance']
Modifiability,"he LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; br label %cond_next. cond_next",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6274,variab,variable,6274,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"he PTX kernel functions are callable by host-side code. .. _address_spaces:. Address Spaces; --------------. The NVPTX back-end uses the following address space mapping:. ============= ======================; Address Space Memory Space; ============= ======================; 0 Generic; 1 Global; 2 Internal Use; 3 Shared; 4 Constant; 5 Local; ============= ======================. Every global variable and pointer type is assigned to one of these address; spaces, with 0 being the default address space. Intrinsics are provided which; can be used to convert pointers between the generic and non-generic address; spaces. As an example, the following IR will define an array ``@g`` that resides in; global device memory. .. code-block:: llvm. @g = internal addrspace(1) global [4 x i32] [ i32 0, i32 1, i32 2, i32 3 ]. LLVM IR functions can read and write to this array, and host-side code can; copy data to it by name with the CUDA Driver API. Note that since address space 0 is the generic space, it is illegal to have; global variables in address space 0. Address space 0 is the default address; space in LLVM, so the ``addrspace(N)`` annotation is *required* for global; variables. Triples; -------. The NVPTX target uses the module triple to select between 32/64-bit code; generation and the driver-compiler interface to use. The triple architecture; can be one of ``nvptx`` (32-bit PTX) or ``nvptx64`` (64-bit PTX). The; operating system should be one of ``cuda`` or ``nvcl``, which determines the; interface used by the generated code to communicate with the driver. Most; users will want to use ``cuda`` as the operating system, which makes the; generated PTX compatible with the CUDA Driver API. Example: 32-bit PTX for CUDA Driver API: ``nvptx-nvidia-cuda``. Example: 64-bit PTX for CUDA Driver API: ``nvptx64-nvidia-cuda``. .. _nvptx_intrinsics:. NVPTX Intrinsics; ================. Address Space Conversion; ------------------------. '``llvm.nvvm.ptr.*.to.gen``' Intrinsics; ^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst:2947,variab,variables,2947,interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NVPTXUsage.rst,1,['variab'],['variables']
Modifiability,"he RooFit collection constructors. #### Allow for use of Python collections instead of C++ STL containers. Some RooFit functions take STL map-like types such as `std::map` as parameters, for example the [RooCategory constructor](https://root.cern/doc/v626/classRooCategory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22219,variab,variables,22219,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['variab'],['variables']
Modifiability,"he SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:146478,portab,portablecl,146478,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['portab'],['portablecl']
Modifiability,"he ``__weak`` and; ``__unsafe_unretained`` qualifiers (and the ``weak`` and; ``unsafe_unretained`` property attributes) are just as laid out; in the :doc:`ARC specification <AutomaticReferenceCounting>`.; In particular, note that some classes do not support forming weak; references to their instances, and note that special care must be; taken when storing weak references in memory where initialization; and deinitialization are outside the responsibility of the compiler; (such as in ``malloc``-ed memory). Loading from a ``__weak`` variable always implicitly retains the; loaded value. In non-ARC modes, this retain is normally balanced; by an implicit autorelease. This autorelease can be suppressed; by performing the load in the receiver position of a ``-retain``; message send (e.g. ``[weakReference retain]``); note that this performs; only a single retain (the retain done when primitively loading from; the weak reference). For the most part, ``__unsafe_unretained`` in non-ARC modes is just the; default behavior of variables and therefore is not needed. However,; it does have an effect on the semantics of block captures: normally,; copying a block which captures an Objective-C object or block pointer; causes the captured pointer to be retained or copied, respectively,; but that behavior is suppressed when the captured variable is qualified; with ``__unsafe_unretained``. Note that the ``__weak`` qualifier formerly meant the GC qualifier in; all non-ARC modes and was silently ignored outside of GC modes. It now; means the ARC-style qualifier in all non-GC modes and is no longer; allowed if not enabled by either ``-fobjc-arc`` or ``-fobjc-weak``.; It is expected that ``-fobjc-weak`` will eventually be enabled by default; in all non-GC Objective-C modes. .. _objc-fixed-enum:. Enumerations with a fixed underlying type; -----------------------------------------. Clang provides support for C++11 enumerations with a fixed underlying type; within Objective-C. For example, one c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:73013,variab,variables,73013,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variables']
Modifiability,"he ``bits`` value and a; function to get that size. The ``get()`` function takes the length of the sequence, *n*, and returns the; ``BitsRecTy`` type corresponding to ``bits<``\ *n*\ ``>``. ``ListRecTy``; ~~~~~~~~~~~~~. This class includes a data member that specifies the type of the list's; elements and a function to get that type. The ``get()`` function takes the ``RecTy`` *type* of the list members and; returns the ``ListRecTy`` type corresponding to ``list<``\ *type*\ ``>``. ``RecordRecTy``; ~~~~~~~~~~~~~~~. This class includes data members that contain the list of parent classes of; this record. It also provides a function to obtain the array of classes and; two functions to get the iterator ``begin()`` and ``end()`` values. The; class defines a type for the return values of the latter two functions. .. code-block:: text. using const_record_iterator = Record * const *;. The ``get()`` function takes an ``ArrayRef`` of pointers to the ``Record``; instances of the *direct* superclasses of the record and returns the ``RecordRecTy``; corresponding to the record inheriting from those superclasses. ``Init``; --------. The ``Init`` class is used to represent TableGen values. The name derives; from *initialization value*. This class should not be confused with the; ``RecordVal`` class, which represents record fields, both their names and; values. The ``Init`` class is the base class for a series of subclasses, one; for each of the available value types. The primary data member of ``Init``; is an enumerated type that represents the specific type of the value. The ``Init`` class provides a few useful functions. * A function to get the type enumerator. * A boolean virtual function to determine whether a value is completely; specified; that is, has no uninitialized subvalues. * Virtual functions to get the value as a string. * Virtual functions to cast the value to other types, implement the bit; range feature of TableGen, and implement the list slice feature. * A virtual f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst:8711,inherit,inheriting,8711,interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackGuide.rst,1,['inherit'],['inheriting']
Modifiability,"he bits with the most significance have the lowest address; location.; ``e``; Specifies that the target lays out data in little-endian form. That; is, the bits with the least significance have the lowest address; location.; ``S<size>``; Specifies the natural alignment of the stack in bits. Alignment; promotion of stack variables is limited to the natural stack; alignment to avoid dynamic stack realignment. The stack alignment; must be a multiple of 8-bits. If omitted, the natural stack; alignment defaults to ""unspecified"", which does not prevent any; alignment promotions.; ``P<address space>``; Specifies the address space that corresponds to program memory.; Harvard architectures can use this to specify what space LLVM; should place things such as functions into. If omitted, the; program memory space defaults to the default address space of 0,; which corresponds to a Von Neumann architecture that has code; and data in the same space.; ``G<address space>``; Specifies the address space to be used by default when creating global; variables. If omitted, the globals address space defaults to the default; address space 0.; Note: variable declarations without an address space are always created in; address space 0, this property only affects the default value to be used; when creating globals without additional contextual information (e.g. in; LLVM passes). .. _alloca_addrspace:. ``A<address space>``; Specifies the address space of objects created by '``alloca``'.; Defaults to the default address space of 0.; ``p[n]:<size>:<abi>[:<pref>][:<idx>]``; This specifies the *size* of a pointer and its ``<abi>`` and; ``<pref>``\erred alignments for address space ``n``. ``<pref>`` is optional; and defaults to ``<abi>``. The fourth parameter ``<idx>`` is the size of the; index that used for address calculation, which must be less than or equal; to the pointer size. If not; specified, the default index size is equal to the pointer size. All sizes; are in bits. The address space, ``n`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:132579,variab,variables,132579,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"he code is being compiled for. The supported GPU; architectures can be found in the `AMDGPU Processor Table <https://llvm.org/docs/AMDGPUUsage.html#processors>`_.; Alternatively, you can use the ``amdgpu-arch`` tool that comes with Clang to list the GPU architecture on your system:. .. code-block:: shell. amdgpu-arch. You can use ``--offload-arch=native`` to automatically detect the GPU architectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4069,variab,variable,4069,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"he context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to keep the variables in; the respective scope (for example, within a loop). - `beginLoop()` helps build the start and the end of a For loop for your; class. Simply place this function in the scope and place the contents of the; `For` loop below this statement. The code squashing task will automatically; build a loop around the statements that follow it. There's no need to worry; about the index of these loops, because they get propagated. For example, if; you want to iterate over a vector of RooFit objects using a loop, you don't; have to think about indexing them properly because the `beginLoop()` function; takes care of that. Simply call this function, place your function call in a; scope and after the scope ends, the loop will also end. - `addToCodeBody()` helps add things to the body of the C++ function that; you're creating. It takes whatever string is computed in its arguments and; adds it to the overall function string (which will later be just-in-time; compiled). The `addToCodeBody",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:17515,variab,variables,17515,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,2,['variab'],['variables']
Modifiability,"he data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; ----------------------------. LLVM uses several intrinsic functions (name prefixed with ""``llvm.dbg``"") to; track source local variables through optimization and code generation. ``llvm.dbg.declare``; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.declare(metadata, metadata, metadata). This intrinsic provides information about a local element (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variable <LangRef.html#dilocalvariable>`_ containing a description of; the variable. The third argument is a `complex expression; <LangRef.html#diexpression>`_. An `llvm.dbg.declare` intrinsic describes the; *address* of a source variable. .. code-block:: text. %i.addr = alloca i32, align 4; call void @llvm.dbg.declare(metadata i32* %i.addr, metadata !1,; metadata !DIExpression()), !dbg !2; !1 = !DILocalVariable(name: ""i"", ...) ; int i; !2 = !DILocation(...); ...; %buffer = alloca [256 x i8], align 8; ; The address of i is buffer+64.; call void @llvm.dbg.declare(metadata [256 x i8]* %buffer, metadata !3,; metadata !DIExpression(DW_OP_plus, 64)), !dbg !4; !3 = !DILocalVariable(name: ""i"", ...) ; int i; !4 = !DILocation(...). A frontend should generate exactly one call to ``llvm.dbg.declare`` at the point; of declaration of a source variable. Optimization passes that fully promote the; variable from memory to SSA values will replace this call with possibly multiple; calls to `llvm.dbg.value`. Passes that delete stores are effectively partial; promotion, and they will insert a mix of calls to ``llvm.dbg.value`` to track; the source variable value when it is available. After optimization, ther",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:8974,variab,variable,8974,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"he delimeter to be wider than the longest `{` or `}`; brace sequence in the content, so that if your expected text contains `{{{`; (three braces) it may be delimited with `{{{{` (four braces), and so on. Regex matching mode may be selected by appending ``-re`` to the diagnostic type; and including regexes wrapped in double curly braces (`{{` and `}}`) in the; directive, such as:. .. code-block:: text. expected-error-re {{format specifies type 'wchar_t **' (aka '{{.+}}')}}. Examples matching error: ""variable has incomplete type 'struct s'"". .. code-block:: c++. // expected-error {{variable has incomplete type 'struct s'}}; // expected-error {{variable has incomplete type}}; // expected-error {{{variable has incomplete type}}}; // expected-error {{{{variable has incomplete type}}}}. // expected-error-re {{variable has type 'struct {{.}}'}}; // expected-error-re {{variable has type 'struct {{.*}}'}}; // expected-error-re {{variable has type 'struct {{(.*)}}'}}; // expected-error-re {{variable has type 'struct{{[[:space:]](.*)}}'}}. Feature Test Macros; ===================; Clang implements several ways to test whether a feature is supported or not.; Some of these feature tests are standardized, like ``__has_cpp_attribute`` or; ``__cpp_lambdas``, while others are Clang extensions, like ``__has_builtin``.; The common theme among all the various feature tests is that they are a utility; to tell users that we think a particular feature is complete. However,; completeness is a difficult property to define because features may still have; lingering bugs, may only work on some targets, etc. We use the following; criteria when deciding whether to expose a feature test macro (or particular; result value for the feature test):. * Are there known issues where we reject valid code that should be accepted?; * Are there known issues where we accept invalid code that should be rejected?; * Are there known crashes, failed assertions, or miscompilations?; * Are there known issues on a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:162591,variab,variable,162591,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variable']
Modifiability,"he destination size, '``llvm.vp.trunc``' cannot be a *no-op cast*. It will; always truncate bits. The conversion is performed on lane positions below the; explicit vector length and where the vector mask is true. Masked-off lanes are; ``poison``. Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <4 x i16> @llvm.vp.trunc.v4i16.v4i32(<4 x i32> %a, <4 x i1> %mask, i32 %evl); ;; For all lanes below %evl, %r is lane-wise equivalent to %also.r. %t = trunc <4 x i32> %a to <4 x i16>; %also.r = select <4 x i1> %mask, <4 x i16> %t, <4 x i16> poison. .. _int_vp_zext:. '``llvm.vp.zext.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare <16 x i32> @llvm.vp.zext.v16i32.v16i16 (<16 x i16> <op>, <16 x i1> <mask>, i32 <vector_length>); declare <vscale x 4 x i32> @llvm.vp.zext.nxv4i32.nxv4i16 (<vscale x 4 x i16> <op>, <vscale x 4 x i1> <mask>, i32 <vector_length>). Overview:; """""""""""""""""". The '``llvm.vp.zext``' intrinsic zero extends its first operand to the return; type. The operation has a mask and an explicit vector length parameter. Arguments:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic takes a value to cast as its first operand.; The return type is the type to cast the value to. Both types must be vectors of; :ref:`integer <t_integer>` type. The bit size of the value must be smaller than; the bit size of the return type. The second operand is the vector mask. The; return type, the value to cast, and the vector mask have the same number of; elements. The third operand is the explicit vector length of the operation. Semantics:; """""""""""""""""""". The '``llvm.vp.zext``' intrinsic fill the high order bits of the value with zero; bits until it reaches the size of the return type. When zero extending from i1,; the result will always be either 0 or 1. The conversion is performed on lane; positions below the explicit vector length and where the vector mask is true.; Masked-off lanes are ``poison``. Examples:; """""""""""""""""". .. cod",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:797990,extend,extends,797990,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['extend'],['extends']
Modifiability,"he files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7988,variab,variables,7988,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['variab'],['variables']
Modifiability,"he first check line matches a regex ``%[a-z]+`` and captures it into the; string variable ``REGISTER``. The second line verifies that whatever is in; ``REGISTER`` occurs later in the file after an ""``andw``"". :program:`FileCheck`; string substitution blocks are always contained in ``[[ ]]`` pairs, and string; variable names can be formed with the regex ``[a-zA-Z_][a-zA-Z0-9_]*``. If a; colon follows the name, then it is a definition of the variable; otherwise, it; is a substitution. :program:`FileCheck` variables can be defined multiple times, and substitutions; always get the latest value. Variables can also be substituted later on the; same line they were defined on. For example:. .. code-block:: llvm. ; CHECK: op [[REG:r[0-9]+]], [[REG]]. Can be useful if you want the operands of ``op`` to be the same register,; and don't care exactly which register it is. If ``--enable-var-scope`` is in effect, variables with names that; start with ``$`` are considered to be global. All others variables are; local. All local variables get undefined at the beginning of each; CHECK-LABEL block. Global variables are not affected by CHECK-LABEL.; This makes it easier to ensure that individual tests are not affected; by variables set in preceding tests. FileCheck Numeric Substitution Blocks; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. :program:`FileCheck` also supports numeric substitution blocks that allow; defining numeric variables and checking for numeric values that satisfy a; numeric expression constraint based on those variables via a numeric; substitution. This allows ``CHECK:`` directives to verify a numeric relation; between two numbers, such as the need for consecutive registers to be used. The syntax to capture a numeric value is; ``[[#%<fmtspec>,<NUMVAR>:]]`` where:. * ``%<fmtspec>,`` is an optional format specifier to indicate what number; format to match and the minimum number of digits to expect. * ``<NUMVAR>:`` is an optional definition of variable ``<NUMVAR>`` from the; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:27597,variab,variables,27597,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"he flag would be a breaking change and should be; avoided. However, an exception is the normalization of ``-march``.; ``-march`` for Arm architectures contains a list of enabled and disabled; extensions and this list is likely to grow. Therefore ``-march`` flags are; unstable. Incomplete interface; --------------------. The new multilib system does multilib selection based on only a limited set of; command line options, and limits which flags can be used for multilib; selection. This is in order to avoid committing to too large an interface.; Later LLVM versions can add support for multilib selection from more command; line options as needed. Extensible; ----------. It is likely that the configuration format will need to evolve in future to; adapt to new requirements.; Using a format like YAML that supports key-value pairs helps here as it's; trivial to add new keys alongside existing ones. Backwards compatibility; -----------------------. New versions of Clang should be able to use configuration written for earlier; Clang versions.; To avoid behaving in a way that may be subtly incorrect, Clang should be able; to detect if the configuration is too new and emit an error. Forwards compatibility; ----------------------. As an author of a multilib configuration, it should be possible to design the; configuration in such a way that it is likely to work well with future Clang; versions. For example, if a future version of Clang is likely to add support; for newer versions of an architecture and the architecture is known to be; designed for backwards compatibility then it should be possible to express; compatibility for such architecture versions in the multilib configuration. Not GNU spec files; ------------------. The GNU spec files standard is large and complex and there's little desire to; import that complexity to LLVM. It's also heavily oriented towards processing; command line argument strings which is hard to do correctly, hence the large; amount of logic dedicated",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst:10895,config,configuration,10895,interpreter/llvm-project/clang/docs/Multilib.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Multilib.rst,1,['config'],['configuration']
Modifiability,"he generated; // histograms we open a browser and the TreeViewer; if (gROOT->IsBatch()) return;; new TBrowser ();; t1->StartViewer();. //In the browser, click on ""ROOT Files"", then on ""tree1.root""; //You can click on the histogram icons in the right panel to draw; //them in the TreeViewer, follow the instructions in the Help.; }; ```. ## Example 2: A Tree with a C Structure. The executable script for this example is; `$ROOTSYS/tutorials/tree/tree2.C. `In this example we show:. - how to build branches from a C structure; - how to make a branch with a fixed length array; - how to make a branch with a variable length array; - how to read selective branches; - how to fill a histogram from a branch; - how to use `TTree::Draw` to show a 3D plot. A C structure (`struct`) is used to build a ROOT tree. In general we; discourage the use of C structures`,` we recommend using a class; instead. However, we do support them for legacy applications written in; C or FORTRAN. The example `struct` holds simple variables and arrays. It; maps to a Geant3 common block `/gctrak/. `This is the definition of the; common block/structure:. ``` {.cpp}; const Int_t MAXMEC = 30;; // PARAMETER (MAXMEC=30); // COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7); // + ,NMEC,LMEC(MAXMEC); // + ,NAMEC(MAXMEC),NSTEP; // + ,PID,DESTEP,DESTEL,SAFETY,SLENG; // + ,STEP,SNEXT,SFIELD,TOFG,GEKRAT,UPWGHT. typedef struct {; Float_t vect[7];; Float_t getot;; Float_t gekin;; Float_t vout[7];; Int_t nmec;; Int_t lmec[MAXMEC];; Int_t namec[MAXMEC];; Int_t nstep;; Int_t pid;; Float_t destep;; Float_t destel;; Float_t safety;; Float_t sleng;; Float_t step;; Float_t snext;; Float_t sfield;; Float_t tofg;; Float_t gekrat;; Float_t upwght;; } Gctrak_t;; ```. When using Geant3, the common block is filled by Geant3 routines at each; step and only the `TTree::Fill` method needs to be called. In this; example we emulate the Geant3 step routine with the `helixStep`; function. We also emulate the filling of the particle values. The ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:43471,variab,variables,43471,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second root file with a different tree; TFile fr(""tree3f.root"",""recreate"");; TTree *t3f = new TTree(""t3f"",""a friend Tree"");; t3f->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3f->Branch(""sumstat"",&sumstat,""sumstat/D"");; t3f->Branch(""pt"",pt,""pt[ntrack]/F"");. /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55952,variab,variables,55952,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he list of friends of `tree`. The number of entries; in the friend must be equal or greater to the number of entries of the; original tree. If the friend tree has fewer entries, a warning is given; and the missing entries are not included in the histogram. Use `TTree::GetListOfFriends` to retrieve the list of friends from a; tree. When the tree is written to file (`TTree::Write`), the friends list is; saved with it. Moreover, when the tree is retrieved, the trees on the; friends list are also retrieved and the friendship restored. When a tree; is deleted, the elements of the friend list are also deleted. It is; possible to declare a friend tree that has the same internal structure; (same branches and leaves) as the original tree, and compare the same; values by specifying the tree. ``` {.cpp}; tree.Draw(""var:ft1.var:ft2.var"");; ```. The example code is in `$ROOTSYS/tutorials/tree/tree3.C`. Here is the; script:. ``` {.cpp}; void tree3w() {; // Example of a Tree where branches are variable length arrays; // A second Tree is created and filled in parallel.; // Run this script with .x tree3.C; // In the function treer, the first Tree is open.; // The second Tree is declared friend of the first tree.; // TTree::Draw is called with variables from both Trees.; const Int_t kMaxTrack = 500;; Int_t ntrack;; Int_t stat[kMaxTrack];; Int_t sign[kMaxTrack];; Float_t px[kMaxTrack];; Float_t py[kMaxTrack];; Float_t pz[kMaxTrack];; Float_t pt[kMaxTrack];; Float_t zv[kMaxTrack];; Float_t chi2[kMaxTrack];; Double_t sumstat;. // create the first root file with a tree; TFile f(""tree3.root"",""recreate"");; TTree *t3 = new TTree(""t3"",""Reconst ntuple"");; t3->Branch(""ntrack"",&ntrack,""ntrack/I"");; t3->Branch(""stat"",stat,""stat[ntrack]/I"");; t3->Branch(""sign"",sign,""sign[ntrack]/I"");; t3->Branch(""px"",px,""px[ntrack]/F"");; t3->Branch(""py"",py,""py[ntrack]/F"");; t3->Branch(""pz"",pz,""pz[ntrack]/F"");; t3->Branch(""zv"",zv,""zv[ntrack]/F"");; t3->Branch(""chi2"",chi2,""chi2[ntrack]/F"");. // create the second roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:55700,variab,variable,55700,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"he method; `TBranch::Fill()`. In this case you do not need to call `TTree::Fill()`; method. The entries can be set by `TTree::SetEntries(Double_t n)`.; Calling this method makes sense only if the number of existing entries; is null. ### Viewing the Tree. ![The tree1.root file and its tree in the browser and a leaf histogram](pictures/030000FC.png). In the right panel of the ROOT object browse are the branches: `ev`,; `px`, `py`, `pz`, and `random`. Note that these are shown as leaves; because they are ""end"" branches with only one leaf. To histogram a leaf,; we can simply double click on it in the browser. This is how the tree; `t1` looks in the Tree Viewer. Here we can add a cut and add other; operations for histogramming the leaves. See ""The Tree Viewer"". For; example, we can plot a two dimensional histogram. ![The tree viewer](pictures/030000FE.png). ### Reading the Tree. The `tree1r` function shows how to read the tree and access each entry; and each leaf. We first define the variables to hold the read values. ``` {.cpp}; Float_t px, py, pz;; ```. Then we tell the tree to populate these variables when reading an entry.; We do this with the method `TTree::SetBranchAddress`. The first; parameter is the branch name, and the second is the address of the; variable where the branch data is to be placed. In this example, the; branch name is `px`. This name was given when the tree was written (see; `tree1w`). The second parameter is the address of the variable `px`. ``` {.cpp}; t1->SetBranchAddress(""px"",&px);; ```. #### GetEntry. Once the branches have been given the address, a specific entry can be; read into the variables with the method `TTree::GetEntry(n)`. It; reads all the branches for entry (n) and populates the given address; accordingly. By default, `GetEntry()` reuses the space allocated by the; previous object for each branch. You can force the previous object to be; automatically deleted if you call `mybranch.SetAutoDelete(kTRUE)`; (default is `kFALSE`). Consi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:38065,variab,variables,38065,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"he module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: An encoding of the linkage type for this variable:. * ``external``: code 0; * ``weak``: code 1; * ``appending``: code 2; * ``internal``: code 3; * ``linkonce``: code 4; * ``dllimport``: code 5; * ``dllexport``: code 6; * ``extern_weak``: code 7; * ``common``: code 8; * ``private``: code 9; * ``weak_odr``: code 10; * ``linkonce_odr``: code 11; * ``available_externally``: code 12; * deprecated : code 13; * deprecated : code 14. * alignment*: The logarithm base 2 of the variable's requested alignment, plus 1. * *section*: If non-zero, the 1-based section index in the table of; `MODULE_CODE_SECTIONNAME`_ entries. .. _visibility:. * *visibility*: If present, an encoding of the visibility of this variable:. * ``default``: code 0; * ``hidden``: code 1; * ``protected``: code 2. .. _bcthreadlocal:. * *threadlocal*: If present, an encoding of the thread local storage mode of the; variable:. * ``not thread local``: code 0; * ``thread local; default TLS model``: code 1; * ``localdynamic``: code 2; * ``initialexec``: code 3; * ``localexec``: code 4. .. _bcunnamedaddr:. * *unnamed_addr*: If present, an encoding of the ``unnamed_addr`` attribute of this; variable:. * not ``unnamed_addr``: code 0; * ``unnamed_addr``: code 1; * ``local_unnamed_addr``: code 2. .. _bcdllstorageclass:. * *dllstorageclass*: If present, an encoding of the DLL storage class of this variable:. * ``default``: code 0; * ``dllimport``: code 1; * ``dllexport``: code 2. * *comdat*: An encoding of the COMDAT of this function. * *attributes*: If nonzero, the 1-based index into the table of AttributeLists. .. _bcpreemptionspecifier:. * *preemptionspecifier*: If present, an encoding of the runtime preemption specifier of this variable:. * ``dso_preemptable``: code 0; * ``dso_local``: code 1. .. _FUNCTION:. MODULE_CODE_FUNCTION Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:28640,variab,variable,28640,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"he object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is Defined. pi = new int; // pi is Conflicting; Borrow(pi);; delete pi;; // pi is Conflicting; }; ```. We could still handle this case by finding a maximal range in the code where; `pi` could be in the Compatible state, and only refactoring that part. ```c++; void ConflictingOwnership() {; int *pi;; pi = GetPtr();; Borrow(pi);. std::unique_ptr<int> pi_unique = std::make_unique<int>();; Borrow(pi_unique.get());; }; ```. ## Example: finding redundant branch conditions. In the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:24839,refactor,refactor,24839,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['refactor'],['refactor']
Modifiability,"he ownership has been transferred. ```c++; void UniqueOwnership3() {; int *pi = new int; // pi is Defined; if (...) {; Borrow(pi);; delete pi; // pi is Compatible; } else {; vector<unique_ptr<int>> v = {std::unique_ptr(pi)}; // pi is Compatible; print(*pi);; use(v);; }; // pi is Compatible; }; ```. We can refactor this code to use `unique_ptr`, however we would have to; introduce a non-owning pointer variable, since we can't use the moved-from; `unique_ptr` to access the object:. ```c++; void UniqueOwnership3() {; std::unique_ptr<int> pi = std::make_unique<int>();; if (...) {; Borrow(pi);; } else {; int *pi_non_owning = pi.get();; vector<unique_ptr<int>> v = {std::move(pi)};; print(*pi_non_owning);; use(v);; }; }; ```. If the original code didn't call `delete` at the very end of the function, then; our refactoring may change the point at which we run the destructor and release; memory. Specifically, if there is some user code after `delete`, then extending; the lifetime of the object until the end of the function may hold locks for; longer than necessary, introduce memory overhead etc. One solution is to always replace `delete` with a call to `reset()`, and then; perform another analysis that removes unnecessary `reset()` calls. ```c++; void AddedMemoryOverhead() {; HugeObject *ho = new HugeObject();; use(ho);; delete ho; // Release the large amount of memory quickly.; LongRunningFunction();; }; ```. This analysis will refuse to refactor code that mixes borrowed pointer values; and unique ownership. In the following code, `GetPtr()` returns a borrowed; pointer, which is assigned to `pi`. Then, `pi` is used to hold a uniquely-owned; pointer. We don't distinguish between these two assignments, and we want each; assignment to be paired with a corresponding sink; otherwise, we transition the; pointer to a `Conflicting` state, like in this example. ```c++; void ConflictingOwnership() {; int *pi; // pi is Compatible; pi = GetPtr(); // pi is Defined; Borrow(pi); // pi is D",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md:24347,extend,extending,24347,interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowAnalysisIntro.md,1,['extend'],['extending']
Modifiability,"he point number `ipoint`.; - When a 2D histogram was drawn with error bars and has a function in its list; it was impossible to rotate it interactively. This problem was reported; [here](https://root-forum.cern.ch/t/2d-histogram-fit-draws-to-wrong-scale/26369).; - As more and more people are using `TGraph2D` for random cloud of points, the default; drawing option implying Delaunay triangulation was not appropriate. The default; drawing option is now change to `P0`.; - It is now possible to set the value of `MaxDigits` on individual axis as; requested [here](https://sft.its.cern.ch/jira/browse/ROOT-35).; For example, to accept 6 digits number like 900000 on the X axis of the; histogram `h` call:; ```{.cpp}; h->GetXaxis()->SetMaxDigits(6);; ```; - Auto-coloring for TF1 (drawing options PFC, PLC and PMC) is implemented. ## 3D Graphics Libraries; - When a LEGO plot was drawn with Theta=90, the X and Y axis were misplaced. ## Geometry Libraries; - Added system of units and physical constants matching the CLHEP port to Geant4, adapted to ROOT by Marko Petric.; - Computing radiation length and nuclear interaction length for mixtures as in Geant4 to have; numeric matching of average properties.; - Added support for reading region definition and production cuts for e+, e-, gamma, p; from GDML files; - Added support for reading/writing parts of the geometry tree to GDML (Markus Frank). ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## Parallelism; - Fix issue which prevented nested TBB task execution without race conditions, e.g. in TDataFrame; - Fix race condition in TTreeProcessorMT due to TBB nested task execution; - The TTaskGroup class has been added to the ROOT::Experimental namespace. It allows to submit to the runtime; item of work which are dealt with in parallel;; - The Async template function has been added the ROOT::Experimental namespace. The template function is analogous; to *std::async* but without the possibility of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:22954,adapt,adapted,22954,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['adapt'],['adapted']
Modifiability,"he problem:. #. ``opt ""-passes=lto<O3>"" a.out.0.2.internalize.bc``; #. ``llc a.out.0.5.precodegen.bc``. If one of these do crash, you should be able to reduce; this with :program:`llvm-reduce`; command line (use the bc file corresponding to the command above that failed):. .. code-block:: bash. llvm-reduce --test reduce.sh a.out.0.2.internalize.bc. Example of reduce.sh script. .. code-block:: bash. $ cat reduce.sh; #!/bin/bash -e. path/to/not --crash path/to/opt ""-passes=lto<O3>"" $1 -o temp.bc 2> err.log; grep -q ""It->second == &Insn"" err.log. Here we have grepped the failed assert message. Please run this, then file a bug with the instructions and reduced .bc file; that llvm-reduce emits. .. _miscompiling:. Miscompilations; ===============. If clang successfully produces an executable, but that executable doesn't run; right, this is either a bug in the code or a bug in the compiler. The first; thing to check is to make sure it is not using undefined behavior (e.g.; reading a variable before it is defined). In particular, check to see if the; program is clean under various `sanitizers; <https://github.com/google/sanitizers>`_ (e.g. ``clang; -fsanitize=undefined,address``) and `valgrind <http://valgrind.org/>`_. Many; ""LLVM bugs"" that we have chased down ended up being bugs in the program being; compiled, not LLVM. Once you determine that the program itself is not buggy, you should choose; which code generator you wish to compile the program with (e.g. LLC or the JIT); and optionally a series of LLVM passes to run. For example:. .. code-block:: bash. bugpoint -run-llc [... optzn passes ...] file-to-test.bc --args -- [program arguments]. bugpoint will try to narrow down your list of passes to the one pass that; causes an error, and simplify the bitcode file as much as it can to assist; you. It will print a message letting you know how to reproduce the; resulting error. The :doc:`OptBisect <OptBisect>` page shows an alternative method for finding; incorrect optimization",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst:8216,variab,variable,8216,interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToSubmitABug.rst,1,['variab'],['variable']
Modifiability,"he proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be imported directly from the; ROOT.py module, but some common ones (most notably **`gMinuit`**,; although that variable now exists at startup from release 5.08 onward); do not exist yet at program startup, as they exist in modules that are; loaded later (e.g. through the auto-loading mechanism). An example; session should make this clear:. ``` {.cpp}; >>> from ROOT import *; >>> gROOT # directly available; <ROOT.TROOT object at 0x399c30>; >>> gMinuit # library not yet loaded: not available; Traceback (most recent call last):; File ""<stdin>"", line 1, in ?; NameError: name 'gMinuit' is not defined; >>> TMinuit # use of TMinuit class forces auto-loading; <class '__main__.TMinuit'>; >>> gMinuit # now gMinuit is available; <__main__.TMinuit object at 0x1458c70>; >>> not not gMinuit # but it is the null pointer, until set; False; >>> g = TMinuit(); >>> not not gMinuit; True; ```. It is also possible to create globals interactively, either by executing; a Cling macro, or by a call to `gROOT.ProcessLine()`. These globals are; made available in the same way: either use them directly after",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:12958,variab,variable,12958,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variable']
Modifiability,"he rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7970,rewrite,rewrite,7970,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"he right default attribute. Promotion expression; ====================. A new expression will be introduced to represent the conversion from a pointer; with an external bounds annotation, such as ``__counted_by``, to; ``__bidi_indexable``. This type of conversion cannot be handled by normal; CastExprs because it requires an extra subexpression(s) to provide the bounds; information necessary to create a wide pointer. Bounds check expression; =======================. Bounds checks are part of semantics defined in the ``-fbounds-safety`` language; model. Hence, exposing the bounds checks and other semantic actions in the AST; is desirable. A new expression for bounds checks has been added to the AST. The; bounds check expression has a ``BoundsCheckKind`` to indicate the kind of checks; and has the additional sub-expressions that are necessary to perform the check; according to the kind. Paired assignment check; =======================. ``-fbounds-safety`` enforces that variables or fields related with the same; external bounds annotation (e.g., ``buf`` and ``count`` related with; ``__counted_by`` in the example below) must be updated side by side within the; same basic block and without side effect in between. .. code-block:: c. typedef struct {; int *__counted_by(count) buf; size_t count;; } sized_buf_t;. void alloc_buf(sized_buf_t *sbuf, sized_t nelems) {; sbuf->buf = (int *)malloc(sizeof(int) * nelems);; sbuf->count = nelems;; }. To implement this rule, the compiler requires a linear representation of; statements to understand the ordering and the adjacency between the two or more; assignments. The Clang CFG is used to implement this analysis as Clang CFG; provides a linear view of statements within each ``CFGBlock`` (Clang; ``CFGBlock`` represents a single basic block in a source-level CFG). Bounds check optimizations; ==========================. In ``-fbounds-safety``, the Clang frontend emits run-time checks for every; memory dereference if the type system or ana",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:5114,variab,variables,5114,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['variab'],['variables']
Modifiability,"he root of the output file is a JSON object (i.e. dictionary),; containing the following fixed keys:. * ``!tablegen_json_version``: a numeric version field that will; increase if an incompatible change is ever made to the structure of; this data. The format described here corresponds to version 1. * ``!instanceof``: a dictionary whose keys are the class names defined; in the TableGen input. For each key, the corresponding value is an; array of strings giving the names of ``def`` records that derive; from that class. So ``root[""!instanceof""][""Instruction""]``, for; example, would list the names of all the records deriving from the; class ``Instruction``. For each ``def`` record, the root object also has a key for the record; name. The corresponding value is a subsidiary object containing the; following fixed keys:. * ``!superclasses``: an array of strings giving the names of all the; classes that this record derives from. * ``!fields``: an array of strings giving the names of all the variables; in this record that were defined with the ``field`` keyword. * ``!name``: a string giving the name of the record. This is always; identical to the key in the JSON root object corresponding to this; record's dictionary. (If the record is anonymous, the name is; arbitrary.). * ``!anonymous``: a boolean indicating whether the record's name was; specified by the TableGen input (if it is ``false``), or invented by; TableGen itself (if ``true``). For each variable defined in a record, the ``def`` object for that; record also has a key for the variable name. The corresponding value; is a translation into JSON of the variable's value, using the; conventions described below. Some TableGen data types are translated directly into the; corresponding JSON type:. * A completely undefined value (e.g. for a variable declared without; initializer in some superclass of this record, and never initialized; by the record itself or any other superclass) is emitted as the JSON; ``null`` value. * ``int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst:16167,variab,variables,16167,interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/BackEnds.rst,1,['variab'],['variables']
Modifiability,"he same array,; etc.). Query for this feature with ``__has_builtin(__builtin_assume_separate_storage)``. ``__builtin_offsetof``; ----------------------. ``__builtin_offsetof`` is used to implement the ``offsetof`` macro, which; calculates the offset (in bytes) to a given member of the given type. **Syntax**:. .. code-block:: c++. __builtin_offsetof(type-name, member-designator). **Example of Use**:. .. code-block:: c++. struct S {; char c;; int i;; struct T {; float f[2];; } t;; };. const int offset_to_i = __builtin_offsetof(struct S, i);; const int ext1 = __builtin_offsetof(struct U { int i; }, i); // C extension; const int offset_to_subobject = __builtin_offsetof(struct S, t.f[1]);. **Description**:. This builtin is usable in an integer constant expression which returns a value; of type ``size_t``. The value returned is the offset in bytes to the subobject; designated by the member-designator from the beginning of an object of type; ``type-name``. Clang extends the required standard functionality in the; following way:. * In C language modes, the first argument may be the definition of a new type.; Any type declared this way is scoped to the nearest scope containing the call; to the builtin. Query for this feature with ``__has_builtin(__builtin_offsetof)``. ``__builtin_call_with_static_chain``; ------------------------------------. ``__builtin_call_with_static_chain`` is used to perform a static call while; setting updating the static chain register. **Syntax**:. .. code-block:: c++. T __builtin_call_with_static_chain(T expr, void* ptr). **Example of Use**:. .. code-block:: c++. auto v = __builtin_call_with_static_chain(foo(3), foo);. **Description**:. This builtin returns ``expr`` after checking that ``expr`` is a non-member; static call expression. The call to that expression is made while using ``ptr``; as a function pointer stored in a dedicated register to implement *static chain*; calling convention, as used by some language to implement closures or nested; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:101661,extend,extends,101661,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['extend'],['extends']
Modifiability,"he test suite, you need to use the following steps:. #. Check out the ``test-suite`` module with:. .. code-block:: bash. % git clone https://github.com/llvm/llvm-test-suite.git test-suite. #. FIXME: these directions are outdated and won't work. Figure out; what the correct thing to do is, and write it down here. #. Configure and build ``llvm``. #. Configure and build ``llvm-gcc``. #. Install ``llvm-gcc`` somewhere. #. *Re-configure* ``llvm`` from the top level of each build tree (LLVM; object directory tree) in which you want to run the test suite, just; as you do before building LLVM. During the *re-configuration*, you must either: (1) have ``llvm-gcc``; you just built in your path, or (2) specify the directory where your; just-built ``llvm-gcc`` is installed using; ``--with-llvmgccdir=$LLVM_GCC_DIR``. You must also tell the configure machinery that the test suite is; available so it can be configured for your build tree:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT ; $LLVM_SRC_ROOT/configure [--with-llvmgccdir=$LLVM_GCC_DIR]. [Remember that ``$LLVM_GCC_DIR`` is the directory where you; *installed* llvm-gcc, not its src or obj directory.]. #. You can now run the test suite from your build tree as follows:. .. code-block:: bash. % cd $LLVM_OBJ_ROOT/projects/test-suite; % make. Note that the second and third steps only need to be done once. After; you have the suite checked out and configured, you don't need to do it; again (unless the test code or configure script changes). Configuring External Tests; ==========================. In order to run the External tests in the ``test-suite`` module, you; must specify *--with-externals*. This must be done during the; *re-configuration* step (see above), and the ``llvm`` re-configuration; must recognize the previously-built ``llvm-gcc``. If any of these is; missing or neglected, the External tests won't work. * *--with-externals*. * *--with-externals=<directory>*. This tells LLVM where to find any external tests. They are expe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst:1369,config,configure,1369,interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteMakefileGuide.rst,1,['config'],['configure']
Modifiability,"he toolchain from step 1. to build libc++, libc++abi, and libunwind. It is also possible to cross-compile from Linux. One method of building the libraries in step 2. is to build them ""stand-alone"".; A stand-alone build doesn't involve the rest of the LLVM tree. The steps are:. * ``cd build-dir``; * ``cmake -DLLVM_PATH=<path to llvm checkout e.g. /llvm-project/> -DCMAKE_INSTALL_PREFIX=<install path> <other options> <path to project e.g. /llvm-project/libcxxabi>``; * ``<make program e.g. ninja>``; * ``<make program> install``. More information on standalone builds can be found in the build documentation for; the respective libraries. The next section discuss the salient options and modifications; required for building and installing the libraries using standalone builds. This assumes; that we are building libunwind and ibc++ as DLLs and statically linking libc++abi into; libc++. Other build configurations are possible, but they are not discussed here. Common CMake configuration options:; -----------------------------------. * ``-D_LIBCPP_ABI_FORCE_ITANIUM'``. Tell the libc++ headers that the Itanium C++ ABI is being used. * ``-DCMAKE_C_FLAGS=""-lmsvcrt -llegacy_stdio_definitions -D_NO_CRT_STDIO_INLINE""``. Supply CRT definitions including stdio definitions that have been removed from the MS VS CRT.; We don't want the stdio functions declared inline as they will cause multiple definition; errors when the same symbols are pulled in from legacy_stdio_definitions.ib. * ``-DCMAKE_INSTALL_PREFIX=<install path>``. Where to install the library and headers. Building libunwind:; -------------------. * ``-DLIBUNWIND_ENABLE_SHARED=ON``; * ``-DLIBUNWIND_ENABLE_STATIC=OFF``. libunwind can be built as a DLL. It is not dependent on other projects. * ``-DLIBUNWIND_USE_COMPILER_RT=OFF``. We use the MS runtime. The CMake files will need to be edited to prevent them adding GNU specific libraries to the link line. Building libc++abi:; -------------------. * ``-DLIBCXXABI_ENABLE_SHARED=OFF``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst:4086,config,configuration,4086,interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToBuildWindowsItaniumPrograms.rst,1,['config'],['configuration']
Modifiability,"he value; of ``idx`` exceeds the runtime length of the vector, the result is a; :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = extractelement <4 x i32> %vec, i32 0 ; yields i32. .. _i_insertelement:. '``insertelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = insertelement <n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <n x <ty>>; <result> = insertelement <vscale x n x <ty>> <val>, <ty> <elt>, <ty2> <idx> ; yields <vscale x n x <ty>>. Overview:; """""""""""""""""". The '``insertelement``' instruction inserts a scalar element into a; vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``insertelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is a scalar value whose; type must equal the element type of the first operand. The third operand; is an index indicating the position at which to insert the value. The; index may be a variable of any integer type, and will be treated as an; unsigned integer. Semantics:; """""""""""""""""""". The result is a vector of the same type as ``val``. Its element values; are those of ``val`` except at position ``idx``, where it gets the value; ``elt``. If ``idx`` exceeds the length of ``val`` for a fixed-length vector,; the result is a :ref:`poison value <poisonvalues>`. For a scalable vector,; if the value of ``idx`` exceeds the runtime length of the vector, the result; is a :ref:`poison value <poisonvalues>`. Example:; """""""""""""""". .. code-block:: text. <result> = insertelement <4 x i32> %vec, i32 1, i32 0 ; yields <4 x i32>. .. _i_shufflevector:. '``shufflevector``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = shufflevector <n x <ty>> <v1>, <n x <ty>> <v2>, <m x i32> <mask> ; yields <m x <ty>>; <result> = shufflevector <vscale x n x <ty>> <v1>, <vscale x n x <ty>> v2, <vscale x m x i32> <mask> ; yields <vscale x m x <ty>>. Overview:; """""""""""""""""". The '``shufflevector``' instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:402842,variab,variable,402842,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"he variable `y` is between `fYmin` and `fYmax`. If a; minimum or maximum value is set for the Y scale before filling, then; all values below `ylow` or above `yup` will be discarded. Setting the; minimum or maximum value for the Y scale before filling has the same; effect as calling the special **`TProfile`** constructor above where; `ylow` and `yup` are specified. ### Build Options. The last parameter is the build option. If a bin has N data points all; with the same value Y, which is the case when dealing with integers,; the spread in Y for that bin is zero, and the uncertainty assigned is; also zero, and the bin is ignored in making subsequent fits. If; `SQRT(Y)` was the correct error in the case above, then; `SQRT(Y)/SQRT(N)` would be the correct error here. In fact, any bin; with non-zero number of entries N but with zero spread; (`spread = s[j]`) should have an uncertainty `SQRT(Y)/SQRT(N)`. Now,; is `SQRT(Y)/SQRT(N)` really the correct uncertainty ? That it is only; in the case where the Y variable is some sort of counting statistics,; following a Poisson distribution. This is the default case. However, Y; can be any variable from an original `NTUPLE`, and does not; necessarily follow a Poisson distribution. The computation of errors; is based on Y = values of data points; N = number of data points. - `' '` - the default is blank, the errors are:. - `spread/SQRT(N)` for a non-zero spread. - `SQRT(Y)/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. - ‘ `s` ' - errors are:. - `spread` for a non-zero spread. - `SQRT(Y)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `i` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `1/SQRT(12*N)` for a Spread of zero and some data points. - `0` for no data points. - ‘ `G` ' - errors are:. - `spread/SQRT(N)` for a non-zero spread. - `sigma/SQRT(N)` for a spread of zero and some data points. - `0` for no data points. The option ' `i` ' is used for integer Y value",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:64174,variab,variable,64174,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"he variables are parsed, we then parse the body and create the; AST node:. .. code-block:: c++. // At this point, we have to have 'in'.; if (CurTok != tok_in); return LogError(""expected 'in' keyword after 'var'"");; getNextToken(); // eat 'in'. auto Body = ParseExpression();; if (!Body); return nullptr;. return std::make_unique<VarExprAST>(std::move(VarNames),; std::move(Body));; }. Now that we can parse and represent the code, we need to support; emission of LLVM IR for it. This code starts out with:. .. code-block:: c++. Value *VarExprAST::codegen() {; std::vector<AllocaInst *> OldBindings;. Function *TheFunction = Builder->GetInsertBlock()->getParent();. // Register all variables and emit their initializer.; for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {; const std::string &VarName = VarNames[i].first;; ExprAST *Init = VarNames[i].second.get();. Basically it loops over all the variables, installing them one at a; time. For each variable we put into the symbol table, we remember the; previous value that we replace in OldBindings. .. code-block:: c++. // Emit the initializer before adding the variable to scope, this prevents; // the initializer from referencing the variable itself, and permits stuff; // like this:; // var a = 1 in; // var a = a in ... # refers to outer 'a'.; Value *InitVal;; if (Init) {; InitVal = Init->codegen();; if (!InitVal); return nullptr;; } else { // If not specified, use 0.0.; InitVal = ConstantFP::get(*TheContext, APFloat(0.0));; }. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);; Builder->CreateStore(InitVal, Alloca);. // Remember the old variable binding so that we can restore the binding when; // we unrecurse.; OldBindings.push_back(NamedValues[VarName]);. // Remember this binding.; NamedValues[VarName] = Alloca;; }. There are more comments here than code. The basic idea is that we emit; the initializer, create the alloca, then update the symbol table to; point to it. Once all the variables are installed in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:27018,variab,variable,27018,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"he; `CoreCLR <https://github.com/dotnet/coreclr>`__ runtime. Support for this GC strategy is a work in progress. This strategy will; differ from; :ref:`statepoint-example GC<statepoint_example_gc>` strategy in; certain aspects like:. * Base-pointers of interior pointers are not explicitly; tracked and reported. * A different format is used for encoding stack maps. * Safe-point polls are only needed before loop-back edges; and before tail-calls (not needed at function-entry). Custom GC Strategies; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifyin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:21934,plugin,plugins,21934,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugins']
Modifiability,"he; individual instructions. TableGen allows an arbitrary hierarchy of classes,; so that the abstract classes for two concepts can share a third superclass that; abstracts common ""sub-concepts"" from the two original concepts. In order to make classes more useful, a concrete record (or another class); can request a class as a parent class and pass *template arguments* to it.; These template arguments can be used in the fields of the parent class to; initialize them in a custom manner. That is, record or class ``A`` can; request parent class ``S`` with one set of template arguments, while record or class; ``B`` can request ``S`` with a different set of arguments. Without template; arguments, many more classes would be required, one for each combination of; the template arguments. Both classes and concrete records can include fields that are uninitialized.; The uninitialized ""value"" is represented by a question mark (``?``). Classes; often have uninitialized fields that are expected to be filled in when those; classes are inherited by concrete records. Even so, some fields of concrete; records may remain uninitialized. TableGen provides *multiclasses* to collect a group of record definitions in; one place. A multiclass is a sort of macro that can be ""invoked"" to define; multiple concrete records all at once. A multiclass can inherit from other; multiclasses, which means that the multiclass inherits all the definitions; from its parent multiclasses. `Appendix C: Sample Record`_ illustrates a complex record in the Intel X86; target and the simple way in which it is defined. Source Files; ============. TableGen source files are plain ASCII text files. The files can contain; statements, comments, and blank lines (see `Lexical Analysis`_). The standard file; extension for TableGen files is ``.td``. TableGen files can grow quite large, so there is an include mechanism that; allows one file to include the content of another file (see `Include; Files`_). This allows large file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:5132,inherit,inherited,5132,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"heJIT = std::make_unique<KaleidoscopeJIT>();. // Run the main ""interpreter loop"" now.; MainLoop();. return 0;; }. We also need to setup the data layout for the JIT:. .. code-block:: c++. void InitializeModuleAndPassManager(void) {; // Open a new context and module.; TheContext = std::make_unique<LLVMContext>();; TheModule = std::make_unique<Module>(""my cool jit"", TheContext);; TheModule->setDataLayout(TheJIT->getDataLayout());. // Create a new builder for the module.; Builder = std::make_unique<IRBuilder<>>(*TheContext);. // Create a new pass manager attached to it.; TheFPM = std::make_unique<legacy::FunctionPassManager>(TheModule.get());; ... The KaleidoscopeJIT class is a simple JIT built specifically for these; tutorials, available inside the LLVM source code; at `llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h; <https://github.com/llvm/llvm-project/blob/main/llvm/examples/Kaleidoscope/include/KaleidoscopeJIT.h>`_.; In later chapters we will look at how it works and extend it with; new features, but for now we will take it as given. Its API is very simple:; ``addModule`` adds an LLVM IR module to the JIT, making its functions; available for execution (with its memory managed by a ``ResourceTracker``); and; ``lookup`` allows us to look up pointers to the compiled code. We can take this simple API and change our code that parses top-level expressions to; look like this:. .. code-block:: c++. static ExitOnError ExitOnErr;; ...; static void HandleTopLevelExpression() {; // Evaluate a top-level expression into an anonymous function.; if (auto FnAST = ParseTopLevelExpr()) {; if (FnAST->codegen()) {; // Create a ResourceTracker to track JIT'd memory allocated to our; // anonymous expression -- that way we can free it after executing.; auto RT = TheJIT->getMainJITDylib().createResourceTracker();. auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));; ExitOnErr(TheJIT->addModule(std::move(TSM), RT));; InitializeModuleAndPassManager();. // Sear",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:12151,extend,extend,12151,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['extend'],['extend']
Modifiability,help/latest/variable/CMAKE_LANG_FLAGS.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html). - `CMAKE_C_COMPILER`. Select the C compiler executable to be used. Note that the C++ compiler is; inferred automatically i.e. when specifying `path/to/clang` CMake will; automatically use `path/to/clang++` as the C++ compiler. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html](https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html). - `CMAKE_Fortran_COMPILER`. Select the Fortran compiler executable to be used. Not set by default and not; required unless running the Fortran Test Suite. - `CMAKE_BUILD_TYPE`. Select a build type like `OPTIMIZE` or `DEBUG` selecting a set of predefined; compiler flags. These flags are applied regardless of the `CMAKE_C_FLAGS`; option and may be changed by modifying `CMAKE_C_FLAGS_OPTIMIZE` etc. See; [https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html). - `TEST_SUITE_FORTRAN`. Activate that Fortran tests. This is a work in progress. More information can be; found in the [Flang documentation](https://flang.llvm.org/docs/FortranLLVMTestSuite.html). - `TEST_SUITE_RUN_UNDER`. Prefix test invocations with the given tool. This is typically used to run; cross-compiled tests within a simulator tool. - `TEST_SUITE_BENCHMARKING_ONLY`. Disable tests that are unsuitable for performance measurements. The disabled; tests either run for a very short time or are dominated by I/O performance; making them unsuitable as compiler performance tests. - `TEST_SUITE_SUBDIRS`. Semicolon-separated list of directories to include. This can be used to only; build parts of the test-suite or to include external suites. This option; does not work reliably with deeper subdirectories as it skips intermediate; `CMakeLists.txt` files which may be required. - `TEST_SUITE_COLLECT_STATS`. Collect internal LLVM statistics. Appends `-save-stats,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:5193,variab,variable,5193,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['variab'],['variable']
Modifiability,"hen be passed to a TableGen backend. TableGen allows you to define Classes and Defs (which are instances of classes) but it doesn't encode what to do with that structure. That's what the backend does. The backend converts this structure into something useful, for example C++ code. These backends are included in the `llvm-tblgen` binary and you can choose which one to run using a command line option. If you don't choose a backend you get a dump of the structure, and that is what this notebook will be showing. This tutorial will focus on the language itself only. The only thing you need to know now is that in addition to `llvm-tblgen` you will see other `*-tblgen` like `clang-tblgen`. The difference between them is the backends they include. The default output from `llvm-tblgen` looks like this:. ```tablegen; %config cellreset on. // Empty source file; ```. ------------- Classes -----------------; ------------- Defs -----------------. **Note:** `%config` is not a TableGen command but a ""magic"" command to the Jupyter kernel for this notebook. By default new cells include the content of previously run cells, but for this notebook we mostly want each to be isolated. On occasion we will use the `%noreset` magic to override this. No source means no classes and no defs. Let's add a class. ## Classes. ```tablegen; class C {}; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------. Followed by a def (definition). ```tablegen; %noreset. def X: C;; ```. ------------- Classes -----------------; class C {; }; ------------- Defs -----------------; def X {	// C; }. `def` creates an instance of a class. Typically, the main loop of a TableGen backend will look for all defs that are instances of a certain class. For example if I am generating register information I would look for all defs that are instances of `RegisterInfo` in the example below. ```tablegen; class RegisterInfo {}; def X0: RegisterInfo {}; def X1: RegisterInfo {}; ```. --------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md:1697,config,config,1697,interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/tablegen_tutorial_part_1.md,1,['config'],['config']
Modifiability,"hen emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7915,variab,variable,7915,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variable']
Modifiability,"hen exiting the function. ``` {.cpp}; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; ```. ### Retrieving Objects from Disk. If you have a ROOT session running, please quit and start fresh. We saw that multiple versions of an object with the same name could be; in a ROOT file. In our example, we saved a modified histogram `hpx` to; the file, which resulted in two `hpx's` uniquely identified by the cycle; number: `hpx;1` and `hpx;2`. The question is how we can retrieve the; right version of `hpx`. When opening the file and using `hpx`, Cling; retrieves the one with the highest cycle number. To read the `hpx;1`; into memory, rather than the `hpx:2` we would get by default, we have to; explicitly get it and assign it to a variable. ``` {.cpp}; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); ```. ### Subdirectories and Navigation. The **`TDirectory`** class lets you organize its contents into; subdirectories, and **`TFile`** being a descendent of **`TDirectory`**; inherits this ability. Here is an example of a ROOT file with multiple; subdirectories as seen in the ROOT browser. To add a subdirectory to a; file use `TDirectory::mkdir`. The example below opens the file for; writing and creates a subdirectory called ""Wed011003"". Listing the; contents of the file shows the new directory in the file and the; **`TDirectory`** object in memory. ``` {.cpp}; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] f->mkdir(""Wed011003""); (class TDirectory*)0x1072b5c8; ```. ``` {.cpp}; root[] f->ls(); TFile** AFile.root; TFile* AFile.root; TDirectory* Wed011003 Wed011003; KEY: TDirectory Wed011003;1 Wed011003; ```. We can change the current directory by navigating into the subdirectory,; and after changing directory; we can see that ***`gDirectory`*** is now; ""`Wed011003`"". ``` {.cpp}; root[] f->cd(""Wed011003""); root[] gDirectory->pwd(); AFile.root:/Wed011003; ```. In addition to ***`gDirectory`*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:37270,inherit,inherits,37270,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherits']
Modifiability,"hen use the command; `gROOT->SetStyle(""MyStyleName"");` to make this new style definition the; default one. As an example, have a look in the file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20220,variab,variable,20220,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['variab'],['variable']
Modifiability,"her = binaryOperator(isAssignmentOperator())); if (a == b); a += b;. Example 2: matches s1 = s2; (matcher = cxxOperatorCallExpr(isAssignmentOperator())); struct S { S& operator=(const S&); };; void x() { S s1, s2; s1 = s2; }. Matcher<BinaryOperator>isComparisonOperator; Matches comparison operators. Example 1: matches a == b (matcher = binaryOperator(isComparisonOperator())); if (a == b); a += b;. Example 2: matches s1 < s2; (matcher = cxxOperatorCallExpr(isComparisonOperator())); struct S { bool operator<(const S& other); };; void x(S s1, S s2) { bool b1 = s1 < s2; }. Matcher<CXXBaseSpecifier>isPrivate; Matches private C++ declarations and C++ base specifers that specify private; inheritance. Examples:; class C {; public: int a;; protected: int b;; private: int c; // fieldDecl(isPrivate()) matches 'c'; };. struct Base {};; struct Derived1 : private Base {}; // matches 'Base'; class Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isProtected; Matches protected C++ declarations and C++ base specifers that specify; protected inheritance. Examples:; class C {; public: int a;; protected: int b; // fieldDecl(isProtected()) matches 'b'; private: int c;; };. class Base {};; class Derived : protected Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isPublic; Matches public C++ declarations and C++ base specifers that specify public; inheritance. Examples:; class C {; public: int a; // fieldDecl(isPublic()) matches 'a'; protected: int b;; private: int c;; };. class Base {};; class Derived1 : public Base {}; // matches 'Base'; struct Derived2 : Base {}; // matches 'Base'. Matcher<CXXBaseSpecifier>isVirtual; Matches declarations of virtual methods and C++ base specifers that specify; virtual inheritance. Example:; class A {; public:; virtual void x(); // matches x; };. Example:; class Base {};; class DirectlyDerived : virtual Base {}; // matches Base; class IndirectlyDerived : DirectlyDerived, Base {}; // matches Base. Usable as: Matcher<CXXMethodDecl>, Matc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:57039,inherit,inheritance,57039,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['inherit'],['inheritance']
Modifiability,"her expression AST node; definitions that we'll use in the basic form of the Kaleidoscope; language:. .. code-block:: c++. /// VariableExprAST - Expression class for referencing a variable, like ""a"".; class VariableExprAST : public ExprAST {; std::string Name;. public:; VariableExprAST(const std::string &Name) : Name(Name) {}; };. /// BinaryExprAST - Expression class for a binary operator.; class BinaryExprAST : public ExprAST {; char Op;; std::unique_ptr<ExprAST> LHS, RHS;. public:; BinaryExprAST(char Op, std::unique_ptr<ExprAST> LHS,; std::unique_ptr<ExprAST> RHS); : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}; };. /// CallExprAST - Expression class for function calls.; class CallExprAST : public ExprAST {; std::string Callee;; std::vector<std::unique_ptr<ExprAST>> Args;. public:; CallExprAST(const std::string &Callee,; std::vector<std::unique_ptr<ExprAST>> Args); : Callee(Callee), Args(std::move(Args)) {}; };. This is all (intentionally) rather straight-forward: variables capture; the variable name, binary operators capture their opcode (e.g. '+'), and; calls capture a function name as well as a list of any argument; expressions. One thing that is nice about our AST is that it captures; the language features without talking about the syntax of the language.; Note that there is no discussion about precedence of binary operators,; lexical structure, etc. For our basic language, these are all of the expression nodes we'll; define. Because it doesn't have conditional control flow, it isn't; Turing-complete; we'll fix that in a later installment. The two things; we need next are a way to talk about the interface to a function, and a; way to talk about functions themselves:. .. code-block:: c++. /// PrototypeAST - This class represents the ""prototype"" for a function,; /// which captures its name, and its argument names (thus implicitly the number; /// of arguments the function takes).; class PrototypeAST {; std::string Name;; std::vector<std::string> Args;. publ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:3321,variab,variables,3321,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"her; does the same job as `scan-build` does. So, you can expect the same output; from this line as simple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:3022,variab,variables,3022,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['variab'],['variables']
Modifiability,"her<UnresolvedUsingValueDecl>...; Matches unresolved using value declarations. Given; template<typename X>; class C : private X {; using X::x;; };; unresolvedUsingValueDecl(); matches using X::x ; Matcher<Decl>usingDeclMatcher<UsingDecl>...; Matches using declarations. Given; namespace X { int x; }; using X::x;; usingDecl(); matches using X::x ; Matcher<Decl>usingDirectiveDeclMatcher<UsingDirectiveDecl>...; Matches using namespace declarations. Given; namespace X { int x; }; using namespace X;; usingDirectiveDecl(); matches using namespace X ; Matcher<Decl>usingEnumDeclMatcher<UsingEnumDecl>...; Matches using-enum declarations. Given; namespace X { enum x {...}; }; using enum X::x;; usingEnumDecl(); matches using enum X::x ; Matcher<Decl>valueDeclMatcher<ValueDecl>...; Matches any value declaration. Example matches A, B, C and F; enum X { A, B, C };; void F();. Matcher<Decl>varDeclMatcher<VarDecl>...; Matches variable declarations. Note: this does not match declarations of member variables, which are; ""field"" declarations in Clang parlance. Example matches a; int a;. Matcher<LambdaCapture>lambdaCaptureMatcher<LambdaCapture>...; Matches lambda captures. Given; int main() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher `lambdaExpr(hasAnyCapture(lambdaCapture()))`,; `lambdaCapture()` matches `x` and `x=1`. Matcher<NestedNameSpecifierLoc>nestedNameSpecifierLocMatcher<NestedNameSpecifierLoc>...; Same as nestedNameSpecifier but matches NestedNameSpecifierLoc. Matcher<NestedNameSpecifier>nestedNameSpecifierMatcher<NestedNameSpecifier>...; Matches nested name specifiers. Given; namespace ns {; struct A { static void f(); };; void A::f() {}; void g() { A::f(); }; }; ns::A a;; nestedNameSpecifier(); matches ""ns::"" and both ""A::"". Matcher<OMPClause>ompDefaultClauseMatcher<OMPDefaultClause>...; Matches OpenMP ``default`` clause. Given. #pragma omp parallel default(none); #pragma omp parallel default(shared); #pragma omp parallel default(private); #pragma o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:20002,variab,variables,20002,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variables']
Modifiability,"here are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4732,plugin,plugin-opt,4732,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin-opt']
Modifiability,"hes (e.g. x86), this; intrinsic is a nop. On platforms with non-coherent instruction and data; cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate; instructions or a system call, if cache flushing requires special; privileges. The default behavior is to emit a call to ``__clear_cache`` from the run; time library. This intrinsic does *not* empty the instruction pipeline. Modifications; of the current function are outside the scope of the intrinsic. '``llvm.instrprof.increment``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment(ptr <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. These will be; lowered by the ``-instrprof`` pass to generate execution counts of a; program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash`` or ``num-counters`` differ between two instances of; ``instrprof.increment`` that refer to the same name. The last argument refers to which of the counters for ``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:527306,variab,variable,527306,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"hese coordinates are in NDC. This means; that they are independent of the user coordinates system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25484,variab,variables,25484,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['variab'],['variables']
Modifiability,"hesis"" {; rankdir=""LR"";; graph [fontname=""Verdana"", fontsize=""12""];; node [fontname=""Verdana"", fontsize=""12""];; edge [fontname=""Sans"", fontsize=""9""];. start [label="" Create an Object \n 'Last Value' \n of type 'Value' "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; assign [label="" Assign the result \n to the 'LastValue' \n (based on respective \n Memory Allocation \n scenario) "", shape=""box""]; print [label="" Pretty Print \n the Value Object "", shape=""Msquare"", fillcolor=""yellow"", style=filled];; start -> assign;; assign -> print;. subgraph SynthesizeExpression {; synth [label="" SynthesizeExpr() "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8025,variab,variable,8025,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['variab'],['variable']
Modifiability,"hich is not yet complete.; The FeldmanCousins class is a separate concrete implementation of the; IntervalCalculator interface. �It uses the NeymanConstruction internally,; and�enforces�specific choices of the test statistic and ordering; principle to realize the Unified intervals described by Feldman and; Cousins in their paper�Phys.Rev.D57:3873-3889,1998. In an extension to the technique discussed in Feldman and Cousins paper,; the FeldmanCousins class also performs a ""profile construction"" if their are nuisance parameters.; In this case, the parameters of interest are scanned in a regular grid. For each point in the grid; the calculator finds the best fit value of the nuisance parameters (given the data). The construction; is then only performed in this subspace of the parameters. As a result, the number of points in the; construction only scales in the number of parameters of interest, not in the number of nuisance parameters. Markov Chain Monte Carlo Interval; A flexible framework for Markov Chain Monte Carlo was added in this; release. The MCMCCalculator is a concrete implementation of the; IntervalCalculator interface. To use it one needs to specify the ProposalFunction.; There is a base class for ProposalFunctions and one concrete implementation: UniformProposal.; Support for other proposal functions will be added in the next release.; The MCMCCalculator scans the space of the parameters of interest and nuisance parameters and; produces a Bayesian posterior. In this version, the prior must be added to the model initially,; otherwise a flat prior is assumed. The MCMCCalculator returns an MCMCInterval, which produces; the smallest interval by taking a contour of the posterior. This first version only supports; 1,2, and 3 dimensional intervals, but will be generalized in the next release. In addition to the MCMC implementation in RooStats, one can export their model and dataset into a workspace,; and then use the Bayesian Analysis Toolkit (BAT) for the MCMC. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:29486,flexible,flexible,29486,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['flexible'],['flexible']
Modifiability,"hich the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ab",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35250,config,configuration,35250,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.org/svn/llvm-project/libcxx/trunk libcxx -r $REVISION. Or using git-svn::. git clone https://llvm.org/git/llvm.git; cd llvm/; git svn init https://llvm.org/svn/llvm-project/llvm/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd tools; git clone https://llvm.org/git/clang.git; cd clang/; git svn init https://llvm.org/svn/llvm-project/clang/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`; cd ../../projects/; git clone https://llvm.org/git/libcxx.git; cd libcxx; git svn init https://llvm.org/svn/llvm-project/libcxx/trunk --username=<username>; git config svn-remote.svn.fetch :refs/remotes/origin/main; git svn rebase -l; git checkout `git svn find-rev -B r258109`. Note that the list would be longer with more sub-projects. .. _workflow-monocheckout-multicommit:. Monorepo Variant; ^^^^^^^^^^^^^^^^. The repository contains natively the source for every sub-projects at the right; revision, which makes this straightforward::. git clone https://github.com/llvm/llvm-project.git; cd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:15800,config,config,15800,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['config']
Modifiability,"hing delimiter takes; precedence over a matching enclosing function name for determining the; language of the raw string contents. If a canonical delimiter is specified, occurrences of other delimiters for; the same language will be updated to the canonical if possible. There should be at most one specification per language and each delimiter; and enclosing function should not occur in multiple specifications. To configure this in the .clang-format file, use:. .. code-block:: yaml. RawStringFormats:; - Language: TextProto; Delimiters:; - 'pb'; - 'proto'; EnclosingFunctions:; - 'PARSE_TEXT_PROTO'; BasedOnStyle: google; - Language: Cpp; Delimiters:; - 'cc'; - 'cpp'; BasedOnStyle: llvm; CanonicalDelimiter: 'cc'. .. _ReferenceAlignment:. **ReferenceAlignment** (``ReferenceAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <ReferenceAlignment>`; Reference alignment style (overrides ``PointerAlignment`` for; references). Possible values:. * ``RAS_Pointer`` (in configuration: ``Pointer``); Align reference like ``PointerAlignment``. * ``RAS_Left`` (in configuration: ``Left``); Align reference to the left. .. code-block:: c++. int& a;. * ``RAS_Right`` (in configuration: ``Right``); Align reference to the right. .. code-block:: c++. int &a;. * ``RAS_Middle`` (in configuration: ``Middle``); Align reference in the middle. .. code-block:: c++. int & a;. .. _ReflowComments:. **ReflowComments** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <ReflowComments>`; If ``true``, clang-format will attempt to re-flow comments. That is it; will touch a comment and *reflow* long comments into new lines, trying to; obey the ``ColumnLimit``. .. code-block:: c++. false:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information; /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */. true:; // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of; // information; /* second veryVeryVeryVeryVeryVe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:99948,config,configuration,99948,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hints about the correlations between the axes. Avery simple technique allows to make the clusters appearing:; Instead of painting solid lines we paint dotted lines. The cluttering of; each individual line is reduced and the clusters show clearly as we can; see on the next figure. The spacing between the dots is a parameter which; can be adjusted in order to get the best results. ![Using dotted lines is a very simple method to reduce the cluttering.](pictures/para5.png). Interactivity is a very important aspect of the Parallel Coordinates plots.; To really explore the data set it is essential to act directly with the; events and the axes. For instance, changing the axes order may show clusters; which were not visible in a different order. On the next figure the axes; order has been changed interactively. We can see that many more clusters; appear and all the “random spheres” we put in the data set are now; clearly visible. Having moved the variables `u,v,w` after the variables; `x,y,z` the correlation between these two sets of variables is clear also. ![Axis order is very important to show clusters.](pictures/para6.png). To pursue further data sets exploration we have implemented the possibility; to define selections interactively. A selection is a set of ranges combined; together. Within a selection, ranges along the same axis are combined with; logical OR, and ranges on different axes with logical AND. A selection is; displayed on top of the complete data set using its own color. Only the; events fulfilling the selection criteria (ranges) are displayed. Ranges; are defined interactively using cursors, like on the first axis on the; figure. Several selections can be defined at the same time,; each selection having its own color. ![Selections are set of ranges which can be defined interactively.](pictures/para7.png). Several selections can been defined. Each cluster is now clearly visible; and the zone with crossing clusters is now understandable whereas,; without any",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:100077,variab,variables,100077,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,3,['variab'],['variables']
Modifiability,"hip, as well as the usual behavior of; copy semantics on the setter.; * ``retain`` implies ``__strong`` ownership.; * ``strong`` implies ``__strong`` ownership.; * ``unsafe_unretained`` implies ``__unsafe_unretained`` ownership.; * ``weak`` implies ``__weak`` ownership. With the exception of ``weak``, these modifiers are available in non-ARC; modes. A property's specified ownership is preserved in its metadata, but otherwise; the meaning is purely conventional unless the property is synthesized. If a; property is synthesized, then the :arc-term:`associated instance variable` is; the instance variable which is named, possibly implicitly, by the; ``@synthesize`` declaration. If the associated instance variable already; exists, then its ownership qualification must equal the ownership of the; property; otherwise, the instance variable is created with that ownership; qualification. A property of retainable object pointer type which is synthesized without a; source of ownership has the ownership of its associated instance variable, if it; already exists; otherwise, :when-revised:`[beginning Apple 3.1, LLVM 3.1]`; :revision:`its ownership is implicitly` ``strong``. Prior to this revision, it; was ill-formed to synthesize such a property. .. admonition:: Rationale. Using ``strong`` by default is safe and consistent with the generic ARC rule; about :ref:`inferring ownership <arc.ownership.inference.variables>`. It is,; unfortunately, inconsistent with the non-ARC rule which states that such; properties are implicitly ``assign``. However, that rule is clearly; untenable in ARC, since it leads to default-unsafe code. The main merit to; banning the properties is to avoid confusion with non-ARC practice, which did; not ultimately strike us as sufficient to justify requiring extra syntax and; (more importantly) forcing novices to understand ownership rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:35795,variab,variable,35795,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"his can be done in; Cling by inserting the bash-like style line:. .. code:: bash; ; #!/usr/bin/cling; ; 3. **Rapid Application Development (RAD):**. Cling can be used successfully for Rapid Application Development allowing for; prototyping and proofs of concept taking advantage of dynamicity and feedback; during the implementation process. 4. **Runtime-Generated Code**. Sometime it's convenient to create code as a reaction to input; (user/network/configuration). Runtime-generated code can interface with C++; libraries. 5. **Embedding Cling:**. The functionality of an application can be enriched by embedding Cling. To embed; Cling, the main program has to be provided. One of the things this main program; has to do is initialize the Cling interpreter. There are optional calls to pass; command line arguments to Cling. Afterwards, you can call the interpreter from; any anywhere within the application. For compilation and linkage the application needs the path to the Clang and LLVM; libraries and the invocation is order dependent since the linker cannot do; backward searches. .. code:: bash. g++ embedcling.cxx -std=c++11 -L/usr/local/lib; -lclingInterpreter -lclingUtils ; -lclangFrontend -lclangSerialization -lclangParse -lclangSema ; -lclangAnalysis -lclangEdit -lclangLex -lclangDriver -lclangCodeGen ; -lclangBasic -lclangAST ; `llvm-config ; --libs bitwriter mcjit orcjit native option ; ipo profiledata instrumentation objcarcopts` ; -lz -pthread -ldl -ltinfo ; -o embedcling; . Embedding Cling requires the creation of the interpreter. Optionally compiler; arguments and the resource directory of LLVM can be passed. An example is the; following:. .. code:: bash. #include ""cling/Interpreter/Interpreter.h"". int main(int argc, char** argv) {; const char* LLVMRESDIR = ""/usr/local/""; //path to llvm resource directory; cling::Interpreter interp(argc, argv, LLVMRESDIR);. interp.declare(""int p=0;"");; }; ; A more complete example could be found in `<tools/demo/cling-demo.cpp>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst:1778,config,config,1778,interpreter/cling/docs/chapters/why_interpreting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/why_interpreting.rst,1,['config'],['config']
Modifiability,"his track; Float_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion. // method definitions ...; ClassDef(Track,1) //A track segment; };; ```. ### Writing the Tree. We create a simple tree with two branches both holding `Event` objects.; One is split and the other is not. We also create a pointer to an; `Event` object (`event`). ``` {.cpp}; void tree4w() {; // check to see if the event class is in the dictionary; // if it is not load the definition in libEvent.so; if (!TClassTable::GetDict(""Event"")) {; gSystem->Load(""$ROOTSYS/test/libEvent.so"");; }; // create a Tree file tree4.root; TFile f(""tree4.root"",""RECREATE"");; // create a ROOT Tree; TTree t4(""t4"",""A Tree with Events"");; // create a pointer to an Event object; Event *event = new Event();; // create two branches, split one; t4.Branch(""event_branch"", ""Event"", &event,16000,2);; t4.Branch(""event_not_split"", ""Event"", &event,16000,0);. // a local variable for the event type; char etype[20];. // fill the tree; for (Int_t ev = 0; ev <100; ev++) {; Float_t sigmat, sigmas;; gRandom->Rannor(sigmat,sigmas);; Int_t ntrack = Int_t(600 + 600 *sigmat/120.);; Float_t random = gRandom->Rndm(1);; sprintf(etype,""type%d"",ev%5);; event->SetType(etype);; event->SetHeader(ev, 200, 960312, random);; event->SetNseg(Int_t(10*ntrack+20*sigmas));; event->SetNvertex(Int_t(1+20*gRandom->Rndm()));; event->SetFlag(UInt_t(random+0.5));; event->SetTemperature(random+20.);; for(UChar_t m = 0; m < 10; m++) {; event->SetMeasure(m, Int_t(gRandom->Gaus(m,m+1)));; }; // continued...; // fill the matrix; for(UChar_t i0 = 0; i0 < 4; i0++) {; for(UChar_t i1 = 0; i1 < 4; i1++) {; event->SetMatrix(i0,i1,gRandom->Gaus(i0*i1,1));; }; }; // create and fill the Track objects; for (Int_t t = 0; t < ntrack; t++) event->AddTrack(random);; t4.Fill(); // Fill the tree; event->Clear(); // Clear before reloading event; }; f.Write(); // Write the file header; t4.Print(); // Print the tree conten",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:62816,variab,variable,62816,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,"histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6147,variab,variable,6147,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['variab'],['variable']
Modifiability,"hives</td></tr>; <tr><td>llvm-devmeeting</td><td>Community/US Developer Meeting</td></tr>; <tr><td>llvm-foundation</td><td>Community/LLVM Foundation</td></tr>; <tr><td>Mlir-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-commits</td><td>no migration at the moment</td></tr>; <tr><td>Openmp-dev</td><td>Runtimes/OpenMP</td></tr>; <tr><td>Parallel_libs-commits</td><td>no migration at the moment</td></tr>; <tr><td>Parallel_libs-dev</td><td>Runtimes/C++</td></tr>; <tr><td>Release-testers</td><td>Project Infrastructure/Release Testers</td></tr>; <tr><td>Test-list</td><td>Obsolete</td></tr>; <tr><td>vmkit-commits</td><td>Obsolete</td></tr>; <tr><td>WiCT</td><td>Community/Women in Compilers and Tools</td></tr>; <tr><td>www-scripts</td><td>Obsolete</td></tr> ; </table>. ## FAQ. ### I don't want to use a web UI. You can do most of the communication with your email client (see section on; Setting up email interactions above). You only need to set up your account once; and then configure which categories you want to subscribe to. ### How do I send a private message?. On the mailing list you have the opportunity to reply only to the sender of; the email, not to the entire list. That is not supported when replying via; email on Discourse. However you can send someone a private message via the; Web UI: Click on the user's name above a post and then on `Message`. Also Discourse does not expose users' email addresses , so your private; replies have to go through their platform (unless you happen to know the; email address of the user.). ### How can my script/tool send automatic messages?**. In case you want to [create a new; post/topic](https://docs.discourse.org/#tag/Posts/paths/~1posts.json/post); automatically from a script or tool, you can use the; [Discourse API](https://docs.discourse.org/). ### Who are the admins for Discourse?. See https://llvm.discourse.group/about. ### What is the reason for the migration?. See; [this email](https://lists.llvm.org/piperm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:10159,config,configure,10159,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,1,['config'],['configure']
Modifiability,"hod finds the first occurrence of the regular expression in the; `string` and returns its position. ## Conventions. In this paragraph, we will explain some of the conventions used in; ROOT source and examples. ### Coding Conventions. From the first days of ROOT development, it was decided to use a set; of coding conventions. This allows a consistency throughout the source; code. Learning these will help you identify what type of information; you are dealing with and enable you to understand the code better and; quicker. Of course, you can use whatever convention you want but if; you are going to submit some code for inclusion into the ROOT sources,; you will need to use these. These are the coding conventions:. - Classes begin with **`T`**: **`TLine`**, **`TTree`**. - Non-class types end with **`_t`**: `Int_t`. - Data members begin with **`f`**: `fTree`. - Member functions begin with a capital: `Loop()`. - Constants begin with **`k`**: `kInitialSize`, `kRed `. - Global variables begin with **`g`**: ***`gEnv`***. - Static data members begin with **`fg`**: `fgTokenClient `. - Enumeration types begin with **`E`**: `EColorLevel`. - Locals and parameters begin with a lower case: `nbytes`. - Getters and setters begin with **`Get`** and **`Set`**:; `SetLast`(), `GetFirst`(). ### Machine Independent Types. Different machines may have different lengths for the same type. The; most famous example is the `int` type. It may be 16 bits on some old; machines and 32 bits on some newer ones. To ensure the size of your; variables, use these pre defined types in ROOT:. - **`Char_t`** Signed Character 1 byte. - **`UChar_t`** Unsigned Character 1 byte. - **`Short_t`** Signed Short integer 2 bytes. - **`UShort_t`** Unsigned Short integer 2 bytes. - **`Int_t`** Signed integer 4 bytes. - **`UInt_t `**Unsigned integer 4 bytes. - **`Long64_t`** Portable signed long integer 8 bytes. - **`ULong64_t`** Portable unsigned long integer 8 bytes. - **`Float_t`** Float 4 bytes. - **`Double_t`** Float",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:29801,variab,variables,29801,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['variab'],['variables']
Modifiability,"hod is called when displaying the event status in a canvas. To; show the event status window, select the `Options` menu and the; `EventStatus` item. This method returns a string of information about; the object at position (x, y). Every time the cursor moves, the object; under the cursor executes the `GetObjectInfo` method. The string is then; shown in the status bar. There is a default implementation in; **`TObject`**, but it is typically overridden for classes that can; report peculiarities for different cursor positions (for example the bin; contents in a TH1). ### IsFolder. By default an object inheriting from **`TObject`** is not brows-able,; because **`TObject::IsFolder()`** returns `kFALSE`. To make a class; browse-able, the `IsFolder` method needs to be overridden to return; `kTRUE`. In general, this method returns `kTRUE` if the object contains; browse-able objects (like containers or lists of other objects). ### Bit Masks and Unique ID. A **`TObject`** descendent inherits two data members: `fBits` and; `fUniqueID`. `fBits `is 32-bit data member used with a bit mask to get; object information. Bits 0 - 13 are reserved as global bits, bits 14 -; 23 can be used in different class hierarchies. ``` {.cpp}; enum EObjBits {; kCanDelete = BIT(0), // if can be deleted; kMustCleanup = BIT(3), // if destructor must call RecursiveRemove(); kObjInCanvas = BIT(3), // for backward compatibility only; kIsReferenced = BIT(4), // if referenced by TRef or TRefArray; kHasUUID = BIT(5), // if has a TUUID, fUniqueID=UUIDNumber; kCannotPick = BIT(6), // if cannot be picked in a pad; kNoContextMenu = BIT(8), // if does not want a context menu; kInvalidObject = BIT(13) // object ctor succeeded but the object should not be used; };; ```. For example, the bits `kMustCleanup` and `kCanDelete` are used in; **`TObject`**. See ""The kCanDelete Bit"" and ""The kMustCleanup Bit"". They; can be set by any object and should not be reused. Make sure not; to overlap them in any given hierarchy. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md:5418,inherit,inherits,5418,documentation/users-guide/AddingaClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/AddingaClass.md,1,['inherit'],['inherits']
Modifiability,"hod. ``` {.cpp}; h->SetDirectory(newDir);; ```. If the parameter is 0, the histogram is no longer associated with a; directory. ``` {.cpp}; h->SetDirectory(0);; ```. Once a histogram is removed from the directory, it will no longer be; deleted when the directory is closed. It is now your responsibility to; delete this histogram object once you are finished with it. To change; the default that automatically adds the histogram to the current; directory, you can call the static function:. ``` {.cpp}; TH1::AddDirectory(kFALSE);; ```. In this case, you will need to do all the bookkeeping for all the; created histograms. ### Saving Objects to Disk. In addition to histograms and trees, you can save any object in a ROOT; file. For example to save a canvas to the ROOT file you can use either; **`TObject::Write()` or `TDirectory`**`::WriteTObject()`. The example:. ``` {.cpp}; root[] c1->Write(); ```. This is equivalent to:. ``` {.cpp}; root[] f->WriteTObject(c1); ```. For objects that do not inherit from **`TObject`** use:. ``` {.cpp}; root[] f->WriteObject(ptr,""nameofobject""); ```. ***`Another example:`***. ``` {.cpp}; root[] TFile *f = new TFile(""hsimple.root"",""UPDATE""); root[] hpx->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] c1->Write(); root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TH1F hpx This is the px distribution : 0; KEY: TH1F hpx;2 This is the px distribution; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;2 Profile of pz versus px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; KEY: TCanvas c1;1 c1; ```. ### Saving Collections to Disk. All collection classes inherit from **`TCollection`** and hence inherit; the **`TCollection::Write()` method. When you call; `TCollection`**`::Write()` each object in the container is written; individually into its own key in the file. To write all objects into one; key you can specify the name of the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:33587,inherit,inherit,33587,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inherit']
Modifiability,"hods. This release contains the following changes:. The ROOT::Math::IParamFunction, ROOT::Math::IParamMultiFunction interfaces (used mainly for fitting) require now a pointer to the parameters (type const double *), when evaluating the function. The derived classes must implement now the const; method DoEvalPar (and not DoEval as before). In addition the method; operator()(const double * x, const double * p) is now const. This change makes the caching of parameter not hidden and the interface is now; thread-safe. ; A similar change in the ROOT::Math::IParamGradFunction, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, lik",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:9820,inherit,inherit,9820,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['inherit'],['inherit']
Modifiability,"hortEnumsOnASingleLine>`; Allow short enums on a single line. .. code-block:: c++. true:; enum { A, B } myEnum;. false:; enum {; A,; B; } myEnum;. .. _AllowShortFunctionsOnASingleLine:. **AllowShortFunctionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); retu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29435,config,configuration,29435,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hould be declared this way:; BreakBeforeBraces: Custom; BraceWrapping:; AfterClass: true. * ``bool AfterCaseLabel`` Wrap case labels. .. code-block:: c++. false: true:; switch (foo) { vs. switch (foo) {; case 1: { case 1:; bar(); {; break; bar();; } break;; default: { }; plop(); default:; } {; } plop();; }; }. * ``bool AfterClass`` Wrap class definitions. .. code-block:: c++. true:; class foo; {};. false:; class foo {};. * ``BraceWrappingAfterControlStatementStyle AfterControlStatement``; Wrap control statements (``if``/``for``/``while``/``switch``/..). Possible values:. * ``BWACS_Never`` (in configuration: ``Never``); Never wrap braces after a control statement. .. code-block:: c++. if (foo()) {; } else {; }; for (int i = 0; i < 10; ++i) {; }. * ``BWACS_MultiLine`` (in configuration: ``MultiLine``); Only wrap braces after a multi-line control statement. .. code-block:: c++. if (foo && bar &&; baz); {; quux();; }; while (foo || bar) {; }. * ``BWACS_Always`` (in configuration: ``Always``); Always wrap braces after a control statement. .. code-block:: c++. if (foo()); {; } else; {}; for (int i = 0; i < 10; ++i); {}. * ``bool AfterEnum`` Wrap enum definitions. .. code-block:: c++. true:; enum X : int; {; B; };. false:; enum X : int { B };. * ``bool AfterFunction`` Wrap function definitions. .. code-block:: c++. true:; void foo(); {; bar();; bar2();; }. false:; void foo() {; bar();; bar2();; }. * ``bool AfterNamespace`` Wrap namespace definitions. .. code-block:: c++. true:; namespace; {; int foo();; int bar();; }. false:; namespace {; int foo();; int bar();; }. * ``bool AfterObjCDeclaration`` Wrap ObjC definitions (interfaces, implementations...). .. note::. @autoreleasepool and @synchronized blocks are wrapped; according to ``AfterControlStatement`` flag. * ``bool AfterStruct`` Wrap struct definitions. .. code-block:: c++. true:; struct foo; {; int x;; };. false:; struct foo {; int x;; };. * ``bool AfterUnion`` Wrap union definitions. .. code-block:: c++. true:; union ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:39824,config,configuration,39824,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"hout; constraining it to a specific triple. **FileCheck-specific substitutions:**. ``%ProtectFileCheckOutput``; This should precede a ``FileCheck`` call if and only if the call's textual; output affects test results. It's usually easy to tell: just look for; redirection or piping of the ``FileCheck`` call's stdout or stderr. .. _Test-specific substitutions:. **Test-specific substitutions:**. Additional substitutions can be defined as follows:. - Lit configuration files (e.g., ``lit.cfg`` or ``lit.local.cfg``) can define; substitutions for all tests in a test directory. They do so by extending the; substitution list, ``config.substitutions``. Each item in the list is a tuple; consisting of a pattern and its replacement, which lit applies using python's; ``re.sub`` function.; - To define substitutions within a single test file, lit supports the; ``DEFINE:`` and ``REDEFINE:`` directives, described in detail below. So that; they have no effect on other test files, these directives modify a copy of the; substitution list that is produced by lit configuration files. For example, the following directives can be inserted into a test file to define; ``%{cflags}`` and ``%{fcflags}`` substitutions with empty initial values, which; serve as the parameters of another newly defined ``%{check}`` substitution:. .. code-block:: llvm. ; DEFINE: %{cflags} =; ; DEFINE: %{fcflags} =. ; DEFINE: %{check} = \; ; DEFINE: %clang_cc1 -verify -fopenmp -fopenmp-version=51 %{cflags} \; ; DEFINE: -emit-llvm -o - %s | \; ; DEFINE: FileCheck %{fcflags} %s. Alternatively, the above substitutions can be defined in a lit configuration; file to be shared with other test files. Either way, the test file can then; specify directives like the following to redefine the parameter substitutions as; desired before each use of ``%{check}`` in a ``RUN:`` line:. .. code-block:: llvm. ; REDEFINE: %{cflags} = -triple x86_64-apple-darwin10.6.0 -fopenmp-simd; ; REDEFINE: %{fcflags} = -check-prefix=SIMD; ; RUN: %{che",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:29242,config,configuration,29242,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"how you can declare and manipulate a stack; variable in the LLVM IR. Stack memory allocated with the alloca; instruction is fully general: you can pass the address of the stack slot; to functions, you can store it in other variables, etc. In our example; above, we could rewrite the example to use the alloca technique to avoid; using a PHI node:. .. code-block:: llvm. @G = weak global i32 0 ; type of @G is i32*; @H = weak global i32 0 ; type of @H is i32*. define i32 @test(i1 %Condition) {; entry:; %X = alloca i32 ; type of %X is i32*.; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; store i32 %X.0, i32* %X ; Update X; br label %cond_next. cond_false:; %X.1 = load i32, i32* @H; store i32 %X.1, i32* %X ; Update X; br label %cond_next. cond_next:; %X.2 = load i32, i32* %X ; Read X; ret i32 %X.2; }. With this, we have discovered a way to handle arbitrary mutable; variables without the need to create Phi nodes at all:. #. Each mutable variable becomes a stack allocation.; #. Each read of the variable becomes a load from the stack.; #. Each update of the variable becomes a store to the stack.; #. Taking the address of a variable just uses the stack address; directly. While this solution has solved our immediate problem, it introduced; another one: we have now apparently introduced a lot of stack traffic; for very simple and common operations, a major performance problem.; Fortunately for us, the LLVM optimizer has a highly-tuned optimization; pass named ""mem2reg"" that handles this case, promoting allocas like this; into SSA registers, inserting Phi nodes as appropriate. If you run this; example through the pass, for example, you'll get:. .. code-block:: bash. $ llvm-as < example.ll | opt -passes=mem2reg | llvm-dis; @G = weak global i32 0; @H = weak global i32 0. define i32 @test(i1 %Condition) {; entry:; br i1 %Condition, label %cond_true, label %cond_false. cond_true:; %X.0 = load i32, i32* @G; br label %cond_next. cond_false:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:6216,variab,variable,6216,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"how_bug.cgi?id=9663. http://www.inf.u-szeged.hu/gcc-arm/; http://citeseer.ist.psu.edu/debus04linktime.html. //===---------------------------------------------------------------------===//. gcc generates smaller code for this function at -O2 or -Os:. void foo(signed char* p) {; if (*p == 3); bar();; else if (*p == 4); baz();; else if (*p == 5); quux();; }. llvm decides it's a good idea to turn the repeated if...else into a; binary tree, as if it were a switch; the resulting code requires -1; compare-and-branches when *p<=2 or *p==5, the same number if *p==4; or *p>6, and +1 if *p==3. So it should be a speed win; (on balance). However, the revised code is larger, with 4 conditional; branches instead of 3. More seriously, there is a byte->word extend before; each comparison, where there should be only one, and the condition codes; are not remembered when the same two values are compared twice. //===---------------------------------------------------------------------===//. More LSR enhancements possible:. 1. Teach LSR about pre- and post- indexed ops to allow iv increment be merged; in a load / store.; 2. Allow iv reuse even when a type conversion is required. For example, i8; and i32 load / store addressing modes are identical. //===---------------------------------------------------------------------===//. This:. int foo(int a, int b, int c, int d) {; long long acc = (long long)a * (long long)b;; acc += (long long)c * (long long)d;; return (int)(acc >> 32);; }. Should compile to use SMLAL (Signed Multiply Accumulate Long) which multiplies; two signed 32-bit values to produce a 64-bit value, and accumulates this with; a 64-bit value. We currently get this with both v4 and v6:. _foo:; smull r1, r0, r1, r0; smull r3, r2, r3, r2; adds r3, r3, r1; adc r0, r2, r0; bx lr. //===---------------------------------------------------------------------===//. This:; #include <algorithm>; std::pair<unsigned, bool> full_add(unsigned a, unsigned b); { return std::make_pair(a + b, a + b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:12416,enhance,enhancements,12416,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['enhance'],['enhancements']
Modifiability,"hr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <htt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73011,config,config,73011,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,"['config', 'extend']","['config', 'extend']"
Modifiability,"hree new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.fram",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22173,adapt,adaptive,22173,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['adapt'],['adaptive']
Modifiability,"hrough launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318210,variab,variable,318210,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"i-c-e's, and a lot of real world code depends on; this unfortunate accident of history (including, e.g., the glibc system; headers). GCC accepts anything its ""fold"" optimizer is capable of reducing to; an integer constant, which means that the definition of what it accepts changes; as its optimizer does. One example is that GCC accepts things like ""``case; X-X:``"" even when ``X`` is a variable, because it can fold this to 0. Another issue are how constants interact with the extensions we support, such; as ``__builtin_constant_p``, ``__builtin_inf``, ``__extension__`` and many; others. C99 obviously does not specify the semantics of any of these; extensions, and the definition of i-c-e does not include them. However, these; extensions are often used in real code, and we have to have a way to reason; about them. Finally, this is not just a problem for semantic analysis. The code generator; and other clients have to be able to fold constants (e.g., to initialize global; variables) and have to handle a superset of what C99 allows. Further, these; clients can benefit from extended information. For example, we know that; ""``foo() || 1``"" always evaluates to ``true``, but we can't replace the; expression with ``true`` because it has side effects. Implementation Approach; ^^^^^^^^^^^^^^^^^^^^^^^. After trying several different approaches, we've finally converged on a design; (Note, at the time of this writing, not all of this has been implemented,; consider this a design goal!). Our basic approach is to define a single; recursive evaluation method (``Expr::Evaluate``), which is implemented; in ``AST/ExprConstant.cpp``. Given an expression with ""scalar"" type (integer,; fp, complex, or pointer) this method returns the following information:. * Whether the expression is an integer constant expression, a general constant; that was folded but has no side effects, a general constant that was folded; but that does have side effects, or an uncomputable/unfoldable value.; * If the e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:120551,variab,variables,120551,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['variab'],['variables']
Modifiability,"i-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:2229,variab,variables,2229,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,2,['variab'],"['variable', 'variables']"
Modifiability,"iable Class; <https://llvm.org/doxygen/classllvm_1_1GlobalVariable.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. Global variables are represented with the (surprise surprise) ``GlobalVariable``; class. Like functions, ``GlobalVariable``\ s are also subclasses of; GlobalValue_, and as such are always referenced by their address (global values; must live in memory, so their ""name"" refers to their constant address). See; GlobalValue_ for more on this. Global variables may have an initial value; (which must be a Constant_), and if they have an initializer, they may be marked; as ""constant"" themselves (indicating that their contents never change at; runtime). .. _m_GlobalVariable:. Important Public Members of the ``GlobalVariable`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * ``GlobalVariable(const Type *Ty, bool isConstant, LinkageTypes &Linkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:159526,variab,variable,159526,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"iable. See the discussion above ‘Getting the right parameter; errors with limits'. The best way to be absolutely sure of the errors is to use; ''independent'' calculations and compare them, or compare the; calculated errors with a picture of the function. Theoretically, the; covariance matrix for a ''physical'' function must be; positive-definite at the minimum, although it may not be so for all; points far away from the minimum, even for a well-determined physical; problem. Therefore, if `MIGRAD` reports that it has found a; non-positive-definite covariance matrix, this may be a sign of one or; more of the following:. #### A Non-physical Region. On its way to the minimum, `MIGRAD` may have traversed a region that; has unphysical behavior, which is of course not a serious problem as; long as it recovers and leaves such a region. #### An Underdetermined Problem. If the matrix is not positive-definite even at the minimum, this may; mean that the solution is not well defined, for example that there are; more unknowns than there are data points, or that the parameterization; of the fit contains a linear dependence. If this is the case, then; `Minuit` (or any other program) cannot solve your problem uniquely.; The error matrix will necessarily be largely meaningless, so the user; must remove the under determinedness by reformulating the; parameterization. `Minuit` cannot do this itself. #### Numerical Inaccuracies. It is possible that the apparent lack of positive-definiteness is due; to excessive round off errors in numerical calculations (in the user; function), or not enough precision. This is unlikely in general, but; becomes more likely if the number of free parameters is very large, or; if the parameters are badly scaled (not all of the same order of; magnitude), and correlations are large. In any case, whether the; non-positive-definiteness is real or only numerical is largely; irrelevant, since in both cases the error matrix will be unreliable; and the minimum sus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:63201,parameteriz,parameterization,63201,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['parameteriz'],['parameterization']
Modifiability,"iable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32643,variab,variable,32643,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variable']
Modifiability,"iables; ---------------------------. Here are some of the CMake variables that are rarely used, along with a brief; explanation and LLVM-related notes. For full documentation, consult the CMake; manual, or execute ``cmake --help-variable VARIABLE_NAME``. **CMAKE_CXX_STANDARD**:STRING; Sets the C++ standard to conform to when building LLVM. Possible values are; 17 and 20. LLVM Requires C++ 17 or higher. This defaults to 17. **CMAKE_INSTALL_BINDIR**:PATH; The path to install executables, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""bin"". **CMAKE_INSTALL_INCLUDEDIR**:PATH; The path to install header files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""include"". **CMAKE_INSTALL_DOCDIR**:PATH; The path to install documentation, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/doc"". **CMAKE_INSTALL_MANDIR**:PATH; The path to install manpage files, relative to the *CMAKE_INSTALL_PREFIX*.; Defaults to ""share/man"". .. _LLVM-related variables:. LLVM-related variables; -----------------------. These variables provide fine control over the build of LLVM and; enabled sub-projects. Nearly all of these variable names begin with; ``LLVM_``. **BUILD_SHARED_LIBS**:BOOL; Flag indicating if each LLVM component (e.g. Support) is built as a shared; library (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:11317,variab,variables,11317,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,ialization.cpp; clang-tools-extra/clangd/index/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80131,refactor,refactor,80131,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"iases`_, and `lists`_ of options. .. _aliases:. Argument Aliases; ----------------. So far, the example works well, except for the fact that we need to check the; quiet condition like this now:. .. code-block:: c++. ...; if (!Quiet && !Quiet2) printInformationalMessage(...);; ... ... which is a real pain! Instead of defining two values for the same; condition, we can use the ""`cl::alias`_"" class to make the ""``-q``"" option an; **alias** for the ""``-quiet``"" option, instead of providing a value itself:. .. code-block:: c++. cl::opt<bool> Force (""f"", cl::desc(""Overwrite output files""));; cl::opt<bool> Quiet (""quiet"", cl::desc(""Don't print informational messages""));; cl::alias QuietA(""q"", cl::desc(""Alias for -quiet""), cl::aliasopt(Quiet));. The third line (which is the only one we modified from above) defines a ""``-q``""; alias that updates the ""``Quiet``"" variable (as specified by the `cl::aliasopt`_; modifier) whenever it is specified. Because aliases do not hold state, the only; thing the program has to query is the ``Quiet`` variable now. Another nice; feature of aliases is that they automatically hide themselves from the ``-help``; output (although, again, they are still visible in the ``-help-hidden output``). Now the application code can simply use:. .. code-block:: c++. ...; if (!Quiet) printInformationalMessage(...);; ... ... which is much nicer! The ""`cl::alias`_"" can be used to specify an; alternative name for any variable type, and has many uses. .. _unnamed alternatives using the generic parser:. Selecting an alternative from a set of possibilities; ----------------------------------------------------. So far we have seen how the CommandLine library handles builtin types like; ``std::string``, ``bool`` and ``int``, but how does it handle things it doesn't; know about, like enums or '``int*``'s?. The answer is that it uses a table-driven generic parser (unless you specify; your own parser, as described in the `Extension Guide`_). This parser maps; literal str",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:12753,variab,variable,12753,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"iation tool [Clad] have been shown to be far more efficient [^2]. \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. Main Advantage of using AD with RooFit: efficient and more precise; derivatives. It computes derivatives with high precision, avoiding the errors; that may arise from approximating derivatives using finite differences. \htmlonly; </div>; \endhtmlonly. ### AD Support essentially requires Code Generation. As we'll discuss in upcoming sections, *AD support* can be added using *C++; Code generation*.; These two terms may be used interchangeably in this document, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current Status of Code Generation in RooFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent rea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:2304,plugin,plugin,2304,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['plugin'],['plugin']
Modifiability,"ibraries out; there in many different languages, none of them fit well with what I needed. By; looking at the features and problems of other libraries, I designed the; CommandLine library to have the following features:. #. Speed: The CommandLine library is very quick and uses little resources. The; parsing time of the library is directly proportional to the number of; arguments parsed, not the number of options recognized. Additionally,; command line argument values are captured transparently into user defined; global variables, which can be accessed like any other variable (and with the; same performance). #. Type Safe: As a user of CommandLine, you don't have to worry about; remembering the type of arguments that you want (is it an int? a string? a; bool? an enum?) and keep casting it around. Not only does this help prevent; error prone constructs, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types directly, meaning that; there is less error and more security built into the library. You don't have; to worry about whether your integral command line argument accidentally got; assigned a value that is not valid for your enum type. #. Powerful: The CommandLine library supports many different types of arguments,; from simple `boolean flags`_ to `scalars arguments`_ (`strings`_,; `integers`_, `enums`_, `doubles`_), to `lists of arguments`_. This is; possible because CommandLin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:1562,variab,variables,1562,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variables']
Modifiability,"ibrary (ON) or as a static library (OFF). Its default value is OFF. On; Windows, shared libraries may be used when building with MinGW, including; mingw-w64, but not when building with the Microsoft toolchain. .. note:: BUILD_SHARED_LIBS is only recommended for use by LLVM developers.; If you want to build LLVM as a shared library, you should use the; ``LLVM_BUILD_LLVM_DYLIB`` option. **LLVM_ABI_BREAKING_CHECKS**:STRING; Used to decide if LLVM should be built with ABI breaking checks or; not. Allowed values are `WITH_ASSERTS` (default), `FORCE_ON` and; `FORCE_OFF`. `WITH_ASSERTS` turns on ABI breaking checks in an; assertion enabled build. `FORCE_ON` (`FORCE_OFF`) turns them on; (off) irrespective of whether normal (`NDEBUG`-based) assertions are; enabled or not. A version of LLVM built with ABI breaking checks; is not ABI compatible with a version built without it. **LLVM_ADDITIONAL_BUILD_TYPES**:LIST; Adding a semicolon separated list of additional build types to this flag; allows for them to be specified as values in CMAKE_BUILD_TYPE without; encountering a fatal error during the configuration process. **LLVM_UNREACHABLE_OPTIMIZE**:BOOL; This flag controls the behavior of `llvm_unreachable()` in release build; (when assertions are disabled in general). When ON (default) then; `llvm_unreachable()` is considered ""undefined behavior"" and optimized as; such. When OFF it is instead replaced with a guaranteed ""trap"". **LLVM_APPEND_VC_REV**:BOOL; Embed version control revision info (Git revision id).; The version info is provided by the ``LLVM_REVISION`` macro in; ``llvm/include/llvm/Support/VCSRevision.h``. Developers using git who don't; need revision info can disable this option to avoid re-linking most binaries; after a branch switch. Defaults to ON. **LLVM_FORCE_VC_REVISION**:STRING; Force a specific Git revision id rather than calling to git to determine it.; This is useful in environments where git is not available or non-functional; but the VC revision is availa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:12703,config,configuration,12703,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['configuration']
Modifiability,"ibrary (`libCling.so`) is also needed in all ROOT; applications, and even by `libCore`. A; program referencing only **`TObject`** only needs `libCore`;; `libCling` will be opened automatically. To add the ability to read and write; ROOT objects one also has to load `libRIO`. As one would expect, none of that; depends on graphics or the GUI. Library dependencies have different consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17494,config,config,17494,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['config'],['config']
Modifiability,"ibute by adding an ``Attr`` to the; ``Decl``. It returns either ``AttributeApplied``, to indicate that the; attribute was successfully applied, or ``AttributeNotApplied`` if it wasn't. The members of ``ParsedAttrInfo`` that may need to be defined, depending on the; attribute, are:. * ``NumArgs`` and ``OptArgs``, which set the number of required and optional; arguments to the attribute.; * ``diagAppertainsToDecl``, which checks if the attribute has been used on the; right kind of declaration and issues a diagnostic if not.; * ``diagLangOpts``, which checks if the attribute is permitted for the current; language mode and issues a diagnostic if not.; * ``existsInTarget``, which checks if the attribute is permitted for the given; target. To see a working example of an attribute plugin, see `the Attribute.cpp example; <https://github.com/llvm/llvm-project/blob/main/clang/examples/Attribute/Attribute.cpp>`_. Putting it all together; =======================. Let's look at an example plugin that prints top-level function names. This; example is checked into the clang repository; please take a look at; the `latest version of PrintFunctionNames.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/PrintFunctionNames.cpp>`_. Running the plugin; ==================. Using the compiler driver; --------------------------. The Clang driver accepts the `-fplugin` option to load a plugin.; Clang plugins can receive arguments from the compiler driver command; line via the `fplugin-arg-<plugin name>-<argument>` option. Using this; method, the plugin name cannot contain dashes itself, but the argument; passed to the plugin can. .. code-block:: console. $ export BD=/path/to/build/directory; $ make -C $BD CallSuperAttr; $ clang++ -fplugin=$BD/lib/CallSuperAttr.so \; -fplugin-arg-call_super_plugin-help \; test.cpp. If your plugin name contains dashes, either rename the plugin or used the; cc1 command line options listed below. Using the cc1 command line; --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:4131,plugin,plugin,4131,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,1,['plugin'],['plugin']
Modifiability,"ibute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-default-queue"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the default queue pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-no-completion-action"" Similar to amdgpu-no-implicitarg-ptr, except specific to the implicit; kernel argument that holds the completion action pointer. If this; attribute is absent, then the amdgpu-no-implicitarg-ptr is also removed. ""amdgpu-lds-size""=""min[,max]"" Min is the minimum number of bytes that will be allocated in the Local; Data Store at address zero. Variables are allocated within this frame; using absolute symbol metadata, primarily by the AMDGPULowerModuleLDS; pass. Optional max is the maximum number of bytes that will be allocated.; Note that min==max indicates that no further variables can be added to; the frame. This is an internal detail of how LDS variables are lowered,; language front ends should not set this attribute. ======================================= ==========================================================. Calling Conventions; -------------------. The AMDGPU backend supports the following calling conventions:. .. table:: AMDGPU Calling Conventions; :name: amdgpu-cc. =============================== ==========================================================; Calling Convention Description; =============================== ==========================================================; ``ccc`` The C calling convention. Used by default.; See :ref:`amdgpu-amdhsa-function-call-convention-non-kernel-functions`; for more details. ``fastcc`` The fast calling convention. Mostly the same as the ``ccc``. ``coldcc`` The cold calling convention. Mostly the same as the ``ccc``. ``amdgpu_cs`` Used for Mesa/AMDPAL compute shaders.; ..TODO::; Describe. ``amdgpu_cs_chain`` Similar to ``amdgpu_cs``, with differences described below. Functions with this calli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:51785,variab,variables,51785,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['variab'],['variables']
Modifiability,"ibution; -----------------. The LoopDistribution pass tries to separate vectorizable parts of a loop; from the non-vectorizable part (which otherwise would make the entire; loop non-vectorizable). Conceptually, it transforms a loop such as. .. code-block:: c. for (int i = 1; i < n; i+=1) { // original loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }. into the following code:. .. code-block:: c. if (rtc) {; for (int i = 1; i < n; i+=1) // coincident loop; A[i] = i;; for (int i = 1; i < n; i+=1) // coincident loop; B[i] = 2 + B[i];; for (int i = 1; i < n; i+=1) // sequential loop; C[i] = 3 + C[i - 1];; } else {; for (int i = 1; i < n; i+=1) { // fallback loop; A[i] = i;; B[i] = 2 + B[i];; C[i] = 3 + C[i - 1];; }; }. where ``rtc`` is a generated runtime check. ``llvm.loop.distribute.followup_coincident`` sets the loop attributes of; all loops without loop-carried dependencies (i.e. vectorizable loops).; There might be more than one such loops. If not defined, the loops will; inherit the original loop's attributes. ``llvm.loop.distribute.followup_sequential`` sets the loop attributes of the; loop with potentially unsafe dependencies. There should be at most one; such loop. If not defined, the loop will inherit the original loop's; attributes. ``llvm.loop.distribute.followup_fallback`` defines the loop attributes; for the fallback loop, which is a copy of the original loop for when; loop versioning is required. If undefined, the fallback loop inherits; all attributes from the original loop. Attributes defined in ``llvm.loop.distribute.followup_all`` are added to; all of the aforementioned output loops. It is recommended to add ``llvm.loop.disable_nonforced`` to; ``llvm.loop.distribute.followup_fallback``. This avoids that the; fallback version (which is likely never executed) is further optimized; which would increase the code size. Versioning LICM; ---------------. The pass hoists code out of loops that are only loop-invariant when; dynamic conditions apply. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:11872,inherit,inherit,11872,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['inherit'],['inherit']
Modifiability,"ic Libraries; =========================. All libraries that you compile as part of your build will be; cross-compiled to your target, and your build system will probably; find them in the right place. But all dependencies that are; normally checked against (like ``libxml`` or ``libz`` etc) will match; against the host platform, not the target. So, if the build system is not aware that you want to cross-compile; your code, it will get every dependency wrong, and your compilation; will fail during build time, not configure time. Also, finding the libraries for your target are not as easy; as for your host machine. There aren't many cross-libraries available; as packages to most OS's, so you'll have to either cross-compile them; from source, or download the package for your target platform,; extract the libraries and headers, put them in specific directories; and add ``-I`` and ``-L`` pointing to them. Also, some libraries have different dependencies on different targets,; so configuration tools to find dependencies in the host can get the; list wrong for the target platform. This means that the configuration; of your build can get things wrong when setting their own library; paths, and you'll have to augment it via additional flags (configure,; Make, CMake, etc). Multilibs; ---------. When you want to cross-compile to more than one configuration, for; example hard-float-ARM and soft-float-ARM, you'll have to have multiple; copies of your libraries and (possibly) headers. Some Linux distributions have support for Multilib, which handle that; for you in an easier way, but if you're not careful and, for instance,; forget to specify ``-ccc-gcc-name armv7l-linux-gnueabihf-gcc`` (which; uses hard-float), Clang will pick the ``armv7l-linux-gnueabi-ld``; (which uses soft-float) and linker errors will happen. The same is true if you're compiling for different environments, like; ``gnueabi`` and ``androideabi``, and might even link and run, but produce; run-time errors, which ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:8537,config,configuration,8537,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['config'],['configuration']
Modifiability,"ic TMyClass {; public:; void Print() const;; };; void TChild::Print() const // child print metod; {; cout << ""This is TChild::Print()"" << endl;; TMyClass::Print();; }; ```. To execute `script4.C` do:. ``` {.cpp}; root[] .L script4.C; root[] TMyClass *a = new TChild; root[] a->Print(); This is TChild::Print(); fX = -1, fY = -1; root[] a->SetX(10); root[] a->SetY(12); root[] a->Print(); This is TChild::Print(); fX = 10, fY = 12; root[] .class TMyClass; =====================================================; class TMyClass; size=0x8 FILE:script4.C LINE:3; List of base class-----------------------------------; List of member variable------------------------------; Defined in TMyClass; 0x0 private: float fX; 0x4 private: float fY; List of member function------------------------------; Defined in TMyClass; filename line:size busy function type and name; script4.C 16:5 0 public: class TMyClass TMyClass(void);; script4.C 22:4 0 public: void Print(void);; script4.C 12:1 0 public: void SetX(float x);; script4.C 13:1 0 public: void SetY(float y);; root[] .q; ```. As you can see, an interpreted class behaves just like a compiled; class.; See ""Adding a Class"" for ways how to add a class with a shared library; and with ACLiC. ## Inspecting Objects. An object of a class inheriting from `TObject` can be inspected,; with the `Inspect()` method. The `TObject::Inspect` method creates a; window listing the current values of the objects members. For example,; the next picture is of `TFile`. ``` {.cpp}; root[] TFile f(""staff.root""); root[] f.Inspect(); ```. You can see the pointers are in red and can be clicked on to follow; the pointer to the object. If you clicked on `fList`, the list of; objects in memory and there were none, no new canvas would be shown.; On top of the page are the navigation buttons to see the previous and; next screen. ![ROOT object inspector of TFile](pictures/03000092.png). ![The object inspector of `fKeys`, the list of keys in the memory](pictures/03000093.png); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md:26229,inherit,inheriting,26229,documentation/users-guide/Cling.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Cling.md,1,['inherit'],['inheriting']
Modifiability,"ic"" model is used. The models correspond to the ELF TLS models; see `ELF Handling For; Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for; more information on under which circumstances the different models may; be used. The target may choose a different TLS model if the specified; model is not supported, or if a better choice of model can be made. A model can also be specified in an alias, but then it only governs how; the alias is accessed. It will not have any effect in the aliasee. For platforms without linker support of ELF TLS model, the -femulated-tls; flag can be used to generate GCC compatible emulated TLS code. .. _runtime_preemption_model:. Runtime Preemption Specifiers; -----------------------------. Global variables, functions and aliases may have an optional runtime preemption; specifier. If a preemption specifier isn't given explicitly, then a; symbol is assumed to be ``dso_preemptable``. ``dso_preemptable``; Indicates that the function or variable may be replaced by a symbol from; outside the linkage unit at runtime. ``dso_local``; The compiler may assume that a function or variable marked as ``dso_local``; will resolve to a symbol within the same linkage unit. Direct access will; be generated even if the definition is not within this compilation unit. .. _namedtypes:. Structure Types; ---------------. LLVM IR allows you to specify both ""identified"" and ""literal"" :ref:`structure; types <t_struct>`. Literal types are uniqued structurally, but identified types; are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used; to forward declare a type that is not yet available. An example of an identified structure specification is:. .. code-block:: llvm. %mytype = type { %mytype*, i32 }. Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only; literal types are uniqued in recent versions of LLVM. .. _nointptrtype:. Non-Integral Pointer Type; -------------------------. Note: non-integral pointer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:27155,variab,variable,27155,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ic, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal's more complete address space? Or are they intended to represent; source language memory spaces such as in OpenCL?. .. _amdgpu-dwarf-memory-spaces:. A.2.14 Memory Spaces; ~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF memory spaces are used for source languages that have the concept of; memory spaces. They are used in the ``DW_AT_LLVM_memory_space`` attribute for; pointer type, reference type, variable, formal parameter, and constant debugger; information entries. Each DWARF memory space is conceptually a separate source language memory space; with its own lifetime and aliasing rules. DWARF memory spaces are used to; specify the source language memory spaces that pointer type and reference type; values refer, and to specify the source language memory space in which variables; are allocated. Although DWARF memory space identifiers are source language specific,; ``DW_MSPACE_LLVM_none`` is a common memory space supported by all source; languages, and defined as the source language default memory space. The set of currently defined DWARF memory spaces, together with source language; mappings, is given in :ref:`amdgpu-dwarf-source-language-memory-spaces-table`. Vendor defined source language memory spaces may be defined using codes in the; range ``DW_MSPACE_LLVM_lo_user`` to ``DW_MSPACE_LLVM_hi_user``. .. table:: Source language memory spaces; :name: amdgpu-dwarf-source-language-memory-spaces-table. =========================== ============ ============== ============== ==============; Memory Space Name Meaning C/C++ OpenCL CUDA/HIP; =========================== ============ ============== ============== ==============; ``DW_MSPACE_LLVM_none`` generic *default* generic *defa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:150940,variab,variables,150940,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"ical bugs; present before that version were hindering the normal execution of the tool. Consequently, the minimum Python version; needed to include distributed RDataFrame in the ROOT build is Python 3.8. More information in the relative; [github issue](https://github.com/root-project/root/issues/11515).; - `Stats` and `StdDev` operations are now available in distributed mode.; - `GetColumnNames` operation is now available in distributed mode. ## Histogram Libraries. - New class `TGraph2DAsymmErrors` to create TGraph2D with asymmetric errors.; ![TGraph2DAsymmErrors](TGraph2DAsymmErrors.png). ## Math Libraries. ### Fitter class. Some improvements and small fixes to the internal object memory management have been applied to the `ROOT::Fit::Fitter` class.; - When setting an external FCN (objective function) to the Fitter, the function object is not cloned anymore.; - A memory leak has been fixed, when using the `GSLMultiFit` class.; - A bug has been resolved in setting fixed variables when using the linear fitter (via the `TLinearMinimizer` class). Support for providing the second derivatives (Hessian matrix) from the model function is added to the `Fitter` class and the corresponding function interfaces. The functionality it is then propagated in the implementation of the `FitMethod` classes and it is also added to the `Minimizer` classes for providing a user computed Hessian of the objective functions to the minimizers. Only Minuit2 (see below) has the capabilities of using this external Hessian. The `GradFunctor` class has been improved by providing a new constructor taking an `std::function` implementing the full gradient calculations instead of the single partial derivative. The specialized methods for least-square/likelihood functions such as Fumili, Fumili2 and GSLMultiFit have been improved in case of binned likelihood fits, where a better approximation is used than before. This makes these method work better (conerging with less number of function calls) for the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:15235,variab,variables,15235,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['variab'],['variables']
Modifiability,"ically numbered. #. This is a second list element. #. Use indentation to create nested lists. ...as well as unordered lists:. * Stuff. + Deeper stuff. * More stuff. Code Blocks; ===========. You can make blocks of code like this:. .. code-block:: c++. int main() {; return 0;; }. For a shell session, use a ``console`` code block (some existing docs use; ``bash``):. .. code-block:: console. $ echo ""Goodbye cruel world!""; $ rm -rf /. If you need to show LLVM IR use the ``llvm`` code block. .. code-block:: llvm. define i32 @test1() {; entry:; ret i32 0; }. Some other common code blocks you might need are ``c``, ``objc``, ``make``,; and ``cmake``. If you need something beyond that, you can look at the `full; list`_ of supported code blocks. .. _`full list`: http://pygments.org/docs/lexers/. However, don't waste time fiddling with syntax highlighting when you could; be adding meaningful content. When in doubt, show preformatted text; without any syntax highlighting like this:. ::. .; +:.; ..:: ::; .++:+:: ::+:.:.; .:+ :; ::.::..:: .+.; ..:+ :: :; ......+:. ..; :++. .. :; .+:::+:: :; .. . .+ ::; +.: .::+.; ...+. .: .; .++:..; ... Generating the documentation; ============================. You can generate the HTML documentation from the sources locally if you want to; see what they would look like. In addition to the normal; `build tools <GettingStarted.html>`_; you need to install `Sphinx`_ and the necessary extensions; using the following command inside the ``llvm-project`` checkout:. .. code-block:: console. pip install --user -r ./llvm/docs/requirements.txt. Then run cmake to build the documentation inside the ``llvm-project`` checkout:. .. code-block:: console. mkdir build; cd build; cmake -DLLVM_ENABLE_SPHINX=On ../llvm; cmake --build . --target docs-llvm-html. In case you already have the Cmake build set up and want to reuse that,; just set the CMake variable ``LLVM_ENABLE_SPHINX=On``. After that you find the generated documentation in ``build/docs/html``; folder.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst:6144,variab,variable,6144,interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SphinxQuickstartTemplate.rst,1,['variab'],['variable']
Modifiability,"icantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------------------------. Instruction selection creates a MIR function from an IR function, and just as; it transforms ``intermediate`` instructions into machine instructions, so must; ``intermediate`` variable locations become machine variable locations.; Within IR, variable locations are always identified by a Value, but in MIR; there can be different types of variable locations. In addition, some IR; locations become unavailable, for example if the operation of multiple IR; instructions are combined into one machine instruction (such as; multiply-and-accumulate) then intermediate Values are lost. To track variable; locations through instruction selection, they are first separated into; locations that do not depend on code generation (constants, stack locations,; allocated virtual registers) and those that do. For those that do, debug; metadata is attached to SDNodes in SelectionDAGs. After instruction selection; has occurred and a MIR function is created, if the SDNode associated with debug; metadata is allocated a virtual register, that virtual register is used as the; variable location. If the SDNode is folded into a machine instruction or; otherwise transformed into a non-register, the variable location becomes; unavailable. Locations that are unavailable are treated as if they have been optim",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:25834,variab,variable,25834,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['variab'],['variable']
Modifiability,"ich are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of the sandbox,; package directory, cache and dataset directory (the latters two only; for PROOF-Lite); the variable names are 'Proof.Sandbox', ; 'Proof.PackageDir', 'Proof.CacheDir' and 'Proof.DataSetDir'. The default location of the sandbox has been changed from ""~/proof"" to ""~/.proof"" to avoid interferences with possible users' working areas.XrdProofd plug-in. Overall refactorization for easier; maintainance and improved solidity; Improved format of printout messages: all information; messages contain now the tag 'xpd-I' and all error messages the; tag 'xpd-E', so that they can easily be grepped out from the; log file.; . Log sending. Implement selective sending of logs from workers to master to avoid duplicating; too many text lines on the master log. Logs are now sent only after Exec, Print; requests and in case an error (level >= kError) occured. Of course, the full; logs can always be retrieved via TProofMgr::GetSessionLogs; . Log retrieval:. for 'grep' operations, use the system 'grep' command; via 'popen'; instead of a handmade filtering; this implies that the full grep; functionality is now available; set the default number of displayed lines to 100; instead of 10. Improve diagnostic in case of worker death: client",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:4350,sandbox,sandbox,4350,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['sandbox'],['sandbox']
Modifiability,"ich; itself indents the code - unless IndentCaseBlocks is enabled). .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: case 1:; bar(); bar();; break; break;; default: default:; plop(); plop();; } }. .. _IndentExternBlock:. **IndentExternBlock** (``IndentExternBlockStyle``) :versionbadge:`clang-format 11` :ref:`¶ <IndentExternBlock>`; IndentExternBlockStyle is the type of indenting of extern blocks. Possible values:. * ``IEBS_AfterExternBlock`` (in configuration: ``AfterExternBlock``); Backwards compatible with AfterExternBlock's indenting. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: true; extern ""C""; {; void foo();; }. .. code-block:: c++. IndentExternBlock: AfterExternBlock; BraceWrapping.AfterExternBlock: false; extern ""C"" {; void foo();; }. * ``IEBS_NoIndent`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configura",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:72499,config,configuration,72499,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"icit; location descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. 4. ``DW_OP_form_tls_address``. ``DW_OP_form_tls_address`` pops one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:112953,variab,variables,112953,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variables']
Modifiability,"ics with the desired semantics. If you have opted in to custom; lowering of a particular intrinsic your pass **must** eliminate all; instances of the corresponding intrinsic in functions which opt in to; your GC. The best example of such a pass is the ShadowStackGC and it's; ShadowStackGCLowering pass. There is currently no way to register such a custom lowering pass; without building a custom copy of LLVM. .. _safe-points:. Generating safe points; -----------------------. LLVM provides support for associating stackmaps with the return address of; a call. Any loop or return safepoints required by a given collector design; can be modeled via calls to runtime routines, or potentially patchable call; sequences. Using gcroot, all call instructions are inferred to be possible; safepoints and will thus have an associated stackmap. .. _assembly:. Emitting assembly code: ``GCMetadataPrinter``; ---------------------------------------------. LLVM allows a plugin to print arbitrary assembly code before and after the rest; of a module's assembly code. At the end of the module, the GC can compile the; LLVM stack map into assembly code. (At the beginning, this information is not; yet computed.). Since AsmWriter and CodeGen are separate components of LLVM, a separate abstract; base class and registry is provided for printing assembly code, the; ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``. The AsmWriter will look; for such a subclass if the ``GCStrategy`` sets ``UsesMetadata``:. .. code-block:: c++. MyGC::MyGC() {; UsesMetadata = true;; }. This separation allows JIT-only clients to be smaller. Note that LLVM does not currently have analogous APIs to support code generation; in the JIT, nor using the object writers. .. code-block:: c++. // lib/MyGC/MyGCPrinter.cpp - Example LLVM GC printer. #include ""llvm/CodeGen/GCMetadataPrinter.h""; #include ""llvm/Support/Compiler.h"". using namespace llvm;. namespace {; class LLVM_LIBRARY_VISIBILITY MyGCPrinter : public GCMetadataPrinter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:35209,plugin,plugin,35209,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['plugin'],['plugin']
Modifiability,"ictions on use of alignas; Unknown. 2206; C++17; Composite type of object and function pointers; Unknown. 2207; CD5; Alignment of allocation function return value; Unknown. 2208; NAD; static_assert-declaration does not declare a member; Unknown. 2209; NAD; Destruction of constructed array elements; Unknown. 2210; NAD; Principal/target constructor confusion; Unknown. 2211; C++17; Hiding by lambda captures and parameters; Clang 8. 2212; CD5; Typedef changing linkage after use; Unknown. 2213; CD6; Forward declaration of partial specializations; Yes. 2214; C++17; Missing requirement on representation of integer values; Unknown. 2215; C++17; Redundant description of language linkage in function call; Unknown. 2216; NAD; Exception specifications in unevaluated contexts; Unknown. 2217; NAD; constexpr constructors for non-literal types; Unknown. 2218; C++17; Ambiguity and namespace aliases; Unknown. 2219; drafting; Dynamically-unreachable handlers; Not resolved. 2220; C++17; Hiding index variable in range-based for; Unknown. 2221; CD6; Copying volatile objects; Unknown. 2222; drafting; Additional contexts where instantiation is not required; Not resolved. 2223; drafting; Multiple alignas specifiers; Not resolved. 2224; C++17; Member subobjects and base-class casts; Unknown. 2225; NAD; reinterpret_cast to same floating-point type; Unknown. 2226; CD5; Xvalues vs lvalues in conditional expressions; Unknown. 2227; CD5; Destructor access and default member initializers; Unknown. 2228; open; Ambiguity resolution for cast to function type; Not resolved. 2229; CD5; Volatile unnamed bit-fields; Clang 7. 2230; NAD; Linkage of extern ""C"" function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:151282,variab,variable,151282,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"id f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const char* bar = ""bar"";; int baz = 42;; [[clang::require_constant_initialization]] int xyz = 42;; varDecl(isConstinit()); matches the declaration of `foo` and `bar`, but not `baz` and `xyz`. Matcher<VarDecl>isDefinition; Matches if a declaration has a body attached. Example matches A, va, fa; class A {};; class B; // Doesn't match, as it has no body.; int va;; extern int vb; // Doesn't match, as it doesn't define the variable.; void fa() {}; void fb(); // Doesn't match, as it has no body.; @interface X; - (void)ma; // Doesn't match, interface is declaration.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:125537,variab,variable,125537,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"id foo();; void bar(); void bar();; } // namespace a }; namespace shortNamespace { namespace shortNamespace {; void baz(); void baz();; } }. .. _ForEachMacros:. **ForEachMacros** (``List of Strings``) :versionbadge:`clang-format 3.7` :ref:`¶ <ForEachMacros>`; A vector of macros that should be interpreted as foreach loops; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. FOREACH(<variable-declaration>, ...); <loop-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. ForEachMacros: ['RANGES_FOR', 'FOREACH']. For example: BOOST_FOREACH. .. _IfMacros:. **IfMacros** (``List of Strings``) :versionbadge:`clang-format 13` :ref:`¶ <IfMacros>`; A vector of macros that should be interpreted as conditionals; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. IF(...); <conditional-body>; else IF(...); <conditional-body>. In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. IfMacros: ['IF']. For example: `KJ_IF_MAYBE; <https://github.com/capnproto/capnproto/blob/master/kjdoc/tour.md#maybes>`_. .. _IncludeBlocks:. **IncludeBlocks** (``IncludeBlocksStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IncludeBlocks>`; Dependent on the value, multiple ``#include`` blocks can be sorted; as one and divided based on category. Possible values:. * ``IBS_Preserve`` (in configuration: ``Preserve``); Sort each ``#include`` block separately. .. code-block:: c++. #include ""b.h"" into #include ""b.h"". #include <lib/main.h> #include ""a.h""; #include ""a.h"" #include <lib/main.h>. * ``IBS_Merge`` (in configuration: ``Merge``); Merge multiple ``#include`` blocks together and sort as one. .. code-block:: c++. #include ""b.h"" into #include ""a.h""; #include ""b.h""; #include <lib/main.h> #include <lib/main.h>; #include ""a.h"". * ``IBS_Regroup`` (in configuration: ``Regroup``); Merge multiple ``#include`` blocks together and sort as one.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:64908,config,configuration,64908,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"id);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-block:: bash. --- command lines ---; $ clang -flto a.c -c -o a.o # <-- a.o is LLVM bitcode file; $ ar q a.a a.o # <-- a.a is an archive with LLVM bitcode; $ clang b.c -c -o b.o # <-- b.o is native object file; $ clang -flto a.a b.o -o main # <-- link with LLVMgold plugin. Gold informs the plugin that foo3 is never referenced outside the IR,; leading LLVM to delete that function. However, unlike in the :ref:`libLTO; example <libLTO-example>` gold does not currently eliminate foo4. Quickstart for using LTO with autotooled projects; =================================================. Once your system ``ld``, ``ar``, and ``nm`` all support LLVM bitcode,; everything is in place for an easy to use LTO build of autotooled projects:. * Follow the instructions :ref:`on how to build LLVMgold.so; <lto-how-to-build>`. * Install the newly built binutils to ``$PREFIX``. * Copy ``Release/lib/LLVMgold.so`` to ``$PREFIX/lib/bfd-plugins/``. * Set environment variables (``$PREFIX`` is where you installed clang and; binutils):. .. code-block:: bash. export CC=""$PREFIX/bin/clang -flto""; export CXX=""$PREFIX/bin/clang++ -flto""; export AR=""$PREFIX/bin/ar""; export NM=""$PREFIX/bin/nm""; export RANLIB=/bin/true #ranlib is not needed, and doesn't support .bc files in .a. * Or you can just set your path:. .. code-block:: bash. export PATH=""$PREFIX/bin:$PATH""; export CC=""clang -flto""; export CXX=""clang++ -flto""; export RANLIB=/bin/true; * Configure and build the project as usual:. .. code-block:: bash. % ./configure && make && make check. The environment variable settings may work for non-autotooled projects too,; but you may need to set the ``LD`` environment variable as well. Licensing; =========. Gold is licensed under the GPLv3. LLVMgold uses the interface file; ``plugin-api.h`` from gold which means that the resulting ``LLVMgold.so``; binary is also GPLv3. This can still be used to link non-GPLv3 programs; just",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:5145,plugin,plugins,5145,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugins']
Modifiability,"ided by your telephone; service. You also have to learn the framework interfaces, which in; this analogy is the same as learning how to use a telephone. If you are interested in doing physics, a good HEP framework will save; you much work. Next is a list of the more commonly used components of; ROOT: Command Line Interpreter, Histograms and Fitting, Writing a; Graphical User Interface, 2D Graphics, Input/Output , Collection; Classes, Script Processor. There are also less commonly used components, as: 3D Graphics,; Parallel Processing (PROOF), Run Time Type Identification (RTTI),; Socket and Network Communication, Threads. #### Advantages of Frameworks. The benefits of frameworks can be summarized as follows:. - Less code to write - the programmer should be able to use and; reuse the majority of the existing code. Basic functionality, such; as fitting and histogramming are implemented and ready to use and; customize. - More reliable and robust code - the code inherited from a; framework has already been tested and integrated with the rest of; the framework. - More consistent and modular code - the code reuse provides; consistency and common capabilities between programs, no matter; who writes them. Frameworks make it easier to break programs into; smaller pieces. - More focus on areas of expertise - users can concentrate on their; particular problem domain. They do not have to be experts at; writing user interfaces, graphics, or networking to use the; frameworks that provide those services. ### Why Object-Oriented?. Object-Oriented Programming offers considerable benefits compared to; Procedure-Oriented Programming:. - Encapsulation enforces data abstraction and increases opportunity; for reuse. - Sub classing and inheritance make it possible to extend and modify; objects. - Class hierarchies and containment containment hierarchies provide; a flexible mechanism for modeling real-world objects and the; relationships among them. - Complexity is reduced because there is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:7431,inherit,inherited,7431,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['inherit'],['inherited']
Modifiability,"ident = !{!8}. ;; Define the global variable itself; !0 = distinct !DIGlobalVariable(name: ""MyGlobal"", scope: !1, file: !2, line: 1, type: !5, isLocal: false, isDefinition: true, align: 64). ;; Define the compile unit.; !1 = distinct !DICompileUnit(language: DW_LANG_C99, file: !2,; producer: ""clang version 4.0.0"",; isOptimized: false, runtimeVersion: 0, emissionKind: FullDebug,; enums: !3, globals: !4). ;;; ;; Define the file; ;;; !2 = !DIFile(filename: ""/dev/stdin"",; directory: ""/Users/dexonsmith/data/llvm/debug-info""). ;; An empty array.; !3 = !{}. ;; The Array of Global Variables; !4 = !{!0}. ;;; ;; Define the type; ;;; !5 = !DIBasicType(name: ""int"", size: 32, encoding: DW_ATE_signed). ;; Dwarf version to output.; !6 = !{i32 2, !""Dwarf Version"", i32 4}. ;; Debug info schema version.; !7 = !{i32 2, !""Debug Info Version"", i32 3}. ;; Compiler identification; !8 = !{!""clang version 4.0.0""}. The align value in DIGlobalVariable description specifies variable alignment in; case it was forced by C11 _Alignas(), C++11 alignas() keywords or compiler; attribute __attribute__((aligned ())). In other case (when this field is missing); alignment is considered default. This is used when producing DWARF output; for DW_AT_alignment value. C/C++ function information; --------------------------. Given a function declared as follows:. .. code-block:: c. int main(int argc, char *argv[]) {; return 0;; }. a C/C++ front-end would generate the following descriptors:. .. code-block:: text. ;;; ;; Define the anchor for subprograms.; ;;; !4 = !DISubprogram(name: ""main"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; flags: DIFlagPrototyped, isOptimized: false,; retainedNodes: !2). ;;; ;; Define the subprogram itself.; ;;; define i32 @main(i32 %argc, i8** %argv) !dbg !4 {; ...; }. C++ specific debug information; ==============================. C++ special member functions information; ----------------------------------------. DWARF v5 introduces a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:43952,variab,variable,43952,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"identifies a DILocation metadata node. These metadata attributes correspond to the operands of a ``llvm.dbg.declare``; IR intrinsic, see the :ref:`source level debugging<format_common_intrinsics>`; documentation. Varying variable locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Variables that are not always on the stack or change location are specified; with the ``DBG_VALUE`` meta machine instruction. It is synonymous with the; ``llvm.dbg.value`` IR intrinsic, and is written:. .. code-block:: text. DBG_VALUE $rax, $noreg, !123, !DIExpression(), debug-location !456. The operands to which respectively:. 1. Identifies a machine location such as a register, immediate, or frame index,. 2. Is either $noreg, or immediate value zero if an extra level of indirection is to be added to the first operand,. 3. Identifies a ``DILocalVariable`` metadata node,. 4. Specifies an expression qualifying the variable location, either inline or as a metadata node reference,. While the source location identifies the ``DILocation`` for the scope of the; variable. The second operand (``IsIndirect``) is deprecated and to be deleted.; All additional qualifiers for the variable location should be made through the; expression metadata. .. _instruction-referencing-locations:. Instruction referencing locations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This experimental feature aims to separate the specification of variable; *values* from the program point where a variable takes on that value. Changes; in variable value occur in the same manner as ``DBG_VALUE`` meta instructions; but using ``DBG_INSTR_REF``. Variable values are identified by a pair of; instruction number and operand number. Consider the example below:. .. code-block:: text. $rbp = MOV64ri 0, debug-instr-number 1, debug-location !12; DBG_INSTR_REF !123, !DIExpression(DW_OP_LLVM_arg, 0), dbg-instr-ref(1, 0), debug-location !456. Instruction numbers are directly attached to machine instructions with an; optional ``debug-instr-number`` attachment, bef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:26236,variab,variable,26236,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['variab'],['variable']
Modifiability,"ider the following code fragment:. int fetch_object_state(struct MyObject *c) {; if (!c->active) goto error;. __block int result;; run_specially_somehow(^{ result = c->state; });; return result;. error:; fprintf(stderr, ""error while fetching object state"");; return -1;; }. GCC accepts this code, but it produces code that will usually crash; when result goes out of scope if the jump is taken. (It's; possible for this bug to go undetected because it often won't crash if; the stack is fresh, i.e. still zeroed.) Therefore, Clang rejects this; code with a hard error:. t.c:3:5: error: goto into protected scope; goto error;; ^; t.c:5:15: note: jump bypasses setup of __block variable; __block int result;; ^. The fix is to rewrite the code to not require jumping into a; __block variable's scope, e.g. by limiting that scope:. {; __block int result;; run_specially_somehow(^{ result = c->state; });; return result;; }. Non-initialization of __block; variables. In the following example code, the x variable is used before it is; defined:. int f0() {; __block int x;; return ^(){ return x; }();; }. By an accident of implementation, GCC and llvm-gcc unintentionally always; zero initialized __block variables. However, any program which depends; on this behavior is relying on unspecified compiler behavior. Programs must; explicitly initialize all local block variables before they are used, as with; other local variables.; Clang does not zero initialize local block variables, and programs which rely; on such behavior will most likely break when built with Clang. Inline assembly. In general, Clang is highly compatible with the GCC inline assembly; extensions, allowing the same set of constraints, modifiers and operands as GCC; inline assembly.; On targets that use the integrated assembler (such as most X86 targets),; inline assembly is run through the integrated assembler instead of your system; assembler (which is most commonly ""gas"", the GNU assembler). The LLVM; integrated assembler i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html:6686,variab,variable,6686,interpreter/llvm-project/clang/www/compatibility.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/compatibility.html,1,['variab'],['variable']
Modifiability,"idth. <kind> defaults to ``integer`` if unspecified. .. option:: -fblocks. Enable the ""Blocks"" language feature. .. option:: -fobjc-abi-version=version. Select the Objective-C ABI version to use. Available versions are 1 (legacy; ""fragile"" ABI), 2 (non-fragile ABI 1), and 3 (non-fragile ABI 2). .. option:: -fobjc-nonfragile-abi-version=<version>. Select the Objective-C non-fragile ABI version to use by default. This will; only be used as the Objective-C ABI when the non-fragile ABI is enabled; (either via :option:`-fobjc-nonfragile-abi`, or because it is the platform; default). .. option:: -fobjc-nonfragile-abi, -fno-objc-nonfragile-abi. Enable use of the Objective-C non-fragile ABI. On platforms for which this is; the default ABI, it can be disabled with :option:`-fno-objc-nonfragile-abi`. Target Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~~. Clang fully supports cross compilation as an inherent part of its design.; Depending on how your version of Clang is configured, it may have support for a; number of cross compilers, or may only support a native target. .. option:: -arch <architecture>. Specify the architecture to build for (Mac OS X specific). .. option:: -target <architecture>. Specify the architecture to build for (all platforms). .. option:: -mmacosx-version-min=<version>. When building for macOS, specify the minimum version supported by your; application. .. option:: -miphoneos-version-min. When building for iPhone OS, specify the minimum version supported by your; application. .. option:: --print-supported-cpus. Print out a list of supported processors for the given target (specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should gene",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:9086,config,configured,9086,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,1,['config'],['configured']
Modifiability,"ied offset. .. option:: --arch-name=<string>. Specify the target architecture when disassembling. Use :option:`--version`; for a list of available targets. .. option:: --build-id=<string>. Look up the object using the given build ID, specified as a hexadecimal; string. The found object is handled as if it were an input filename. .. option:: -C, --demangle. Demangle symbol names in the output. .. option:: --debug-file-directory <path>. Provide a path to a directory with a `.build-id` subdirectory to search for; debug information for stripped binaries. Multiple instances of this argument; are searched in the order given. .. option:: --debuginfod, --no-debuginfod. Whether or not to try debuginfod lookups for debug binaries. Unless specified,; debuginfod is only enabled if libcurl was compiled in (``LLVM_ENABLE_CURL``); and at least one server URL was provided by the environment variable; ``DEBUGINFOD_URLS``. .. option:: --debug-vars=<format>. Print the locations (in registers or memory) of source-level variables; alongside disassembly. ``format`` may be ``unicode`` or ``ascii``, defaulting; to ``unicode`` if omitted. .. option:: --debug-vars-indent=<width>. Distance to indent the source-level variable display, relative to the start; of the disassembly. Defaults to 52 characters. .. option:: -j, --section=<section1[,section2,...]>. Perform commands on the specified sections only. For Mach-O use; `segment,section` to specify the section name. .. option:: -l, --line-numbers. When disassembling, display source line numbers. Implies; :option:`--disassemble`. .. option:: -M, --disassembler-options=<opt1[,opt2,...]>. Pass target-specific disassembler options. Available options:. * ``reg-names-std``: ARM only (default). Print in ARM 's instruction set documentation, with r13/r14/r15 replaced by sp/lr/pc.; * ``reg-names-raw``: ARM only. Use r followed by the register number.; * ``no-aliases``: AArch64 and RISC-V only. Print raw instruction mnemonic instead of pseudo instruction ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst:4174,variab,variables,4174,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-objdump.rst,1,['variab'],['variables']
Modifiability,"ied on the browser objects - can be `name`,; `type`, `size`, `date`:. ``` {.cpp}; Browser.SortBy: name; ```. Number of items in a group view:. ``` {.cpp}; Browser.GroupView: 10000; ```. Show or not hidden items:. ``` {.cpp}; Browser.ShowHidden: no; ```. Create a thumbnail view after executing the macro (default is `yes`). ``` {.cpp}; Browser.AutoThumbnail: yes; ```. ### TRint Specific Settings. Rint (interactive ROOT executable) specific alias, logon and logoff; macros. ``` {.cpp}; Rint.Load: rootalias.C; Rint.Logon: rootlogon.C; Rint.Logoff: rootlogoff.C; ```. Record ROOT session commands in a given history file (default is; `$(HOME)/.root_hist`). If set to ""`-`"", it turn off the command; recording. ``` {.cpp}; Rint.History: $(HOME)/.root_hist; ```. Next two lines set the history file size handling. Once `HistSize` is; reached, the last `HistSave` entries are removed. If `HistSize` is set; to 0, it turns off command recording. Both values can be overridden by; environment variable `ROOT_HIST=size[:save]`, where the ""`:save`"" part; is optional. ``` {.cpp}; Rint.HistSize: 500; Rint.HistSave: 400; ```. ### ACLiC Specific Settings. `ACLiC.Linkdef` specifies the suffix that will be added to the script; name to try to locate a custom linkdef file when generating the; dictionary. ``` {.cpp}; ACLiC.Linkdef: _linkdef; ```. The top directory for storing the libraries produced by ACLiC is set by:. ``` {.cpp}; ACLiC.BuildDir: /where/I/would/like/my/compiled/scripts; ```. The additional include directives for ACLiC compilations are set by:. ``` {.cpp}; ACLiC.IncludePaths: -I/where/the/includes/are; ```. ### PROOF Related Variables. PROOF debug options. ``` {.cpp}; Proof.DebugLevel: 0; Proof.DebugMask:-1; ```. PROOF GDB hooks allows a debugger to be attached early in the startup; phase of `proofserv: `0 - don't wait; 1 - master proofserv enters wait; loop; 2 - slave proofserv enters wait loop; 3 - any proofserv enters; wait loop. ``` {.cpp}; Proof.GdbHook: 0; ```. On the master t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md:12660,variab,variable,12660,documentation/users-guide/InstallandBuild.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InstallandBuild.md,1,['variab'],['variable']
Modifiability,"ield,Column,Cluster,...}Descriptor; The descriptor classes provide read-only access to the on-disk meta-data of an RNTuple.; The meta-data include the schema (fields and columns), information about clusters and the page locations.; The descriptor classes are closely related to the format specification. For normal read and write tasks, access to the descriptor is not necessary.; One notable exception is bulk reading, where the descriptor can be used to determine entry boundaries of clusters.; The descriptors are used internally, e.g. to build an RNTupleModel from the on-disk information.; The descriptors are also useful for inspection purposes. The descriptor classes contain a copy of the meta-data; they are not linked to an open page source.; A descriptor can be used after its originating page source has been deleted. ### RField<T>; The RField<T> classes are central in RNTuple:; they link the in-memory representation of data types to their on-disk representation.; All field classes inherit from `RFieldBase`. Every type with RNTuple I/O supported has a corresponding RField<T> template specialization.; Complex types are composed of fields and sub fields.; E.g., a `struct` is represented by a parent field for the `struct` itself and a subfield for every member of the `struct`.; Fields of complex types have type-erased versions in addition to the templated ones (e.g., `RVectorField`, `RClassField`).; In this way, fields can be constructed even if the type information is only available at runtime.; To this end, `RFieldBase::Create()` creates an `RField` object from a type string. On the ""in-memory"" side, fields can construct and destroy objects of their wrapped type; (cf. `CreateValue()`, `CreateObject()`, `GetDeleter()` methods).; Existing objects in memory can be bound to fields (cf. `BindValue()` method). On the ""on-disk"" side, fields know about the possible column representations of their wrapped type.; Upon connecting a field to a page source or page sink,; fields c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:7844,inherit,inherit,7844,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['inherit'],['inherit']
Modifiability,"iends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative values were ignored and there was no way for the user to disable the use of submergers). . Packetizer optimizations: improved worked distribution when; the number of files left to be processed is smaller than the number of; workers and at least one file has a number of events significantly; larger than the average; better apply the upper/lower limits on the; expected packet processing time.; Add the possibility to single-out disk partitions in the; packetizer; this works adding the beginning of a path in the name; defining a new TFileNode (e.g. 'host://disk1' instead of 'host' only as; it was so far). These feature can be enabled by defining the rootrc; vari",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:6619,variab,variable,6619,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"ients; Integration with IDEs; Use the LLVM 'BSD' License. Internal Design and Implementation:. A real-world, production quality compiler; A simple and hackable code base; A single unified parser for C, Objective C, C++,; and Objective C++; Conformance with C/C++/ObjC and their; variants. End-User Features. Fast compiles and Low Memory Use. A major focus of our work on clang is to make it fast, light and scalable.; The library-based architecture of clang makes it straight-forward to time and; profile the cost of each layer of the stack, and the driver has a number of; options for performance analysis. Many detailed benchmarks can be found online.; Compile time performance is important, but when using clang as an API, often; memory use is even more so: the less memory the code takes the more code you can; fit into memory at a time (useful for whole program analysis tools, for; example).; In addition to being efficient when pitted head-to-head against GCC in batch; mode, clang is built with a library based; architecture that makes it relatively easy to adapt it and build new tools; with it. This means that it is often possible to apply out-of-the-box thinking; and novel techniques to improve compilation in various ways. Expressive Diagnostics. In addition to being fast and functional, we aim to make Clang extremely user; friendly. As far as a command-line compiler goes, this basically boils down to; making the diagnostics (error and warning messages) generated by the compiler; be as useful as possible. There are several ways that we do this, but the; most important are pinpointing exactly what is wrong in the program,; highlighting related information so that it is easy to understand at a glance,; and making the wording as clear as possible.; Here is one simple example that illustrates the quality of Clang diagnostic:. $ clang -fsyntax-only t.c; t.c:7:39: error: invalid operands to binary expression ('int' and 'struct A'); return y + func(y ? ((SomeA.X + 40) + SomeA) / ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html:1439,adapt,adapt,1439,interpreter/llvm-project/clang/www/features.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/features.html,1,['adapt'],['adapt']
Modifiability,"ier). A text/uri-list is a standard file listing format; for drag and drop that specifies a list of files (each file per line).; Each line ends with a carriage return and newline` rn`. File names have; to be valid, url-encoded URI's as shown below:. `file://localhost/usr/bin/opera` or; `file://localhost/c:/programs/myfile.txt`. `file://server/data/software.xml` or; `http://root.cern.ch/root/images/ftpstats.gif`. The atoms and the drag and drop manager (**`TGDNDManager`**), are; created at the main application creation time (class TGMainFrame). Setting a Drag Source - first, create and fill data:. ``` {.cpp}; TH1F *h = new TH1F(""h"",""h"",1000,-3,3);; h->FillRandom(""gaus"",50000);; TDNDdata data;; TBufferFile *buf = new TBufferFile(TBuffer::kWrite);; buf->WriteObject(h);; data.fData = buf->Buffer();; data.fDataLength = buf->Length();; data.fDataType = gVirtualX->InternAtom(""application/root"");; ```. Then, set a GUI widget as DND Source, and associate the data. Source; widget can be any class inheriting from **`TGFrame`**. ``` {.cpp}; SourceWidget=new TGIcon(this,gClient->GetPicture(""f1_s.xpm""),32,32);; SourceWidget->SetDNDSource(kTRUE);; SourceWidget->SetDNDdata(&data);; ```. Setting A Drop Target - set the widget as DND Target, and set the DND; types it must be aware of: as `SourceWidget`, `TargetWidget` can be any; class inheriting from **`TGFrame`**. ``` {.cpp}; TargetWidget = new TRootEmbeddedCanvas(""Target"", this, 700, 400);; TargetWidget->SetDNDTarget(kTRUE);; gVirtualX->SetDNDAware(TargetWidget->GetId(),; gDNDManager->GetTypeList());; ```. `gDNDManager->GetTypeList()` returns the list of types recognized by; ROOT. Note that the Widget may receive drag and drop messages with drop-data; it does not understand, and thus it should only accept drops of the; proper type. ### Handling Drag and Drop Events. Once a widget has been set as DND Target, it has to handle Drag and Drop; events. `Atom_t HandleDNDenter(Atom_t *typelist)` - this method is used to; handle a drag oper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:110086,inherit,inheriting,110086,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['inherit'],['inheriting']
Modifiability,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62214,config,configuration,62214,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ies ; and depends on ROOT, is is advised to compile first ROOT without VecGeom support, ; then compile VecGeom against this ROOT version, then re-configure ROOT to enable ; VecGeom and Vc support, using the flags -Dvc=ON -Dvecgeom=on; ; This has been implemented by Mihaela Gheata <Mihaela.Gheata@cern.ch>. ## Database Libraries. * Fix `TPgSQLStatement::SetBinary` to actually handle binary data (previous limited to ascii). ## Networking Libraries. * When seeing too many requested ranges, Apache 2.4 now simply sends the whole file; (MaxRanges configuration parameter). TWebFile can handle this case now, but this can; trigger multiple transmissions of the full file. TWebFile warns when Apache reacts by; sending the full file. ## GUI Libraries. * A new `Browser.ExpandDirectories` option (the default is `yes`) has been added, allowing to prevent expanding the parent directory tree in the ROOT Browser (for example on nfs). ## Language Bindings. ### PyROOT. * Added a new configuration option to disable processing of the rootlogon[.py|C] macro in addition; ro the -n option in the command arguments. To disable processing the rootlogon do the following; before any other command that will trigger initialization:; ```; >>> import ROOT; >>> ROOT.PyConfig.DisableRootLogon = True; >>> ...; ```. ### Notebook integration. * Refactoring of the Jupyter integration layer into the new package JupyROOT.; * Added ROOT [Jupyter Kernel for ROOT](https://root.cern.ch/root-has-its-jupyter-kernel); * Magics are now invoked with standard syntax ""%%"", for example ""%%cpp"".; * The methods ""toCpp"" and ""toPython"" have been removed.; * Factorise output capturing and execution in an accelerator library and use ctypes to invoke functions.; * When the ROOT kernel is used, the output is consumed progressively; * Capture unlimited output also when using an IPython Kernel (fixes [ROOT-7960]). ## JavaScript ROOT. - New geometry (TGeo) classes support:; - browsing through volumes hieararchy; - changing visibil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:25246,config,configuration,25246,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,1,['config'],['configuration']
Modifiability,"ies; of large commits. The principle advantage of this approach is that it minimises the cost of; inconsistency [BradburyTransition]_ [RobinsonTransition]_. It goes against a policy of avoiding large-scale reformatting of existing code; [GreeneDistinguish]_. It has been suggested that LLD would be a good starter project for the renaming; [Ueyama]_. Keeping git blame usable; ************************. ``git blame`` (or ``git annotate``) permits quickly identifying the commit that; changed a given line in a file. After renaming variables, many lines will show; as being changed by that one commit, requiring a further invocation of ``git; blame`` to identify prior, more interesting commits [GreeneGitBlame]_; [RicciAcronyms]_. **Mitigation**: `git-hyper-blame; <https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/git-hyper-blame.html>`_; can ignore or ""look through"" a given set of commits.; A ``.git-blame-ignore-revs`` file identifying the variable renaming commits; could be added to the LLVM git repository root directory.; It is being `investigated; <https://public-inbox.org/git/20190324235020.49706-1-michael@platin.gs/>`_; whether similar functionality could be added to ``git blame`` itself. Minimising cost of downstream merges; ************************************. There are many forks of LLVM with downstream changes. Merging a large-scale; renaming change could be difficult for the fork maintainers. **Mitigation**: A large-scale renaming would be automated. A fork maintainer can; merge from the commit immediately before the renaming, then apply the renaming; script to their own branch. They can then merge again from the renaming commit,; resolving all conflicts by choosing their own version. This could be tested on; the [SVE]_ fork. Provisional Plan; ================. This is a provisional plan for the `Big bang`_ approach. It has not been agreed. #. Investigate improving ``git blame``. The extent to which it can be made to; ""look throu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst:9599,variab,variable,9599,interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/VariableNames.rst,1,['variab'],['variable']
Modifiability,"iew and ELF targets with recent versions of Clang, GCC and MSVC; (-O0 -g). .. code-block:: c++. // definitions.h; #ifdef _MSC_VER; #define forceinline __forceinline; #elif defined(__clang__); #if __has_attribute(__always_inline__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #endif; #elif defined(__GNUC__); #define forceinline inline __attribute__((__always_inline__)); #else; #define forceinline inline; #error; #endif. As the test is dependent on inline compiler options, the above header; file defines *forceinline*. .. code-block:: c++. #include ""definitions.h"". .. code-block:: c++. 1 #include ""definitions.h""; 2 forceinline int InlineFunction(int Param) {; 3 int Var_1 = Param;; 4 {; 5 int Var_2 = Param + Var_1;; 6 Var_1 = Var_2;; 7 }; 8 return Var_1;; 9 }; 10; 11 int test(int Param_1, int Param_2) {; 12 int A = Param_1;; 13 A += InlineFunction(Param_2);; 14 return A;; 15 }. The above test is used to illustrate a variable issue found in the Clang; compiler:; `PR43860 (Bugs LLVM) <https://bugs.llvm.org/show_bug.cgi?id=43860>`_ /; `PR43205 (GitHub) <https://github.com/llvm/llvm-project/issues/43205>`_. These are the logical views that :program:`llvm-debuginfo-analyzer`; generates for 3 different compilers (MSVC, Clang and GCC), emitting; different debug information formats (CodeView, DWARF) on different; platforms. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format,producer; --output-sort=name; --print=symbols; pr-43860-codeview-clang.o; pr-43860-codeview-msvc.o; pr-43860-dwarf-clang.o; pr-43860-dwarf-gcc.o. CODEVIEW - Clang (Windows); ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'clang version 14.0.0'; [002] 2 {Function} inlined 'InlineFunction' -> 'int'; [003] {Parameter} '' -> 'int'; [002] {Function} extern not_inlined 'test' -> 'int'; [003] {Variable} 'A' -> 'int'; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:49589,variab,variable,49589,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variable']
Modifiability,"iews.llvm.org/D95776 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Generic address space | :good:`done` | https://reviews.llvm.org/D95778 and https://reviews.llvm.org/D103401 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Builtin function overloads with generic address space | :good:`done` | https://reviews.llvm.org/D105526, https://reviews.llvm.org/D107769 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | Program scope variables in global memory | :good:`done` | https://reviews.llvm.org/D103191 |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | 3D image writes including builtin functions | :good:`done` | https://reviews.llvm.org/D106260 (frontend) |; +------------------------------+-------------------------+-----------------------------------------+----------------------+--------------------------------------------------------------------------------------------------------------------------------+; | Feature optionality | read_write images including builtin functions | :good:`done` | https://reviews.llvm.org/D104915 (frontend) and https://reviews.llvm.o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:17586,variab,variables,17586,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['variab'],['variables']
Modifiability,"if any dbg.value has its operand optimized out and cannot be; recovered, then a kill dbg.value is necessary to terminate earlier variable; locations. Additional kill dbg.values may be necessary when the debugger can; observe re-ordering of assignments. How variable location metadata is transformed during CodeGen; ============================================================. LLVM preserves debug information throughout mid-level and backend passes,; ultimately producing a mapping between source-level information and; instruction ranges. This; is relatively straightforwards for line number information, as mapping; instructions to line numbers is a simple association. For variable locations; however the story is more complex. As each ``llvm.dbg.value`` intrinsic; represents a source-level assignment of a value to a source variable, the; variable location intrinsics effectively embed a small imperative program; within the LLVM IR. By the end of CodeGen, this becomes a mapping from each; variable to their machine locations over ranges of instructions.; From IR to object emission, the major transformations which affect variable; location fidelity are:. 1. Instruction Selection; 2. Register allocation; 3. Block layout. each of which are discussed below. In addition, instruction scheduling can; significantly change the ordering of the program, and occurs in a number of; different passes. Some variable locations are not transformed during CodeGen. Stack locations; specified by ``llvm.dbg.declare`` are valid and unchanging for the entire; duration of the function, and are recorded in a simple MachineFunction table.; Location changes in the prologue and epilogue of a function are also ignored:; frame setup and destruction may take several instructions, require a; disproportionate amount of debugging information in the output binary to; describe, and should be stepped over by debuggers anyway. Variable locations in Instruction Selection and MIR; ---------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:24569,variab,variable,24569,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves up the; inheritance tree until it reaches an ancestor without a parent. To; serialize the object data members it calls their `Streamer`. They in; turn move up their own inheritance tree and so forth. The simple data; members are written to the buffer directly. Eventually the buffer; contains all simple data members of all the classes that make up this; particular object. Data members that are references (as; `MyClass &fObj;`) are never saved, it is always the responsibility of; the object's constructor to set them properly. ### Automatically Generated Streamers. A `Streamer `usually calls other `Streamers`: the `Streamer `of its; parents and data members. This architecture depends on all classes; having `Streamers`, because eventually they will be called. To ensure; that a class has a `Streamer`, `rootcling` automatically creates one in; the `ClassDef` macro that is defined in `$ROOTSYS/include/Rtypes.h`.; `ClassDef` defines several methods for any class, and one of them is the; `Streamer`. The automatically generated `Streamer `is complete and can; be used as long as no customization is needed. The `Event` class is defined in `$ROOTSYS/test/Event.h`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:43161,inherit,inheritance,43161,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['inherit'],['inheritance']
Modifiability,"if it did, it could not eliminate the sext. 4) the code; generator has historically assumed that the result is extended to i32, which is; a problem on PIC16 (and is also probably wrong on alpha and other 64-bit; targets). //===----------------------------------------------------------------------===//; // The proposal; //===----------------------------------------------------------------------===//. I suggest that we have the front-end fully lower out the ABI issues here to; LLVM IR. This makes it 100% explicit what is going on and means that there is; no cause for confusion. For example, the cases above should compile into:. define i32 @z() nounwind {; entry:; %0 = tail call i32 (...)* @y() nounwind; 	%1 = trunc i32 %0 to i16; %2 = sext i16 %1 to i32; ret i32 %2; }; define i32 @b() nounwind {; entry:; 	%0 = tail call i32 (...)* @a() nounwind; 	%retval12 = trunc i32 %0 to i16; 	%tmp = sext i16 %retval12 to i32; 	ret i32 %tmp; }. In this model, no functions will return an i1/i8/i16 (and on a x86-64 target; that extends results to i64, no i32). This solves the ambiguity issue, allows us ; to fully describe all possible ABIs, and now allows the optimizers to reason; about and eliminate these extensions. The one thing that is missing is the ability for the front-end and optimizer to; specify/infer the guarantees provided by the ABI to allow other optimizations.; For example, in the y/z case, since y is known to return a sign extended value,; the trunc/sext in z should be eliminable. This can be done by introducing new sext/zext attributes which mean ""I know; that the result of the function is sign extended at least N bits. Given this,; and given that it is stuck on the y function, the mid-level optimizer could; easily eliminate the extensions etc with existing functionality. The major disadvantage of doing this sort of thing is that it makes the ABI; lowering stuff even more explicit in the front-end, and that we would like to; eventually move to having the code generat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt:3741,extend,extends,3741,interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExtendedIntegerResults.txt,1,['extend'],['extends']
Modifiability,"if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83947,variab,variables,83947,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"if they were disjoint partitions of the; memory (that is, if you have one variable, as above, it represents the entire; memory, and if you have multiple variables, each one represents some; disjoint portion of the memory). First, because alias analysis results conflict with each other, and; each result may be what an analysis wants (IE; TBAA may say no-alias, and something else may say must-alias), it is; not possible to partition the memory the way every optimization wants.; Second, some alias analysis results are not transitive (IE A noalias B,; and B noalias C, does not mean A noalias C), so it is not possible to; come up with a precise partitioning in all cases without variables to; represent every pair of possible aliases. Thus, partitioning; precisely may require introducing at least N^2 new virtual variables,; phi nodes, etc. Each of these variables may be clobbered at multiple def sites. To give an example, if you were to split up struct fields into; individual variables, all aliasing operations that may-def multiple struct; fields, will may-def more than one of them. This is pretty common (calls,; copies, field stores, etc). Experience with SSA forms for memory in other compilers has shown that; it is simply not possible to do this precisely, and in fact, doing it; precisely is not worth it, because now all the optimizations have to; walk tons and tons of virtual variables and phi nodes. So we partition. At the point at which you partition, again,; experience has shown us there is no point in partitioning to more than; one variable. It simply generates more IR, and optimizations still; have to query something to disambiguate further anyway. As a result, LLVM partitions to one variable. Precision in practice; ^^^^^^^^^^^^^^^^^^^^^. In practice, there are implementation details in LLVM that also affect the; results' precision provided by ``MemorySSA``. For example, AliasAnalysis has various; caps, or restrictions on looking through phis which can affect what ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:17715,variab,variables,17715,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['variab'],['variables']
Modifiability,"if( NOT LLVM_BUILD_TOOLS ); set(EXCLUDE_FROM_ALL ON); endif(). # If we don't need RTTI or EH, there's no reason to export anything; # from this plugin.; if( NOT LLVM_REQUIRES_RTTI ); if( NOT LLVM_REQUIRES_EH ); set(LLVM_EXPORTED_SYMBOL_FILE ${CMAKE_CURRENT_SOURCE_DIR}/bugpoint.exports); endif(); endif(). if(WIN32 OR CYGWIN OR ZOS); set(LLVM_LINK_COMPONENTS Core Support); endif(). add_llvm_library( BugpointPasses MODULE BUILDTREE_ONLY; TestPasses.cpp. DEPENDS; intrinsics_gen; bugpoint; ); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt:144,plugin,plugin,144,interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint-passes/CMakeLists.txt,1,['plugin'],['plugin']
Modifiability,"if(LLVM_BYE_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_BYE_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(Bye; Bye.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt:138,plugin,plugin,138,interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Bye/CMakeLists.txt,2,['plugin'],['plugin']
Modifiability,"if(LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS); message(WARNING ""Setting LLVM_EXAMPLEIRTRANSFORMS_LINK_INTO_TOOLS=ON only makes sense for testing purpose""); endif(). # The plugin expects to not link against the Support and Core libraries,; # but expects them to exist in the process loading the plugin. This doesn't; # work with DLLs on Windows (where a shared library can't have undefined; # references), so just skip this example on Windows.; if (NOT WIN32 AND NOT CYGWIN); add_llvm_pass_plugin(ExampleIRTransforms; SimplifyCFG.cpp; DEPENDS; intrinsics_gen; BUILDTREE_ONLY; ). install(TARGETS ${name} RUNTIME DESTINATION ""${LLVM_EXAMPLES_INSTALL_DIR}""); set_target_properties(${name} PROPERTIES FOLDER ""Examples""); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt:170,plugin,plugin,170,interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/IRTransforms/CMakeLists.txt,2,['plugin'],['plugin']
Modifiability,"if(NOT asan OR MSVC); return(); endif(). # Make a shared library that holds the ROOT default config for address sanitizer.; # This is can be used with LD_PRELOAD; add_library(ROOTSanitizerConfig SHARED SanitizerSetup.cxx). # Make a static library that holds the ROOT default config for address sanitizer.; # We link this into all executables in ROOT, so they automatically start up with good defaults.; set(library ROOTStaticSanitizerConfig); add_library(${library} STATIC SanitizerSetup.cxx); set_property(TARGET ${library} PROPERTY POSITION_INDEPENDENT_CODE ON). # This pulls in the sanitizer link flags when linking against the config library; target_link_libraries(${library} INTERFACE ${ASAN_EXTRA_EXE_LINKER_FLAGS}). # Make it visible to the outside to sanitize e.g. roottest executables; set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${library}); add_library(ROOT::${library} ALIAS ${library}). # Now sanitize executables that are not created with ROOT_EXECUTABLE():; foreach(target llvm-min-tblgen llvm-tblgen clang-tblgen); target_link_libraries(${target} PRIVATE ${library}); endforeach(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt:93,config,config,93,core/sanitizer/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt,3,['config'],['config']
Modifiability,"ifficult to support on-the-fly redefinition; of the event weight variable in the new data store scheme. To declare a data set weighed,; use the WeightVar() modifier of the constructor instead,e.g.:. RooDataSet wdata(""wdata"",""wdata"",RooArgSet(x,y,wgt),WeightVar(wgt)) ;. The RooHist class that represents data as a histogram in a RooPlot has been modified; so that it can show approximate Poisson errors for non-integer data. These approximate; errors are calculated from interpolation of the error bars of the nearest integers. NB: A weighted dataset; plotted with RooAbsData::plotOn() will be default show sum-of-weights-squared errors. Only; when Poisson error are forced through a DataError(RooAbsData::Poisson) argument these; approximate Poisson error bars are shown. Miscellaneous improvements other. The RooFit messagee service class RooMsgService has been augmented with a stack that; can store its configurate state information. A call to saveState() will save the; present configuration, which can be restored through a subsequent call to restoreState().; In addition to the method RooAbsArg::printCompactTree() which is mostly intende for; debugging, a new method RooAbsArg::printComponentTree() has been added that prints; the tree structure of a pdf in a more user-friendly content oriented way. The printing ; of the leaf nodes (the variables) is omitted in this method to keep the output compact. RooStats. This release contains significant bug fixes and it is strongly; recommended to update to this version if using older ones. . Major Changes in LimitCalculator and HypoTestCalculator classes: usage of ModelConfig class. The RooStats calculator interfaces have been changed to use the ModelConfig class.; All the setter methods with the parameter lists, pdf instances and name have been removed from the interfaces.; The SetWorkspace(RooWorkspace & ) has also been removed, while a SetModel(const ModelConfig &); function is introduced. Users are supposed to pass all the model info",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:10853,config,configuration,10853,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,1,['config'],['configuration']
Modifiability,"ific; complaint is that people perceive LLVM as being incapable of performing; high-level language-specific optimization: LLVM ""loses too much; information"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:9856,enhance,enhance,9856,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['enhance'],['enhance']
Modifiability,"ification string. MODULE_CODE_ASM Record; ^^^^^^^^^^^^^^^^^^^^^^. ``[ASM, ...string...]``. The ``ASM`` record (code 4) contains a variable number of values representing; the bytes of ``module asm`` strings, with individual assembly blocks separated; by newline (ASCII 10) characters. .. _MODULE_CODE_SECTIONNAME:. MODULE_CODE_SECTIONNAME Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[SECTIONNAME, ...string...]``. The ``SECTIONNAME`` record (code 5) contains a variable number of values; representing the bytes of a single section name string. There should be one; ``SECTIONNAME`` record for each section name referenced (e.g., in global; variable or function ``section`` attributes) within the module. These records; can be referenced by the 1-based index in the *section* fields of ``GLOBALVAR``; or ``FUNCTION`` records. MODULE_CODE_DEPLIB Record; ^^^^^^^^^^^^^^^^^^^^^^^^^. ``[DEPLIB, ...string...]``. The ``DEPLIB`` record (code 6) contains a variable number of values representing; the bytes of a single dependent library name string, one of the libraries; mentioned in a ``deplibs`` declaration. There should be one ``DEPLIB`` record; for each library name referenced. MODULE_CODE_GLOBALVAR Record; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``[GLOBALVAR, strtab offset, strtab size, pointer type, isconst, initid, linkage, alignment, section, visibility, threadlocal, unnamed_addr, externally_initialized, dllstorageclass, comdat, attributes, preemptionspecifier]``. The ``GLOBALVAR`` record (code 7) marks the declaration or definition of a; global variable. The operand fields are:. * *strtab offset*, *strtab size*: Specifies the name of the global variable.; See `STRTAB_BLOCK Contents`_. * *pointer type*: The type index of the pointer type used to point to this; global variable. * *isconst*: Non-zero if the variable is treated as constant within the module,; or zero if it is not. * *initid*: If non-zero, the value index of the initializer for this variable,; plus 1. .. _linkage type:. * *linkage*: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst:26701,variab,variable,26701,interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BitCodeFormat.rst,1,['variab'],['variable']
Modifiability,"ified; ``<N>`` has precedence. The default is 5. .. option:: --dump-input-filter <value>. In the dump requested by ``--dump-input``, print only input lines of kind; ``<value>`` plus any context specified by ``--dump-input-context``. When; there are multiple occurrences of this option, the ``<value>`` that appears; earliest in the list below has precedence. The default is ``error`` when; ``--dump-input=fail``, and it's ``all`` when ``--dump-input=always``. * ``all`` - All input lines; * ``annotation-full`` - Input lines with annotations; * ``annotation`` - Input lines with starting points of annotations; * ``error`` - Input lines with starting points of error annotations. .. option:: --enable-var-scope. Enables scope for regex variables. Variables with names that start with ``$`` are considered global and; remain set throughout the file. All other variables get undefined after each encountered ``CHECK-LABEL``. .. option:: -D<VAR=VALUE>. Sets a filecheck pattern variable ``VAR`` with value ``VALUE`` that can be; used in ``CHECK:`` lines. .. option:: -D#<FMT>,<NUMVAR>=<NUMERIC EXPRESSION>. Sets a filecheck numeric variable ``NUMVAR`` of matching format ``FMT`` to; the result of evaluating ``<NUMERIC EXPRESSION>`` that can be used in; ``CHECK:`` lines. See section; ``FileCheck Numeric Variables and Expressions`` for details on supported; numeric expressions. .. option:: -version. Show the version number of this program. .. option:: -v. Print good directive pattern matches. However, if ``-dump-input=fail`` or; ``-dump-input=always``, add those matches as input annotations instead. .. option:: -vv. Print information helpful in diagnosing internal FileCheck issues, such as; discarded overlapping ``CHECK-DAG:`` matches, implicit EOF pattern matches,; and ``CHECK-NOT:`` patterns that do not have matches. Implies ``-v``.; However, if ``-dump-input=fail`` or ``-dump-input=always``, just add that; information as input annotations instead. .. option:: --allow-deprecated-dag-over",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:6157,variab,variable,6157,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variable']
Modifiability,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12748,config,config,12748,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"ightforward: we emit the RHS of the assignment, create a store, and; return the computed value. Returning a value allows for chained; assignments like ""X = (Y = Z)"". Now that we have an assignment operator, we can mutate loop variables; and arguments. For example, we can now run code like this:. ::. # Function to print a double.; extern printd(x);. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. def test(x); printd(x) :; x = 4 :; printd(x);. test(123);. When run, this example prints ""123"" and then ""4"", showing that we did; actually mutate the value! Okay, we have now officially implemented our; goal: getting this to work requires SSA construction in the general; case. However, to be really useful, we want the ability to define our; own local variables, let's add this next!. User-defined Local Variables; ============================. Adding var/in is just like any other extension we made to; Kaleidoscope: we extend the lexer, the parser, the AST and the code; generator. The first step for adding our new 'var/in' construct is to; extend the lexer. As before, this is pretty trivial, the code looks like; this:. .. code-block:: c++. enum Token {; ...; // var definition; tok_var = -13; ...; }; ...; static int gettok() {; ...; if (IdentifierStr == ""in""); return tok_in;; if (IdentifierStr == ""binary""); return tok_binary;; if (IdentifierStr == ""unary""); return tok_unary;; if (IdentifierStr == ""var""); return tok_var;; return tok_identifier;; ... The next step is to define the AST node that we will construct. For; var/in, it looks like this:. .. code-block:: c++. /// VarExprAST - Expression class for var/in; class VarExprAST : public ExprAST {; std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames;; std::unique_ptr<ExprAST> Body;. public:; VarExprAST(std::vector<std::pair<std::string, std::unique_ptr<ExprAST>>> VarNames,; std::unique_ptr<ExprAST> Body); : VarNames(std::move(V",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:22991,extend,extend,22991,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['extend'],['extend']
Modifiability,"iginal spectrum, are presented in the Figure 4.8. ![Original spectrum before unfolding](figures/image100.png). ![Contents of the responses in the original spectrum](figures/image102.png). Another example where we have used the unfolding method is the; decomposition of continuum of gamma-ray spectra. Using simulation and; interpolation techniques, we have synthesized the response matrix (size; `3400x3400` channels) of Gammasphere spectrometer (Figure 4.9). Its details are; presented in Figure 4.10. The original spectrum of Co^56 before and after; continuum decomposition are presented in Figures 4.11, 4.12, respectively. ![Response matrix (size 3400x3400 channels) of Gammasphere spectrometer](figures/image104.png). ![Detail of Figure 4.9](figures/image106.png). ![Original spectrum of Co56 before continuum decomposition](figures/image108.png). ![Original spectrum of Co56 after continuum decomposition](figures/image110.png). ## 2-DIMENSIONAL SPECTRA. We have extended the method of Gold deconvolution also for; 2-dimensional data. Again, the goal of the deconvolution methods is to; improve the resolution in the spectrum and to decompose multiplets. The method of optimized 2-dimensional deconvolution is described in details in [8]. Mathematical formulation of 2-dimensional convolution system is as; follows:. $$ y(i_1,i_2) = \sum_{k_1=0}^{N_1-1}\sum_{k_2=0}^{N_2-1}h(i_1-k_1,i_2-k_2)x(k_1,k_2), i_1=0,1,2,...,N_1-1, i_2=0,1,2,...,N_2-1 $$. Assuming we know the output; spectrum `y` and the response spectrum `h`, the task is to calculate the matrix `x`. The basic function has the form of. ``` {.cpp}; char *Deconvolution2(float **source,; const float **resp,; int sizex,; int sizey,; int niter);; ```. This function calculates deconvolution from the source spectrum according to; the response spectrum. The result is placed in the matrix pointed by the source; pointer. Function parameters:. - **`source`**: pointer to the matrix of the source spectrum; - **`resp`**: pointer to the ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:32603,extend,extended,32603,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['extend'],['extended']
Modifiability,"ignPacket. ; Memory controlAdd; the possibility to display the memory footprint on workers and master as a; function of the entry processed (workers) or of the merging step; (master). A new button has been added to the PROOF dialog box to; retrieve and display the memory usage. On the workers about 100; measurements are recorded by default; this number can be changed with 'proof->SetParameter(""PROOF_MemLogFreq"", memlogfreq)';Add; the possibility to set upper limits on the virtual memory used by; processes; the session gets firts a warning when it reaches 80% of; the limit, and then processing is stopped whenit exceeds 95% of the; limit, sending back the results. Also, the memory footprint is notified; when the session is terminated. The limit in MBs is set by the; environment variable ""ROOTPROOFASSOFT"". An hard limit can be set via the; env ""ROOTPROOFASHARD"" (also in MBs): the process is automatically; killed by the system if it reaches this limit. Envs variables for the; PROOF processes can be set using the directive 'xpd.putenv' in the; xrootd config file.Input dataIntroduce the; concept of 'input data': these are objects that are distributed in; optimal way to the workers, which are available via the input list, but; which are not saved in the TQueryResult object. These are meant for big; objects whic can create a big overload when distributed via the; standard input list (which should mostly be used for job control; parameters).  To add an input-data object just use; TProof::AddInputData(TObject *); if the input-data objects are in a; file you can use TProof::SetInputDataFile(const char *file); the final; set of input-data objects is assembled from the objects added via; AddInputData and those found in the file defined bySetInputDataFile.  . Improvements:. More; complete set of tests in test/stressProof . To run with PROOF-Lite pass; the argument 'lite' as master URL, e.g. './stressProof lite'.Possibility; to control on the client via rc variable the location of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html:3085,variab,variables,3085,proof/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v522/index.html,1,['variab'],['variables']
Modifiability,"igned to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global variables that never have their address; taken. If obviously true, it marks read/write globals as constant, deletes; variables only stored to, etc. ``gvn``: Global Value Numbering; -------------------------------. This pass performs global value numbering to eliminate fully and partially; redundant instructions. It also performs redundant load elimination. .. _passes-indvars:. ``indvars``: Canonicalize Induction Variables; ---------------------------------------------. This transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the ind",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:17689,variab,variables,17689,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variables']
Modifiability,"ignificantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26165,variab,variable,26165,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['variab'],['variable']
Modifiability,"igrate-downstream-fork.py`` are in the; Python script and are expanded on below to a more general recipe::. # Make a repository which will become your final local mirror of the; # monorepo.; mkdir my-monorepo; git -C my-monorepo init. # Add a remote to the monorepo.; git -C my-monorepo remote add upstream/monorepo https://github.com/llvm/llvm-project.git. # Add remotes for each git mirror you use, from upstream as well as; # your local mirror. All projects are listed here but you need only; # import those for which you have local branches.; my_projects=( clang; clang-tools-extra; compiler-rt; debuginfo-tests; libcxx; libcxxabi; libunwind; lld; lldb; llvm; openmp; polly ); for p in ${my_projects[@]}; do; git -C my-monorepo remote add upstream/split/${p} https://github.com/llvm-mirror/${p}.git; git -C my-monorepo remote add local/split/${p} https://my.local.mirror.org/${p}.git; done. # Pull in all the commits.; git -C my-monorepo fetch --all. # Run migrate-downstream-fork to rewrite local branches on top of; # the upstream monorepo.; (; cd my-monorepo; migrate-downstream-fork.py \; refs/remotes/local \; refs/tags \; --new-repo-prefix=refs/remotes/upstream/monorepo \; --old-repo-prefix=refs/remotes/upstream/split \; --source-kind=split \; --revmap-out=monorepo-map.txt; ). # Octopus-merge the resulting local split histories to unify them. # Assumes local work on local split mirrors is on main (and; # upstream is presumably represented by some other branch like; # upstream/main).; my_local_branch=""main"". git -C my-monorepo branch --no-track local/octopus/main \; $(git -C my-monorepo merge-base refs/remotes/upstream/monorepo/main \; refs/remotes/local/split/llvm/${my_local_branch}); git -C my-monorepo checkout local/octopus/${my_local_branch}. subproject_branches=(); for p in ${my_projects[@]}; do; subproject_branch=${p}/local/monorepo/${my_local_branch}; git -C my-monorepo branch ${subproject_branch} \; refs/remotes/local/split/${p}/${my_local_branch}; if [[ ""${p}"" != ""l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:21453,rewrite,rewrite,21453,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['rewrite'],['rewrite']
Modifiability,"igurability of GL event-handler to allow inversion of; controls from scene-centric to viewer-centric. The following rootrc; variables control the behaviour:. OpenGL.EventHandler.ViewerCentricControls: 1; OpenGL.EventHandler.ArrowKeyFactor: -1.0; OpenGL.EventHandler.MouseDragFactor: -1.0; OpenGL.EventHandler.MouseWheelFactor: -1.0. Add camera auto-rotation support. Controls are available from the; ""Extras"" tab of TGLViewer GUI editor. Implemented in class; TGLAutoRotator, can be sub-classed and attached to a viewer via; TGLViewer::SetAutoRotator() method.; Added new overlay element class TGLCameraGuide that shows the; orientation of major axes. To use, call this on a TGLViewer object:. gl_viewer->AddOverlayElement(new TGLCameraGuide(0.9, 0.1, 0.08));. Fix an issue with GL-clip object not being properly updated after; a scene update.; Hide / show menu-bar with a time-out (default 400ms). This can be; adjusted by calling static method:; TGLSAViewer::SetMenuHidingTimeout(200);; To disable menu hiding for Eve viewers, where it is enabled by; default, set the following rootrc variable:; Eve.Viewer.HideMenus: off. EVE; Major changes. Implement central infractructure to allow eve-elements to support; internal multiple selection and highlightning of their sub-parts. Use this in TEveDigitSet and its sub-classes TEveQuadSet and; TEveBoxSet. TEveSecondarySelectable: New secondary base-class for elements; supporting internal multiple selection / highlight.; TEveViewer - Add functions to handle additional mouse-over signals; from TGLViewer.; TEveElement - Add 3 new functions:; virtual TString GetHighlightTooltip();; virtual void UnSelected();; virtual void UnHighlighted();. TEveDigitSet, TEveQuadSet, TEveBoxSet. Sub-class TEveDigitSet from TEveSecondarySelectable.; Implement functions needed for internal selection.; Add common base-class TEveDigitSetGL for quad and box-set GL rendering.; Move anti-flickering controls from TEveQuadSet to TEveDigitSet and; implement it also in TEve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html:2587,variab,variable,2587,graf3d/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v528/index.html,1,['variab'],['variable']
Modifiability,"igure we present; the background, which was added to the synthetic spectrum. One can; observe good coincidence with the estimated background. The method of; the estimation of Compton edge is described in details in [3]. ![Synthetic spectrum with Compton edges](figures/image012.png). The generalized form of the algorithm is implemented in the following function. ``` {.cpp}; char *Background1General(float *spectrum,; int size,; int number_of_iterations,; int direction,; int filter_order,; bool compton);; ```. The meaning of the parameters is as follows:. - **`spectrum`**: pointer to the vector of the source spectrum; - **`size`**: length of spectrum vector; - **`number_of_iterations`**: maximal width of clipping window; - **`direction`**: direction of change of clipping window. Possible values:; - `BACK1_INCREASING_WINDOW`; - `BACK1_DECREASING_WINDOW`; - **`filter_order`**: order of clipping filter. Possible values:; - `BACK1_ORDER2`; - `BACK1_ORDER4`; - `BACK1_ORDER6`; - `BACK1_ORDER8`; - **`compton`**: logical variable whether the estimation of Compton edge will be included. Possible values:; - `BACK1_EXCLUDE_COMPTON`; - `BACK1_INCLUDE_COMPTON`. ## 2-DIMENSIONAL SPECTRA. This basic background estimation function allows to separate useless; spectrum information (2D-continuous background and coincidences of peaks; with background in both dimensions) from peaks. It calculates background; spectrum from the source spectrum. The result is placed in the array; pointed by spectrum pointer. On successful completion it returns 0. On; error it returns a pointer to the string describing error. ``` {.cpp}; char *Background2(float **spectrum,; int sizex,; int sizey,; int number_of_iterations);; ```. Function parameters:. - **`spectrum`**: pointer to the array of the source spectrum; - **`sizex`**: x length of spectrum; - **`sizey`**: y length of spectrum; - **`number_of_iterations`**: width of the clipping window. In Figure 1.6 we present an example of a 2-dimensional spectrum bef",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:4200,variab,variable,4200,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variable']
Modifiability,"igured things:. - a HTCondor cluster capable of running PROOF on Demand. - certificate authentication. - your experiment's software (if available on CernVM-FS). Obtain the CernVM image and contextualization; ---------------------------------------------. ### Download the CernVM bare image. The Virtual Analysis Facility currently works with *CernVM Batch 2.7.1; 64-bit*. This means that you need to have this CernVM image available; either on your local hard disk (in case of a desktop deployment) or in; your cloud's image repository. > For convenience we provide the direct link for the working versions:; >; > - [CernVM 2.7.1 batch 64-bit for; > **KVM**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.hdd.gz); >; > - [CernVM 2.7.1 batch 64-bit for; > **Xen**](https://cernvm.cern.ch/releases/19/cernvm-batch-node-2.7.1-2-3-x86_64.ext3.gz); >; > Images are gzipped. In most cases you'll need to gunzip them before; > registering to your image repository. ### Create VM configuration profiles. CernVM images are base images supporting boot-time customization via; configuration profiles called ""contexts"". Context creation can be; performed through the [CernVM Online](https://cernvm-online.cern.ch/); website. The site is immediately accessible if you have a CERN account. Go to your [CernVM Online; Dashboard](https://cernvm-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:1631,config,configuration,1631,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['config'],['configuration']
Modifiability,"ihood calculation: `LikelihoodWrapper` and `LikelihoodGradientWrapper`.; These are used by the `RooAbsMinimizerFcn` implementation `MinuitFcnGrad` which expects them to, respectively, provide likelihood and likelihood gradient values for use by `Minuit2` in fitting the pdf to the dataset. The `Wrapper`s can be implemented for different kinds of algorithms, or with different kinds of optimization ""back-ends"" in mind.; One implementation of each is ready for use in `RooFit` currently:. 1. `LikelihoodSerial` is more or less simply a rewrite of the existing serial calculation of a `RooNLLVar`.; 2. `LikelihoodGradientJob` calculates the partial derivatives or the gradient in parallel on multiple CPUs/cores, based on `RooFit::MultiProcess`, which is a fork-based multi-processing task execution framework with dynamic load balancing. Other possible implementations could use the GPU or external tools like TensorFlow. The coupling of all these classes to `RooMinimizer` is made via the `MinuitFcnGrad` class, which owns the `Wrappers` that calculate the likelihood components. Note: a second `LikelihoodWrapper` class called `LikelihoodJob` is also available.; This class emulates the existing `NumCPU(>1)` functionality of the `RooAbsTestStatistic` tree, which is implemented based on `RooRealMPFE`.; This class is not yet thoroughly tested and should not be considered production ready. ### Usage example: `MultiProcess` enabled parallel gradient calculator. The main selling point of using `RooFit::TestStatistics` from a performance point of view is the implementation of the `RooFit::MultiProcess` based `LikelihoodGradientJob` calculator class.; To use it, one should create a `RooMinimizer` using the new constructor that takes a `RooAbsL`-based likelihood instead of a `RooAbsReal`. Taking any of the above created `likelihood` objects (as long as they are in a `std::shared_ptr`), we can create a `RooMinimizer` with parallel gradient calculation using:; ``` {.cpp}; std::shared_ptr<RooAb",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md:7522,coupling,coupling,7522,roofit/doc/developers/test_statistics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/test_statistics.md,1,['coupling'],['coupling']
Modifiability,ilable for use in tailoring; rf303_conditional.C - Use of tailored p.d.f as conditional p.d.fs.s; rf304_uncorrprod.C - Simple uncorrelated multi-dimensional p.d.f.s; rf305_condcorrprod.C - Multi-dimensional p.d.f.s with conditional p.d.fs in product; rf306_condpereventerrors.C - Complete example with use of conditional p.d.f. with per-event errors; rf307_fullpereventerrors.C -Complete example with use of full p.d.f. with per-event errors; rf308_normintegration2d.C - Examples on normalization of p.d.f.s in more than one dimension; rf309_ndimplot.C - Making 2 and 3 dimensional plots of p.d.f.s and datasets; rf310_sliceplot.C -Projecting p.d.f and data slices in discrete observables; rf311_rangeplot.C -Projecting p.d.f and data ranges in continuous observables; rf312_multirangefit.C - Performing fits in multiple (disjoint) ranges in one or more dimensions; rf313_paramranges.C - Working with parameterized ranges to define non-rectangular regions; rf314_paramfitrange.C - Working with parameterized ranges in a fit.; rf315_projectpdf.C - Marginizalization of multi-dimensional p.d.f.s through integration; rf316_llratioplot.C - Using the likelihood ratio technique to construct a signal enhanced 1-D projection of a multi-dimensional p.d.f.; ; DATA AND CATEGORIES. rf401_importttreethx.C -Overview of advanced option for importing data from ROOT TTree and THx histograms; rf402_datahandling.C - Tools for manipulation of (un)binned datasets; rf403_weightedevts.C - Using weights in unbinned datasets; rf404_categories.C - Working with RooCategory objects to describe discrete variables; rf405_realtocatfuncs.C - Demonstration of real-->discrete mapping functions; rf406_cattocatfuncs.C - Demonstration of discrete-->discrete (invertable) functions; rf407_latextables.C - Latex printing of lists and sets of RooArgSets; ; ORGANIZATION AND SIMULTANEOUS FITS. rf501_simultaneouspdf.C - Using simultaneous p.d.f.s to describe simultaneous fits to multiple datasets; rf502_wspacewrite.C - Creating,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:3285,parameteriz,parameterized,3285,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['parameteriz'],['parameterized']
Modifiability,"ild the plugin, and then call clang with the plugin from the; source tree:. .. code-block:: console. $ export BD=/path/to/build/directory; $ (cd $BD && make PrintFunctionNames ); $ clang++ -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \; -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D_GNU_SOURCE \; -I$BD/tools/clang/include -Itools/clang/include -I$BD/include -Iinclude \; tools/clang/tools/clang-check/ClangCheck.cpp -fsyntax-only \; -Xclang -load -Xclang $BD/lib/PrintFunctionNames.so -Xclang \; -plugin -Xclang print-fns. Also see the print-function-name plugin example's; `README <https://github.com/llvm/llvm-project/blob/main/clang/examples/PrintFunctionNames/README.txt>`_. Using the clang command line; ----------------------------. Using `-fplugin=plugin` on the clang command line passes the plugin; through as an argument to `-load` on the cc1 command line. If the plugin; class implements the ``getActionType`` method then the plugin is run; automatically. For example, to run the plugin automatically after the main AST; action (i.e. the same as using `-add-plugin`):. .. code-block:: c++. // Automatically run the plugin after the main AST action; PluginASTAction::ActionType getActionType() override {; return AddAfterMainAction;; }. Interaction with ``-clear-ast-before-backend``; ----------------------------------------------. To reduce peak memory usage of the compiler, plugins are recommended to run; *before* the main action, which is usually code generation. This is because; having any plugins that run after the codegen action automatically turns off; ``-clear-ast-before-backend``. ``-clear-ast-before-backend`` reduces peak; memory by clearing the Clang AST after generating IR and before running IR; optimizations. Use ``CmdlineBeforeMainAction`` or ``AddBeforeMainAction`` as; ``getActionType`` to run plugins while still benefitting from; ``-clear-ast-before-backend``. Plugins must make sure not to modify the AST,; otherwise they should run after the main action. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst:6983,plugin,plugin,6983,interpreter/llvm-project/clang/docs/ClangPlugins.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangPlugins.rst,6,['plugin'],"['plugin', 'plugins']"
Modifiability,"ild"". Please see also; Getting Started; with the LLVM System using Microsoft Visual Studio and; Building LLVM with CMake.; . Testing on the Command Line. If you want more control over how the tests are run, it may; be convenient to run the test harness on the command-line directly. Before; running tests from the command line, you will need to ensure that; lit.site.cfg files have been created for your build. You can do; this by running the tests as described in the previous sections. Once the; tests have started running, you can stop them with control+C, as the; files are generated before running any tests.; Once that is done, to run all the tests from the command line,; execute a command like the following:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test. For CMake builds e.g. on Windows with Visual Studio, you will need; to specify your build configuration (Debug, Release, etc.) via; --param=build_config=(build config). You may also need to specify; the build mode (Win32, etc) via --param=build_mode=(build mode).; Additionally, you will need to specify the lit site configuration which; lives in (build dir)\tools\clang\test, via; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg.; ; To run a single test:. python (path to llvm)\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=(build dir)\tools\clang\test\lit.site.cfg; (path to llvm)\llvm\tools\clang\test\(dir)\(test). For example:. python C:\Tools\llvm\utils\lit\lit.py -sv; --param=build_mode=Win32 --param=build_config=Debug; --param=clang_site_config=C:\Tools\build\tools\clang\test\lit.site.cfg; C:\Tools\llvm\tools\clang\test\Sema\wchar.c. The -sv option above tells the runner to show the test output if; any tests failed, to help you determine the cause of failure.; You can also pass ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html:6413,config,configuration,6413,interpreter/llvm-project/clang/www/hacking.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/hacking.html,1,['config'],['configuration']
Modifiability,"ild; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`` and ``nm`` also accept the ``-plugin`` option and it's possible to; to install ``LLVMgold.so`` to ``/usr/lib/bfd-plugins`` for a seamless setup.; If you built your own gold, be sure to install the ``ar`` and ``nm-new`` you; built to ``/usr/bin``. Example of link time optimization; ---------------------------------. The following example shows a worked example of the gold plugin mixing LLVM; bitcode and native code. .. code-block:: c. --- a.c ---; #include <stdio.h>. extern void foo1(void);; extern void foo4(void);. void foo2(void) {; printf(""Foo2\n"");; }. void foo3(void) {; foo4();; }. int main(void) {; foo1();; }. --- b.c ---; #include <stdio.h>. extern void foo2(void);. void foo1(void) {; foo2();; }. void foo4(void) {; printf(""Foo4"");; }. .. code-blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:3206,plugin,plugin,3206,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,2,['plugin'],['plugin']
Modifiability,"ild; * [[#12718](https://github.com/root-project/root/issues/12718)] - A crash when trying to initialise a vector from a >1D numpy array in PyROOT; * [[#12685](https://github.com/root-project/root/issues/12685)] - `TEnum::GetEnum` does NOT process typedefs; * [[#12644](https://github.com/root-project/root/issues/12644)] - Can't find cxxabi.h and build module 'ROOT_Foundation_Stage1_NoRTTI' when building from source on Macos; * [[#12631](https://github.com/root-project/root/issues/12631)] - Unable to build master with external XROOTD; * [[#12621](https://github.com/root-project/root/issues/12621)] - [I/O][RDF] Usage of xrootd from multi-thread event loops runs into severe bottlenecks; * [[#12592](https://github.com/root-project/root/issues/12592)] - [doc] TProfile bin error documentation is not correct; * [[#12591](https://github.com/root-project/root/issues/12591)] - Allow partial enablement of modules; * [[#12527](https://github.com/root-project/root/issues/12527)] - MacOS build fails if configured without cocoa; * [[#12492](https://github.com/root-project/root/issues/12492)] - The problem with building ROOT v6-26-10 in debug mode on ubuntu 20.04; * [[#12230](https://github.com/root-project/root/issues/12230)] - Wrong conversion from Numpy Array to `std.vector` when using the wrong type; * [[#12091](https://github.com/root-project/root/issues/12091)] - TSpline SaveAs not using equidistant and loss of precision; * [[#11924](https://github.com/root-project/root/issues/11924)] - PyROOT: wrong overload resolution for C++ functions from python ; * [[#11901](https://github.com/root-project/root/issues/11901)] - Binary distribution for Ubutu 22.04 is broken (on WSL2); * [[#11750](https://github.com/root-project/root/issues/11750)] - FindXROOTD adds libraries to link against irrespective of xrootd version used; * [[#11746](https://github.com/root-project/root/issues/11746)] - TH2::Fill(const char *namex, const char *namey, Double_t w) doesn't update fTsumwxy; * [[#11743](ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:41512,config,configured,41512,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['config'],['configured']
Modifiability,"ilder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the function. The final missing piece is adding the mem2reg pass, which allows us to; get good codegen once again:. .. code-block:: c++. // Promote allocas to registers.; TheFPM->add(createPromoteMemoryToRegisterPass());; // Do simple ""peephole"" optimizations and bit-twiddling optzns.; TheFPM->add(createInstructionCombiningPass());; // Reassociate expressions.; TheFPM->add(createReassociatePass());; ... It is interesting to see what the code looks like before and after the; mem2reg optimization runs. For example, this is the before/after code; for our recursive fib function. Before the optimization:. .. code-bloc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:16053,variab,variable,16053,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"ile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-thr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3532,plugin,plugin,3532,interpreter/llvm-project/clang/docs/ThinLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst,1,['plugin'],['plugin']
Modifiability,"ile store i32 -1, i32* inttoptr (i32 1342341148 to i32*), align 4,; !tbaa; !0. is compiled and optimized to:. movw r0, #32796; mov.w r1, #-1; movt r0, #20480; str r1, [r0]; movw r0, #32796 @ <= this MOVW is not needed, value is there already; movt r0, #20482; str r1, [r0]. //===---------------------------------------------------------------------===//. Improve codegen for select's:; if (x != 0) x = 1; if (x == 1) x = 1. ARM codegen used to look like this:; mov r1, r0; cmp r1, #1; mov r0, #0; moveq r0, #1. The naive lowering select between two different values. It should recognize the; test is equality test so it's more a conditional move rather than a select:; cmp r0, #1; movne r0, #0. Currently this is a ARM specific dag combine. We probably should make it into a; target-neutral one. //===---------------------------------------------------------------------===//. Optimize unnecessary checks for zero with __builtin_clz/ctz. Those builtins; are specified to be undefined at zero, so portable code must check for zero; and handle it as a special case. That is unnecessary on ARM where those; operations are implemented in a way that is well-defined for zero. For; example:. int f(int x) { return x ? __builtin_clz(x) : sizeof(int)*8; }. should just be implemented with a CLZ instruction. Since there are other; targets, e.g., PPC, that share this behavior, it would be best to implement; this in a target-independent way: we should probably fold that (when using; ""undefined at zero"" semantics) to set the ""defined at zero"" bit and have; the code generator expand out the right code. //===---------------------------------------------------------------------===//. Clean up the test/MC/ARM files to have more robust register choices. R0 should not be used as a register operand in the assembler tests as it's then; not possible to distinguish between a correct encoding and a missing operand; encoding, as zero is the default value for the binary encoder.; e.g.,; add r0, r0 // bad; add r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt:20811,portab,portable,20811,interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/README.txt,1,['portab'],['portable']
Modifiability,ile.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61320,config,configuration,61320,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ile: !1, line: 3, type: !12); !16 = !DILocation(line: 3, column: 9, scope: !4); !17 = !DILocalVariable(name: ""Z"", scope: !18, file: !1, line: 5, type: !12); !18 = distinct !DILexicalBlock(scope: !4, file: !1, line: 4, column: 5); !19 = !DILocation(line: 5, column: 11, scope: !18); !20 = !DILocation(line: 6, column: 11, scope: !18); !21 = !DILocation(line: 6, column: 9, scope: !18); !22 = !DILocation(line: 8, column: 9, scope: !4); !23 = !DILocation(line: 8, column: 7, scope: !4); !24 = !DILocation(line: 9, column: 3, scope: !4). This example illustrates a few important details about LLVM debugging; information. In particular, it shows how the ``llvm.dbg.declare`` intrinsic and; location information, which are attached to an instruction, are applied; together to allow a debugger to analyze the relationship between statements,; variable definitions, and the code used to implement the function. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %X, metadata !11, metadata !13), !dbg !14; ; [debug line = 2:7] [debug variable = X]. The first intrinsic ``%llvm.dbg.declare`` encodes debugging information for the; variable ``X``. The metadata ``!dbg !14`` attached to the intrinsic provides; scope information for the variable ``X``. .. code-block:: text. !14 = !DILocation(line: 2, column: 9, scope: !4); !4 = distinct !DISubprogram(name: ""foo"", scope: !1, file: !1, line: 1, type: !5,; isLocal: false, isDefinition: true, scopeLine: 1,; isOptimized: false, retainedNodes: !2). Here ``!14`` is metadata providing `location information; <LangRef.html#dilocation>`_. In this example, scope is encoded by ``!4``, a; `subprogram descriptor <LangRef.html#disubprogram>`_. This way the location; information attached to the intrinsics indicates that the variable ``X`` is; declared at line number 2 at a function level scope in function ``foo``. Now lets take another example. .. code-block:: llvm. call void @llvm.dbg.declare(metadata i32* %Z, metadata !17, metadata !13), !dbg !19; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:16122,variab,variable,16122,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variable']
Modifiability,"iler backend, you need to create and modify a few; files. The absolute minimum is discussed here. But to actually use the LLVM; target-independent code generator, you must perform the steps described in the; :doc:`LLVM Target-Independent Code Generator <CodeGenerator>` document. First, you should create a subdirectory under ``lib/Target`` to hold all the; files related to your target. If your target is called ""Dummy"", create the; directory ``lib/Target/Dummy``. In this new directory, create a ``CMakeLists.txt``. It is easiest to copy a; ``CMakeLists.txt`` of another target and modify it. It should at least contain; the ``LLVM_TARGET_DEFINITIONS`` variable. The library can be named ``LLVMDummy``; (for example, see the MIPS target). Alternatively, you can split the library; into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``, the latter of which; should be implemented in a subdirectory below ``lib/Target/Dummy`` (for example,; see the PowerPC target). Note that these two naming schemes are hardcoded into ``llvm-config``. Using; any other naming scheme will confuse ``llvm-config`` and produce a lot of; (seemingly unrelated) linker errors when linking ``llc``. To make your target actually do something, you need to implement a subclass of; ``TargetMachine``. This implementation should typically be in the file; ``lib/Target/DummyTargetMachine.cpp``, but any file in the ``lib/Target``; directory will be built and should work. To use LLVM's target independent code; generator, you should do what all current machine backends do: create a; subclass of ``LLVMTargetMachine``. (To create a target from scratch, create a; subclass of ``TargetMachine``.). To get LLVM to actually build and link your target, you need to run ``cmake``; with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Dummy``. This will build your; target without needing to add it to the list of all the targets. Once your target is stable, you can add it to the ``LLVM_ALL_TARGETS`` variable; located in the main ``CMakeLists",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:6947,config,config,6947,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['config'],['config']
Modifiability,"iler. **LLVM_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of LLVM build system; components to install. All LLVM-based tools are components, as well as most; of the libraries and runtimes. Component names match the names of the build; system targets. **LLVM_DISTRIBUTIONS**:STRING; This variable can be set to a semi-colon separated list of distributions. See; the :ref:`Multi-distribution configurations` section above for details on this; and other CMake variables to configure multiple distributions. **LLVM_RUNTIME_DISTRIBUTION_COMPONENTS**:STRING; This variable can be set to a semi-colon separated list of runtime library; components. This is used in conjunction with *LLVM_ENABLE_RUNTIMES* to specify; components of runtime libraries that you want to include in your distribution.; Just like with *LLVM_DISTRIBUTION_COMPONENTS*, component names match the names; of the build system targets. **LLVM_DYLIB_COMPONENTS**:STRING; This variable can be set to a semi-colon separated name of LLVM library; components. LLVM library components are either library names with the LLVM; prefix removed (i.e. Support, Demangle...), LLVM target names, or special; purpose component names. The special purpose component names are:. #. ``all`` - All LLVM available component libraries; #. ``Native`` - The LLVM target for the Native system; #. ``AllTargetsAsmParsers`` - All the included target ASM parsers libraries; #. ``AllTargetsDescs`` - All the included target descriptions libraries; #. ``AllTargetsDisassemblers`` - All the included target dissassemblers libraries; #. ``AllTargetsInfos`` - All the included target info libraries. **LLVM_INSTALL_TOOLCHAIN_ONLY**:BOOL; This option defaults to ``Off``: when set to ``On`` it removes many of the; LLVM development and testing tools as well as component libraries from the; default ``install`` target. Including the development tools is not recommended; for distributions as many of the LLVM tools are only inten",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:12441,variab,variable,12441,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['variab'],['variable']
Modifiability,"ility in LLVM, as well as how to use it. :doc:`LoopTerminology`; A document describing Loops and associated terms as used in LLVM. :doc:`CycleTerminology`; A document describing cycles as a generalization of loops. :doc:`Vectorizers`; This document describes the current status of vectorization in LLVM. :doc:`LinkTimeOptimization`; This document describes the interface between LLVM intermodular optimizer; and the linker and its design. :doc:`GoldPlugin`; How to build your programs with link-time optimization on Linux. :doc:`Remarks`; A reference on the implementation of remarks in LLVM. :doc:`Source Level Debugging with LLVM <SourceLevelDebugging>`; This document describes the design and philosophy behind the LLVM; source-level debugger. :doc:`How to Update Debug Info <HowToUpdateDebugInfo>`; This document specifies how to correctly update debug info in various kinds; of code transformations. :doc:`InstrRefDebugInfo`; This document explains how LLVM uses value tracking, or instruction; referencing, to determine variable locations for debug info in the final; stages of compilation. :doc:`RemoveDIsDebugInfo`; This is a migration guide describing how to move from debug info using; intrinsics such as dbg.value to using the non-instruction DPValue object. :doc:`InstrProfileFormat`; This document explains two binary formats of instrumentation-based profiles. Code Generation; ---------------. :doc:`WritingAnLLVMBackend`; Information on how to write LLVM backends for machine targets. :doc:`CodeGenerator`; The design and implementation of the LLVM code generator. Useful if you are; working on retargetting LLVM to a new architecture, designing a new codegen; pass, or enhancing existing components. :doc:`TableGen <TableGen/index>`; Describes the TableGen tool, which is used heavily by the LLVM code; generator. ==========; GlobalISel; ==========. :doc:`MIRPatterns <GlobalISel/MIRPatterns>`; Describes the design of MIR Patterns and how to use them. ===; JIT; ===. :doc:`MCJITDesig",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst:4277,variab,variable,4277,interpreter/llvm-project/llvm/docs/UserGuides.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/UserGuides.rst,1,['variab'],['variable']
Modifiability,"ill issue strong and weak write-barrier assignments in the same manner as; objects. ``__weak __block`` Support; --------------------------. Objective-C (and Objective-C++) support the ``__weak`` attribute on ``__block``; variables. Under normal circumstances the compiler uses the Objective-C runtime; helper support functions ``objc_assign_weak`` and ``objc_read_weak``. Both; should continue to be used for all reads and writes of ``__weak __block``; variables:. .. code-block:: c. objc_read_weak(&block->byref_i->forwarding->i). The ``__weak`` variable is stored in a ``_block_byref_foo`` structure and the; ``Block`` has copy and dispose helpers for this structure that call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src-> _block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. and:. .. code-block:: c. _Block_object_dispose(src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BYREF);. In turn, the ``block_byref`` copy support helpers distinguish between whether; the ``__block`` variable is a ``Block`` or not and should either call:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_OBJECT | BLOCK_BYREF_CALLER);. for something declared as an object or:. .. code-block:: c. _Block_object_assign(&dest->_block_byref_i, src->_block_byref_i, BLOCK_FIELD_IS_WEAK | BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);. for something declared as a ``Block``. A full example follows:. .. code-block:: c. __block __weak id obj = <initialization expression>;; functioncall(^{ [obj somemessage]; });. would translate to:. .. code-block:: c. struct _block_byref_obj {; void *isa; // uninitialized; struct _block_byref_obj *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_i *dst, struct _block_byref_i *src);; void (*byref_dispose)(struct _block_byref_i *);; id captured_obj;; };. void _block_byref_obj_keep(struct _block_byref_voidBlock *dst, struct _block_byref_voi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:20312,variab,variable,20312,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,ime of temporaries in init-captures; Unknown. 1928; NAD; Triviality of deleted special member functions; Unknown. 1929; CD4; template keyword following namespace nested-name-specifier; Unknown. 1930; CD4; init-declarator-list vs member-declarator-list; Unknown. 1931; CD5; Default-constructible and copy-assignable closure types; Unknown. 1932; CD4; Bit-field results of conditional operators; Unknown. 1933; NAD; Implementation limit for initializer-list elements; Unknown. 1934; NAD; Relaxing exception-specification compatibility requirements; Unknown. 1935; CD5; Reuse of placement arguments in deallocation; Unknown. 1936; CD6; Dependent qualified-ids; Unknown. 1937; CD5; Incomplete specification of function pointer from lambda; Unknown. 1938; CD5; Should hosted/freestanding be implementation-defined?; Unknown. 1939; open; Argument conversions to nondeduced parameter types revisited; Not resolved. 1940; CD4; static_assert in anonymous unions; Clang 3.5. 1941; CD4; SFINAE and inherited constructor default arguments; Clang 3.9. 1942; CD4; Incorrect reference to trailing-return-type; Unknown. 1943; CD5; Unspecified meaning of “bit”; Unknown. 1944; open; New C incompatibilities; Not resolved. 1945; open; Friend declarations naming members of class templates in non-templates; Not resolved. 1946; CD4; exception-specifications vs pointer dereference; Unknown. 1947; NAD; Digit separators following non-octal prefix; Clang 3.5. 1948; NAD; exception-specification of replacement global new; Clang 3.5. 1949; CD4; “sequenced after” instead of “sequenced before”; Unknown. 1950; NAD; Restructuring description of ranks of conversion sequences; Unknown. 1951; CD4; Cv-qualification and literal types; Unknown. 1952; CD4; Constant expressions and library undefined behavior; Unknown. 1953; open; Data races and common initial sequence; Not resolved. 1954; tentatively ready; typeid null dereference check in subexpressions; Unknown. 1955; CD4; #elif with invalid controlling expression; Unknown,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:131817,inherit,inherited,131817,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['inherit'],['inherited']
Modifiability,"ime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; Expressions with invalid results and ill-formedness; Yes. 452; CD1; Wording nit on description of this; Yes. 453; tentatively ready; References may only bind to “valid” objects; Unknown. 454; CD1; When is a definition of a static data member required?; Unknown. 455; NAD; Partial ordering and non-deduced arguments; Unknown. 456; NAD; Is initialized const int or const bool variable a null pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:31277,variab,variables,31277,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"imizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:. * Pointers; * References; * ``goto`` or labels; * Variable Length Arrays; * ``_Complex`` and ``_Imaginary``; * C Threads or Atomics (or Obj-C blocks); * ``union`` types `(in progress for HLSL 202x) <https://github.com/microsoft/DirectXShaderCompiler/pull/4132>`_; * Most features C11 and later. HLSL does not support the following C++ features:. * RTTI; * Exceptions; * Multiple inheritance; * Access specifiers; * Anonymous or inline namespaces; * ``new`` & ``delete`` operators in all of their forms (array, placement, etc); * Constructors and destructors; * Any use of the ``virtual`` keyword; * Most features C++11 and later; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:10371,inherit,inheritance,10371,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,1,['inherit'],['inheritance']
Modifiability,"imple `scan-build` would do:. $ intercept-build <your build command> && analyze-build. The major difference is how and when the analyzer is run. The `scan-build`; tool has three distinct model to run the analyzer:. 1. Use compiler wrappers to make actions.; The compiler wrappers does run the real compiler and the analyzer.; This is the default behaviour, can be enforced with `--override-compiler`; flag. 2. Use special library to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` flag to get this model. 3. Use compiler wrappers to intercept compiler calls during the build process.; The analyzer run against each modules after the build finished.; Use `--intercept-first` and `--override-compiler` flags together to get; this model. The 1. and 3. are using compiler wrappers, which works only if the build; process respects the `CC` and `CXX` environment variables. (Some build; process can override these variable as command line parameter only. This case; you need to pass the compiler wrappers manually. eg.: `intercept-build; --override-compiler make CC=intercept-cc CXX=intercept-c++ all` where the; original build command would have been `make all` only.). The 1. runs the analyzer right after the real compilation. So, if the build; process removes removes intermediate modules (generated sources) the analyzer; output still kept. The 2. and 3. generate the compilation database first, and filters out those; modules which are not exists. So, it's suitable for incremental analysis during; the development. The 2. mode is available only on FreeBSD and Linux. Where library preload; is available from the dynamic loader. Not supported on OS X (unless System; Integrity Protection feature is turned off). `intercept-build` command uses only the 2. and 3. mode to generate the; compilation database. `analyze-build` does only run the analyzer against the; captured compiler calls. Known problems; -----",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md:3073,variab,variable,3073,interpreter/llvm-project/clang/tools/scan-build-py/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/scan-build-py/README.md,1,['variab'],['variable']
Modifiability,"implementation Foo; @end. Matcher<Decl>objcInterfaceDeclMatcher<ObjCInterfaceDecl>...; Matches Objective-C interface declarations. Example matches Foo; @interface Foo; @end. Matcher<Decl>objcIvarDeclMatcher<ObjCIvarDecl>...; Matches Objective-C instance variable declarations. Example matches _enabled; @implementation Foo {; BOOL _enabled;; }; @end. Matcher<Decl>objcMethodDeclMatcher<ObjCMethodDecl>...; Matches Objective-C method declarations. Example matches both declaration and definition of -[Foo method]; @interface Foo; - (void)method;; @end. @implementation Foo; - (void)method {}; @end. Matcher<Decl>objcPropertyDeclMatcher<ObjCPropertyDecl>...; Matches Objective-C property declarations. Example matches enabled; @interface Foo; @property BOOL enabled;; @end. Matcher<Decl>objcProtocolDeclMatcher<ObjCProtocolDecl>...; Matches Objective-C protocol declarations. Example matches FooDelegate; @protocol FooDelegate; @end. Matcher<Decl>parmVarDeclMatcher<ParmVarDecl>...; Matches parameter variable declarations. Given; void f(int x);; parmVarDecl(); matches int x. Matcher<Decl>recordDeclMatcher<RecordDecl>...; Matches class, struct, and union declarations. Example matches X, Z, U, and S; class X;; template<class T> class Z {};; struct S {};; union U {};. Matcher<Decl>staticAssertDeclMatcher<StaticAssertDecl>...; Matches a C++ static_assert declaration. Example:; staticAssertDecl(); matches; static_assert(sizeof(S) == sizeof(int)); in; struct S {; int x;; };; static_assert(sizeof(S) == sizeof(int));. Matcher<Decl>tagDeclMatcher<TagDecl>...; Matches tag declarations. Example matches X, Z, U, S, E; class X;; template<class T> class Z {};; struct S {};; union U {};; enum E {; A, B, C; };. Matcher<Decl>templateTemplateParmDeclMatcher<TemplateTemplateParmDecl>...; Matches template template parameter declarations. Given; template <template <typename> class Z, int N> struct C {};; templateTypeParmDecl(); matches 'Z', but not 'N'. Matcher<Decl>templateTypeParmDeclMatcher<TemplateT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:16447,variab,variable,16447,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"improved. Now it supports sending RDataFrame tasks to a [Dask](https://dask.org/) scheduler. Through Dask, RDataFrame can be also scaled to a cluster of machines managed through a batch system like HTCondor or Slurm. Here is an example:. ```python; import ROOT; from dask.distributed import Client; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame. # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; client = Client(""SCHEDULER_ADDRESS""); df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D(""x""); ```. Other notable additions and improvements include:. - Enable triggering multiple distributed computation graphs through `RunGraphs`. This also allows sending both Spark and Dask jobs at the same time through a single function call.; - Greatly reduce distributed tasks processing overhead in TTree-based analyses by refactoring the translation from task metadata to RDataFrame object on the workers.; - Refactor triggering of the computation graph in the distributed tasks, so that it now runs with the Python GIL released. This allows interoperability with frameworks like Dask that run different Python threads along the main processing one.; - Set minimum Python version to use this tool to 3.7. This allows using more modern Python functionality in distributed RDataFrame code and is in line with the Python support provided by Spark and Dask.; - Add support for the following operations:; - `DefinePerSample`; - `HistoND`; - `Redefine`; - Make sure a user-provided `npartitions` parameter to a distributed RDataFrame constructor always takes precedence over the value computed by default.; - Improve support for friend trees in distributed executions, now any kind of friendship layout between the main tree and the friend tree(s) is expected to work.; - Add support for TChain data sources with no tree name an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:11327,refactor,refactoring,11327,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['refactor'],['refactoring']
Modifiability,"in JITLink, and for others it is provided in cooperation with the; (prototype) ORC runtime. JITLink aims to support the following features, some of which are still under; development:. 1. Cross-process and cross-architecture linking of single relocatable objects; into a target *executor* process. 2. Support for all object format features. 3. Open linker data structures (``LinkGraph``) and pass system. JITLink and ObjectLinkingLayer; ==============================. ``ObjectLinkingLayer`` is ORCs wrapper for JITLink. It is an ORC layer that; allows objects to be added to a ``JITDylib``, or emitted from some higher level; program representation. When an object is emitted, ``ObjectLinkingLayer`` uses; JITLink to construct a ``LinkGraph`` (see :ref:`constructing_linkgraphs`) and; calls JITLink's ``link`` function to link the graph into the executor process. The ``ObjectLinkingLayer`` class provides a plugin API,; ``ObjectLinkingLayer::Plugin``, which users can subclass in order to inspect and; modify ``LinkGraph`` instances at link time, and react to important JIT events; (such as an object being emitted into target memory). This enables many features; and optimizations that were not possible under MCJIT or RuntimeDyld. ObjectLinkingLayer Plugins; --------------------------. The ``ObjectLinkingLayer::Plugin`` class provides the following methods:. * ``modifyPassConfig`` is called each time a LinkGraph is about to be linked. It; can be overridden to install JITLink *Passes* to run during the link process. .. code-block:: c++. void modifyPassConfig(MaterializationResponsibility &MR,; const Triple &TT,; jitlink::PassConfiguration &Config). * ``notifyLoaded`` is called before the link begins, and can be overridden to; set up any initial state for the given ``MaterializationResponsibility`` if; needed. .. code-block:: c++. void notifyLoaded(MaterializationResponsibility &MR). * ``notifyEmitted`` is called after the link is complete and code has been; emitted to the executor pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:2303,plugin,plugin,2303,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['plugin'],['plugin']
Modifiability,"in ROOT we will use the tree produced by the following; “pseudo C++” code:. ``` {.cpp}; void parallel_example() {; TNtuple *nt = new TNtuple(""nt"",""Demo ntuple"",""x:y:z:u:v:w:a:b:c"");; for (Int_t i=0; i<3000; i++) {; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x, s1y, s1z, s2x, s2y, s2z, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, s3y, rnd );; nt->Fill( s2x-1, s2y-1, s2z, s1x+.5, s1y+.5, s1z+.5, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; nt->Fill( s1x+1, s1y+1, s1z+1, s3x-2, s3y-2, s3z-2, rnd, rnd, rnd );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, s3x, rnd, s3z );; nt->Fill( rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd, rnd );; }; ```. The data set generated has:. - 9 variables: x, y, z, u, v, w, a, b, c.; - 3000*8 = 24000 events.; - 3 sets of random points distributed on spheres: s1, s2, s3; - Random values (noise): rnd; - The variables a,b,c are almost completely random. The variables a; and c are correlated via the 1st and 3rd coordinates of the 3rd “sphere” s3. The command used to produce the Parallel Coordinates plot is:. ``` {.cpp}; nt->Draw(""x:a:y:b:z:u:c:v:w"","""",""PARA"");; ```. ![Cluttered output produced when all the tree events are plotted.](pictures/para3.png). If the 24000 events are plotted as solid lines and no special techniques; are used to clarify the picture, the result is the previous picture; which is very cluttered and useless. To improve the readability of the; Parallel Coordinates output and to explore interactively the data set,; many techniques are available. We have implemented a few in ROOT. First; of all, in order to show better where the clusters on the various axes; are, a 1D histogram is associated to each axis. These histograms; (one per axis) are filled according to the number of lines passing; through the bins. ![The histogram’s axis can be represented with colors or as bar charts.](pictures/para4.png). These histograms can be represented which colors (get from a pal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:97861,variab,variables,97861,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variables']
Modifiability,"in TPaletteAxis drawing - draw label, avoid too large ticks.; 3. Fix error with col drawing - bin with maximum value got wrong color; 4. Test for existing jquery.js, jquery-ui.js and d3.js libraries, reuse when provided; 5. Fix several I/O problems; now one could read files, produced in Geant4; 6. Implement 'e2' drawing option for TH1 class,; use by default 'e' option when TH1 has non-empty fSumw2; 7. Reuse statistic from histogram itself, when no axis selection done; 8. Support log/lin z scale for color drawing; 9. Implement interactive z-scale selection on TPaletteAxis; 10. Allow to redraw item with other draw options (before one should clear drawings); 11. Several improvements in THttpServer user interface - repair hierarchy reload,; hide unsupported context menu entries, status line update. ## Changes in 3.4; 1. Support usage of minimized versions of .js and .css files.; Minimized scripts used by default on web servers.; 2. Implement JSROOT.extend instead of jQuery.extend, reduce; usage of jquery.js in core JSROOT classes; 3. Implement main graphics without jquery at all,; such mode used in `nobrowser` mode.; 4. Provide optional latex drawing with MathJax SVG.; TMathText always drawn with MathJax,; other classes require `mathjax` option in URL; 5. Improve drawing of different text classes, correctly handle; their alignment and scaling, special handling for IE; 6. Fix error with time axes - time offset was not correctly interpreted. ## Changes in 3.3; 1. Use d3.time.scale for display of time scales; 2. Within JSRootCore.js script URL one could specify JSROOT; functionality to be loaded: '2d', '3d', 'io', 'load', 'onload'.; Old method with JSROOT.AssertPrerequisites will also work.; 3. With THttpServer JSROOT now provides simple control functionality.; One could publish commands and execute them from the browser; 4. One could open several ROOT files simultaneously; 5. Add 'simple' layout - drawing uses full space on the right side; 6. Allow to open ROOT files in o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:66445,extend,extend,66445,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['extend'],['extend']
Modifiability,"in a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle that semantically important behavior should be explicit. A simple; fix is to clear the instance variable manually during ``dealloc``; a more; holistic solution is to move semantically important side-effects out of; ``dealloc`` and into a separate teardown phase which can rely on working with; well-formed objects. .. _arc.misc.autoreleasepool:. ``@autoreleasepool``; --------------------. To simplify the use of autorelease pools, and to bring them under the control; of the compiler, a new kind of statement is available in Objective-C. It is; written ``@autoreleasepool`` followed by a *compound-statement*, i.e. by a new; scope delimited by curly braces. Upon entry to this block, the current state; of the autorelease pool is captured. When the block is exited normally,; whether by fallthrough or directed control flow (such as ``return`` o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89896,variab,variable,89896,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variable']
Modifiability,"in configuration: ``JavaScript``); Should be used for JavaScript. * ``LK_Json`` (in configuration: ``Json``); Should be used for JSON. * ``LK_ObjC`` (in configuration: ``ObjC``); Should be used for Objective-C, Objective-C++. * ``LK_Proto`` (in configuration: ``Proto``); Should be used for Protocol Buffers; (https://developers.google.com/protocol-buffers/). * ``LK_TableGen`` (in configuration: ``TableGen``); Should be used for TableGen code. * ``LK_TextProto`` (in configuration: ``TextProto``); Should be used for Protocol Buffer messages in text format; (https://developers.google.com/protocol-buffers/). * ``LK_Verilog`` (in configuration: ``Verilog``); Should be used for Verilog and SystemVerilog.; https://standards.ieee.org/ieee/1800/6700/; https://sci-hub.st/10.1109/IEEESTD.2018.8299595. .. _LineEnding:. **LineEnding** (``LineEndingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <LineEnding>`; Line ending style (``\n`` or ``\r\n``) to use. Possible values:. * ``LE_LF`` (in configuration: ``LF``); Use ``\n``. * ``LE_CRLF`` (in configuration: ``CRLF``); Use ``\r\n``. * ``LE_DeriveLF`` (in configuration: ``DeriveLF``); Use ``\n`` unless the input has more lines ending in ``\r\n``. * ``LE_DeriveCRLF`` (in configuration: ``DeriveCRLF``); Use ``\r\n`` unless the input has more lines ending in ``\n``. .. _MacroBlockBegin:. **MacroBlockBegin** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockBegin>`; A regular expression matching macros that start a block. .. code-block:: c++. # With:; MacroBlockBegin: ""^NS_MAP_BEGIN|\; NS_TABLE_HEAD$""; MacroBlockEnd: ""^\; NS_MAP_END|\; NS_TABLE_.*_END$"". NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. # Without:; NS_MAP_BEGIN; foo();; NS_MAP_END. NS_TABLE_HEAD; bar();; NS_TABLE_FOO_END. .. _MacroBlockEnd:. **MacroBlockEnd** (``String``) :versionbadge:`clang-format 3.7` :ref:`¶ <MacroBlockEnd>`; A regular expression matching macros that end a block. .. _Macros:. **Macros** (``List of Strings``) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:84531,config,configuration,84531,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"in configuration: ``Middle``); Align pointer in the middle. .. code-block:: c++. int * a;. .. _QualifierAlignment:. **QualifierAlignment** (``QualifierAlignmentStyle``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierAlignment>`; Different ways to arrange specifiers and qualifiers (e.g. const/volatile). .. warning::. Setting ``QualifierAlignment`` to something other than ``Leave``, COULD; lead to incorrect code formatting due to incorrect decisions made due to; clang-formats lack of complete semantic information.; As such extra care should be taken to review code changes made by the use; of this option. Possible values:. * ``QAS_Leave`` (in configuration: ``Leave``); Don't change specifiers/qualifiers to either Left or Right alignment; (default). .. code-block:: c++. int const a;; const int *a;. * ``QAS_Left`` (in configuration: ``Left``); Change specifiers/qualifiers to be left-aligned. .. code-block:: c++. const int a;; const int *a;. * ``QAS_Right`` (in configuration: ``Right``); Change specifiers/qualifiers to be right-aligned. .. code-block:: c++. int const a;; int const *a;. * ``QAS_Custom`` (in configuration: ``Custom``); Change specifiers/qualifiers to be aligned based on ``QualifierOrder``.; With:. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const']. .. code-block:: c++. int const a;; int const *a;. .. _QualifierOrder:. **QualifierOrder** (``List of Strings``) :versionbadge:`clang-format 14` :ref:`¶ <QualifierOrder>`; The order in which the qualifiers appear.; Order is an array that can contain any of the following:. * const; * inline; * static; * friend; * constexpr; * volatile; * restrict; * type. .. note::. it MUST contain 'type'. Items to the left of 'type' will be placed to the left of the type and; aligned in the order supplied. Items to the right of 'type' will be; placed to the right of the type and aligned in the order supplied. .. code-block:: yaml. QualifierOrder: ['inline', 'static', 'type', 'const', 'volatile' ]. .. _Ra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:97321,config,configuration,97321,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"in fitting. See rf606_nllerrorhandling.C for details; RooDataHist - Add new named argument constructor that can collate multiple ROOT THn histgrams into a n+1 dimensional RooDataHist; RooDataSet - Add new named argument constructor that can collate multiple input RooDataSets into a n+1 dimensional RooDataSet.Add createHistogram() method for simplified plotting; RooFitResult - Add new method correlationHist() that returns a labeled TH2 with the contents of the fit correlation matrix; RooFFTConvPdf - Automatically put sampling windows of 'resolution model' p.d.f. centered around zero, even if fit range of convolution observable does not bracket zero. Improve internal efficiency; RooAbsData - Add ability to plot efficiency distribution with correct binomial errors given a RooRealVar and a RooCategory category observable encoding distribution and accept/reject state respectively. See rf701_efficiencyfit.C for details ; RooAbsPdf - Included extended ML term by default in fit if p.d.f is extendable. You can still use Extended() to override default behavior. Do not run MINOS by default anymore if no fit options are provided.; RooProfileLL - Add option to always start minimization from global minimimum (takes more time, but improves reproducibility). Can now profile multi-core paralellized likelihoods as well.; RooRealSumPdf - Enable plotting of component p.d.f.s using same scheme as RooAddPdf, i.e. just use the Components() specified in plotOn().; RooExpensiveObjectCache - New cache manager for sharing and storing of expensive components cached by operator p.d.f.s ; RooMCStudy - Add Silence() argument to constructor to request minimal verbosity during running; RooMinuit - Improve contour() method to return RooPlots rather than drawing TGraphs straight on a canvas; RooWorkspace - Add private expensive object cache to workspace; RooBinningCategory - New real-to-category function that maps values of input RooRealVar to categories with labels that correspond to bins of input R",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:8280,extend,extendable,8280,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['extend'],['extendable']
Modifiability,"in real aspect.; - New graphics style ""BELLE2"" from Martin Ritter. ## 3D Graphics Libraries. ## Geometry Libraries. ### Geometry drawing in web browser. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7657,config,configuration,7657,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['config'],['configuration']
Modifiability,"in this case is scaled by the histogram bin width. ### TFormula. * Fix several bugs in the new TFormula class.; * Add as new pre-defined functions: `crystalball`, `breitwigner` and `cheb0,cheb1,...cheb10` for the Chebyshev polynomials. . ## Math Libraries. ### Random numbers. * Move from MathMore to MathCore the class `ROOT::Math::Random`. Make it a new interface class for random number generation. Add interfaces for standard; ROOT random engines, GSL random engines and random engines provided by the C++ standard library (`std::random`).; * Add a new randomengine, `MIXMAX` based on matrix-recursive random number generator from Kostas and George Savvidy. See this [paper](http://dx.doi.org/10.1016/j.cpc.2015.06.003). ## R Interface. Apply several improvements in the interface to R, allowing to use R functions within ROOT.; See more at the [ROOT-R User Guide](http://oproject.org/tiki-index.php?page=ROOT%20R%20Users%20Guide). . ## TMVA. Add new TMVA plug-in based on R and Python (using Scikit-Learn) ; * See the [RMVA Web page](http://oproject.org/tiki-index.php?page=RMVA) for a detailed description of the new TMVA method based on R; * See the [PyMVA Web page](http://oproject.org/tiki-index.php?page=PyMVA) for detailed description of the machine learning methods added in TMVA and based on the Python Scikit-Learn package. ## RooFit Libraries; . ## 2D Graphics Libraries. ### THistPainter. Improve the algorithm to compute the lower limit of an axis in log scale when its; real lower limit is 0. The problem was reported in ROOT-7414. Using the `COL` option with histograms having some negative bins; the empty bins; (containing 0) are drawn. In some cases one wants to not draw empty bins; (containing 0) of histograms having a negative minimum. The option `1`, used with; the option `COL`, allows to do that. Implement the Log option for `CANDLE` plots as requested; [here](https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=20225&p=87006#p87006). ### TTeXDump. From Dmitry Kalinkin (via",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:14082,plug-in,plug-in,14082,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['plug-in'],['plug-in']
Modifiability,"in this process.; Such volumes having shape parameters known only when used have to be; positioned only with **`TGeoManager::Node()` method (see ‘Creating and; Positioning Volumes').**. Other case when shape parameterizations are quite useful is scaling; geometry structures. Imagine that we would like to enlarge/shrink a; detector structure on one or more axes. This happens quite often in real; life and is handled by ""fitting mother"" parameters. This is accomplished; by defining shapes with one or more invalid (negative) parameters. For; instance, defining a box having `dx=10.`, `dy=10.`, and `dz=-1` will not; generate an error but will be interpreted in a different way: A special; volume **`TGeoVolumeMulti`** will be created. Whenever positioned inside; a mother volume, this will create a normal **`TGeoVolume`** object; having as shape a box with `dz` fitting the corresponding `dz `of the; mother shape. Generally, this type of parameterization is used when; positioning volumes in containers having a matching shape, but it works; also for most reasonable combinations. ## Geometry Creation. A given geometry can be built in various ways, but one has to follow; some mandatory steps. Even if we might use some terms that will be; explained later, here are few general rules:. - Volumes need media and shapes in order to be created.; - Both containers and contained volumes must be created before linking; them together, and the relative transformation matrix must be; provided.; - Any volume have to be positioned somewhere otherwise it will not be; considered as part of the geometry.; - Visibility or tracking properties of volumes can be provided both at; build time or after geometry is closed, but global visualization; settings (see section: ""The Drawing Package"") should not be provided; at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. - Positioned volumes should not extrude their container or intersect; with others within ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:56569,parameteriz,parameterization,56569,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['parameteriz'],['parameterization']
Modifiability,"in two ways:; 1. `LD_PRELOAD`: A micro library `libROOTSanitizerConfig.<dylib|so>` is created with the setup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1636,config,config,1636,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['config'],['config']
Modifiability,"in)LTO pipelines, module cloning led to some cases of; miscompilation, and we have moved away from trying to keep bitcode; generation and optimization completely disjoint. Bit-for-bit compatibility is not (and never was) a guarantee, and we reserve; the right to change this at any time. Explicitly, users should not rely on; the produced bitcode or object code to match their non-LTO counterparts; precisely. They will exhibit similar performance characteristics, but may; not be bit-for-bit the same. Internally, the ``.llvm.lto`` section is created by running the; ``EmbedBitcodePass`` after the ``ThinLTOPreLinkDefaultPipeline``. This pass is; responsible for emitting the ``.llvm.lto`` section. Afterwards, the; ``ThinLTODefaultPipeline`` runs and the compiler can emit the fat object file. Limitations; ===========. Linkers; -------. Currently, using LTO with LLVM fat lto objects is supported by LLD and by the; GNU linkers via :doc:`GoldPlugin`. This may change in the future, but; extending support to other linkers isn't planned for now. .. NOTE; For standard linking the fat object files should be usable by any; linker capable of using ELF objects, since the ``.llvm.lto`` section is; marked ``SHF_EXCLUDE``. Supported File Formats; ----------------------. The current implementation only supports ELF files. At time of writing, it is; unclear if it will be useful to support other object file formats like ``COFF``; or ``Mach-O``. Usage; =====. Clang users can specify ``-ffat-lto-objects`` with ``-flto`` or ``-flto=thin``.; Without the ``-flto`` option, ``-ffat-lto-objects`` has no effect. Compile an object file using FatLTO:. .. code-block:: console. $ clang -flto -ffat-lto-objects example.c -c -o example.o. Link using the object code from the fat object without LTO. This turns; ``-ffat-lto-objects`` into a no-op, when ``-fno-lto`` is specified:. .. code-block:: console. $ clang -fno-lto -ffat-lto-objects -fuse-ld=lld example.o. Alternatively, you can omit any references to L",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst:2471,extend,extending,2471,interpreter/llvm-project/llvm/docs/FatLTO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/FatLTO.rst,1,['extend'],['extending']
Modifiability,"in/sh``). To run ``/bin/sh``, first you specify options; to the shell itself (like ``-x`` which turns on trace output), then you specify; the name of the script to run, then you specify arguments to the script. These; arguments to the script are parsed by the Bourne shell command line option; processor, but are not interpreted as options to the shell itself. Using the; CommandLine library, we would specify this as:. .. code-block:: c++. cl::opt<string> Script(cl::Positional, cl::desc(""<input script>""), cl::init(""-""));; cl::list<string> Argv(cl::ConsumeAfter, cl::desc(""<program arguments>...""));; cl::opt<bool> Trace(""x"", cl::desc(""Enable trace output""));. which automatically provides the help output:. ::. USAGE: spiffysh [options] <input script> <program arguments>... OPTIONS:; -help - display available options (-help-hidden for more); -x - Enable trace output. At runtime, if we run our new shell replacement as ```spiffysh -x test.sh -a -x; -y bar``', the ``Trace`` variable will be set to true, the ``Script`` variable; will be set to ""``test.sh``"", and the ``Argv`` list will contain ``[""-a"", ""-x"",; ""-y"", ""bar""]``, because they were specified after the last positional argument; (which is the script name). There are several limitations to when ``cl::ConsumeAfter`` options can be; specified. For example, only one ``cl::ConsumeAfter`` can be specified per; program, there must be at least one `positional argument`_ specified, there must; not be any `cl::list`_ positional arguments, and the ``cl::ConsumeAfter`` option; should be a `cl::list`_ option. .. _can be changed:; .. _Internal vs External Storage:. Internal vs External Storage; ----------------------------. By default, all command line options automatically hold the value that they; parse from the command line. This is very convenient in the common case,; especially when combined with the ability to define command line options in the; files that use them. This is called the internal storage model. Sometimes, however,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:32325,variab,variable,32325,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['variab'],['variable']
Modifiability,"in; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72078,plugin,plugins,72078,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['plugin'],['plugins']
Modifiability,"in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge for its repositories. However,; there have been issues with this bridge working correctly in the past,; so it's not clear if this is something that will be supported going forward. Monorepo Drawbacks; ------------------. * Using the monolithic repository may add overhead for those contributing to a; standalone sub-project, particula",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:10165,config,configure,10165,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['config'],['configure']
Modifiability,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77297,config,configured,77297,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configured']
Modifiability,"inc` and `src` subdirectories. To see what classes are in a; library, you can check the `<library>/inc` directory for the list of; class definitions. For example, the physics library `libPhysics.so`; contains these class definitions:. ``` {.cpp}; > ls -m $ROOTSYS/math/physics/inc/; LinkDef.h, TFeldmanCousins.h, TGenPhaseSpace.h, TLorentzRotation.h,; TLorentzVector.h, TQuaternion.h, TRobustEstimator.h, TRolke.h,; TRotation.h, TVector2.h, TVector3.h; ```. ## How to Find More Information. website The ROOT web site has up to date documentation. The ROOT; source code automatically generates this documentation, so each class; is explicitly documented on its own web page, which is always up to; date with the latest official release of ROOT. The ROOT Reference Guide web pages can be found at class index; reference guide <https://root.cern/doc/master/classes.html>. Each; page contains a class description, and an explanation of each method.; It shows the class inheritance tree and lets you jump to the parent; class page by clicking on the class name. If you want more details,; you can even see the source. There is a help page available in the; little box on the upper right hand side of each class documentation; page. You can see on the next page what a typical class documentation; web page looks like. The ROOT web site also contains in addition to; this Reference Guide, ""How To's"", a list of publications and example; applications. ### Class Reference Guide. The top of any class reference page lets you jump to different parts; of the documentation. The first line links to the class index and the; index for the current module (a group of classes, often a library).; The second line links to the ROOT homepage and the class overviews.; The third line links the source information - a HTML version of the; source and header file as well as the CVS (the source management; system used for the ROOT development) information of the files. The; last line links the different parts of the cu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:24634,inherit,inheritance,24634,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['inherit'],['inheritance']
Modifiability,"include(GetLibraryName). if(LLVM_ENABLE_LIBXML2); set(imported_libs LibXml2::LibXml2); endif(). add_llvm_component_library(LLVMWindowsManifest; WindowsManifestMerger.cpp. ADDITIONAL_HEADER_DIRS; ${LLVM_MAIN_INCLUDE_DIR}/llvm/WindowsManifest; ${Backtrace_INCLUDE_DIRS}. LINK_LIBS; ${imported_libs}. LINK_COMPONENTS; Support; ). # This block is only needed for llvm-config. When we deprecate llvm-config and; # move to using CMake export, this block can be removed.; if(LLVM_ENABLE_LIBXML2); # CMAKE_BUILD_TYPE is only meaningful to single-configuration generators.; if(CMAKE_BUILD_TYPE); string(TOUPPER ${CMAKE_BUILD_TYPE} build_type); get_property(libxml2_library TARGET LibXml2::LibXml2 PROPERTY LOCATION_${build_type}); endif(); if(NOT libxml2_library); get_property(libxml2_library TARGET LibXml2::LibXml2 PROPERTY LOCATION); endif(); get_library_name(${libxml2_library} libxml2_library); set_property(TARGET LLVMWindowsManifest PROPERTY LLVM_SYSTEM_LIBS ${libxml2_library}); endif(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt:364,config,config,364,interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/WindowsManifest/CMakeLists.txt,3,['config'],"['config', 'configuration']"
Modifiability,"include(UseLibtool); endif(). # Override the default target with an environment variable named by LLVM_TARGET_TRIPLE_ENV.; set(LLVM_TARGET_TRIPLE_ENV CACHE STRING ""The name of environment variable to override default target. Disabled by blank.""); mark_as_advanced(LLVM_TARGET_TRIPLE_ENV). if(CMAKE_SYSTEM_NAME MATCHES ""BSD|Linux|OS390""); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default ON); else(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default OFF); endif(); set(LLVM_ENABLE_PER_TARGET_RUNTIME_DIR ${LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_default} CACHE BOOL; ""Enable per-target runtimes directory""). set(LLVM_PROFDATA_FILE """" CACHE FILEPATH; ""Profiling data file to use when compiling in order to improve runtime performance.""). if(LLVM_INCLUDE_TESTS); # Lit test suite requires at least python 3.6; set(LLVM_MINIMUM_PYTHON_VERSION 3.6); else(); # FIXME: it is unknown if this is the actual minimum bound; set(LLVM_MINIMUM_PYTHON_VERSION 3.0); endif(). # Find python before including config-ix, since it needs to be able to search; # for python modules.; find_package(Python3 ${LLVM_MINIMUM_PYTHON_VERSION} REQUIRED; COMPONENTS Interpreter). # All options referred to from HandleLLVMOptions have to be specified; # BEFORE this include, otherwise options will not be correctly set on; # first cmake run; include(config-ix). # By default, we target the host, but this can be overridden at CMake; # invocation time. Except on 64-bit AIX, where the system toolchain; # expect 32-bit objects by default.; if(""${LLVM_HOST_TRIPLE}"" MATCHES ""^powerpc64-ibm-aix""); string(REGEX REPLACE ""^powerpc64"" ""powerpc"" LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); else(); # Only set default triple when native target is enabled.; if (LLVM_NATIVE_TARGET); set(LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT ""${LLVM_HOST_TRIPLE}""); endif(); endif(). set(LLVM_DEFAULT_TARGET_TRIPLE ""${LLVM_DEFAULT_TARGET_TRIPLE_DEFAULT}"" CACHE STRING; ""Default target for which LLVM will generate code."" ); message(STATUS ""LLVM default tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:37581,config,config-ix,37581,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['config'],['config-ix']
Modifiability,"inconvenient; since the fuzzer needs to report a leak with a reproducer as soon as the leaky; mutation is found. However, running full leak detection after every mutation; is expensive. By default (``-detect_leaks=1``) libFuzzer will count the number of; ``malloc`` and ``free`` calls when executing every mutation.; If the numbers don't match (which by itself doesn't mean there is a leak); libFuzzer will invoke the more expensive LeakSanitizer_; pass and if the actual leak is found, it will be reported with the reproducer; and the process will exit. If your target has massive leaks and the leak detection is disabled; you will eventually run out of RAM (see the ``-rss_limit_mb`` flag). Developing libFuzzer; ====================. LibFuzzer is built as a part of LLVM project by default on macos and Linux.; Users of other operating systems can explicitly request compilation using; ``-DCOMPILER_RT_BUILD_LIBFUZZER=ON`` flag.; Tests are run using ``check-fuzzer`` target from the build directory; which was configured with ``-DCOMPILER_RT_INCLUDE_TESTS=ON`` flag. .. code-block:: console. ninja check-fuzzer. FAQ; =========================. Q. Why doesn't libFuzzer use any of the LLVM support?; -----------------------------------------------------. There are two reasons. First, we want this library to be used outside of the LLVM without users having to; build the rest of LLVM. This may sound unconvincing for many LLVM folks,; but in practice the need for building the whole LLVM frightens many potential; users -- and we want more users to use this code. Second, there is a subtle technical reason not to rely on the rest of LLVM, or; any other large body of code (maybe not even STL). When coverage instrumentation; is enabled, it will also instrument the LLVM support code which will blow up the; coverage set of the process (since the fuzzer is in-process). In other words, by; using more external dependencies we will slow down the fuzzer while the main; reason for it to exist is ext",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:27503,config,configured,27503,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['config'],['configured']
Modifiability,"ind a heap map given the stack address. The missing pieces are a) integration with rewriting (RS4GC) from the; abstract machine model and b) support for optionally decomposing on stack; objects so as not to require heap maps for them. The later is required; for ease of integration with some collectors. Lowering Quality and Representation Overhead; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The current statepoint lowering is known to be somewhat poor. In the very; long term, we'd like to integrate statepoints with the register allocator;; in the near term this is unlikely to happen. We've found the quality of; lowering to be relatively unimportant as hot-statepoints are almost always; inliner bugs. Concerns have been raised that the statepoint representation results in a; large amount of IR being produced for some examples and that this; contributes to higher than expected memory usage and compile times. There's; no immediate plans to make changes due to this, but alternate models may be; explored in the future. Relocations Along Exceptional Edges; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Relocations along exceptional paths are currently broken in ToT. In; particular, there is current no way to represent a rethrow on a path which; also has relocations. See `this llvm-dev discussion; <https://groups.google.com/forum/#!topic/llvm-dev/AE417XjgxvI>`_ for more; detail. Bugs and Enhancements; =====================. Currently known bugs and enhancements under consideration can be; tracked by performing a `bugzilla search; <https://bugs.llvm.org/buglist.cgi?cmdtype=runnamed&namedcmd=Statepoint%20Bugs&list_id=64342>`_; for [Statepoint] in the summary field. When filing new bugs, please; use this tag so that interested parties see the newly filed bug. As; with most LLVM features, design discussions take place on the `Discourse forums <https://discourse.llvm.org>`_ and patches; should be sent to `llvm-commits; <http://lists.llvm.org/mailman/listinfo/llvm-commits>`_ for review.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:36414,enhance,enhancements,36414,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['enhance'],['enhancements']
Modifiability,index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support/FileCache.cpp; clang-tools-extra/clangd/support/FileCache.h; clang-tools-extra/clangd/support/Function.h; clang-tools-extra/clangd/support/Logger.cpp; clang-tools-extra/clangd/support/Markup.cpp; clang-tools-extra/clangd/support/Markup.h; clang-tools-extra/clangd/support/MemoryTree.cpp; clang-tools-extra/clangd/support/MemoryTree.h; clang-tools-extra/clangd/support/Path.cpp; clang-tools-extra/clangd/support/Path.h; clang-,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80505,refactor,refactor,80505,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"ine namespace declaration. The attribute takes; one or more strings (called tags); the order does not matter. See https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html for; details. Tags on an inline namespace are called ""implicit tags"", all other tags are; ""explicit tags"". Mangling; ========. All tags that are ""active"" on an <unqualified-name> are emitted after the; <unqualified-name>, before <template-args> or <discriminator>, and are part of; the same <substitution> the <unqualified-name> is. They are mangled as:. .. code-block:: none. <abi-tags> ::= <abi-tag>* # sort by name; <abi-tag> ::= B <tag source-name>. Example:. .. code-block:: c++. __attribute__((abi_tag(""test""))); void Func();; // gets mangled as: _Z4FuncB4testv (prettified as `Func[abi:test]()`). Active tags; ===========. A namespace does not have any active tags. For types (class / struct / union /; enum), the explicit tags are the active tags. For variables and functions, the active tags are the explicit tags plus any; ""required tags"" which are not in the ""available tags"" set:. .. code-block:: none. derived-tags := (required-tags - available-tags); active-tags := explicit-tags + derived-tags. Required tags for a function; ============================. If a function is used as a local scope for another name, and is part of; another function as local scope, it doesn't have any required tags. If a function is used as a local scope for a guard variable name, it doesn't; have any required tags. Otherwise the function requires any implicit or explicit tag used in the name; for the return type. Example:. .. code-block:: c++. namespace A {; inline namespace B __attribute__((abi_tag)) {; struct C { int x; };; }; }. A::C foo(); // gets mangled as: _Z3fooB1Bv (prettified as `foo[abi:B]()`). Required tags for a variable; ============================. A variable requires any implicit or explicit tag used in its type. Available tags; ==============. All tags used in the prefix and in the template argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst:1429,variab,variables,1429,interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ItaniumMangleAbiTags.rst,1,['variab'],['variables']
Modifiability,"ined enums are stored as a leaf field with a single subfield named `_0`.; The parent field has no attached columns.; The subfield corresponds to the integer type the underlies the enum.; Unscoped and scoped enums are supported as long as the enum has a dictionary. ### User-defined classes. User-defined classes might behave either as a record or as a collection of elements of a given type.; The behavior depends on whether the class has an associated collection proxy. #### Regular class / struct. User defined C++ classes are supported with the following limitations; - The class must have a dictionary; - All persistent members and base classes must be themselves types with RNTuple I/O support; - Transient members must be marked, e.g. by a `//!` comment; - The class must not be in the `std` namespace; - The class must be empty or splittable (e.g., the class must not provide a custom streamer); - There is no support for polymorphism,; i.e. a field of class `A` cannot store class `B` that derives from `A`; - Virtual inheritance is unsupported. User classes are stored as a record parent field with no attached columns.; Direct base classes and persistent members are stored as subfields with their respective types.; The field name of member subfields is identical to the C++ field name.; The field name of base class subfields are numbered and preceded by a colon (`:`), i.e. `:_0`, `:_1`, ... #### Classes with an associated collection proxy. User classes that specify a collection proxy behave as collections of a given value type. The on-disk representation of non-associative collections is identical to a `std::vector<T>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64|32]`.; - Child field of type `T`, which must be a type with RNTuple I/O support. The on-disk representation of associative collections is identical to a `std::map<K, V>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:45254,inherit,inheritance,45254,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['inherit'],['inheritance']
Modifiability,"ined. Variables are provided; to hold temporary values while processing the body. See `Defvar in a Record; Body`_ for more details. When class ``C2`` inherits from class ``C1``, it acquires all the field; definitions of ``C1``. As those definitions are merged into class ``C2``, any; template arguments passed to ``C1`` by ``C2`` are substituted into the; definitions. In other words, the abstract record fields defined by ``C1`` are; expanded with the template arguments before being merged into ``C2``. .. _def:. ``def`` --- define a concrete record; ------------------------------------. A ``def`` statement defines a new concrete record. .. productionlist::; Def: ""def"" [`NameValue`] `RecordBody`; NameValue: `Value` (parsed in a special mode). The name value is optional. If specified, it is parsed in a special mode; where undefined (unrecognized) identifiers are interpreted as literal; strings. In particular, global identifiers are considered unrecognized.; These include global variables defined by ``defvar`` and ``defset``. A; record name can be the null string. If no name value is given, the record is *anonymous*. The final name of an; anonymous record is unspecified but globally unique. Special handling occurs if a ``def`` appears inside a ``multiclass``; statement. See the ``multiclass`` section below for details. A record can inherit from one or more classes by specifying the; :token:`ParentClassList` clause at the beginning of its record body. All of; the fields in the parent classes are added to the record. If two or more; parent classes provide the same field, the record ends up with the field value; of the last parent class. As a special case, the name of a record can be passed as a template argument; to that record's parent classes. For example:. .. code-block:: text. class A <dag d> {; dag the_dag = d;; }. def rec1 : A<(ops rec1)>;. The DAG ``(ops rec1)`` is passed as a template argument to class ``A``. Notice; that the DAG includes ``rec1``, the record being ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:27884,variab,variables,27884,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['variab'],['variables']
Modifiability,"iner only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mechanism. The following; sorted collections are available (the stored items must be sortable):. - **`TSortedList`**. - **`TBtree`**. Unordered collections don't maintain th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3907,inherit,inheritance,3907,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inheritance']
Modifiability,"ines: 1 vs. ShortNamespaceLines: 0; namespace b { namespace b {; int foo; int foo;; int bar; int bar;; } // namespace b } // namespace b. .. _SkipMacroDefinitionBody:. **SkipMacroDefinitionBody** (``Boolean``) :versionbadge:`clang-format 18` :ref:`¶ <SkipMacroDefinitionBody>`; Do not format macro definition body. .. _SortIncludes:. **SortIncludes** (``SortIncludesOptions``) :versionbadge:`clang-format 3.8` :ref:`¶ <SortIncludes>`; Controls if and how clang-format will sort ``#includes``. Possible values:. * ``SI_Never`` (in configuration: ``Never``); Includes are never sorted. .. code-block:: c++. #include ""B/A.h""; #include ""A/B.h""; #include ""a/b.h""; #include ""A/b.h""; #include ""B/a.h"". * ``SI_CaseSensitive`` (in configuration: ``CaseSensitive``); Includes are sorted in an ASCIIbetical or case sensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""B/A.h""; #include ""B/a.h""; #include ""a/b.h"". * ``SI_CaseInsensitive`` (in configuration: ``CaseInsensitive``); Includes are sorted in an alphabetical or case insensitive fashion. .. code-block:: c++. #include ""A/B.h""; #include ""A/b.h""; #include ""a/b.h""; #include ""B/A.h""; #include ""B/a.h"". .. _SortJavaStaticImport:. **SortJavaStaticImport** (``SortJavaStaticImportOptions``) :versionbadge:`clang-format 12` :ref:`¶ <SortJavaStaticImport>`; When sorting Java imports, by default static imports are placed before; non-static imports. If ``JavaStaticImportAfterImport`` is ``After``,; static imports are placed after non-static imports. Possible values:. * ``SJSIO_Before`` (in configuration: ``Before``); Static imports are placed before non-static imports. .. code-block:: java. import static org.example.function1;. import org.example.ClassA;. * ``SJSIO_After`` (in configuration: ``After``); Static imports are placed after non-static imports. .. code-block:: java. import org.example.ClassA;. import static org.example.function1;. .. _SortUsingDeclarations:. **SortUsingDeclarations** (``SortUsingDeclaration",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:109662,config,configuration,109662,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ing an histogram with a function if it is represented as an histogram with zero errors (equivalent to the case of options ""F1"" or ""F2"" in the original HDIFF routine of HBOOK). The bug has been fixed also for the TH2 and TH3 corresponding method. In addition in the case of TH3 use now all 6 axis combinations for estimating the maximum deviation. This is consistent with what is done in the 2D case.; Improved the TH1::Chi2Test for the treatment of empty bins in the histograms. If both histograms have one empty bin, the number of degree of freedom is decreased by one but the test is performed without reporting an error. If only one histogram is having an empty bin it is considered in the comparison. Fixed a bug in preserving the global statistic information after scaling, adding or rebinning the histogram. TH2. Improve TH2::FitFitSliceX and TH2::FitFitSliceY by adding the possibility to return the generated histograms in a TObjArray when the passed pointer is not null. Support also variable bin size histograms. Improve histogram projections. The implementation of TH2::ProjectionX and TH2::ProjectionY has been combined in a single private method. TH3. Fixed a couple of bugs in TH3::Project3DProfile. TProfile and TProfile2D. Add a new option ""W"" in TProfile::ProjectionX and TProfile::ProjectionXY to be able to return the equivalent weighted filled histogram. Its bin content is equal to the profile bin content multiplied by the bin entries. Implement in the TProfile a new option, ""G"" for the bin error. This option can be used, bin by bin, for the combination of measurements y with known gaussian error dy. In this case the profile must be filled; with a weight = 1./dy**2 and the resulting error from the combination (1./sqrt(Sum(1./dy**2) ) ) will be calculated by the profile. . THnSparse. Implement THnSparse::Projection and THnSparse::Merge. New Tutorials. tutorials/hist/sparsehist.C: an example how to use the new multi dim histogram class THnSparse.; tutorials/hist/drawspar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html:1821,variab,variable,1821,hist/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/doc/v520/index.html,1,['variab'],['variable']
Modifiability,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:2023,config,configure,2023,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"ing and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:14919,config,config,14919,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,2,"['config', 'variab']","['config', 'variables']"
Modifiability,"ing behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:31926,variab,variables,31926,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"ing diagnostics; of static analysis tools, such as the Clang Static Analyzer.; `Documentation <https://clang.llvm.org/docs/AttributeReference.html#suppress>`__. - Support ""Deducing this"" (P0847R7). (Worked out of the box); (`af4751738db8 <https://github.com/llvm/llvm-project/commit/af4751738db89a142a8880c782d12d4201b222a8>`__). - Added a new checker ``core.BitwiseShift`` which reports situations where; bitwise shift operators produce undefined behavior (because some operand is; negative or too large).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#core-bitwiseshift-c-c>`__. - Added a new experimental checker ``alpha.core.StdVariant`` to detect variant; accesses via wrong alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70005,polymorphi,polymorphic,70005,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['polymorphi'],['polymorphic']
Modifiability,"ing format; ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Size +-+; |  |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Items (for list frames) |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | FRAME PAYLOAD |; | ... |; ```. _Size_: The absolute value gives the (uncompressed) size in bytes of the frame and the payload. _T(ype)_: Can be either 0 for a **record frame** or 1 for a **list frame**.; The type should be interpreted as the sign bit of the size, i.e. negative sizes indicate list frames. _Number of items_: Only used for list frames to indicate the length of the list in the frame payload. File format readers should use the size provided in the frame to seek to the data that follows a frame; instead of summing up the sizes of the elements in the frame.; This approach ensures that frames can be extended in future file format versions; without breaking the deserialization of older readers. ## Locators and Envelope Links. A locator is a generalized way to specify a certain byte range on the storage medium.; For disk-based storage, the locator is just byte offset and byte size.; For other storage systems, the locator contains enough information to retrieve the referenced block,; e.g. in object stores, the locator can specify a certain object ID.; The locator has the following format. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Size |T|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Offset +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. _Size_: If `T` is zero, the number of bytes to read, i.e. the compressed size of the referenced block.; Otherwise, the 16 least-significant bits, i.e. bits 0:15, specify the size of the locator itself (see below",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:8992,extend,extended,8992,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['extend'],['extended']
Modifiability,"ing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a discarded section. The metadata is often used with an explicit section consisting of valid C; identifiers so that the runtime can find the metadata section with; linker-defined encapsulation symbols ``__start_<section_name>`` and; ``__stop_<section_name>``. It does not have any effect on non-ELF targets. Example:. .. code-block:: text. $a = comdat any; @a = global i32 1, comdat $a; @b = internal global i32 2, comdat $a, section ""abc"", !as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:318454,variab,variable,318454,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ing multiple tests divided into logical blocks, one; or more ``CHECK:`` directives may inadvertently succeed by matching lines in a; later block. While an error will usually eventually be generated, the check; flagged as causing the error may not actually bear any relationship to the; actual source of the problem. In order to produce better error messages in these cases, the ""``CHECK-LABEL:``""; directive can be used. It is treated identically to a normal ``CHECK``; directive except that FileCheck makes an additional assumption that a line; matched by the directive cannot also be matched by any other check present in; ``match-filename``; this is intended to be used for lines containing labels or; other unique identifiers. Conceptually, the presence of ``CHECK-LABEL`` divides; the input stream into separate blocks, each of which is processed independently,; preventing a ``CHECK:`` directive in one block matching a line in another block.; If ``--enable-var-scope`` is in effect, all local variables are cleared at the; beginning of the block. For example,. .. code-block:: llvm. define %struct.C* @C_ctor_base(%struct.C* %this, i32 %x) {; entry:; ; CHECK-LABEL: C_ctor_base:; ; CHECK: mov [[SAVETHIS:r[0-9]+]], r0; ; CHECK: bl A_ctor_base; ; CHECK: mov r0, [[SAVETHIS]]; %0 = bitcast %struct.C* %this to %struct.A*; %call = tail call %struct.A* @A_ctor_base(%struct.A* %0); %1 = bitcast %struct.C* %this to %struct.B*; %call2 = tail call %struct.B* @B_ctor_base(%struct.B* %1, i32 %x); ret %struct.C* %this; }. define %struct.D* @D_ctor_base(%struct.D* %this, i32 %x) {; entry:; ; CHECK-LABEL: D_ctor_base:. The use of ``CHECK-LABEL:`` directives in this case ensures that the three; ``CHECK:`` directives only accept lines corresponding to the body of the; ``@C_ctor_base`` function, even if the patterns match lines found later in; the file. Furthermore, if one of these three ``CHECK:`` directives fail,; FileCheck will recover by continuing to the next block, allowing multiple test; fa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:22373,variab,variables,22373,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,1,['variab'],['variables']
Modifiability,"ing the enumeration are not actually retained and; released. .. admonition:: Rationale. This is an optimization made possible because fast enumeration loops promise; to keep the objects retained during enumeration, and the collection itself; cannot be synchronously modified. It can be overridden by explicitly; qualifying the variable with ``__strong``, which will make the variable; mutable again and cause the loop to retain the objects it encounters. .. _arc.misc.blocks:. Blocks; ------. The implicit ``const`` capture variables created when evaluating a block; literal expression have the same ownership semantics as the local variables; they capture. The capture is performed by reading from the captured variable; and initializing the capture variable with that value; the capture variable is; destroyed when the block literal is, i.e. at the end of the enclosing scope. The :ref:`inference <arc.ownership.inference>` rules apply equally to; ``__block`` variables, which is a shift in semantics from non-ARC, where; ``__block`` variables did not implicitly retain during capture. ``__block`` variables of retainable object owner type are moved off the stack; by initializing the heap copy with the result of moving from the stack copy. With the exception of retains done as part of initializing a ``__strong``; parameter variable or reading a ``__weak`` variable, whenever these semantics; call for retaining a value of block-pointer type, it has the effect of a; ``Block_copy``. The optimizer may remove such copies when it sees that the; result is used only as an argument to a call. When a block pointer type is converted to a non-block pointer type (such as; ``id``), ``Block_copy`` is called. This is necessary because a block allocated; on the stack won't get copied to the heap when the non-block pointer escapes.; A block pointer is implicitly converted to ``id`` when it is passed to a; function as a variadic argument. .. _arc.misc.exceptions:. Exceptions; ----------. By default in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:96662,variab,variables,96662,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['variab'],['variables']
Modifiability,"ing to call ``[super dealloc]`` in such a; method is nearly always a bug. Sometimes, the object is simply trying to; prevent itself from being destroyed, but ``dealloc`` is really far too late; for the object to be raising such objections. Somewhat more legitimately, an; object may have been pool-allocated and should not be deallocated with; ``free``; for now, this can only be supported with a ``dealloc``; implementation outside of ARC. Such an implementation must be very careful; to do all the other work that ``NSObject``'s ``dealloc`` would, which is; outside the scope of this document to describe. The instance variables for an ARC-compiled class will be destroyed at some; point after control enters the ``dealloc`` method for the root class of the; class. The ordering of the destruction of instance variables is unspecified,; both within a single class and between subclasses and superclasses. .. admonition:: Rationale. The traditional, non-ARC pattern for destroying instance variables is to; destroy them immediately before calling ``[super dealloc]``. Unfortunately,; message sends from the superclass are quite capable of reaching methods in; the subclass, and those methods may well read or write to those instance; variables. Making such message sends from dealloc is generally discouraged,; since the subclass may well rely on other invariants that were broken during; ``dealloc``, but it's not so inescapably dangerous that we felt comfortable; calling it undefined behavior. Therefore we chose to delay destroying the; instance variables to a point at which message sends are clearly disallowed:; the point at which the root class's deallocation routines take over. In most code, the difference is not observable. It can, however, be observed; if an instance variable holds a strong reference to an object whose; deallocation will trigger a side-effect which must be carefully ordered with; respect to the destruction of the super class. Such code violates the design; principle",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:89105,variab,variables,89105,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"ing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/binutils/include``. The correct include; path will contain the file ``plugin-api.h``. Usage; =====. You should produce bitcode files from ``clang`` with the option; ``-flto``. This flag will also cause ``clang`` to look for the gold plugin in; the ``lib`` directory under its prefix and pass the ``-plugin`` option to; ``ld``. It will not look for an alternate linker without ``-fuse-ld=gold``,; which is why you otherwise need gold to be the installed system linker in; your path. ``ar`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2506,plugin,plugins,2506,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugins']
Modifiability,"ing"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficiencies belonging into a bin. Since the best; background rejection is in general obtained for the lowest; possible signal efficiency, the reference signal efficiency; is the lowest value in the bin.; ; Cuts: Fixed Cuts (optimisaton) method -> event; with smallest value was not included in search for optimal; cut (thanks to Dimitris Varouchas, LAL-Orsay, for helping; us detecting the problem).; ; Genetic Algorithm: Corrected configurable random; seed in GeneticAlgorithm (thanks to David Gonzalez Maline,; CERN, for pointing this out); ; GUI: Fixes in input-variable and MVA plotting:; under/over-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:4735,config,configurable,4735,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,1,['config'],['configurable']
Modifiability,"ing; the option of automatic loading), standard classes are never duplicated, and; there is no additional ""per-module"" overhead.; Thus, eventually (depending on the number of classes bound, across how many; modules, what use fraction, etc.), this initial cost is recouped when; compared to other binders.; As a rule of thumb, if about 10% of classes are used, it takes several; hundreds of bound classes before the cppyy-approach is beneficial.; In High Energy Physics, from which it originated, cppyy is regularly used in; software stacks of many thousands of classes, where this advantage is very; important. `Distributing headers`; ----------------------. cppyy requires C/C++ headers to be available at run-time, which was never a; problem in the developer-centric world from which it originated: software; always had supported C++ APIs already, made available through header files,; and Python simply piggy-backed onto those.; JIT-ing code in those headers, which potentially picked up system headers; that were configured differently, was thus also never a problem.; Or rather, the same problem exists for C++, and configuration for C++ to; resolve potential issues translates transparently to Python. There are only two alternatives: precompile headers into LLVM bitcode and; distribute those or provide a restricted set of headers.; Precompiled headers (and modules) were never designed to be portable and; relocatable, however, thus that may not be the panacea it seems.; A restricted set of headers is some work, but cppyy can operate on abstract; interface classes just fine (including Python-side cross-inheritance). `Large deployment`; ------------------. The single biggest headache in maintaining an installation of Python; extension modules is that Python patch releases can break them.; The two typical solutions are to either restrict the choice of Python; interpreter and version that are supported (common in HPC) or to provide; binaries (wheels) for a large range of different int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst:10003,config,configured,10003,bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/philosophy.rst,1,['config'],['configured']
Modifiability,"ingle; Assignment <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_; - the concepts are really quite natural once you grok them. Note that instead of adding virtual methods to the ExprAST class; hierarchy, it could also make sense to use a `visitor; pattern <http://en.wikipedia.org/wiki/Visitor_pattern>`_ or some other; way to model this. Again, this tutorial won't dwell on good software; engineering practices: for our purposes, adding a virtual method is; simplest. The second thing we want is a ""LogError"" method like we used for the; parser, which will be used to report errors found during code generation; (for example, use of an undeclared parameter):. .. code-block:: c++. static std::unique_ptr<LLVMContext> TheContext;; static std::unique_ptr<IRBuilder<>> Builder(TheContext);; static std::unique_ptr<Module> TheModule;; static std::map<std::string, Value *> NamedValues;. Value *LogErrorV(const char *Str) {; LogError(Str);; return nullptr;; }. The static variables will be used during code generation. ``TheContext``; is an opaque object that owns a lot of core LLVM data structures, such as; the type and constant value tables. We don't need to understand it in; detail, we just need a single instance to pass into APIs that require it. The ``Builder`` object is a helper object that makes it easy to generate; LLVM instructions. Instances of the; `IRBuilder <https://llvm.org/doxygen/IRBuilder_8h_source.html>`_; class template keep track of the current place to insert instructions; and has methods to create new instructions. ``TheModule`` is an LLVM construct that contains functions and global; variables. In many ways, it is the top-level structure that the LLVM IR; uses to contain code. It will own the memory for all of the IR that we; generate, which is why the codegen() method returns a raw Value\*,; rather than a unique_ptr<Value>. The ``NamedValues`` map keeps track of which values are defined in the; current scope and what their LLVM representation is. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:3164,variab,variables,3164,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variables']
Modifiability,"ining the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup following a certain order. - `common.before`. - `local.before`. - `local.conf`. - `$VafConf_LocalPodLocation/PoD_env.sh`. - `common.after`. - `local.after`. The `common.*` files are sourced both for the local and the remote; environment. This might be convenient to avoid repeating the same; configuration in different places. Each file is looked for first in the system-wide directory and then in; the user's directory. If a configuration file does not exist, it is; silently skipped. The `$VafConf_LocalPodLocation/PoD_env.sh` environment script, provided; with each PROOF on Demand installation, *must exist*: without this file,; the VAF client won't start. ### List of VAF-specific variables. There are some special variables that need to be set in one of the above; configuration files. `$VafConf_LocalPodLocation`; : Full path to the PoD installation on the client. > The `$VafConf_LocalPodLocation` variable must be set before the; > `PoD_env.sh` script gets sourced, so set it either in; > `common.before`, `local.before` or `local.conf`. Since PoD is; > usually system-wide installed, its location is normally; > system-wide set in either the `local.conf` file by the system; > administrator. `$VafConf_RemotePodLocation`; : Full path to the PoD installation on the VAF master node. *Note: this variable should be set in the configuration files for; the local environment despite it refers to a software present on the; remote nodes.*. `$VafConf_PodRms` *(optional)*; : Name of the Resource Management System used for submitting PoD jobs.; Run `pod-submit -l` to see the possible values. If not set, defaults to `condor`. `$VafConf_PodQueue` *(optional)*; : Queue name ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:3307,variab,variables,3307,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['variab'],['variables']
Modifiability,"initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remembering the active navigation state is; to use parallel navigation. The following paragraphs will describe the; usage of a single navigator. All setters/getters for navigation state; parameters as well as navigation queries provided by **`TGeoNavigator`**; are interfaced by **`TGeoManager`** and will act on the current; navigator. ### Initializing the Starting Point. The current point (`x,y,z`) known by the modeller is stored as; `Double_t fCurrentPoint[3]` by the navigator class. This array of the; three coordinates is defined in the current global reference system and; can be retrieved any time:. ``` {.cpp}; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; ```. Initializing this point can be done ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:103232,variab,variables,103232,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['variab'],['variables']
Modifiability,"initializer2(). * ``BCIS_AfterColon`` (in configuration: ``AfterColon``); Break constructor initializers after the colon and commas. .. code-block:: c++. Constructor() :; initializer1(),; initializer2(). .. _BreakInheritanceList:. **BreakInheritanceList** (``BreakInheritanceListStyle``) :versionbadge:`clang-format 7` :ref:`¶ <BreakInheritanceList>`; The inheritance list style to use. Possible values:. * ``BILS_BeforeColon`` (in configuration: ``BeforeColon``); Break inheritance list before the colon and after the commas. .. code-block:: c++. class Foo; : Base1,; Base2; {};. * ``BILS_BeforeComma`` (in configuration: ``BeforeComma``); Break inheritance list before the colon and commas, and align; the commas with the colon. .. code-block:: c++. class Foo; : Base1; , Base2; {};. * ``BILS_AfterColon`` (in configuration: ``AfterColon``); Break inheritance list after the colon and commas. .. code-block:: c++. class Foo :; Base1,; Base2; {};. * ``BILS_AfterComma`` (in configuration: ``AfterComma``); Break inheritance list only after the commas. .. code-block:: c++. class Foo : Base1,; Base2; {};. .. _BreakStringLiterals:. **BreakStringLiterals** (``Boolean``) :versionbadge:`clang-format 3.9` :ref:`¶ <BreakStringLiterals>`; Allow breaking string literals when formatting. In C, C++, and Objective-C:. .. code-block:: c++. true:; const char* x = ""veryVeryVeryVeryVeryVe""; ""ryVeryVeryVeryVeryVery""; ""VeryLongString"";. false:; const char* x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. In C# and Java:. .. code-block:: c++. true:; string x = ""veryVeryVeryVeryVeryVe"" +; ""ryVeryVeryVeryVeryVery"" +; ""VeryLongString"";. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. C# interpolated strings are not broken. In Verilog:. .. code-block:: c++. true:; string x = {""veryVeryVeryVeryVeryVe"",; ""ryVeryVeryVeryVeryVery"",; ""VeryLongString""};. false:; string x =; ""veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString"";. .. _ColumnLimit:. **C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:55712,config,configuration,55712,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,"['config', 'inherit']","['configuration', 'inheritance']"
Modifiability,"ink your program with ``-fsanitize=memtag`` flag. This; will only work when targeting AArch64 with MemTag extension. One; possible way to achieve that is to add ``-target; aarch64-linux -march=armv8+memtag`` to compilation flags. Implementation; ==============. See `HardwareAssistedAddressSanitizer`_ for a general overview of a; tag-based approach to memory safety. MemTagSanitizer follows a; similar implementation strategy, but with the tag storage (shadow); provided by the hardware. A quick overview of MTE hardware capabilities:. * Every 16 aligned bytes of memory can be assigned a 4-bit Allocation Tag.; * Every pointer can have a 4-bit Address Tag that is in its most significant byte.; * Most memory access instructions generate an exception if Address Tag != Allocation Tag.; * Special instructions are provided for fast tag manipulation. Stack instrumentation; =====================. Stack-based memory errors are detected by updating Allocation Tag for; each local variable to a random value at the start of its lifetime,; and resetting it to the stack pointer Address Tag at the end of; it. Unallocated stack space is expected to match the Address Tag of; SP; this allows to skip tagging of any variable when memory safety can; be statically proven. Allocating a truly random tag for each stack variable in a large; function may incur significant code size overhead, because it means; that each variable's address is an independent, non-rematerializable; value; thus a function with N local variables will have extra N live; values to keep through most of its life time. For this reason MemTagSanitizer generates at most one random tag per; function, called a ""base tag"". Other stack variables, if there are; any, are assigned tags at a fixed offset from the base. Please refer to `this document; <https://github.com/google/sanitizers/wiki/Stack-instrumentation-with-ARM-Memory-Tagging-Extension-(MTE)>`_; for more details about stack instrumentation. Heap tagging; ============. **Note",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst:1927,variab,variable,1927,interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemTagSanitizer.rst,1,['variab'],['variable']
Modifiability,"inkage,; Constant *Initializer = 0, const std::string &Name = """", Module* Parent = 0)``. Create a new global variable of the specified type. If ``isConstant`` is true; then the global variable will be marked as unchanging for the program. The; Linkage parameter specifies the type of linkage (internal, external, weak,; linkonce, appending) for the variable. If the linkage is InternalLinkage,; WeakAnyLinkage, WeakODRLinkage, LinkOnceAnyLinkage or LinkOnceODRLinkage, then; the resultant global variable will have internal linkage. AppendingLinkage; concatenates together all instances (in different translation units) of the; variable into a single variable but is only applicable to arrays. See the; `LLVM Language Reference <LangRef.html#modulestructure>`_ for further details; on linkage types. Optionally an initializer, a name, and the module to put; the variable into may be specified for the global variable as well. * ``bool isConstant() const``. Returns true if this is a global variable that is known not to be modified at; runtime. * ``bool hasInitializer()``. Returns true if this ``GlobalVariable`` has an initializer. * ``Constant *getInitializer()``. Returns the initial value for a ``GlobalVariable``. It is not legal to call; this method if there is no initializer. .. _BasicBlock:. The ``BasicBlock`` class; ------------------------. ``#include ""llvm/IR/BasicBlock.h""``. header source: `BasicBlock.h; <https://llvm.org/doxygen/BasicBlock_8h_source.html>`_. doxygen info: `BasicBlock Class; <https://llvm.org/doxygen/classllvm_1_1BasicBlock.html>`_. Superclass: Value_. This class represents a single entry single exit section of the code, commonly; known as a basic block by the compiler community. The ``BasicBlock`` class; maintains a list of Instruction_\ s, which form the body of the block. Matching; the language definition, the last element of this list of instructions is always; a terminator instruction. In addition to tracking the list of instructions that make up the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:160407,variab,variable,160407,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"inker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the users; * Self-contained header files -- every header file should be able to compile; on its own. For instance, `cat header.h header.h | gcc -fsyntax-only -xc++ -`.; This command concatenates `header.h` twice before compiling it to make sure; it has proper include protectors.; * Enable it in `rootcling` -- rootcling can produce a C++ Modules-aware; dictionary when it is invoked with `-cxxmodule` flag.; * Modularization of external dependencies -- if a header file is not explicitly; nominated as part of a module and it is transitively included in two modules,; both modules contain that header file content. In other words, the header is; duplicated. In turn, this leads to performance regressions. If a dictionary; depends on a header (directly or indirectly) from a external library",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:14493,variab,variable,14493,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['variab'],['variable']
Modifiability,"inlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a; simple scalar option by using the ""``cl::opt``"" template (as opposed to the; ""``cl::list``"" template), and tell the CommandLine library that the data; type that we are parsing is a string. The second and third parameters (which are optional) are used to sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:4566,variab,variable,4566,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicDispatchModeConservative`` - Models the case where the dynamic type; information is assumed to be incorrect, for example, implies that the method; definition is overr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12986,config,config,12986,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['config'],['config']
Modifiability,"inserting the new instruction into the basic block at the location where the; old instruction was, and replacing any uses of the old instruction with the; new instruction. The following example illustrates the replacement of one; ``AllocaInst`` with another. .. code-block:: c++. AllocaInst* instToReplace = ...;; BasicBlock::iterator ii(instToReplace);. ReplaceInstWithInst(instToReplace->getParent(), ii,; new AllocaInst(Type::Int32Ty, 0, ""ptrToReplacedInt""));. Replacing multiple uses of Users and Values; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". You can use ``Value::replaceAllUsesWith`` and ``User::replaceUsesOfWith`` to; change more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:120538,variab,variable,120538,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['variab'],['variable']
Modifiability,"instance, ``[n(0)] { return ++n; }``). C++14 generic lambdas; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_generic_lambdas)`` or; ``__has_extension(cxx_generic_lambdas)`` to determine if support for generic; (polymorphic) lambdas is enabled; (for instance, ``[] (auto x) { return x + 1; }``). C++14 relaxed constexpr; ^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_relaxed_constexpr)`` or; ``__has_extension(cxx_relaxed_constexpr)`` to determine if variable; declarations, local variable modification, and control flow constructs; are permitted in ``constexpr`` functions. C++14 return type deduction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_return_type_deduction)`` or; ``__has_extension(cxx_return_type_deduction)`` to determine if support; for return type deduction for functions (using ``auto`` as a return type); is enabled. C++14 runtime-sized arrays; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_runtime_array)`` or; ``__has_extension(cxx_runtime_array)`` to determine if support; for arrays of runtime bound (a restricted form of variable-length arrays); is enabled.; Clang's implementation of this feature is incomplete. C++14 variable templates; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_variable_templates)`` or; ``__has_extension(cxx_variable_templates)`` to determine if support for; templated variable declarations is enabled. C11; ---. The features listed below are part of the C11 standard. As a result, all these; features are enabled with the ``-std=c11`` or ``-std=gnu11`` option when; compiling C code. Additionally, because these features are all; backward-compatible, they are available as extensions in all language modes. C11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(c_alignas)`` or ``__has_extension(c_alignas)`` to determine; if support for alignment specifiers using ``_Alignas`` is enabled. Use ``__has_feature(c_alignof)`` or ``__has_extension(c_alignof)`` to determine; if support for the ``_Alignof`` keyword i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:50972,variab,variable-length,50972,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['variab'],['variable-length']
Modifiability,"instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet loaded. #### Plugins: Runtime Library Dependencies for Linking. plugin manager The Plugin Manager **`TPluginManager`** allows; postponing library dependencies to runtime: a plugin library will only; be loaded when it is needed. Non-plugins will need to be linked, and; are thus loaded at start-up. Plugins are defined by a base class (e.g.; **`TFile`**) that will be implemented in a plugin, a tag used to; identify the plugin (e.g. `^rfio:` as part of the protocol string),; the plugin class of which an object will be created; (e.g. **`TRFIOFile`**), the library to be loaded (in short; `lib",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:18510,plugin,plugin,18510,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,2,['plugin'],['plugin']
Modifiability,"int non-default options after command line parsing. .. option:: --version. Display the version of the tool. .. option:: @<FILE>. Read command-line options from `<FILE>`. If no input file is specified, :program:`llvm-debuginfo-analyzer`; defaults to read `a.out` and return an error when no input file is found. If `-` is used as the input file, :program:`llvm-debuginfo-analyzer`; reads the input from its standard input stream. .. _attributes_:. ATTRIBUTES; ~~~~~~~~~~; The following options enable attributes given for the printed elements.; The attributes are divided in categories based on the type of data being; added, such as: internal offsets in the binary file, location descriptors,; register names, user source filenames, additional element transformations,; toolchain name, binary file format, etc. .. option:: --attribute=<value[,value,...]>. With **value** being one of the options in the following lists. .. code-block:: text. =all: Include all the below attributes.; =extended: Add low-level attributes.; =standard: Add standard high-level attributes. The following attributes describe the most common information for a; logical element. They help to identify the lexical scope level; the; element visibility across modules (global, local); the toolchain name; that produced the binary file. .. code-block:: text. =global: Element referenced across Compile Units.; =format: Object file format name.; =level: Lexical scope level (File=0, Compile Unit=1).; =local: Element referenced only in the Compile Unit.; =producer: Toolchain identification name. The following attributes describe files and directory names from the; user source code, where the elements are declared or defined; functions; with public visibility across modules. These options allow to map the; elements to their user code location, for cross references purposes. .. code-block:: text. =directories: Directories referenced in the debug information.; =filename: Filename where the element is defined.; =files: Files",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:4808,extend,extended,4808,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['extend'],['extended']
Modifiability,"int() methods:; virtual void Print(Option_t *wildcard="""") const;; virtual void Print(Option_t *wildcard, Option_t *option) const;; with; virtual void Print(Option_t *option="""") const;; virtual void Print(Option_t *option, Int_t recurse) const;; virtual void Print(Option_t *option, const char* wildcard,; Int_t recurse=1) const;; virtual void Print(Option_t *option, TPRegexp& regexp,; Int_t recurse=1) const;. Introduce three new protected methods used to print out collection details.; These are called from the Print() methods and make overriding of what; is printed for a collection / entries easier.; virtual void PrintCollectionHeader(Option_t* option) const;; virtual const char* GetCollectionEntryName(TObject* entry) const;; virtual void PrintCollectionEntry(TObject* entry, Option_t* option,; Int_t recurse) const;. Improve performance of reading TExMap object (50 times faster) using an updated,; slightly larger (16%) on file format for the TExMap object. ACLiC; Fix problem finding rootcint in the --prefix configuration.; Change the naming convention for the temporary files created by ACLiC, instead of randomly named ACLiC now uses:scriptname_scriptextension_ACLiC_function.extension; When ACLiC need to revert to the temp directory for storing the library, it now create the directory; structure under a directory named after the userid. Allow white space in the name of the directory where a script to be compiled by ACLiC resides.; Add optional 5th argument to CompileMacro to allow set the file bit; mode of the directory created.; Avoid looking for Microsoft's link.exe when we already have it (and hence avoid complaining about cygpath when cygwin is not even installed. Meta. Insure that the TClass list of methods is refreshed when new functions are added to the dictionary. TStyle. In TStyle::Reset, the Frame; Fill Color default value did not match the TFrame; Fill Color default value. TSystem. DirName now properly handle; repeated '/'; this allow mkdir(""a/b//c"",true); to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html:1128,config,configuration,1128,core/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v522/index.html,1,['config'],['configuration']
Modifiability,"inter to; the right class. Casting to the wrong class will give wrong results and; may well crash the program! Therefore, the user has to be very careful.; Often a container only contains one class of objects, but if it really; contains a mixture, it is possible to ask each object about its class; using the `InheritsFrom` method. For example if `myObject` is a **`TObject`** pointer:. ``` {.cpp}; if (myObject->InheritsFrom(""TParticle"") {; printf(""myObject is a TParticlen"");; }; ```. As the name suggests, this test works even if the object is a subclass; of **`TParticle`**. The member function `IsA()` can be used instead of; `InheritsFrom` to make the test exact. The `InheritsFrom` and `IsA`; methods use the extensive Run Time Type Information (RTTI) available via; the ROOT meta-classes. ### Types of Collections. The ROOT system implements the following basic types of collections:; unordered collections, ordered collections and sorted collections. Next; figure shows the inheritance hierarchy for the primary collection; classes. All primary collection classes derive from the abstract base; class **`TCollection`**. ![The inheritance hierarchy of the primary collection classes](pictures/020001A3.jpg). ### Ordered Collections (Sequences). Sequences are collections that are externally ordered because they; maintain internal elements according to the order in which they were; added. The following sequences are available:. - **`TList`**. - **`THashList`**. - **`TOrdCollection`**. - **`TObjArray`**. - **`TClonesArray`**. The **`TOrdCollection`**, **`TObjArray`** as well as the; **`TClonesArray`** can be sorted using their Sort() member function (for; this, the stored objects must provide a comparison function by; overriding TObject::Compare() and also must enable sorting by overriding; TObject::IsSortable() to return true). Ordered collections all derive; from the abstract base class **`TSeqCollection`**. Sorted collections; are ordered by an internal (automatic) sorting mech",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:3755,inherit,inheritance,3755,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['inherit'],['inheritance']
Modifiability,"inters of interior pointers are not explicitly; tracked and reported. * A different format is used for encoding stack maps. * Safe-point polls are only needed before loop-back edges; and before tail-calls (not needed at function-entry). Custom GC Strategies; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:22248,extend,extend,22248,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['extend'],['extend']
Modifiability,"into it. Each reference to the variable does a reload; from the stack. Also, note that we didn't modify the if/then/else; expression, so it still inserts a PHI node. While we could make an; alloca for it, it is actually easier to create a PHI node for it, so we; still just make the PHI. Here is the code after the mem2reg pass runs:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp one double %booltmp, 0.000000e+00; br i1 %ifcond, label %then, label %else. then:; br label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; br label %ifcont. ifcont: ; preds = %else, %then; %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]; ret double %iftmp; }. This is a trivial case for mem2reg, since there are no redefinitions of; the variable. The point of showing this is to calm your tension about; inserting such blatant inefficiencies :). After the rest of the optimizers run, we get:. .. code-block:: llvm. define double @fib(double %x) {; entry:; %cmptmp = fcmp ult double %x, 3.000000e+00; %booltmp = uitofp i1 %cmptmp to double; %ifcond = fcmp ueq double %booltmp, 0.000000e+00; br i1 %ifcond, label %else, label %ifcont. else:; %subtmp = fsub double %x, 1.000000e+00; %calltmp = call double @fib(double %subtmp); %subtmp5 = fsub double %x, 2.000000e+00; %calltmp6 = call double @fib(double %subtmp5); %addtmp = fadd double %calltmp, %calltmp6; ret double %addtmp. ifcont:; ret double 1.000000e+00; }. Here we see that the simplifycfg pass decided to clone the return; instruction into the end of the 'else' block. This allowed it to; eliminate some branches and the PHI node. Now that all symbol table references are updated to use stack variables,; we'll add the assignment operator. New As",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:19112,variab,variable,19112,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses the EXEC register as a bit mask to; select between the register (for inactive lanes) and the stack spill location; (for active lanes that are spilled). This needs to evaluate to a location; description, and not a value, as a debugger needs to change the value if the; user assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:25231,variab,variable,25231,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"io 2015; - Extensions SDK (you'll be prompted to install it if you open ClangFormat.sln). The extension is built using CMake to generate the usual LLVM.sln by setting; the following CMake vars:. - BUILD_CLANG_FORMAT_VS_PLUGIN=ON. - NUGET_EXE_DIR=path/to/nuget_dir (unless nuget.exe is already available in PATH). example:; cd /d C:\code\llvm; mkdir build & cd build; cmake -DBUILD_CLANG_FORMAT_VS_PLUGIN=ON -DNUGET_EXE_DIR=C:\nuget .. Once LLVM.sln is generated, build the clang_format_vsix target, which will build; ClangFormat.sln, the C# extension application. The CMake build will copy clang-format.exe and LICENSE.TXT into the ClangFormat/; directory so they can be bundled with the plug-in, as well as creating; ClangFormat/source.extension.vsixmanifest. Once the plug-in has been built with; CMake once, it can be built manually from the ClangFormat.sln solution in Visual; Studio. ===========; Debugging; ===========. Once you've built the clang_format_vsix project from LLVM.sln at least once,; open ClangFormat.sln in Visual Studio, then:. - Make sure the ""Debug"" target is selected; - Open the ClangFormat project properties; - Select the Debug tab; - Set ""Start external program:"" to where your devenv.exe is installed. Typically; it's ""C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\devenv.exe""; - Set ""Command line arguments"" to: /rootsuffix Exp; - You can now set breakpoints if you like; - Press F5 to build and run with debugger. If all goes well, a new instance of Visual Studio will be launched in a special; mode where it uses the experimental hive instead of the normal configuration hive.; By default, when you build a VSIX project in Visual Studio, it auto-registers the; extension in the experimental hive, allowing you to test it. In the new Visual Studio; instance, open or create a C++ solution, and you should now see the Clang Format; entries in the Tool menu. You can test it out, and any breakpoints you set will be; hit where you can debug as usual.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt:1748,config,configuration,1748,interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/README.txt,1,['config'],['configuration']
Modifiability,"ion &F, FunctionAnalysisManager &AM);`` method. We start by showing you how to construct a pass, from setting up the build,; creating the pass, to executing and testing it. Looking at existing passes is; always a great way to learn details. .. warning::; This document deals with the new pass manager. LLVM uses the legacy pass; manager for the codegen pipeline. For more details, see; :doc:`WritingAnLLVMPass` and :doc:`NewPassManager`. Quick Start --- Writing hello world; ===================================. Here we describe how to write the ""hello world"" of passes. The ""HelloWorld""; pass is designed to simply print out the name of non-external functions that; exist in the program being compiled. It does not modify the program at all,; it just inspects it. The code below already exists; feel free to create a pass with a different; name alongside the HelloWorld source files. .. _writing-an-llvm-npm-pass-build:. Setting up the build; --------------------. First, configure and build LLVM as described in :doc:`GettingStarted`. Next, we will reuse an existing directory (creating a new directory involves; messing around with more CMake files than we want). For this example, we'll use; ``llvm/lib/Transforms/Utils/HelloWorld.cpp``, which has already been created.; If you'd like to create your own pass, add a new source file into; ``llvm/lib/Transforms/Utils/CMakeLists.txt`` (assuming you want your pass in; the ``Transforms/Utils`` directory. Now that we have the build set up for a new pass, we need to write the code; for the pass itself. .. _writing-an-llvm-npm-pass-basiccode:. Basic code required; -------------------. Now that the build is setup for a new pass, we just have to write it. First we need to define the pass in a header file. We'll create; ``llvm/include/llvm/Transforms/Utils/HelloWorld.h``. The file should; contain the following boilerplate:. .. code-block:: c++. #ifndef LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H; #define LLVM_TRANSFORMS_HELLONEW_HELLOWORLD_H. #include",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst:2069,config,configure,2069,interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMNewPMPass.rst,1,['config'],['configure']
Modifiability,"ion 5,; and the new semantics for DWARF Version 6 which has been done for some; other features. Another option is to limit the execution to be on the same stack only to; the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute of a ``DW_TAG_dwarf_procedure`` debugging; information entry. The DWARF would be ill-formed if E is a location list; expression that does not match exactly one location list entry. In all; other cases the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute would evaluate E with the current context,; except the result kind is a location description, the compilation unit; is the one that contains D, and the initial stack is empty. The location; description result is pushed on the stack. * If D has a ``DW_AT_const_value`` attribute with a value V, then it is as; if a ``DW_OP_implicit_value V`` operation was executed. *This allows a call operation to be used to compute the location; description for any variable or formal parameter regardless of whether the; producer has optimized it to a constant. This is consistent with the*; ``DW_OP_implicit_pointer`` *operation.*. .. note::. Alternatively, could deprecate using ``DW_AT_const_value`` for; ``DW_TAG_variable`` and ``DW_TAG_formal_parameter`` debugger information; entries that are constants and instead use ``DW_AT_location`` with an; operation expression that results in a location description with one; implicit location description. Then this rule would not be required. * Otherwise, there is no effect and no changes are made to the stack. .. note::. In DWARF Version 5, if D does not have a ``DW_AT_location`` then; ``DW_OP_call*`` is defined to have no effect. It is unclear that this is; the right definition as a producer should be able to rely on using; ``DW_OP_call*`` to get a location description for any non-\; ``DW_TAG_dwarf_procedure`` debugging information entries. Also, the; producer should not be creating DWARF with ``DW_OP_call*`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:80473,variab,variable,80473,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['variab'],['variable']
Modifiability,"ion body; with respect to control flow in that goto, break, and continue do not; escape the Block. Exceptions are treated *normally* in that when; thrown they pop stack frames until a catch clause is found. Objective-C Extensions; ======================. Objective-C extends the definition of a Block reference type to be; that also of id. A variable or expression of Block type may be; messaged or used as a parameter wherever an id may be. The converse is; also true. Block references may thus appear as properties and are; subject to the assign, retain, and copy attribute logic that is; reserved for objects. All Blocks are constructed to be Objective-C objects regardless of; whether the Objective-C runtime is operational in the program or; not. Blocks using automatic (stack) memory are objects and may be; messaged, although they may not be assigned into ``__weak`` locations; if garbage collection is enabled. Within a Block literal expression within a method definition; references to instance variables are also imported into the lexical; scope of the compound statement. These variables are implicitly; qualified as references from self, and so self is imported as a const; copy. The net effect is that instance variables can be mutated. The :block-term:`Block_copy` operator retains all objects held in; variables of automatic storage referenced within the Block expression; (or form strong references if running under garbage collection).; Object variables of ``__block`` storage type are assumed to hold; normal pointers with no provision for retain and release messages. Foundation defines (and supplies) ``-copy`` and ``-release`` methods for; Blocks. In the Objective-C and Objective-C++ languages, we allow the; ``__weak`` specifier for ``__block`` variables of object type. If; garbage collection is not enabled, this qualifier causes these; variables to be kept without retain messages being sent. This; knowingly leads to dangling pointers if the Block (or a copy) outlives; the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:9407,variab,variables,9407,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variables']
Modifiability,"ion for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31698,config,configuration,31698,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['config'],['configuration']
Modifiability,"ion in the tablegen file; ``clang/include/clang/Driver/Options.td``. This is done by instantiating the; ``Option`` class (defined in ``llvm/include/llvm/Option/OptParser.td``). The; instance is typically created through one of the helper classes that encode the; acceptable ways to specify the option value on the command line:. * ``Flag`` - the option does not accept any value,; * ``Joined`` - the value must immediately follow the option name within the same; argument,; * ``Separate`` - the value must follow the option name in the next command line; argument,; * ``JoinedOrSeparate`` - the value can be specified either as ``Joined`` or; ``Separate``,; * ``CommaJoined`` - the values are comma-separated and must immediately follow; the option name within the same argument (see ``Wl,`` for an example). The helper classes take a list of acceptable prefixes of the option (e.g.; ``""-""``, ``""--""`` or ``""/""``) and the option name:. .. code-block:: diff. // Options.td. + def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">;. Then, specify additional attributes via mix-ins:. * ``HelpText`` holds the text that will be printed besides the option name when; the user requests help (e.g. via ``clang --help``).; * ``Group`` specifies the ""category"" of options this option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:29948,plugin,plugin,29948,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['plugin'],['plugin']
Modifiability,"ion is `PHI` instructions: these become implicit definitions at; control flow merges once regalloc finishes, and any debug numbers attached to; `PHI` instructions are lost. To circumvent this, debug numbers of `PHI`s are; recorded at the start of register allocation (`phi-node-elimination`), then; `DBG_PHI` instructions are inserted after regalloc finishes. This requires some; maintenance of which register a variable is located in during regalloc, but at; single positions (block entry points) rather than ranges of instructions. An example, before regalloc:. ```text; bb.2:; %2 = PHI %1, %bb.0, %2, %bb.1, debug-instr-number 1; ```. After:. ```text; bb.2:; DBG_PHI $rax, 1; ```. # `LiveDebugValues`. After optimisations and code layout complete, information about variable; values must be translated into variable locations, i.e. registers and stack; slots. This is performed in the [`LiveDebugValues` pass][LiveDebugValues], where; the debug instructions and machine code are separated out into two independent; functions:; * One that assigns values to variable names,; * One that assigns values to machine registers and stack slots. LLVM's existing SSA tools are used to place `PHI`s for each function, between; variable values and the values contained in machine locations, with value; propagation eliminating any unnecessary `PHI`s. The two can then be joined up; to map variables to values, then values to locations, for each instruction in; the function. Key to this process is being able to identify the movement of values between; registers and stack locations, so that the location of values can be preserved; for the full time that they are resident in the machine. # Required target support and transition guide. Instruction referencing will work on any target, but likely with poor coverage.; Supporting instruction referencing well requires:; * Target hooks to be implemented to allow `LiveDebugValues` to follow values; through the machine,; * Target-specific optimisations to be in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md:4617,variab,variable,4617,interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrRefDebugInfo.md,1,['variab'],['variable']
Modifiability,"ion of the CERNLIB algorithm; DGAUSS by Sigfried Kolbig, and it is used by the TF1::Integral method. The second one uses the Gauss Legendre quadrature formula. It is used by the TF1::IntegralFast method.; These classes implement both the same virtual interface as the adaptive integration methods provided by the MathMore library. They can all be created and used easily via the common class ROOT::Math::IntegratorOneDim providing the interfaces for numerical integration.; New template methods have been also included in the common Integration class in order to be able to integrate automatically any C++ callable object. ROOT::Math::RichardsonDerivator implementing numerical derivation using the Richardson's extrapolation formula (use 2 derivative estimates to compute a third, more accurate estimation). This is used by the TD1::Derivative method. ; BrentRootFinder for finding the root of one-dimensional function using the Brent algorithm. The class inherits from a virtual interface, which is also implemented by the MathMore root finder methods. The user can instantiate, via the common ROOT::Math::RootFinder class, all the various root finder algorithms. The BrentRootFinder class is used by TF1::GetX . ; A similar class, BrentMinimizer1D, provides the possibility to find the minimum of one-dimensional functions using the Brent algorithm. This class is used by TF1::GetMinimum or TF1::GetMaximum; Use ROOT convention for all enumeration names defining the type of numerical algorithms (start with k, like kADAPTIVE for the integration type). This affects both MathCore and MathMore.; . In addition we use now the ROOT convention for all enumeration names defining the type of numerical algorithms. The names start with k, like kADAPTIVE for the integration type. This change affects both MathCore and MathMore and it breaks backward compatibility. MathCore Function interfaces; Mathcore provides as well interfaces for the evaluation of mathematical and parametric functions to be used ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:7797,inherit,inherits,7797,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['inherit'],['inherits']
Modifiability,"ion or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73206,variab,variables,73206,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,ion sequences in non-call contexts; Unknown. 2292; CD5; simple-template-id is ambiguous between class-name and type-name; Clang 9. 2293; CD5; Requirements for simple-template-id used as a class-name; Unknown. 2294; CD5; Dependent auto static data members; Unknown. 2295; CD5; Aggregates with deleted defaulted constructors; Unknown. 2296; open; Are default argument instantiation failures in the “immediate context”?; Not resolved. 2297; open; Unclear specification of atomic operations; Not resolved. 2298; open; Actions and expression evaluation; Not resolved. 2299; CD5; constexpr vararg functions; Unknown. 2300; CD5; Lambdas in multiple definitions; Unknown. 2301; open; Value-initialization and constexpr constructor evaluation; Not resolved. 2302; NAD; Address comparison between different member subobjects; Unknown. 2303; CD5; Partial ordering and recursive variadic inheritance; Clang 12. 2304; NAD; Incomplete type vs overload resolution; Unknown. 2305; CD5; Explicit instantiation of constexpr or inline variable template; Unknown. 2306; NAD; Nested friend templates of class templates; Unknown. 2307; CD5; Unclear definition of “equivalent to a nontype template parameter”; Unknown. 2308; NAD; Structured bindings and lambda capture; Unknown. 2309; CD5; Restrictions on nested statements within constexpr functions; Unknown. 2310; CD5; Type completeness and derived-to-base pointer conversions; Unknown. 2311; open; Missed case for guaranteed copy elision; Not resolved. 2312; CD6; Structured bindings and mutable; Unknown. 2313; CD5; Redeclaration of structured binding reference variables; Unknown. 2314; dup; Structured bindings and lambda capture; Unknown. 2315; CD5; What is the “corresponding special member” of a variant member?; Unknown. 2316; drafting; Simplifying class conversions in conditional expressions; Not resolved. 2317; CD5; Self-referential default member initializers; Unknown. 2318; CD5; Nondeduced contexts in deduction from a braced-init-list; Unknown. 2319; draf,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:157276,variab,variable,157276,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variable']
Modifiability,"ion support in RooFit classes. **Approach 1:** For very simple cases like `RooRatio`, it may be preferable to; write the entire code in a single string. **Approach 2:** Another approach could be to extract free functions in a; separate header file.; Since Clad prefers the code for models to be within a single translation unit,; in many classes, this has been implemented by moving the computational; aspects of the RooFit class; to free functions in a single header file named [MathFuncs] (and/or; [MathFuncs], where relevant). This approach enables easier debugging; (e.g., you can standalone-compile the generated code with just a few header; files copied outside ROOT). *Refactoring* It is important to refactor the code such that:. - the footprint of the generated code is minimized by referring to existing; functions with the definition known by interpreter (i.e., they are in public; header files). - to reuse common code, both in the generated code, and in the existing; RooAbsReal::evaluate() method (meaning that the refactoring of `evaluate()` is; optional, but it is recommended). \htmlonly; <div class=""pyrootbox"">; \endhtmlonly. *Implement Code Generation support in custom classes*: Framework developers; that want to implement Code Generation support for their custom classes, this; approach of extracting free functions in a separate header file is not; suitable, since they can't put the code in a header that is part of the ROOT; installation. Please note the following recommendations:. - while developing your custom class, add these functions to your classes; header file (e.g., as part of the class definition), and. - if/when your class is upstreamed to RooFit, expect to move into the; `RooFit::detail` namespace and their implementations into `MathFuncs.h`. \htmlonly; </div>; \endhtmlonly. *Overriding the Translate Function*: The `RooAbsArg::translate()` function; needs to be overridden to specify how the class is translating to C++ code; that is using the aforemention",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:6429,refactor,refactoring,6429,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['refactor'],['refactoring']
Modifiability,"ion units containing the definition; of a virtual member function (whether inline or not), other than members; of :ref:`ignored <cfi-ignorelist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5486,polymorphi,polymorphic,5486,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['polymorphi'],['polymorphic']
Modifiability,"ion"". Here are a few observations about this:. First, you're right that LLVM does lose information. For example, as of; this writing, there is no way to distinguish in the LLVM IR whether an; SSA-value came from a C ""int"" or a C ""long"" on an ILP32 machine (other; than debug info). Both get compiled down to an 'i32' value and the; information about what it came from is lost. The more general issue; here, is that the LLVM type system uses ""structural equivalence"" instead; of ""name equivalence"". Another place this surprises people is if you; have two types in a high-level language that have the same structure; (e.g. two different structs that have a single int field): these types; will compile down into a single LLVM type and it will be impossible to; tell what it came from. Second, while LLVM does lose information, LLVM is not a fixed target: we; continue to enhance and improve it in many different ways. In addition; to adding new features (LLVM did not always support exceptions or debug; info), we also extend the IR to capture important information for; optimization (e.g. whether an argument is sign or zero extended,; information about pointers aliasing, etc). Many of the enhancements are; user-driven: people want LLVM to include some specific feature, so they; go ahead and extend it. Third, it is *possible and easy* to add language-specific optimizations,; and you have a number of choices in how to do it. As one trivial; example, it is easy to add language-specific optimization passes that; ""know"" things about code compiled for a language. In the case of the C; family, there is an optimization pass that ""knows"" about the standard C; library functions. If you call ""exit(0)"" in main(), it knows that it is; safe to optimize that into ""return 0;"" because C specifies what the; 'exit' function does. In addition to simple library knowledge, it is possible to embed a; variety of other language-specific information into the LLVM IR. If you; have a specific need and run into ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:10004,extend,extend,10004,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['extend'],['extend']
Modifiability,"ion, ROOT::Math::IParamMultiGradFunction interfaces, where the parameter values are now required for calculating the partial derivatives with respect to the parameters.; This changes the signature of the pure abstract method, DoParameterDerivative(const double *x, const double * p, , which takes also a pointer (type const double *) to the parameters.; In addition, these classes do not inherit anymore from the function gradient interface (ROOT::Math::IGradFunction and ROOT::Math::IMultiGradFunction). They define only the parameter gradient which is needed for fitting and not the coordinate gradient. A derived class, like ROOT::Math::Polynomial, implementing both functionality (coordinate and parameter gradient) inherits then from both interfaces.; . More detailed description of the current MathCore release can be found at this location. MathMore; This new release contains:. Modify and rename the class ROOT::Math::RootFinder to ROOT::Math::GSLRootFinder to distinguish from the main interface class which has been put in the Mathcore library and it can create the GSLRootFinder using the plug-in manager. Furthermore, the class ROOT::Math::GSLRootFinder is not anymore a template class on the algorithm. They type of root-finder algorithm can now be selected via an enumeration; Fixed a bug in the ROOT::Math::GSLNLSMultiFi class.; Changes also in the class for the new enumeration names (all names start with k, like kADAPTIVE for the integration types).; . More detailed description of the current MathMore release can be found at this location. GenVector; The new physics vector classes have been moved out from the MathCore library in a new library, libGenVector. The library contains as well the CINT dictionary including main instantiations for the template classes. For this release the instantiation of some extra methods, in particular of the class ROOT::Math::TRansform3D have been added in the dictionary library.; Due to a CINT limitation, the dictionary for explicit template ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:10532,plug-in,plug-in,10532,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['plug-in'],['plug-in']
Modifiability,"ion. The point lies on the plane and the normal vector; points outside the half space. The half space is the only shape; which is infinite and can be used only in Boolean operations that; result in non-infinite composite shapes (see also ""Composite Shapes""; below). A half space has to be defined using the constructor:. ``` {.cpp}; TGeoHalfSpace (const char *name, Double_t *point[3],; Double_t *norm[3]);; ```. ### Composite Shapes. Composite shapes are Boolean combinations of two or more shape; components. The supported Boolean operations are union (+), intersection; (\*) and subtraction(-). Composite shapes derive from the base; **`TGeoShape`** class, therefore providing all shape features:; computation of bounding box, finding if a given point is inside or; outside the combination, as well as computing the distance to; entering/exiting. They can be directly used for creating volumes or used; in the definition of other composite shapes. Composite shapes are provided in order to complement and extend the set; of basic shape primitives. They have a binary tree internal structure,; therefore all shape-related geometry queries are signals propagated from; top level down to the final leaves, while the provided answers are; assembled and interpreted back at top. This `CSG`; `(composite solid geometry)` hierarchy is effective for small number of; components, while performance drops dramatically for large structures.; Building a complete geometry in this style is virtually possible but; highly not recommended. #### The Structure of Composite Shapes. A composite shape can always be looked as the result of a Boolean; operation between only two shape components. All information identifying; these two components as well as their positions with respect to the; frame of the composite is represented by an object called Boolean node.; A composite shape has a pointer to such a Boolean node. Since the shape; components may also be composites, they will also contain binary Boolean; no",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:42883,extend,extend,42883,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['extend'],['extend']
Modifiability,"ion. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_, and `program objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation first describes the representation aspects; common to any source-language. :ref:`ccxx_frontend` describes the data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; ----------------------------. LLVM uses several intrinsic functions (name prefixed with ""``llvm.dbg``"") to; track source local variables through optimization and code generation. ``llvm.dbg.declare``; ^^^^^^^^^^^^^^^^^^^^. .. code-block:: llvm. void @llvm.dbg.declare(metadata, metadata, metadata). This intrinsic provides information about a local element (e.g., variable).; The first argument is metadata holding the address of variable, typically a; static alloca in the function entry block. The second argument is a; `local variabl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:7793,variab,variables,7793,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"ion.; [Ubuntu Packaging Guide]:http://packaging.ubuntu.com/html/getting-set-up.html#create-your-gpg-key. #### Windows; CPT is meant to be executed on cmd.exe prompt. Make sure you have set the; environment properly before continuing.; Below is a list of required packages for Windows (Win32-x86):. [MSYS Git] for Windows. [Python] for Windows. Microsoft Visual Studio 11 (2012), with Microsoft Visual C++ 2012. [MSYS Git]:http://msysgit.github.io/; [Python]:https://www.python.org/. ###### Setting Up:; Unlike other UNIX-like platforms, Windows requires you to follow some rules.; Do not ignore this section unless you want CPT to fail mid-way with wierd; errors. You should require these instructions only once. * While installing the packages make sure the executable is in a path that; doesn't contain spaces. For example, you should install Python in a path like. ```sh; C:\Python27; ```; rather than. ```sh; C:\Program Files (x86)\Python 2.7; ```; * Path to all the required executables should be present in the Windows; **PATH** environment variable.; * In case of MSYS Git, choose the option ""Run Git from Windows; Command Prompt"" during installation. A good way to check if everything is detected properly by the script is to; run the following command:; ```sh; cd tools/packaging/; ./cpt.py --check-requirements; ```. #### Red Hat Linux (Fedora/Scientific Linux CERN); This section applies to all distros based on Red Hat Linux like Fedora, and; Scientific Linux CERN (SLC). Apparently, you can build RPM packages in any; distro regardless of the package manager it uses. This has been tested on; Fedora, SLC, Ubuntu, and CrunchBang. If you are interested, you can test it; on your favourite platform and email me the results. Depending on the package manager of your distro, you can install the; packages required by CPT to build RPM bundles. For a Red Hat based distro; (which uses ```yum``` package manager), you can use the following command; (also performed automatically by CPT):; ```sh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md:4495,variab,variable,4495,interpreter/cling/tools/packaging/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/tools/packaging/README.md,1,['variab'],['variable']
Modifiability,"ion: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after an open bracket, if the parameters don't fit; on a single line. Closing brackets will be placed on a new line.; E.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2; ). .. note::. This currently only applies to braced initializer lists (when; ``Cpp11BracedListStyle`` is ``true``) and parentheses. .. _AlignArrayOfStructures:. **AlignArrayOfStructures** (``ArrayInitializerAlignmentStyle``) :versionbadge:`clang-format 13` :ref:`¶ <AlignArrayOfStructures>`; if not ``None``, when using initialization for an array of structs; aligns the fields into columns. .. note::. As of clang-format 15 this option only applied to arrays with equal; number of columns per row. Possible values:. * ``AIAS_Left`` (in configuration: ``Left``); Align array column and left justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; {7, 5, ""!!"" }; };. * ``AIAS_Right`` (in configuration: ``Right``); Align array column and right justify the columns e.g.:. .. code-block:: c++. struct test demo[] =; {; {56, 23, ""hello""},; {-1, 93463, ""world""},; { 7, 5, ""!!""}; };. * ``AIAS_None`` (in configuration: ``None``); Don't align array initializer columns. .. _AlignConsecutiveAssignments:. **AlignConsecutiveAssignments** (``AlignConsecutiveStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignConsecutiveAssignments>`; Style of aligning consecutive assignments. ``Consecutive`` will result in formattings like:. .. code-block:: c++. int a = 1;; int somelongname = 2;; double c = 3;. Nested configuration flags:. Alignment options. They can also be read as a whole for compatibility. The choices are:; - None; - Consecutive; - AcrossEmptyLines; - AcrossComments; - AcrossEmptyLinesAndComments. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:8651,config,configuration,8651,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ion::viewCFGOnly()`` (does; not include the instructions), the ``MachineFunction::viewCFG()`` and; ``MachineFunction::viewCFGOnly()``, and the ``SelectionDAG::viewGraph()``; methods. Within GDB, for example, you can usually use something like ``call; DAG.viewGraph()`` to pop up a window. Alternatively, you can sprinkle calls to; these functions in your code in places you want to debug. Getting this to work requires a small amount of setup. On Unix systems; with X11, install the `graphviz <http://www.graphviz.org>`_ toolkit, and make; sure 'dot' and 'gv' are in your path. If you are running on macOS, download; and install the macOS `Graphviz program; <http://www.pixelglow.com/graphviz/>`_ and add; ``/Applications/Graphviz.app/Contents/MacOS/`` (or wherever you install it) to; your path. The programs need not be present when configuring, building or; running LLVM and can simply be installed when needed during an active debug; session. ``SelectionDAG`` has been extended to make it easier to locate *interesting*; nodes in large complex graphs. From gdb, if you ``call DAG.setGraphColor(node,; ""color"")``, then the next ``call DAG.viewGraph()`` would highlight the node in; the specified color (choices of colors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:53935,extend,extended,53935,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['extend'],['extended']
Modifiability,"ion; macros referencing other macros will be; ignored.; * Overloading by arity is supported: for example, given the macro; definitions A=x, A()=y, A(a)=a. .. code-block:: c++. A; -> x;; A(); -> y;; A(z); -> z;; A(a, b); // will not be expanded. .. _MaxEmptyLinesToKeep:. **MaxEmptyLinesToKeep** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <MaxEmptyLinesToKeep>`; The maximum number of consecutive empty lines to keep. .. code-block:: c++. MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0; int f() { int f() {; int = 1; int i = 1;; i = foo();; i = foo(); return i;; }; return i;; }. .. _NamespaceIndentation:. **NamespaceIndentation** (``NamespaceIndentationKind``) :versionbadge:`clang-format 3.7` :ref:`¶ <NamespaceIndentation>`; The indentation used for namespaces. Possible values:. * ``NI_None`` (in configuration: ``None``); Don't indent in namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_Inner`` (in configuration: ``Inner``); Indent only in inner namespaces (nested in other namespaces). .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. * ``NI_All`` (in configuration: ``All``); Indent in all namespaces. .. code-block:: c++. namespace out {; int i;; namespace in {; int i;; }; }. .. _NamespaceMacros:. **NamespaceMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <NamespaceMacros>`; A vector of macros which are used to open namespace blocks. These are expected to be macros of the form:. .. code-block:: c++. NAMESPACE(<namespace-name>, ...) {; <namespace-content>; }. For example: TESTSUITE. .. _ObjCBinPackProtocolList:. **ObjCBinPackProtocolList** (``BinPackStyle``) :versionbadge:`clang-format 7` :ref:`¶ <ObjCBinPackProtocolList>`; Controls bin-packing Objective-C protocol conformance list; items into as few lines as possible when they go over ``ColumnLimit``. If ``Auto`` (the default), delegates to the value in; ``BinPackParameters``. If that is ``true``, bin-packs Objectiv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:87304,config,configuration,87304,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ion`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic shared object file."">,; + MarshallingInfoStringVector<CodeGenOpts<""PassPlugins"">>;. Inner workings of the system are introduced in the :ref:`marshalling; infrastructure <OptionMarshalling>` section and the available annotations are; listed :ref:`here <OptionMarshallingAnnotations>`. In case the marshalling infrastructure does not support the desired semantics,; consider simplifying it to fit the existing model. This makes the command line; more uniform and reduces the amount of custom, manually written code. Remember; that the ``-cc1`` command line interface is intended only for Clang developers,; meaning it does not need to mirror the driver interface, maintain backward; compatibility or be compatible with GCC. If the option semantics cannot be encoded via marshalling annotations, you can; resort to parsing/serializing the command line arguments manually:. .. code-block:: diff. // CompilerInvocation.cpp. static bool ParseCodeGe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:32102,plugin,plugin,32102,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['plugin'],['plugin']
Modifiability,"ions (to allow processing '``ls -lad``'; naturally), ``ld`` style `prefix`_ options (to parse '``-lmalloc; -L/usr/lib``'), and interpreter style options. This document will hopefully let you jump in and start using CommandLine in your; utility quickly and painlessly. Additionally it should be a simple reference; manual to figure out how stuff works. Quick Start Guide; =================. This section of the manual runs through a simple CommandLine'ification of a; basic compiler tool. This is intended to show you how to jump into using the; CommandLine library in your own program, and show you some of the cool things it; can do. To start out, you need to include the CommandLine header file into your program:. .. code-block:: c++. #include ""llvm/Support/CommandLine.h"". Additionally, you need to add this as the first line of your main program:. .. code-block:: c++. int main(int argc, char **argv) {; cl::ParseCommandLineOptions(argc, argv);; ...; }. ... which actually parses the arguments and fills in the variable declarations. Now that you are ready to support command line arguments, we need to tell the; system which ones we want, and what type of arguments they are. The CommandLine; library uses a declarative syntax to model command line arguments with the; global variable declarations that capture the parsed values. This means that; for every command line option that you would like to support, there should be a; global variable declaration to capture the result. For example, in a compiler,; we would like to support the Unix-standard '``-o <filename>``' option to specify; where to put the output. With the CommandLine library, this is represented like; this:. .. _scalars arguments:; .. _here:. .. code-block:: c++. cl::opt<string> OutputFilename(""o"", cl::desc(""Specify output filename""), cl::value_desc(""filename""));. This declares a global variable ""``OutputFilename``"" that is used to capture the; result of the ""``o``"" argument (first parameter). We specify that this is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:4300,variab,variable,4300,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['variab'],['variable']
Modifiability,"ionsOnASingleLine** (``ShortFunctionStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AllowShortFunctionsOnASingleLine>`; Dependent on the value, ``int f() { return 0; }`` can be put on a; single line. Possible values:. * ``SFS_None`` (in configuration: ``None``); Never merge functions into a single line. * ``SFS_InlineOnly`` (in configuration: ``InlineOnly``); Only merge functions defined inside a class. Same as ""inline"",; except it does not implies ""empty"": i.e. top level empty functions; are not merged either. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {; }. * ``SFS_Empty`` (in configuration: ``Empty``); Only merge empty functions. .. code-block:: c++. void f() {}; void f2() {; bar2();; }. * ``SFS_Inline`` (in configuration: ``Inline``); Only merge functions defined inside a class. Implies ""empty"". .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() {; foo();; }; void f() {}. * ``SFS_All`` (in configuration: ``All``); Merge all functions fitting on a single line. .. code-block:: c++. class Foo {; void f() { foo(); }; };; void f() { bar(); }. .. _AllowShortIfStatementsOnASingleLine:. **AllowShortIfStatementsOnASingleLine** (``ShortIfStyle``) :versionbadge:`clang-format 3.3` :ref:`¶ <AllowShortIfStatementsOnASingleLine>`; Dependent on the value, ``if (a) return;`` can be put on a single line. Possible values:. * ``SIS_Never`` (in configuration: ``Never``); Never put short ifs on the same line. .. code-block:: c++. if (a); return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_WithoutElse`` (in configuration: ``WithoutElse``); Put short ifs on the same line only if there is no else statement. .. code-block:: c++. if (a) return;. if (b); return;; else; return;. if (c); return;; else {; return;; }. * ``SIS_OnlyFirstIf`` (in configuration: ``OnlyFirstIf``); Put short ifs, but not else ifs nor else statements, on the same line. .. code-block:: c++. if (a) return;. if (b) retur",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:29638,config,configuration,29638,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ious tests. .. _format:. Debugging information format; ============================. LLVM debugging information has been carefully designed to make it possible for; the optimizer to optimize the program and debugging information without; necessarily having to know anything about debugging information. In; particular, the use of metadata avoids duplicated debugging information from; the beginning, and the global dead code elimination pass automatically deletes; debugging information for a function if it decides to delete the function. To do this, most of the debugging information (descriptors for types,; variables, functions, source files, etc) is inserted by the language front-end; in the form of LLVM metadata. Debug information is designed to be agnostic about the target debugger and; debugging information representation (e.g. DWARF/Stabs/etc). It uses a generic; pass to decode the information that represents variables, types, functions,; namespaces, etc: this allows for arbitrary source-language semantics and; type-systems to be used, as long as there is a module written for the target; debugger to interpret the information. To provide basic functionality, the LLVM debugger does have to make some; assumptions about the source-level language being debugged, though it keeps; these to a minimum. The only common features that the LLVM debugger assumes; exist are `source files <LangRef.html#difile>`_, and `program objects; <LangRef.html#diglobalvariable>`_. These abstract objects are used by a; debugger to form stack traces, show information about local variables, etc. This section of the documentation first describes the representation aspects; common to any source-language. :ref:`ccxx_frontend` describes the data layout; conventions used by the C and C++ front-ends. Debug information descriptors are `specialized metadata nodes; <LangRef.html#specialized-metadata>`_, first-class subclasses of ``Metadata``. .. _format_common_intrinsics:. Debugger intrinsic functions; --",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:7140,variab,variables,7140,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['variab'],['variables']
Modifiability,"iple times. **--bb** *basic-block-specifier*. Extract basic blocks(s) specified in *basic-block-specifier*. May be; specified multiple times. Each <function:bb[;bb]> specifier pair will create; a function. If multiple basic blocks are specified in one pair, the first; block in the sequence should dominate the rest. **--delete**. Delete specified Globals from Module. **-f**. Enable binary output on terminals. Normally, :program:`llvm-extract` will; refuse to write raw bitcode output if the output stream is a terminal. With; this option, :program:`llvm-extract` will write raw bitcode regardless of the; output device. **--func** *function-name*. Extract the function named *function-name* from the LLVM bitcode. May be; specified multiple times to extract multiple functions at once. **--rfunc** *function-regular-expr*. Extract the function(s) matching *function-regular-expr* from the LLVM bitcode.; All functions matching the regular expression will be extracted. May be; specified multiple times. **--glob** *global-name*. Extract the global variable named *global-name* from the LLVM bitcode. May be; specified multiple times to extract multiple global variables at once. **--rglob** *glob-regular-expr*. Extract the global variable(s) matching *global-regular-expr* from the LLVM; bitcode. All global variables matching the regular expression will be; extracted. May be specified multiple times. **--keep-const-init**. Preserve the values of constant globals. **--recursive**. Recursively extract all called functions. **-help**. Print a summary of command line options. **-o** *filename*. Specify the output filename. If filename is ""-"" (the default), then; :program:`llvm-extract` sends its output to standard output. **-S**. Write output in LLVM intermediate language (instead of bitcode). EXIT STATUS; -----------. If :program:`llvm-extract` succeeds, it will exit with 0. Otherwise, if an error; occurs, it will exit with a non-zero value. SEE ALSO; --------. :manpage:`bugpoint(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst:2297,variab,variable,2297,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-extract.rst,4,['variab'],"['variable', 'variables']"
Modifiability,"ippet. The user can assume that in the provided code snippet the following variables; will be defined:. The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to; facilitate the rule definitions. The user can expect the following variables being predeclared:. * newObj; - variable representing the target in-memory object, its type is that of the; target object; * oldObj; - in normal conversion rules, an object of TVirtualObject class representing the; input data, guaranteed to hold the data members declared in the source property; of the rule; * buffer; - in raw conversion rules, an object of TBuffer class holding the data member; declared in source property of the rule; * names of the data members of the target object declared in the target property of the; rule declared to be the appropriate type; * onfile.xxx; - in normal conversion rules, names of the variables of basic types declared; in the source property of the rule. #### The C++ API. The schema evolution C++ API consists of two classes: `ROOT::TSchemaRuleSet` and; `ROOT::TSchemaRule`. Objects of the TSchemaRule class represent the rules and their fields have exactly the same; meaning as the ones of rules specified in the dictionaries. `TSchemaRuleSet` objects; manage the sets of rules and ensure their consistency. There can be no conflicting; rules in the rule sets. The rule sets are owned by the `TClass` objects corresponding to the; target classes defined in the rules and can be accessed using `TClass::{Get|Adopt}SchemaRules`. ### Manual Schema Evolution. If you have written your own `Streamer` as described in the section; ""Streamers with Special Additions"", you will have to manually add code; for each version and manage the evolution of your class. When you add or; remove data members, you must modify the `Streamer` by hand. ROOT; assumes that you have increased the class version numbe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:82264,variab,variables,82264,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variables']
Modifiability,"iptor;; const FOO foo;; };. void __block_invoke_10(struct __block_literal_10 *_block) {; printf(""%d\n"", _block->foo.value());; }. void __block_copy_10(struct __block_literal_10 *dst, struct __block_literal_10 *src) {; FOO_ctor(&dst->foo, &src->foo);; }. void __block_dispose_10(struct __block_literal_10 *src) {; FOO_dtor(&src->foo);; }. static struct __block_descriptor_10 {; unsigned long int reserved;; unsigned long int Block_size;; void (*copy_helper)(struct __block_literal_10 *dst, struct __block_literal_10 *src);; void (*dispose_helper)(struct __block_literal_10 *);; } __block_descriptor_10 = { 0, sizeof(struct __block_literal_10), __block_copy_10, __block_dispose_10 };. and the code would be:. .. code-block:: c++. {; FOO foo;; comp_ctor(&foo); // default constructor; struct __block_literal_10 _block_literal = {; &_NSConcreteStackBlock,; (1<<25)|(1<<26)|(1<<29), <uninitialized>,; __block_invoke_10,; &__block_descriptor_10,; };; comp_ctor(&_block_literal->foo, &foo); // const copy into stack version; struct __block_literal_10 &block = &_block_literal; // assign literal to block variable; block->invoke(block); // invoke block; comp_dtor(&_block_literal->foo); // destroy stack version of const block copy; comp_dtor(&foo); // destroy original version; }. C++ objects stored in ``__block`` storage start out on the stack in a; ``block_byref`` data structure as do other variables. Such objects (if not; ``const`` objects) must support a regular copy constructor. The ``block_byref``; data structure will have copy and destroy helper routines synthesized by the; compiler. The copy helper will have code created to perform the copy; constructor based on the initial stack ``block_byref`` data structure, and will; also set the (1<<26) bit in addition to the (1<<25) bit. The destroy helper; will have code to do the destructor on the object stored within the supplied; ``block_byref`` heap data structure. For example,. .. code-block:: c++. __block FOO blockStorageFoo;. requires the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:25757,variab,variable,25757,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"ir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address; ninja clang-objc-fuzzer. ======================; Running clang-objc-fuzzer; ======================; bin/clang-objc-fuzzer CORPUS_DIR. e.g. using the example objc corpus,. bin/clang-objc-fuzzer <path to corpus_examples/objc> <path to new directory to store corpus findings>. =======================================================; Building clang-proto-fuzzer (Linux-only instructions); =======================================================; Install the necessary dependencies:; - binutils // needed for libprotobuf-mutator; - liblzma-dev // needed for libprotobuf-mutator; - libz-dev // needed for libprotobuf-mutator; - docbook2x // needed for libprotobuf-mutator; - Recent version of protobuf [3.3.0 is known to work]. Within your LLVM build directory, run CMake with the following variable; definitions:; - CMAKE_C_COMPILER=clang; - CMAKE_CXX_COMPILER=clang++; - LLVM_USE_SANITIZE_COVERAGE=YES; - LLVM_USE_SANITIZER=Address; - CLANG_ENABLE_PROTO_FUZZER=ON. Then build the clang-proto-fuzzer and clang-proto-to-cxx targets. Optionally,; you may also build clang-fuzzer with this setup. Example:; cd $LLVM_SOURCE_DIR; mkdir build && cd build; cmake .. -GNinja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZE_COVERAGE=YES -DLLVM_USE_SANITIZER=Address \; -DCLANG_ENABLE_PROTO_FUZZER=ON; ninja clang-proto-fuzzer clang-proto-to-cxx. This directory also contains a Dockerfile which sets up all required; dependencies and builds the fuzzers. ============================; Running clang-proto-fuzzer; ============================; bin/clang-proto-fuzzer CORPUS_DIR. Arguments can be specified after -ignore_remaining_args=1 to modify the compiler; invocation. For example, the following command line will fuzz LLVM with a; custom optimization level and target triple:; bin/clang-proto-fuzzer CORPUS_DIR -ignore_remai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt:2896,variab,variable,2896,interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/README.txt,1,['variab'],['variable']
Modifiability,"ir to your compiler,; the build will also generate the `generate-coverage-report` target to generate; the code coverage report for LLVM, and the `clear-profile-data` utility target; to delete captured profile data. See documentation for; *LLVM_CODE_COVERAGE_TARGETS* and *LLVM_COVERAGE_SOURCE_DIRS* for more; information on configuring code coverage reports. **LLVM_CODE_COVERAGE_TARGETS**:STRING; If set to a semicolon separated list of targets, those targets will be used; to drive the code coverage reports. If unset, the target list will be; constructed using the LLVM build's CMake export list. **LLVM_COVERAGE_SOURCE_DIRS**:STRING; If set to a semicolon separated list of directories, the coverage reports; will limit code coverage summaries to just the listed directories. If unset,; coverage reports will include all sources identified by the tooling. **LLVM_INDIVIDUAL_TEST_COVERAGE**:BOOL; Enable individual test case coverage. When set to ON, code coverage data for; each test case will be generated and stored in a separate directory under the; config.test_exec_root path. This feature allows code coverage analysis of each; individual test case. Defaults to OFF. **LLVM_BUILD_LLVM_DYLIB**:BOOL; If enabled, the target for building the libLLVM shared library is added.; This library contains all of LLVM's components in a single shared library.; Defaults to OFF. This cannot be used in conjunction with BUILD_SHARED_LIBS.; Tools will only be linked to the libLLVM shared library if LLVM_LINK_LLVM_DYLIB; is also ON.; The components in the library can be customised by setting LLVM_DYLIB_COMPONENTS; to a list of the desired components.; This option is not available on Windows. **LLVM_BUILD_TESTS**:BOOL; Include LLVM unit tests in the 'all' build target. Defaults to OFF. Targets; for building each unit test are generated in any case. You can build a; specific unit test using the targets defined under *unittests*, such as; ADTTests, IRTests, SupportTests, etc. (Search for ``add_llvm_u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:16023,config,config,16023,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['config'],['config']
Modifiability,ir/unittests/Rewrite; - `1`; - `1`; - `0`; - :good:`100%`; * - mlir/unittests/Support; - `5`; - `4`; - `1`; - :part:`80%`; * - mlir/unittests/TableGen; - `5`; - `3`; - `2`; - :part:`60%`; * - mlir/unittests/Transforms; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libompd/src; - `9`; - `9`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/include; - `8`; - `8`; - `0`; - :good:`100%`; * - openmp/libomptarget/DeviceRTL/src; - `12`; - `9`; - `3`; - :part:`75%`; * - openmp/libomptarget/include; - `9`; - `8`; - `1`; - :part:`88%`; * - openmp/libomptarget/plugins/amdgpu/dynamic_hsa; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/amdgpu/impl; - `13`; - `10`; - `3`; - :part:`76%`; * - openmp/libomptarget/plugins/amdgpu/src; - `2`; - `1`; - `1`; - :part:`50%`; * - openmp/libomptarget/plugins/common/elf_common; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/common/MemoryManager; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/dynamic_cuda; - `2`; - `2`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/cuda/src; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/generic-elf-64bit/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/include; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/lib; - `1`; - `0`; - `1`; - :none:`0%`; * - openmp/libomptarget/plugins/remote/server; - `3`; - `3`; - `0`; - :good:`100%`; * - openmp/libomptarget/plugins/remote/src; - `3`; - `2`; - `1`; - :part:`66%`; * - openmp/libomptarget/plugins/ve/src; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/libomptarget/src; - `7`; - `6`; - `1`; - :part:`85%`; * - openmp/libomptarget/tools/deviceinfo; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/doc/doxygen; - `1`; - `1`; - `0`; - :good:`100%`; * - openmp/runtime/src; - `75`; - `65`; - `10`; - :part:`86%`; * - openmp/runtime/src/thirdparty/ittnotify; - `6`; - `5`; - `1`; - :part:`83%`; * - openm,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst:122259,plugin,plugins,122259,interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormattedStatus.rst,1,['plugin'],['plugins']
Modifiability,"irectNestedType`` function is added. It's useful; for formatters to quickly find directly nested type when it's known; where to search for it, avoiding more expensive global search via; ``SBTarget::FindFirstType``.; * ``lldb-vscode`` was renamed to ``lldb-dap`` and and its installation; instructions have been updated to reflect this. The underlying functionality; remains unchanged.; * The ``mte_ctrl`` register can now be read from AArch64 Linux core files.; * LLDB on AArch64 Linux now supports debugging the Scalable Matrix Extension; (SME) and Scalable Matrix Extension 2 (SME2) for both live processes and core; files. For details refer to the; `AArch64 Linux documentation <https://lldb.llvm.org/use/aarch64-linux.html>`_.; * LLDB now supports symbol and binary acquisition automatically using the; DEBUFINFOD protocol. The standard mechanism of specifying DEBUFINOD servers in; the ``DEBUGINFOD_URLS`` environment variable is used by default. In addition,; users can specify servers to request symbols from using the LLDB setting; ``plugin.symbol-locator.debuginfod.server_urls``, override or adding to the; environment variable. * When running on AArch64 Linux, ``lldb-server`` now provides register; field information for the following registers: ``cpsr``, ``fpcr``,; ``fpsr``, ``svcr`` and ``mte_ctrl``. ::. (lldb) register read cpsr; cpsr = 0x80001000; = (N = 1, Z = 0, C = 0, V = 0, SS = 0, IL = 0, <...>. This is only available when ``lldb`` is built with XML support.; Where possible the CPU's capabilities are used to decide which; fields are present, however this is not always possible or entirely; accurate. If in doubt, refer to the numerical value. * On Windows, LLDB can now read the thread names. Changes to Sanitizers; ---------------------; * HWASan now defaults to detecting use-after-scope bugs. * `SpecialCaseList <https://clang.llvm.org/docs/SanitizerSpecialCaseList.html#format>`_; used by sanitizer ignore lists (e.g. ``*_ignorelist.txt`` in the Clang; resource direct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:16805,plugin,plugin,16805,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['plugin'],['plugin']
Modifiability,"irectories. - `cycle` =\* means all cycles (memory and file). - `cycle` ="""" means apply to a memory object. - `cycle` = 9999 also means apply to a memory object. - `namecycle` = """" means the same as `namecycle` =""T\*"". - `namecycle` = `T*` delete subdirectories. For example to delete a directory from a file, you must specify the; directory cycle:. ``` {.cpp}; root[] f->Delete(""Wed011003;1""); ```. Some other examples of `namecycle` format are:. - `foo`:delete the object named `foo` from memory. - `foo;1`: delete the cycle 1 of the object named `foo` from the file. - `foo;*`: delete all cycles of `foo` from the file and also from; memory. - `*;2`: delete all objects with cycle number 2 from the file. - `*;*: delete` all objects from memory and from the file. - `T*;*`: delete all objects from memory and from the file including; all subdirectories. ## Streamers. To follow the discussion on `Streamers`, you need to know what a; *simple* data type is. A variable is of a simple data type if it cannot; be decomposed into other types. Examples of simple data types are longs,; shorts, floats, and chars. In contrast, a variable is of a *composite*; data type if it can be decomposed. For example, classes, structures, and; arrays are composite types. Simple types are also called primitive; types, basic types, and Cling sometimes calls them fundamental types. When we say, ""writing an object to a file"", we actually mean writing the; current values of the data members. The most common way to do this is to; decompose (also called the serialization of) the object into its data; members and write them to disk. The decomposition is the job of the; `Streamer`. Every class with ambitions to be stored in a file has a; `Streamer `that decomposes it and ""streams"" its members into a buffer. The methods of the class are not written to the file, it contains only; the persistent data members. To decompose the parent classes, the; `Streamer `calls the `Streamer `of the parent classes. It moves u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:41955,variab,variable,41955,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"is a stack-allocated object and it points to the first byte of the; object, the object is dead.; ``ptr`` is conservatively considered as a non-stack-allocated object if; the stack coloring algorithm that is used in the optimization pipeline cannot; conclude that ``ptr`` is a stack-allocated object. Calling ``llvm.lifetime.end`` on an already dead alloca is no-op. If ``ptr`` is a non-stack-allocated object or it does not point to the first; byte of the object, it is equivalent to simply filling all bytes of the object; with ``poison``. '``llvm.invariant.start``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare ptr @llvm.invariant.start.p0(i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.start``' intrinsic specifies that the contents of; a memory object will not change. Arguments:; """""""""""""""""""". The first argument is a constant integer representing the size of the; object, or -1 if it is variable sized. The second argument is a pointer; to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that until an ``llvm.invariant.end`` that uses; the return value, the referenced memory location is constant and; unchanging. '``llvm.invariant.end``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The memory object can belong to any address space. ::. declare void @llvm.invariant.end.p0(ptr <start>, i64 <size>, ptr nocapture <ptr>). Overview:; """""""""""""""""". The '``llvm.invariant.end``' intrinsic specifies that the contents of a; memory object are mutable. Arguments:; """""""""""""""""""". The first argument is the matching ``llvm.invariant.start`` intrinsic.; The second argument is a constant integer representing the size of the; object, or -1 if it is variable sized and the third argument is a; pointer to the object. Semantics:; """""""""""""""""""". This intrinsic indicates that the memory is mutable aga",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:864094,variab,variable,864094,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"is an error (emit an error and return null if there is already an; entry for VarName) but we choose to allow shadowing of variables. In; order to handle this correctly, we remember the Value that we are; potentially shadowing in ``OldVal`` (which will be null if there is no; shadowed variable). Once the loop variable is set into the symbol table, the code; recursively codegen's the body. This allows the body to use the loop; variable: any references to it will naturally find it in the symbol; table. .. code-block:: c++. // Emit the step value.; Value *StepVal = nullptr;; if (Step) {; StepVal = Step->codegen();; if (!StepVal); return nullptr;; } else {; // If not specified, use 1.0.; StepVal = ConstantFP::get(*TheContext, APFloat(1.0));; }. Value *NextVar = Builder->CreateFAdd(Variable, StepVal, ""nextvar"");. Now that the body is emitted, we compute the next value of the iteration; variable by adding the step value, or 1.0 if it isn't present.; '``NextVar``' will be the value of the loop variable on the next; iteration of the loop. .. code-block:: c++. // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Convert condition to a bool by comparing non-equal to 0.0.; EndCond = Builder->CreateFCmpONE(; EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), ""loopcond"");. Finally, we evaluate the exit value of the loop, to determine whether; the loop should exit. This mirrors the condition evaluation for the; if/then/else statement. .. code-block:: c++. // Create the ""after loop"" block and insert it.; BasicBlock *LoopEndBB = Builder->GetInsertBlock();; BasicBlock *AfterBB =; BasicBlock::Create(*TheContext, ""afterloop"", TheFunction);. // Insert the conditional branch into the end of LoopEndBB.; Builder->CreateCondBr(EndCond, LoopBB, AfterBB);. // Any new code will be inserted in AfterBB.; Builder->SetInsertPoint(AfterBB);. With the code for the body of the loop complete, we just need to finish; up the control flow for it. This code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst:24278,variab,variable,24278,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl05.rst,1,['variab'],['variable']
Modifiability,"is an important; step: LLVM still doesn't have code which requires the new toolchains, but it; soon will. If you compile LLVM but don't read the forums, we should; tell you!. * Ensure that at least one LLVM release has had this soft-error. Not all; developers compile LLVM top-of-tree. These release-bound developers should; also be told about upcoming changes. * Turn the soft-error into a hard-error after said LLVM release has branched. * Update the :doc:`coding standards<CodingStandards>` to allow the new; features we've explicitly approved in the RFC. * Start using the new features in LLVM's codebase. Here's a `sample RFC; <https://discourse.llvm.org/t/rfc-migrating-past-c-11/50943>`_ and the; `corresponding change <https://reviews.llvm.org/D57264>`_. .. _ci-usage:. Working with the CI system; --------------------------. The main continuous integration (CI) tool for the LLVM project is the; `LLVM Buildbot <https://lab.llvm.org/buildbot/>`_. It uses different *builders*; to cover a wide variety of sub-projects and configurations. The builds are; executed on different *workers*. Builders and workers are configured and; provided by community members. The Buildbot tracks the commits on the main branch and the release branches.; This means that patches are built and tested after they are merged to the these; branches (aka post-merge testing). This also means it's okay to break the build; occasionally, as it's unreasonable to expect contributors to build and test; their patch with every possible configuration. *If your commit broke the build:*. * Fix the build as soon as possible as this might block other contributors or; downstream users.; * If you need more time to analyze and fix the bug, please revert your change to; unblock others. *If someone else broke the build and this blocks your work*. * Comment on the code review in `GitHub <https://github.com/llvm/llvm-project/pulls>`_; (if available) or email the author, explain the problem and how this impacts; you. Add a ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:36073,config,configurations,36073,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['config'],['configurations']
Modifiability,"is compiled in the project. Each command object contains the translation unit's main file, the; working directory of the compile run and the actual compile command. Example:. ::. [; { ""directory"": ""/home/user/llvm/build"",; ""arguments"": [""/usr/bin/clang++"", ""-Irelative"", ""-DSOMEDEF=With spaces, quotes and \\-es."", ""-c"", ""-o"", ""file.o"", ""file.cc""],; ""file"": ""file.cc"" },. { ""directory"": ""/home/user/llvm/build"",; ""command"": ""/usr/bin/clang++ -Irelative -DSOMEDEF=\""With spaces, quotes and \\-es.\"" -c -o file.o file.cc"",; ""file"": ""file2.cc"" },. ...; ]. The contracts for each field in the command object are:. - **directory:** The working directory of the compilation. All paths; specified in the **command** or **file** fields must be either; absolute or relative to this directory.; - **file:** The main translation unit source processed by this; compilation step. This is used by tools as the key into the; compilation database. There can be multiple command objects for the; same file, for example if the same source file is compiled with; different configurations.; - **arguments:** The compile command argv as list of strings.; This should run the compilation step for the translation unit ``file``.; ``arguments[0]`` should be the executable name, such as ``clang++``.; Arguments should not be escaped, but ready to pass to ``execvp()``.; - **command:** The compile command as a single shell-escaped string.; Arguments may be shell quoted and escaped following platform conventions,; with '``""``' and '``\``' being the only special characters. Shell expansion; is not supported. Either **arguments** or **command** is required. **arguments** is preferred,; as shell (un)escaping is a possible source of errors.; - **output:** The name of the output created by this compilation step.; This field is optional. It can be used to distinguish different processing; modes of the same input file. Build System Integration; ========================. The convention is to name the file compile\_command",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst:3546,config,configurations,3546,interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/JSONCompilationDatabase.rst,1,['config'],['configurations']
Modifiability,"is doesn't fully enforce all inter-library dependencies, and importantly; doesn't enforce header file circular dependencies created by inline functions.; A good way to answer the ""is this layered correctly"" would be to consider; whether a Unix linker would succeed at linking the program if all inline; functions were defined out-of-line. (& for all valid orderings of dependencies; - since linking resolution is linear, it's possible that some implicit; dependencies can sneak through: A depends on B and C, so valid orderings are; ""C B A"" or ""B C A"", in both cases the explicit dependencies come before their; use. But in the first case, B could still link successfully if it implicitly; depended on C, or the opposite in the second case). .. _minimal list of #includes:. ``#include`` as Little as Possible; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``#include`` hurts compile time performance. Don't do it unless you have to,; especially in header files. But wait! Sometimes you need to have the definition of a class to use it, or to; inherit from it. In these cases go ahead and ``#include`` that header file. Be; aware however that there are many cases where you don't need to have the full; definition of a class. If you are using a pointer or reference to a class, you; don't need the header file. If you are simply returning a class instance from a; prototyped function or method, you don't need it. In fact, for most cases, you; simply don't need the definition of a class. And not ``#include``\ing speeds up; compilation. It is easy to try to go too overboard on this recommendation, however. You; **must** include all of the header files that you are using --- you can include; them either directly or indirectly through another header file. To make sure; that you don't accidentally forget to include a header file in your module; header, make sure to include your module header **first** in the implementation; file (as mentioned above). This way there won't be any hidden dependencies that; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:32050,inherit,inherit,32050,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['inherit'],['inherit']
Modifiability,"is is not a safe way to distribute LLVM or; LLVM-based tools. The simplest example of building a distribution with reasonable performance is; captured in the DistributionExample CMake cache file located at; clang/cmake/caches/DistributionExample.cmake. The following command will perform; and install the distribution build:. .. code-block:: console. $ cmake -G Ninja -C <path to clang>/cmake/caches/DistributionExample.cmake <path to LLVM source>; $ ninja stage2-distribution; $ ninja stage2-install-distribution. Difference between ``install`` and ``install-distribution``; -----------------------------------------------------------. One subtle but important thing to note is the difference between the ``install``; and ``install-distribution`` targets. The ``install`` target is expected to; install every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; whi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:3480,config,configuration,3480,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configuration']
Modifiability,"is is useful in; cases where the memory accessed by the snippet depends on the location; of the snippet, like RIP-relative addressing. EXAMPLE 1: benchmarking instructions; ------------------------------------. Assume you have an X86-64 machine. To measure the latency of a single; instruction, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-name=ADD64rr. Measuring the uop decomposition or inverse throughput of an instruction works similarly:. .. code-block:: bash. $ llvm-exegesis --mode=uops --opcode-name=ADD64rr; $ llvm-exegesis --mode=inverse_throughput --opcode-name=ADD64rr. The output is a YAML document (the default is to write to stdout, but you can; redirect the output to a file using `--benchmarks-file`):. .. code-block:: none. ---; key:; opcode_name: ADD64rr; mode: latency; config: ''; cpu_name: haswell; llvm_triple: x86_64-unknown-linux-gnu; num_repetitions: 10000; measurements:; - { key: latency, value: 1.0058, debug_string: '' }; error: ''; info: 'explicit self cycles, selecting one aliasing configuration.; Snippet:; ADD64rr R8, R8, R10; '; ... To measure the latency of all instructions for the host architecture, run:. .. code-block:: bash. $ llvm-exegesis --mode=latency --opcode-index=-1. EXAMPLE 2: benchmarking a custom code snippet; ---------------------------------------------. To measure the latency/uops of a custom piece of code, you can specify the; `snippets-file` option (`-` reads from standard input). .. code-block:: bash. $ echo ""vzeroupper"" | llvm-exegesis --mode=uops --snippets-file=-. Real-life code snippets typically depend on registers or memory.; :program:`llvm-exegesis` checks the liveliness of registers (i.e. any register; use has a corresponding def or is a ""live in""). If your code depends on the; value of some registers, you need to use snippet annotations to ensure setup; is performed properly. For example, the following code snippet depends on the values of XMM1 (which; will be set by the tool) and the memory buff",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:5618,config,configuration,5618,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['config'],['configuration']
Modifiability,"is program to create a little endian version of the table. The table; is used in PPCISelLowering.cpp, PPCTargetLowering::LOWERVECTOR_SHUFFLE(). //===----------------------------------------------------------------------===//. Opportunies to use instructions from PPCInstrVSX.td during code gen; - Conversion instructions (Sections 7.6.1.5 and 7.6.1.6 of ISA 2.07); - Scalar comparisons (xscmpodp and xscmpudp); - Min and max (xsmaxdp, xsmindp, xvmaxdp, xvmindp, xvmaxsp, xvminsp). Related to this: we currently do not generate the lxvw4x instruction for either; v4f32 or v4i32, probably because adding a dag pattern to the recognizer requires; a single target type. This should probably be addressed in the PPCISelDAGToDAG logic. //===----------------------------------------------------------------------===//. Currently EXTRACT_VECTOR_ELT and INSERT_VECTOR_ELT are type-legal only; for v2f64 with VSX available. We should create custom lowering; support for the other vector types. Without this support, we generate; sequences with load-hit-store hazards. v4f32 can be supported with VSX by shifting the correct element into; big-endian lane 0, using xscvspdpn to produce a double-precision; representation of the single-precision value in big-endian; double-precision lane 0, and reinterpreting lane 0 as an FPR or; vector-scalar register. v2i64 can be supported with VSX and P8Vector in the same manner as; v2f64, followed by a direct move to a GPR. v4i32 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 1, using a direct move to a GPR, and; sign-extending the 32-bit result to 64 bits. v8i16 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 3, using a direct move to a GPR, and; sign-extending the 16-bit result to 64 bits. v16i8 can be supported with VSX and P8Vector by shifting the correct; element into big-endian lane 7, using a direct move to a GPR, and; sign-extending the 8-bit result to 64 bits.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt:10862,extend,extending,10862,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_ALTIVEC.txt,3,['extend'],['extending']
Modifiability,"is release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the sum of integrals in each range. This implies that the likelihood takes into account all inter-range and intra-range information. ### Deprecation of the `RooMinuit` class. The `RooMinuit` class was the old interface between RooFit and minuit. With ROOT version 5.24, the more general `RooMinimizer` adapter was introduced, which became the default with ROOT 6.08. Before 6.26, it was possible to still use the `RooMinuit` by passing the `Minimizer(""OldMinuit"", ""minimizer"")` command argument to `RooAbsPdf::fitTo()`. This option is now removed. ### Increase of the `RooAbsArg` class version. The class version of `RooAbsArg` was incremented from 7 to 8 in this release. In some circumstances, this can cause warnings in `TStreamerInfo` for classes inheriting from `RooAbsArg` when reading; older RooFit models from a file. These warnings are harmless and can be avoided by incrementing also the class version of the inheriting class. ### Compile-time protection against creating empty `RooCmdArg`s from strings. The implicit [RooCmdArg](https://root.cern/doc/v626/classRooCmdArg.html) constructor from `const char*` was removed to avoid the accidental construction of meaningless RooCmdArgs that only have a name but no payload.; This causes new compiler errors in your code if you pass a string instead of a RooCmdArg to various RooFit functions, such as [RooAbsPdf::fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5).; If this happens, please consult the documentation of [fitTo()](https://root.cern/doc/v626/classRooAbsPdf.html#a5f79f16f4a26a19c9e66fb5c080f59c5) to check which of the [free functions in the `RooFit` namespace](https://root.cern/doc/v626/group__CmdArgs.html) you need to use to achieve ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:30904,inherit,inheriting,30904,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['inherit'],['inheriting']
Modifiability,"is selected by; the code generator, that it is a two-address instruction, has a particular; encoding, etc. The contents and semantics of the information in the record are; specific to the needs of the X86 backend, and are only shown as an example. As you can see, a lot of information is needed for every instruction supported; by the code generator, and specifying it all manually would be unmaintainable,; prone to bugs, and tiring to do in the first place. Because we are using; TableGen, all of the information was derived from the following definition:. .. code-block:: text. let Defs = [EFLAGS],; isCommutable = 1, // X = ADD Y,Z --> X = ADD Z,Y; isConvertibleToThreeAddress = 1 in // Can transform into LEA.; def ADD32rr : I<0x01, MRMDestReg, (outs GR32:$dst),; (ins GR32:$src1, GR32:$src2),; ""add{l}\t{$src2, $dst|$dst, $src2}"",; [(set GR32:$dst, (add GR32:$src1, GR32:$src2))]>;. This definition makes use of the custom class ``I`` (extended from the custom; class ``X86Inst``), which is defined in the X86-specific TableGen file, to; factor out the common features that instructions of its class share. A key; feature of TableGen is that it allows the end-user to define the abstractions; they prefer to use when describing their information. Syntax; ======. TableGen has a syntax that is loosely based on C++ templates, with built-in; types and specification. In addition, TableGen's syntax introduces some; automation concepts like multiclass, foreach, let, etc. Basic concepts; --------------. TableGen files consist of two key parts: 'classes' and 'definitions', both of; which are considered 'records'. **TableGen records** have a unique name, a list of values, and a list of; superclasses. The list of values is the main data that TableGen builds for each; record; it is this that holds the domain specific information for the; application. The interpretation of this data is left to a specific `backend`_,; but the structure and format rules are taken care of and are fixed by; Table",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst:6891,extend,extended,6891,interpreter/llvm-project/llvm/docs/TableGen/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/index.rst,1,['extend'],['extended']
Modifiability,"is to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16610,variab,variable,16610,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variable']
Modifiability,"is transformation analyzes and transforms the induction variables (and; computations derived from them) into simpler forms suitable for subsequent; analysis and transformation. This transformation makes the following changes to each loop with an; identifiable induction variable:. * All loops are transformed to have a *single* canonical induction variable; which starts at zero and steps by one.; * The canonical induction variable is guaranteed to be the first PHI node in; the loop header block.; * Any pointer arithmetic recurrences are raised to use array subscripts. If the trip count of a loop is computable, this pass also makes the following; changes:. * The exit condition for the loop is canonicalized to compare the induction; value against the exit value. This turns loops like:. .. code-block:: c++. for (i = 7; i*i < 1000; ++i). into. .. code-block:: c++. for (i = 0; i != 25; ++i). * Any use outside of the loop of an expression derived from the indvar is; changed to compute the derived value outside of the loop, eliminating the; dependence on the exit value of the induction variable. If the only purpose; of the loop is to compute the exit value of some derived expression, this; transformation will make the loop dead. This transformation should be followed by strength reduction after all of the; desired loop transformations have been performed. Additionally, on targets; where it is profitable, the loop could be transformed to count down to zero; (the ""do loop"" optimization). ``inline``: Function Integration/Inlining; -----------------------------------------. Bottom-up inlining of functions into callees. .. _passes-instcombine:. ``instcombine``: Combine redundant instructions; -----------------------------------------------. Combine instructions to form fewer, simple instructions. This pass does not; modify the CFG. This pass is where algebraic simplification happens. This pass combines things like:. .. code-block:: llvm. %Y = add i32 %X, 1; %Z = add i32 %Y, 1. in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:18727,variab,variable,18727,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['variab'],['variable']
Modifiability,"is useful for filing bug reports against scan-build or the; analyzer, as we can see the exact options (and files) passed to the analyzer.; For more comprehensible logs, don't perform a parallel build.; Run './configure' through scan-build; If an analyzed project uses an autoconf generated configure script,; you will probably need to run configure script through; scan-build in order to analyze the project.; Example. $ scan-build ./configure; $ scan-build --keep-cc make. The reason configure also needs to be run through; scan-build is because scan-build scans your source files by; interposing on the compiler. This interposition is currently done by; scan-build temporarily setting the environment variable CC to; ccc-analyzer. The program ccc-analyzer acts like a fake; compiler, forwarding its command line arguments over to the compiler to perform; regular compilation and clang to perform static analysis.; Running configure typically generates makefiles that have hardwired; paths to the compiler, and by running configure through; scan-build that path is set to ccc-analyzer. Analyzing iPhone Projects; Conceptually Xcode projects for iPhone applications are nearly the same as; their cousins for desktop applications. scan-build can analyze these; projects as well, but users often encounter problems with just building their; iPhone projects from the command line because there are a few extra preparative; steps they need to take (e.g., setup code signing).; Recommendation: use ""Build and Analyze""; The absolute easiest way to analyze iPhone projects is to use the; Analyze; feature in Xcode (which is based on the Clang Static Analyzer). There a; user can analyze their project right from a menu without most of the setup; described later.; Instructions are available on this; website on how to use open source builds of the analyzer as a replacement for; the one bundled with Xcode.; Using scan-build directly; If you wish to use scan-build with your iPhone project, keep the; follow",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html:7738,config,configure,7738,interpreter/llvm-project/clang/www/analyzer/scan-build.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/scan-build.html,2,['config'],['configure']
Modifiability,"is way we 'mount' `/usr/include/module.modulemap`; non-invasively. The reasons why we need to extend the C++ modules support; beyond ROOT is described bellow.; * rootcling -cxxmodule creates a single artifact *Name.pcm* after the library; name. At a final stage, ROOT might be able to integrate the Name.pcm with the; shared library itself.; * Improved correctness in number of cases -- in a few cases ROOT is more; correct. In particular, when resolving global variables and function; declarations which are not part of the ROOT PCH.; * Enhanced symbol resolution mechanisms, bloom filters -- standard ROOT relies; on information in ROOTMAP files to react when the llvm JIT issues an; unresolved symbol callback. C++ Modules-aware ROOT relies on a behavior much; closer to the standard linker behavior. In particular, we start searching on; the LD_LIBRARY_PATH descending to the system libraries. The algorithm is very; efficient because it uses bloom filters[[5]]. This in turn allows ROOT symbol; to be extended to system libraries. ### Module Registration Approaches. The C++ modules system supports /*preloading*/ of all modules at startup time.; The current implementation of loading of C++ modules in clang has an overhead; and is between 40-60 MB depending on the ROOT configuration while there might; be 2x slowdown depending on the workflow. These issues are very likely to be; addressed by the LLVM community in midterm. Preloading of all C++ modules is semantically the closest to C++ behavior.; However, in order to achieve performance ROOT loads them on demand using; a global module index file. It has sufficient information to map a looked up; identifier to the module which contains the corresponding definition. Switching; back to preloading of all C++ modules is done by setting the `ROOT_USE_GMI`; environment variable to false.; ; ### Supported Platforms. We support all platforms with glibc++ versions: 5.2 onward. We support OSX from XCode 10 onward. ## Changes required by the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:13669,extend,extended,13669,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['extend'],['extended']
Modifiability,"is->b; cxxDependentScopeMemberExpr(isArrow()); matches this->m; unresolvedMemberExpr(isArrow()); matches this->f<T>, f<T>. Matcher<VarDecl>hasAutomaticStorageDuration; Matches a variable declaration that has automatic storage duration. Example matches x, but not y, z, or a.; (matcher = varDecl(hasAutomaticStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>hasGlobalStorage; Matches a variable declaration that does not have local storage. Example matches y and z (matcher = varDecl(hasGlobalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasLocalStorage; Matches a variable declaration that has function scope and is a; non-static local variable. Example matches x (matcher = varDecl(hasLocalStorage()); void f() {; int x;; static int y;; }; int z;. Matcher<VarDecl>hasStaticStorageDuration; Matches a variable declaration that has static storage duration.; It includes the variable declared at namespace scope and those declared; with ""static"" and ""extern"" storage class specifiers. void f() {; int x;; static int y;; thread_local int z;; }; int a;; static int b;; extern int c;; varDecl(hasStaticStorageDuration()); matches the function declaration y, a, b and c. Matcher<VarDecl>hasThreadStorageDuration; Matches a variable declaration that has thread storage duration. Example matches z, but not x, z, or a.; (matcher = varDecl(hasThreadStorageDuration()); void f() {; int x;; static int y;; thread_local int z;; }; int a;. Matcher<VarDecl>isConstexpr; Matches constexpr variable and function declarations,; and if constexpr. Given:; constexpr int foo = 42;; constexpr int bar();; void baz() { if constexpr(1 > 0) {} }; varDecl(isConstexpr()); matches the declaration of foo.; functionDecl(isConstexpr()); matches the declaration of bar.; ifStmt(isConstexpr()); matches the if statement in baz. Matcher<VarDecl>isConstinit; Matches constinit variable declarations. Given:; constinit int foo = 42;; constinit const ch",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:124936,variab,variable,124936,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['variab'],['variable']
Modifiability,"isLValue()``). Different kinds of declarations have different rules:. * **Type names** (including classes, structs, enums, typedefs, etc) should be; nouns and start with an upper-case letter (e.g. ``TextFileReader``). * **Variable names** should be nouns (as they represent state). The name should; be camel case, and start with an upper case letter (e.g. ``Leader`` or; ``Boats``). * **Function names** should be verb phrases (as they represent actions), and; command-like function should be imperative. The name should be camel case,; and start with a lower case letter (e.g. ``openFile()`` or ``isFoo()``). * **Enum declarations** (e.g. ``enum Foo {...}``) are types, so they should; follow the naming conventions for types. A common use for enums is as a; discriminator for a union, or an indicator of a subclass. When an enum is; used for something like this, it should have a ``Kind`` suffix; (e.g. ``ValueKind``). * **Enumerators** (e.g. ``enum { Foo, Bar }``) and **public member variables**; should start with an upper-case letter, just like types. Unless the; enumerators are defined in their own small namespace or inside a class,; enumerators should have a prefix corresponding to the enum declaration name.; For example, ``enum ValueKind { ... };`` may contain enumerators like; ``VK_Argument``, ``VK_BasicBlock``, etc. Enumerators that are just; convenience constants are exempt from the requirement for a prefix. For; instance:. .. code-block:: c++. enum {; MaxSize = 42,; Density = 12; };. As an exception, classes that mimic STL classes can have member names in STL's; style of lower-case words separated by underscores (e.g. ``begin()``,; ``push_back()``, and ``empty()``). Classes that provide multiple; iterators should add a singular prefix to ``begin()`` and ``end()``; (e.g. ``global_begin()`` and ``use_begin()``). Here are some examples:. .. code-block:: c++. class VehicleMaker {; ...; Factory<Tire> F; // Avoid: a non-descriptive abbreviation.; Factory<Tire> Factory; // Bet",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:43567,variab,variables,43567,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['variab'],['variables']
Modifiability,"isible context (e.g., function prototype, struct definition, etc.). .. _Default pointer types in typeof:. Default pointer types in ``typeof()``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When ``typeof()`` takes an expression, it respects the bounds annotation on; the expression type, including the bounds annotation is implcit. For example,; the global variable ``g`` in the following code is implicitly ``__single`` so; ``typeof(g)`` gets ``char *__single``. The similar is true for the parameter; ``p``, so ``typeof(p)`` returns ``void *__single``. The local variable ``l`` is; implicitly ``__bidi_indexable``, so ``typeof(l)`` becomes; ``int *__bidi_indexable``. .. code-block:: C. char *g; // typeof(g) == char *__single. void foo(void *p) {; // typeof(p) == void *__single. int *l; // typeof(l) == int *__bidi_indexable; }. When the type of expression has an ""external"" bounds annotation, e.g.,; ``__sized_by``, ``__counted_by``, etc., the compiler may report an error on; ``typeof`` if the annotation creates a dependency with another declaration or; variable. For example, the compiler reports an error on ``typeof(p1)`` shown in; the following code because allowing it can potentially create another type; dependent on the parameter ``size`` in a different context (Please note that an; external bounds annotation on a parameter may only refer to another parameter of; the same function). On the other hand, ``typeof(p2)`` works resulting in ``int; *__counted_by(10)``, since it doesn't depend on any other declaration. .. TODO: add a section describing constraints on external bounds annotations. .. code-block:: C. void foo(int *__counted_by(size) p1, size_t size) {; // typeof(p1) == int *__counted_by(size); // -> a compiler error as it tries to create another type; // dependent on `size`. int *__counted_by(10) p2; // typeof(p2) == int *__counted_by(10); // -> no error. }. When ``typeof()`` takes a type name, the compiler doesn't apply an implicit; bounds annotation on the named pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:26352,variab,variable,26352,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['variab'],['variable']
Modifiability,ism.cpp; openmp/libomptarget/DeviceRTL/src/Reduction.cpp; openmp/libomptarget/DeviceRTL/src/State.cpp; openmp/libomptarget/DeviceRTL/src/Synchronization.cpp; openmp/libomptarget/DeviceRTL/src/Tasking.cpp; openmp/libomptarget/DeviceRTL/src/Utils.cpp; openmp/libomptarget/include/Debug.h; openmp/libomptarget/include/device.h; openmp/libomptarget/include/DeviceEnvironment.h; openmp/libomptarget/include/interop.h; openmp/libomptarget/include/omptarget.h; openmp/libomptarget/include/omptargetplugin.h; openmp/libomptarget/include/rtl.h; openmp/libomptarget/include/SourceInfo.h; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.cpp; openmp/libomptarget/plugins/amdgpu/dynamic_hsa/hsa.h; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.cpp; openmp/libomptarget/plugins/amdgpu/impl/get_elf_mach_gfx_name.h; openmp/libomptarget/plugins/amdgpu/impl/hsa_api.h; openmp/libomptarget/plugins/amdgpu/impl/impl.cpp; openmp/libomptarget/plugins/amdgpu/impl/impl_runtime.h; openmp/libomptarget/plugins/amdgpu/impl/internal.h; openmp/libomptarget/plugins/amdgpu/impl/interop_hsa.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.cpp; openmp/libomptarget/plugins/amdgpu/impl/msgpack.h; openmp/libomptarget/plugins/amdgpu/impl/rt.h; openmp/libomptarget/plugins/amdgpu/src/print_tracing.h; openmp/libomptarget/plugins/common/elf_common/elf_common.cpp; openmp/libomptarget/plugins/common/elf_common/elf_common.h; openmp/libomptarget/plugins/common/MemoryManager/MemoryManager.h; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.cpp; openmp/libomptarget/plugins/cuda/dynamic_cuda/cuda.h; openmp/libomptarget/plugins/generic-elf-64bit/src/rtl.cpp; openmp/libomptarget/plugins/remote/include/Utils.h; openmp/libomptarget/plugins/remote/server/OffloadingServer.cpp; openmp/libomptarget/plugins/remote/server/Server.cpp; openmp/libomptarget/plugins/remote/server/Server.h; openmp/libomptarget/plugins/remote/src/Client.cpp; openmp/libomptarget/plugins/remote/src/Client.h; openmp/libomptarget/plugins/v,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:407245,plugin,plugins,407245,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['plugin'],['plugins']
Modifiability,"ist its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");; root[] gDirectory->pwd(); AFile1.root:/; ```. If you create ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21681,variab,variable,21681,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"istributions are in the MathMore library and are defined in; the header file `Math/ProbFuncInv.h`. The following picture illustrates the available statistical functions; (PDF, CDF and quantiles) in the case of the normal distribution. ![PDF, CDF and quantiles in the case of the normal distribution](pictures/03000128.png). ## Numerical Algorithms. ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. * Evaluation of function derivatives.; * Evaluation of integrals.; * Finding the roots of a function; * Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function.; ROOT provides a common way of specifying them via some interfaces. ## ROOT::Math Function interfaces. To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function.; In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ![ROOT::Math Function interface structure](pictures/function-hierarchy.png). ### One-dimensional Function Interfaces. These interfaces are used for numerical algorithms operating only on one-dimensional functions and cannot be applied to multi-dimensional functions.; For this case the users needs to define a function object which evaluates in one dimension, and the object will have to derivate from the following:. * `ROOT::Math::IBaseFunctionOneDim`: This class is the most basic function. Provides a method to evaluate the function given a value (simple double) by implementing; `double operator() (const double )`. The user class defined only needs to reimplement the pure abstract method `double DoEval(double x)`,; that will do the work of evaluating the function at point x. Example on how to create a class that represents a mathematical function. The user only has to override two methods from `IBaseFunction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:35026,inherit,inherit,35026,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['inherit'],['inherit']
Modifiability,"isual Studio 2019 and Python 3.9.6:. 1. Download and install `Visual Studio <https://visualstudio.microsoft.com/>`_.; 2. In the Visual Studio installer, Workloads tab, select the; **Desktop development with C++** workload. Under Individual components tab,; select **Git for Windows**.; 3. Complete the Visual Studio installation.; 4. Download and install the latest `Python 3 release <http://www.python.org/>`_.; 5. In the first install screen, select both **Install launcher for all users**; and **Add Python to the PATH**. This will allow installing psutil for all; users for the regression tests and make Python available from the command; line.; 6. In the second install screen, select (again) **Install for all users** and; if you want to develop `lldb <https://lldb.llvm.org/>`_, selecting; **Download debug binaries** is useful.; 7. Complete the Python installation.; 8. Run a ""Developer Command Prompt for VS 2019"" **as administrator**. This command; prompt provides correct path and environment variables to Visual Studio and; the installed tools.; 9. In the terminal window, type the commands:. .. code-block:: bat. c:; cd \. You may install the llvm sources in other location than ``c:\llvm`` but do not; install into a path containing spaces (e.g. ``c:\Documents and Settings\...``); as it will fail. 10. Register the Microsoft Debug Interface Access (DIA) DLLs. .. code-block:: bat. regsvr32 ""%VSINSTALLDIR%\DIA SDK\bin\msdia140.dll""; regsvr32 ""%VSINSTALLDIR%\DIA SDK\bin\amd64\msdia140.dll"". The DIA library is required for LLVM PDB tests and; `LLDB development <https://lldb.llvm.org/resources/build.html>`_. 11. Install psutil and obtain LLVM source code:. .. code-block:: bat. pip install psutil; git clone https://github.com/llvm/llvm-project.git llvm. Instead of ``git clone`` you may download a compressed source distribution; from the `releases page <https://github.com/llvm/llvm-project/releases>`_.; Select the last link: ``Source code (zip)`` and unpack the downloaded file us",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst:3858,variab,variables,3858,interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStartedVS.rst,1,['variab'],['variables']
Modifiability,"isualization system can be used to render rich content such as images,; therefore bringing more interactivity into the Jupyter’s world. You can find; more information on `Xeus Cling's Read the Docs; <https://xeus-cling.readthedocs.io/en/latest/>`_ webpage. 2. **Interactive CUDA C++ with Cling:**. `CUDA <https://blogs.nvidia.com/blog/2012/09/10/what-is-cuda-2/>`_ is a platform; and Application Programming Interface (API) created by `NVIDIA; <https://www.nvidia.com/en-us/>`_. It controls `GPU; <https://en.wikipedia.org/wiki/Graphics_processing_unit>`_ (Graphical Processing; Unit) for parallel programming, enabling developers to harness the power of; graphic processing units (GPUs) to speed up applications. As an example,; `PIConGPU <https://github.com/ComputationalRadiationPhysics/picongpu>`_ is a; CUDA-based plasma physics application to solve the dynamics of a plasma by; computing the motion of electrons and ions in the plasma field. Interactive GPU; programming was made possible by extending Cling functionality to compile CUDA; C++ code. The new Cling-CUDA C++ can be used on Jupyter Notebook platform, and; enables big, interactive simulation with GPUs, easy GPU development and; debugging, and effective GPU programming learning. 3. **Clad:**. `Clad <https://compiler-research.org/clad/>`_ enables automatic differentiation; (AD) for C++. It was first developed as a plugin for Cling, and is now a plugin; for Clang compiler. Clad is based on source code transformation. Given C++; source code of a mathematical function, it can automatically generate C++ code; for computing derivatives of the function. It supports both forward-mode and; reverse-mode AD. 4. **Cling for live coding music and musical instruments:**. The artistic live coding community has been growing steadily since around the; year 2000. The Temporary Organisation for the Permanence of Live Art Programming; (TOPLAP) has been around since 2004, Algorave (algorithmic rave parties); recently celebrated its tenth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst:1655,extend,extending,1655,interpreter/cling/docs/chapters/applications.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/chapters/applications.rst,1,['extend'],['extending']
Modifiability,"it is initialized as follows:. .. code-block:: c. struct __block_literal_1 __block_literal_1 = {; &_NSConcreteGlobalBlock,; (1<<28)|(1<<29), <uninitialized>,; __block_invoke_1,; &__block_descriptor_1; };. that is, a different address is provided as the first value and a particular; (1<<28) bit is set in the ``flags`` field, and otherwise it is the same as for; stack based ``Block`` literals. This is an optimization that can be used for; any ``Block`` literal that imports no ``const`` or ``__block`` storage; variables. Imported Variables; ==================. Variables of ``auto`` storage class are imported as ``const`` copies. Variables; of ``__block`` storage class are imported as a pointer to an enclosing data; structure. Global variables are simply referenced and not considered as; imported. Imported ``const`` copy variables; ---------------------------------. Automatic storage variables not marked with ``__block`` are imported as; ``const`` copies. The simplest example is that of importing a variable of type ``int``:. .. code-block:: c. int x = 10;; void (^vv)(void) = ^{ printf(""x is %d\n"", x); }; x = 11;; vv();. which would be compiled to:. .. code-block:: c. struct __block_literal_2 {; void *isa;; int flags;; int reserved;; void (*invoke)(struct __block_literal_2 *);; struct __block_descriptor_2 *descriptor;; const int x;; };. void __block_invoke_2(struct __block_literal_2 *_block) {; printf(""x is %d\n"", _block->x);; }. static struct __block_descriptor_2 {; unsigned long int reserved;; unsigned long int Block_size;; } __block_descriptor_2 = { 0, sizeof(struct __block_literal_2) };. and:. .. code-block:: c. struct __block_literal_2 __block_literal_2 = {; &_NSConcreteStackBlock,; (1<<29), <uninitialized>,; __block_invoke_2,; &__block_descriptor_2,; x; };. In summary, scalars, structures, unions, and function pointers are generally; imported as ``const`` copies with no need for helper functions. Imported ``const`` copy of ``Block`` reference; ----------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:7101,variab,variable,7101,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variable']
Modifiability,"it isRef = 1;; }. ``let`` --- override fields in classes or records; -------------------------------------------------. A ``let`` statement collects a set of field values (sometimes called; *bindings*) and applies them to all the classes and records defined by; statements within the scope of the ``let``. .. productionlist::; Let: ""let"" `LetList` ""in"" ""{"" `Statement`* ""}""; :| ""let"" `LetList` ""in"" `Statement`; LetList: `LetItem` ("","" `LetItem`)*; LetItem: `TokIdentifier` [""<"" `RangeList` "">""] ""="" `Value`. The ``let`` statement establishes a scope, which is a sequence of statements; in braces or a single statement with no braces. The bindings in the; :token:`LetList` apply to the statements in that scope. The field names in the :token:`LetList` must name fields in classes inherited by; the classes and records defined in the statements. The field values are; applied to the classes and records *after* the records inherit all the fields from; their parent classes. So the ``let`` acts to override inherited field; values. A ``let`` cannot override the value of a template argument. Top-level ``let`` statements are often useful when a few fields need to be; overridden in several records. Here are two examples. Note that ``let``; statements can be nested. .. code-block:: text. let isTerminator = true, isReturn = true, isBarrier = true, hasCtrlDep = true in; def RET : I<0xC3, RawFrm, (outs), (ins), ""ret"", [(X86retflag 0)]>;. let isCall = true in; // All calls clobber the non-callee saved registers...; let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,; MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,; XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {; def CALLpcrel32 : Ii32<0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),; ""call\t${dst:call}"", []>;; def CALL32r : I<0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),; ""call\t{*}$dst"", [(X86call GR32:$dst)]>;; def CALL32m : I<0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),; ""call\t{*}$dst"", []>;; }. N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:33662,inherit,inherited,33662,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['inherit'],['inherited']
Modifiability,"it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13671,variab,variables,13671,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['variab'],['variables']
Modifiability,"it` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suite is discovered, its config file is loaded. Config files; themselves are Python modules which will be executed. When the config file is; executed, two important global variables are predefined:. **lit_config**. The global **lit** configuration object (a *LitConfig* instance), which defines; the builtin test formats, global configuration parameters, and other helper; routines for implementing test configurations. **config**. This is the config object (a *TestingConfig* instance) for the test suite,; which the config file is expected to populate. The following variables are also; available on the *config* object, some of which must be set by the config and; others are optional or predefined:. **name** *[required]* The name of the test suite, for use in reports and; diagnostics. **test_format** *[required]* The test format object which will be used to; discover and run tests in the test suite. Generally this will be a builtin test; format available from the *lit.formats* module. **test_source_root** The filesystem path to the test suite root. For out-of-dir; builds this is the directory that will be scanned for tests. **test_exec_root** For out-of-dir builds, the path to the test suite root inside; the object directory. This is where tests will be run and temporary output files; placed. **environment** A dictionary representing the environment to use when executing; tests in the suite. **standalone_tests** When true, mark a directory with tests expected to be run; standalone. Test discovery is disabled for that directory. *lit.suffixes* and; *lit.excludes* must be empty when this variable is true. **s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:15363,variab,variables,15363,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,3,"['config', 'variab']","['config', 'variables']"
Modifiability,"ite. **XPASS**. The test succeeded, but it was expected to fail. This is used for tests which; were specified as expected to fail, but are now succeeding (generally because; the feature they test was broken and has been fixed). **FAIL**. The test failed. **UNRESOLVED**. The test result could not be determined. For example, this occurs when the test; could not be run, the test itself is invalid, or the test was interrupted. **UNSUPPORTED**. The test is not supported in this environment. This is used by test formats; which can report unsupported tests. **TIMEOUT**. The test was run, but it timed out before it was able to complete. This is; considered a failure. Depending on the test format tests may produce additional information about; their status (generally only for failures). See the :ref:`output-options`; section for more information. .. _lit-infrastructure:. LIT INFRASTRUCTURE; ------------------. This section describes the :program:`lit` testing architecture for users interested in; creating a new :program:`lit` testing implementation, or extending an existing one. :program:`lit` proper is primarily an infrastructure for discovering and running; arbitrary tests, and to expose a single convenient interface to these; tests. :program:`lit` itself doesn't know how to run tests, rather this logic is; defined by *test suites*. TEST SUITES; ~~~~~~~~~~~. As described in :ref:`test-discovery`, tests are always located inside a *test; suite*. Test suites serve to define the format of the tests they contain, the; logic for finding those tests, and any additional information to run the tests. :program:`lit` identifies test suites as directories containing ``lit.cfg`` or; ``lit.site.cfg`` files (see also :option:`--config-prefix`). Test suites are; initially discovered by recursively searching up the directory hierarchy for; all the input files passed on the command line. You can use; :option:`--show-suites` to display the discovered test suites at startup. Once a test suit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst:13858,extend,extending,13858,interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/lit.rst,1,['extend'],['extending']
Modifiability,"ite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simplified version of the `TTree` class. A ROOT `TNtuple` object can; store rows of float entries. Let's tackle the problem according to the; usual strategy commenting a minimal example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file.C; ```. This data written to this example n-tuple represents, in the statistical; sense, three independent variables (Potential or Voltage, Pressure and; Temperature), and one variable (Current) which depends on the others; according to very simple laws, and an additional Gaussian smearing. This; set of variables mimics a measurement of an electrical resistance while; varying pressure and temperature. Imagine your task now consists in finding the relations among the; variables -- of course without knowing the code used to generate them.; You will see that the possibilities of the `NTuple` class enable you to; perform this analysis task. Open the ROOT file (`cond_data.root`); written by the macro above in an interactive session and use a; `TBrowser` to interactively inspect it:. ``` {.cpp}; root[0] TBrowser b; ```; You find the columns of your n-tuple written as *leafs*. Simply clicking; on them you can obtain histograms of the variables!. Next, try the following commands at the shell prompt and in the; interactive ROOT shell, respectively:. ``` {.cpp}; > root conductivity_experiment.root; Attaching file conductivity_experiment.root as _file0...; root [0] cond_data->Draw(""Current:Potential""); ```. You just produced a correlation plot with one single line of code!. Try to extend the syntax typing for example. ``` {.cpp}; root [1] cond_data->Draw(""Current:Potential"",""Temperature<270""); ```. What do you obtain ?. Now try. ``` {.cpp}; root [2] cond_data-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:2757,variab,variables,2757,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variables']
Modifiability,"itectures on your system:. .. code-block:: shell. clang++ --offload-arch=native -xhip sample.cpp -o sample. Path Setting for Dependencies; =============================. Compiling a HIP program depends on the HIP runtime and device library. The paths to the HIP runtime and device libraries; can be specified either using compiler options or environment variables. The paths can also be set through the ROCm path; if they follow the ROCm installation directory structure. Order of Precedence for HIP Path; --------------------------------. 1. ``--hip-path`` compiler option; 2. ``HIP_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). Order of Precedence for Device Library Path; -------------------------------------------. 1. ``--hip-device-lib-path`` compiler option; 2. ``HIP_DEVICE_LIB_PATH`` environment variable *(use with caution)*; 3. ``--rocm-path`` compiler option; 4. ``ROCM_PATH`` environment variable *(use with caution)*; 5. Default automatic detection (relative to Clang or at the default ROCm installation location). .. list-table::; :header-rows: 1. * - Compiler Option; - Environment Variable; - Description; - Default Value; * - ``--rocm-path=<path>``; - ``ROCM_PATH``; - Specifies the ROCm installation path.; - Automatic detection; * - ``--hip-path=<path>``; - ``HIP_PATH``; - Specifies the HIP runtime installation path.; - Determined by ROCm directory structure; * - ``--hip-device-lib-path=<path>``; - ``HIP_DEVICE_LIB_PATH``; - Specifies the HIP device library installation path.; - Determined by ROCm directory structure. .. note::. We recommend using the compiler options as the primary method for specifying these paths. While the environment variables ``ROCM_PATH``, ``HIP_PATH``, and ``HIP_DEVICE_LIB_PATH`` are supported, their use can lead to implicit dependencies that might",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:4468,variab,variable,4468,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,1,['variab'],['variable']
Modifiability,"iterals. .. code-block:: c++. true:; return ""Code""; ""\0\52\26\55\55\0""; ""x013""; ""\02\xBA"";; false:; return ""Code"" ""\0\52\26\55\55\0"" ""x013"" ""\02\xBA"";. .. _BreakAfterAttributes:. **BreakAfterAttributes** (``AttributeBreakingStyle``) :versionbadge:`clang-format 16` :ref:`¶ <BreakAfterAttributes>`; Break after a group of C++11 attributes before variable or function; (including constructor/destructor) declaration/definition names or before; control statements, i.e. ``if``, ``switch`` (including ``case`` and; ``default`` labels), ``for``, and ``while`` statements. Possible values:. * ``ABS_Always`` (in configuration: ``Always``); Always break after attributes. .. code-block:: c++. [[maybe_unused]]; const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]]; inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]]; if (a); f();; else; g();. switch (b) {; [[unlikely]]; case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Leave`` (in configuration: ``Leave``); Leave the line breaking after attributes as is. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]]; int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]]; int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]]; default:; return;; }. * ``ABS_Never`` (in configuration: ``Never``); Never break after attributes. .. code-block:: c++. [[maybe_unused]] const int i;; [[gnu::const]] [[maybe_unused]] int j;. [[nodiscard]] inline int f();; [[gnu::const]] [[nodiscard]] int g();. [[likely]] if (a); f();; else; g();. switch (b) {; [[unlikely]] case 1:; ++b;; break;; [[likely]] default:; return;; }. .. _BreakAfterJavaFieldAnnotations:. **BreakAfterJavaFieldAnnotations** (``Boolean``) :versionbadge:`clang-format 3.8` :ref:`¶ <BreakAfterJavaFieldAnnotations>`; Break after each annotation on a field in Java files. .. code-block:: java. true: false:; @Partial vs. @Partial @Mock DataLoad loader;; @Mock; Dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:44526,config,configuration,44526,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"ith C++ Modules which is important but; unfair comparison. As we noted earlier, PCH is very efficient, it cannot be; extended to the experiments’ software stacks because of its design constraints.; On the contrary, the C++ Modules can be used in third-party code where the PCH; is not available. The comparisons are to give a good metric when we are ready to switch ROOT to use; C++ Modules by default. However, since it is essentially the same technology,; optimizations of C++ Modules also affect the PCH. We have a few tricks up in; the sleeves to but they come with given trade-offs. #### Preloading of C++ Modules. The main focus for the technology preview was not in performance until recently.; We have invested some resources in optimizations and we would like to show you; (probably outdated) performance results:. * Memory footprint -- mostly due to importing all C++ Modules at startup; we see overhead which depends on the number of preloaded modules. For; ROOT it is between 40-60 MB depending on the concrete configuration.; When the workload increases we notice that the overall memory performance; decreases in number of cases.; * Execution times -- likewise we have an execution overhead. For ; workflows which take ms the slowdown can be 2x. Increasing of the work; to seconds shows 50-60% slowdowns. The performance is dependent on many factors such as configuration of ROOT and; workflow. You can read more at our Intel IPCC-ROOT Showcase presentation; here (pp 25-33)[[8]]. #### Loading C++ Modules on Demand. In long term, we should optimize the preloading of modules to be a no-op and; avoid recursive behavior based on identifier lookup callbacks. Unfortunately,; at the moment the loading of C++ modules on demand shows significantly better; performance results. You can visit our continuous performance monitoring tool where we compare; the performance of ROOT against ROOT with a PCH [[9]].; *Note: if you get error 400, clean your cache or open a private browser session.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md:18375,config,configuration,18375,README/README.CXXMODULES.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/README.CXXMODULES.md,1,['config'],['configuration']
Modifiability,"ith RNTuple I/O support.; The child fields are named `_0` and `_1`. #### std::tuple<T1, T2, ..., Tn>. A tuple is stored using an empty parent field with $n$ subfields of type `T1`, `T2`, ..., `Tn`.; All types must have RNTuple I/O support.; The child fields are named `_0`, `_1`, ... #### std::bitset\<N\>. A bitset is stored as a repetitive leaf field with an attached `Bit` column.; The bitset size `N` is stored as repetition parameter in the field meta-data.; Within the repetition blocks, bits are stored in little-endian order, i.e. the least significant bits come first. #### std::unique_ptr\<T\>, std::optional\<T\>. A unique pointer and an optional type have the same on disk representation.; They are represented as a collection of `T`s of zero or one elements.; The collection parent field has a principal column of type `(Split)Index[64|32]`.; It has a single subfield named `_0` for `T`, where `T` must have RNTuple I/O support.; Note that RNTuple does not support polymorphism, so the type `T` is expected to be `T` and not a child class of `T`. #### std::set\<T\>, std::unordered_set\<T\>, std::multiset\<T\>, std::unordered_multiset\<T\>. While STL (unordered) (multi)sets by definition are associative containers; (i.e., elements are referenced by their keys, which in the case for sets are equal to the values),; on disk they are represented as sequential collections.; This means that they have the same on-disk representation as `std::vector<T>`, using two fields:; - Collection parent field whose principal column is of type `(Split)Index[64|32]`.; - Child field of type `T`, which must be a type with RNTuple I/O support.; The name of the child field is `_0`. #### std::map\<K, V\>, std::unordered_map\<K, V\>, std::multimap\<K, V\>, std::unordered_multimap\<K, V\>. An (unordered) (multi)map is stored using a collection parent field,; whose principal column is of type `(Split)Index[64|32]` and a child field of type `std::pair<K, V>` named `_0`. ### std::atomic\<T\>. Atomic ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:43014,polymorphi,polymorphism,43014,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['polymorphi'],['polymorphism']
Modifiability,"ith it. We; open the file with the intent to update it, and list its contents. ``` {.cpp}; root[] TFile f (""hsimple.root"",""UPDATE""); root[] f.ls(); TFile** hsimple.root; TFile* hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. It shows the two lines starting with **`TFile`** followed by four lines; starting with the word ""`KEY`"". The four keys tell us that there are; four objects on disk in this file. The syntax of the listing is:. ``` {.cpp}; KEY: <class> <variable>;<cycle number> <title>; ```. For example, the first line in the list means there is an object in the; file on disk, called `hpx`. It is of the class **`TH1F`**; (one-dimensional histogram of floating numbers). The object's title is; ""This is the `px` distribution"". If the line starts with `OBJ`, the; object is in memory. The \<class\> is the name of the ROOT class; (T-something). The \<variable\> is the name of the object. The cycle; number along with the variable name uniquely identifies the object. The; \<title\> is the string given in the constructor of the object as title. ![The structure of TFile](pictures/030000E8.png). The figure shows a **`TFile`** with five objects in the top directory; `(kObjA;1, kObjA;2, kObjB;1, kObjC;1` and `kObjD;1)`. `ObjA` is on file; twice with two different cycle numbers. It also shows four objects in; memory (`mObjE`, `mObjeF`, `mObjM`, `mObjL`). It also shows several; subdirectories. ### The Current Directory. When you create a **`TFile`** object, it becomes the current directory.; Therefore, the last file to be opened is always the current directory.; To check your current directory you can type:. ``` {.cpp}; root[] gDirectory->pwd(); Rint:/; ```. This means that the current directory is the ROOT session (`Rint`). When; you create a file, and repeat the command the file becomes the current; directory. ``` {.cpp}; root[] TFile f1(""AFile1.root"");",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:21610,variab,variable,21610,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['variab'],['variable']
Modifiability,"ith the content for a; specific row. By doing so, the logic for reading the n-tuple and the; code to process it can be split and the source code remains clear. ### Storing Arbitrary N-tuples ###. It is also possible to write n-tuples of arbitrary type by using ROOT's; `TBranch` class. This is especially important as `TNtuple::Fill()`; accepts only floats. The following macro creates the same n-tuple as; before but the branches are booked directly. The `Fill()` function then; fills the current values of the connected variables to the tree. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_ntuple_to_file_advanced.C; ```. The `Branch()` function requires a pointer to a variable and a; definition of the variable type. The following table lists some of the possible; values.; Please note that ROOT is not checking the input and mistakes are likely; to result in serious problems. This holds especially if values are read; as another type than they have been written, e.g. when storing a; variable as float and reading it as double. List of variable types that can be used to define the type of a branch in ROOT:. type size C++ identifier; ------------------ -------- --------------- ------------; signed integer 32 bit int I; 64 bit long L; unsigned integer 32 bit unsigned int i; 64 bit unsigned long l; floating point 32 bit float F; 64 bit double D; boolean - bool O. ### Processing N-tuples Spanning over Several Files ###. Usually n-tuples or trees span over many files and it would be difficult; to add them manually. ROOT thus kindly provides a helper class in the; form of `TChain`. Its usage is shown in the following macro which is; very similar to the previous example. The constructor of a `TChain`; takes the name of the `TTree` (or `TNuple`) as an argument. The files; are added with the function `Add(fileName)`, where one can also use; wild-cards as shown in the example. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_ntuple_with_chain.C; ```. ### *For the advanced user:* Processing tree",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:5324,variab,variable,5324,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['variab'],['variable']
Modifiability,"ith; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78492,variab,variables,78492,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"ithIntArgument[10])(int);. Variadic ``...`` arguments are supported. [variadic.c] A Block that; takes no arguments must specify void in the argument list [voidarg.c].; An empty parameter list does not represent, as K&R provide, an; unspecified argument list. Note: both gcc and clang support K&R style; as a convenience. A Block reference may be cast to a pointer of arbitrary type and vice; versa. [cast.c] A Block reference may not be dereferenced via the; pointer dereference operator ``*``, and thus a Block's size may not be; computed at compile time. [sizeof.c]. Block Literal Expressions; =========================. A :block-term:`Block literal expression` produces a reference to a; Block. It is introduced by the use of the ``^`` token as a unary; operator. .. code-block:: c. Block_literal_expression ::= ^ block_decl compound_statement_body; block_decl ::=; block_decl ::= parameter_list; block_decl ::= type_expression. where type expression is extended to allow ``^`` as a Block reference; (pointer) where ``*`` is allowed as a function reference (pointer). The following Block literal:. .. code-block:: c. ^ void (void) { printf(""hello world\n""); }. produces a reference to a Block with no arguments with no return value. The return type is optional and is inferred from the return; statements. If the return statements return a value, they all must; return a value of the same type. If there is no value returned the; inferred type of the Block is void; otherwise it is the type of the; return statement value. If the return type is omitted and the argument list is ``( void )``,; the ``( void )`` argument list may also be omitted. So:. .. code-block:: c. ^ ( void ) { printf(""hello world\n""); }. and:. .. code-block:: c. ^ { printf(""hello world\n""); }. are exactly equivalent constructs for the same expression. The type_expression extends C expression parsing to accommodate Block; reference declarations as it accommodates function pointer; declarations. Given:. .. code-block:: c. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:2703,extend,extended,2703,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['extend'],['extended']
Modifiability,"ithm, hsv modulo color component [15]. int bar_thickness; // applies only for bar display mode; int bar_empty_flag; // (empty bars, full bars) applies only for bar display mode; int border_color; // color of background of the picture; int full_border; // decides whether background is painted; int raster_en_dis; // decides whether the axes and rasters are shown; int raster_long; // decides whether the rasters are drawn as long lines; int raster_color; // color of the rasters; char *raster_description_x; // x axis description; char *raster_description_y; // y axis description. int pen_color; // color of spectrum; int pen_dash; // style of pen; int pen_width; // width of line. int chanmark_style; // style of channel marks; int chanmark_width; // width of channel marks; int chanmark_height; // height of channel marks; int chanmark_en_dis; // decides whether the channel marks are shown; int chanmark_color; // color of channel marks. // auxiliary variables, transform coefficients, for internal use only; double mx;; double my;; double px;; double py;. // auxiliary internal variables, working place; double gbezx,gbezy;; TPoint bz[4];; };; ```. The examples using different display parameters are shown in the next; few Figures. ![Display mode -polyline, width of pen=3](figures/image214.png). ![Display mode- bars, shown channel marks](figures/image216.png). ![Display mode- steps, log scale, shown channel marks](figures/image218.png). ![Display mode -Bezier curve interpolation, shown channel marks](figures/image220.png). ![Display mode- rainbow bars, color algorithm (model) RGB, number of color levels=1024, pen width=3](figures/image222.png). ![Display mode-empty bars, color algorithm YIQ, number of color levels 2048](figures/image224.png). ## 2-DIMENSIONAL SPECTRA. The 2-dimensional visualization function displays spectrum; (or its part) on the Canvas of a form. Before calling the function, one; has to fill in the `two_dim_pic` structure containing all parameters of the; displa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md:73914,variab,variables,73914,documentation/spectrum/Spectrum.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/spectrum/Spectrum.md,1,['variab'],['variables']
Modifiability,"itional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/lib; clang++ -fPIC -std=c++17 -msse4.2 -O2 -pthread -shared \; -I scudo/standalone/include \; scudo/standalone/*.cpp \; -o $HOME/libscudo.so. and then use it with existing binaries as follows:. .. code:: console. LD_PRELOAD=$HOME/libscudo.so ./a.out. Clang; -----; With a recent version of Clang (post rL317337), the ""old"" version of the; allocator can be linked with a binary at compilation using the; ``-fsanitize=scudo`` command-line argument, if the target platform is supported.; Currently, the only other sanitizer Scudo is compatible with is UBSan; (eg: ``-fsanitize=scudo,undefined``). Compiling with Scudo will also enforce; PIE for the output binary. We will transition this to the standalone Scudo version in the future. Options; -------; Several aspects of the allocator can be configured on a per process basis; through the following ways:. - at compile time, by defining ``SCUDO_DEFAULT_OPTIONS`` to the options string; you want set by default;. - by defining a ``__scudo_default_options`` function in one's program that; returns the options string to be parsed. Said function must have the following; prototype: ``extern ""C"" const char* __scudo_default_options(void)``, with a; default visibility. This will override the compile time define;. - through the environment variable SCUDO_OPTIONS, containing the options string; to be parsed. Options defined this way will override any definition made; through ``__scudo_default_options``. - via the standard ``mallopt`` `API <https://man7.org/linux/man-pages/man3/mallopt.3.html>`_,; using parameters that are Scudo specific. When dealing with the options string, it follows a syntax similar to ASan, where; distinct options can be assigned in the same string, separated by colons. For example, using the environment variable:. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:7094,config,configured,7094,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['config'],['configured']
Modifiability,"itle positioning to native ROOT behavior; 8. Add interactivity (moving, context menu) for TLine, TBox, TText, TLatex, TDiamond, TGaxis, TASImage; 9. Use new gStyle attributes for candle and violin plots; 10. Implement autoplace for TLegend, also via context menu; 11. Change algorithm of building smooth (bezier) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13346,config,configure,13346,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"itle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73390,config,configuration-example,73390,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['config'],['configuration-example']
Modifiability,"ity = ROOT::Experimental::RLogScopedVerbosity(ROOT::Detail::RDF::RDFLogChannel(), ROOT::Experimental::ELogLevel.kInfo);`.; - With [ROOT-10023](https://sft.its.cern.ch/jira/browse/ROOT-10023) fixed, `RDataFrame` can now read and write certain branches containing unsplit objects, i.e. `TBranchObjects`. More information is available at [ROOT-10022](https://sft.its.cern.ch/jira/browse/ROOT-10022).; - CSV files can now be opened and processed from remote HTTP(S) locations; - `RDataFrame` results produced by the same action in different computation graphs can now be merged thanks to the new interface provided by `ROOT::Detail::RDF::RMergeableValue`, introduced in [#5552](https://github.com/root-project/root/pull/5552). A feature originally requested with [ROOT-9869](https://sft.its.cern.ch/jira/browse/ROOT-9869), it helps streamline `RDataFrame` workflows in a distributed environment. Currently only a subset of `RDataFrame` actions have their corresponding mergeable class, but in the future it will be possible to extend it to any action through the creation of a new `RMergeableValue` derived class. ### Behavior changes. - `Snapshot` now respects the basket size and split level of the original branch when copying branches to a new `TTree`.; - `Snapshot` now writes branches coming from friend `TTree`s even if they have the same name as branches in the main tree (`friendname_` is prepended to the name of the output branches). More details at [#7181](https://github.com/root-project/root/issues/7181).; - Just-in-time compilation of string expressions passed to `Filter` and `Define` now generates functions that take fundamental types by const value (rather than by non-const reference as before). This will break code that was assigning to column values in string expressions: this is an intended side effect as we want to prevent non-expert users from performing assignments (`=`) rather than comparisons (`==`). Expert users can resort to compiled callables if they absolutely have ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:7602,extend,extend,7602,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['extend'],['extend']
Modifiability,"ity refer to the; same object if they are in the same shared object. Usually, hidden; visibility indicates that the symbol will not be placed into the; dynamic symbol table, so no other module (executable or shared; library) can reference it directly.; ""``protected``"" - Protected style; On ELF, protected visibility indicates that the symbol will be; placed in the dynamic symbol table, but that references within the; defining module will bind to the local symbol. That is, the symbol; cannot be overridden by another module. A symbol with ``internal`` or ``private`` linkage must have ``default``; visibility. .. _dllstorageclass:. DLL Storage Classes; -------------------. All Global Variables, Functions and Aliases can have one of the following; DLL storage class:. ``dllimport``; ""``dllimport``"" causes the compiler to reference a function or variable via; a global pointer to a pointer that is set up by the DLL exporting the; symbol. On Microsoft Windows targets, the pointer name is formed by; combining ``__imp_`` and the function or variable name.; ``dllexport``; On Microsoft Windows targets, ""``dllexport``"" causes the compiler to provide; a global pointer to a pointer in a DLL, so that it can be referenced with the; ``dllimport`` attribute. the pointer name is formed by combining ``__imp_``; and the function or variable name. On XCOFF targets, ``dllexport`` indicates; that the symbol will be made visible to other modules using ""exported""; visibility and thus placed by the linker in the loader section symbol table.; Since this storage class exists for defining a dll interface, the compiler,; assembler and linker know it is externally referenced and must refrain from; deleting the symbol. A symbol with ``internal`` or ``private`` linkage cannot have a DLL storage; class. .. _tls_model:. Thread Local Storage Models; ---------------------------. A variable may be defined as ``thread_local``, which means that it will; not be shared by threads (each thread will have a separat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:24797,variab,variable,24797,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"ivating example that shows how we could use these:. ::. # Define ':' for sequencing: as a low-precedence operator that ignores operands; # and just returns the RHS.; def binary : 1 (x y) y;. # Recursive fib, we could do this before.; def fib(x); if (x < 3) then; 1; else; fib(x-1)+fib(x-2);. # Iterative fib.; def fibi(x); var a = 1, b = 1, c in; (for i = 3, i < x in; c = a + b :; a = b :; b = c) :; b;. # Call it.; fibi(10);. In order to mutate variables, we have to change our existing variables; to use the ""alloca trick"". Once we have that, we'll add our new; operator, then extend Kaleidoscope to support new variable definitions. Adjusting Existing Variables for Mutation; =========================================. The symbol table in Kaleidoscope is managed at code generation time by; the '``NamedValues``' map. This map currently keeps track of the LLVM; ""Value\*"" that holds the double value for the named variable. In order; to support mutation, we need to change this slightly, so that; ``NamedValues`` holds the *memory location* of the variable in question.; Note that this change is a refactoring: it changes the structure of the; code, but does not (by itself) change the behavior of the compiler. All; of these changes are isolated in the Kaleidoscope code generator. At this point in Kaleidoscope's development, it only supports variables; for two things: incoming arguments to functions and the induction; variable of 'for' loops. For consistency, we'll allow mutation of these; variables in addition to other user-defined variables. This means that; these will both need memory locations. To start our transformation of Kaleidoscope, we'll change the; ``NamedValues`` map so that it maps to AllocaInst\* instead of Value\*. Once; we do this, the C++ compiler will tell us what parts of the code we need; to update:. .. code-block:: c++. static std::map<std::string, AllocaInst*> NamedValues;. Also, since we will need to create these allocas, we'll use a helper; function that e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:11893,variab,variable,11893,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['variab'],['variable']
Modifiability,"ivative(double x) const; {; return -cos(x);; }. };; ```. ### Multi-dimensional Function Interfaces. The most generic case of a multidimensional function has similar approach. Some examples will be shown next. It is important to notice, that one dimensional functions can be also implemented through; the interfaces that will be presented here. Nevertheless, the user needs to implement those following the indications of the previous chapter, for algorithm working exclusivly on one-dimensional; functions. For algorithms working on both one-dimensional and multi-dimensional functions they should instead use this interface. * `ROOT::Math::IBaseFunctionMultiDim`: This interface provides the `double operator() (const double*)` that takes an array of doubles with all the values for the different dimensions. In this case,; the user has to provide the functionality for two different functions: `double DoEval(const double*)` and `unsigned int NDim()`. The first ones evaluates the function given the array that represents; the multiple variables. The second returns the number of dimensions of the function. Example of implementing a basic multi-dimensional function:. ```{.cpp}; #include ""Math/IFunction.h"". class MyFunction: public ROOT::Math::IBaseFunctionMultiDim; {; public:; double DoEval(const double* x) const; {; return x[0] + sin(x[1]);; }. unsigned int NDim() const; {; return 2;; }. ROOT::Math::IBaseFunctionMultiDim* Clone() const; {; return new MyFunction();; }. };; ```. * `ROOT::Math::IGradientFunctionMultiDim`: This interface offers the same functionality as the base function plus the calculation of the derivative.; It only adds the `double Derivative(double* x, uint ivar)` method for the user to implement. This method must implement the derivative of the function with respect to the variable indicated with the; second parameter. Example of implementing a multi-dimensional gradient function. ```{.cpp}; #include ""Math/IFunction.h"". class MyGradientFunction: public ROOT::Mat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:38156,variab,variables,38156,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['variab'],['variables']
Modifiability,"ive run-loop (with a JIT!), and emitted debug information in; standalone executables - all in under 1000 lines of (non-comment/non-blank); code. Our little language supports a couple of interesting features: it; supports user defined binary and unary operators, it uses JIT; compilation for immediate evaluation, and it supports a few control flow; constructs with SSA construction. Part of the idea of this tutorial was to show you how easy and fun it; can be to define, build, and play with languages. Building a compiler; need not be a scary or mystical process! Now that you've seen some of; the basics, I strongly encourage you to take the code and hack on it.; For example, try adding:. - **global variables** - While global variables have questionable value; in modern software engineering, they are often useful when putting; together quick little hacks like the Kaleidoscope compiler itself.; Fortunately, our current setup makes it very easy to add global; variables: just have value lookup check to see if an unresolved; variable is in the global variable symbol table before rejecting it.; To create a new global variable, make an instance of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:1621,variab,variables,1621,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,3,['variab'],"['variable', 'variables']"
Modifiability,"ive-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140310,variab,variables,140310,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['variab'],['variables']
Modifiability,"iver. ``%clang_cpp``; Invokes the Clang driver for C++. ``%clang_cl``; Invokes the CL-compatible Clang driver. ``%clangxx``; Invokes the G++-compatible Clang driver. ``%clang_cc1``; Invokes the Clang frontend. ``%itanium_abi_triple``, ``%ms_abi_triple``; These substitutions can be used to get the current target triple adjusted to; the desired ABI. For example, if the test suite is running with the; ``i686-pc-win32`` target, ``%itanium_abi_triple`` will expand to; ``i686-pc-mingw32``. This allows a test to run with a specific ABI without; constraining it to a specific triple. **FileCheck-specific substitutions:**. ``%ProtectFileCheckOutput``; This should precede a ``FileCheck`` call if and only if the call's textual; output affects test results. It's usually easy to tell: just look for; redirection or piping of the ``FileCheck`` call's stdout or stderr. .. _Test-specific substitutions:. **Test-specific substitutions:**. Additional substitutions can be defined as follows:. - Lit configuration files (e.g., ``lit.cfg`` or ``lit.local.cfg``) can define; substitutions for all tests in a test directory. They do so by extending the; substitution list, ``config.substitutions``. Each item in the list is a tuple; consisting of a pattern and its replacement, which lit applies using python's; ``re.sub`` function.; - To define substitutions within a single test file, lit supports the; ``DEFINE:`` and ``REDEFINE:`` directives, described in detail below. So that; they have no effect on other test files, these directives modify a copy of the; substitution list that is produced by lit configuration files. For example, the following directives can be inserted into a test file to define; ``%{cflags}`` and ``%{fcflags}`` substitutions with empty initial values, which; serve as the parameters of another newly defined ``%{check}`` substitution:. .. code-block:: llvm. ; DEFINE: %{cflags} =; ; DEFINE: %{fcflags} =. ; DEFINE: %{check} = \; ; DEFINE: %clang_cc1 -verify -fopenmp -fopenmp-versi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:28640,config,configuration,28640,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['config'],['configuration']
Modifiability,"ization; .. _`gold plugin interface`: http://gcc.gnu.org/wiki/whopr/driver. .. _lto-how-to-build:. How to build it; ===============. You need to have gold with plugin support and build the LLVMgold plugin.; The gold linker is installed as ld.gold. To see whether gold is the default; on your system, run ``/usr/bin/ld -v``. It will report ""GNU; gold"" or else ""GNU ld"" if not. If gold is already installed at; ``/usr/bin/ld.gold``, one option is to simply make that the default by; backing up your existing ``/usr/bin/ld`` and creating a symbolic link; with ``ln -s /usr/bin/ld.gold /usr/bin/ld``. Alternatively, you can build; with clang's ``-fuse-ld=gold`` or add ``-fuse-ld=gold`` to LDFLAGS, which will; cause the clang driver to invoke ``/usr/bin/ld.gold`` directly. If you have gold installed, check for plugin support by running; ``/usr/bin/ld.gold -plugin``. If it complains ""missing argument"" then; you have plugin support. If not, and you get an error such as ""unknown option"",; then you will either need to build gold or install a version with plugin; support. * Download, configure and build gold with plugin support:. .. code-block:: bash. $ git clone --depth 1 git://sourceware.org/git/binutils-gdb.git binutils; $ mkdir build; $ cd build; $ ../binutils/configure --enable-gold --enable-plugins --disable-werror; $ make all-gold. That should leave you with ``build/gold/ld-new`` which supports; the ``-plugin`` option. Running ``make`` will additionally build; ``build/binutils/ar`` and ``nm-new`` binaries supporting plugins. Once you're ready to switch to using gold, backup your existing; ``/usr/bin/ld`` then replace it with ``ld-new``. Alternatively, install; in ``/usr/bin/ld.gold`` and use ``-fuse-ld=gold`` as described earlier. Optionally, add ``--enable-gold=default`` to the above configure invocation; to automatically install the newly built gold as the default linker with; ``make install``. * Build the LLVMgold plugin. Run CMake with; ``-DLLVM_BINUTILS_INCDIR=/path/to/bin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst:2029,plugin,plugin,2029,interpreter/llvm-project/llvm/docs/GoldPlugin.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GoldPlugin.rst,1,['plugin'],['plugin']
Modifiability,"ize how the build will be generated. Options are boolean; variables, with possible values ON/OFF. Options and variables are defined on the; CMake command line like this:. .. code-block:: console. $ cmake -DVARIABLE=value path/to/llvm/source. You can set a variable after the initial CMake invocation to change its; value. You can also undefine a variable:. .. code-block:: console. $ cmake -UVARIABLE path/to/llvm/source. Variables are stored in the CMake cache. This is a file named ``CMakeCache.txt``; stored at the root of your build directory that is generated by ``cmake``.; Editing it yourself is not recommended. Variables are listed in the CMake cache and later in this document with; the variable name and type separated by a colon. You can also specify the; variable and type on the CMake command line:. .. code-block:: console. $ cmake -DVARIABLE:TYPE=value path/to/llvm/source. Frequently-used CMake variables; -------------------------------. Here are some of the CMake variables that are used often, along with a; brief explanation. For full documentation, consult the CMake manual,; or execute ``cmake --help-variable VARIABLE_NAME``. See `Frequently; Used LLVM-related Variables`_ below for information about commonly; used variables that control features of LLVM and enabled subprojects. .. _cmake_build_type:. **CMAKE_BUILD_TYPE**:STRING; This configures the optimization level for ``make`` or ``ninja`` builds. Possible values:. =========================== ============= ========== ========== ==========================; Build Type Optimizations Debug Info Assertions Best suited for; =========================== ============= ========== ========== ==========================; **Release** For Speed No No Users of LLVM and Clang; **Debug** None Yes Yes Developers of LLVM; **RelWithDebInfo** For Speed Yes No Users that also need Debug; **MinSizeRel** For Size No No When disk space matters; =========================== ============= ========== ========== ==========================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:6620,variab,variables,6620,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"ize of the error matrix of the; parameters, since only variable parameters have errors. An important feature of M is that parameters are allowed to change types; during the M minimization and analysis of a $\mbox{FCN}$ function.; Several applications in M have methods available to make variable; parameters fixed and vice-versa; to impose, change, or remove limits; from variable parameters; and even to define completely new parameters; at any time during a run. In addition, some M applications (notably the; $\mbox{MINOS}$ error analysis) cause one or more variable parameters; to be temporarily fixed during the calculation. Therefore, the; correspondence between external and internal parameter lists is in; general a dynamic one, and the number of internal parameters is not; necessarily constant. For more details about parameter interaction see [api:parameters]. ### The transformation for parameters with limits ###. [intro:limits]. For variable parameters with double sided limits $a$ (lower) and $b$; (upper), M uses the following transformation:. $$\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}$$. so that the internal value $P_{\mathrm{int}}$ can take on any value,; while the external value $P_{\mathrm{ext}}$ can take on values only; between the lower limit $a$ and the upper limit $b$. Since the; transformation is necessarily non-linear, it would transform a nice; linear problem into a nasty non-linear one, which is the reason why; limits should be avoided if not necessary. In addition, the; transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced; in the numerical calculation of the $\mbox{FCN}$ value. The effects; of non-linearity and numerical roundoff bo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:8164,variab,variable,8164,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['variab'],['variable']
Modifiability,"izer may not be able to vectorize math library functions; that correspond to these intrinsics if the library calls access external state; such as ""errno"". To allow better optimization of C/C++ math library functions,; use ""-fno-math-errno"". The loop vectorizer knows about special instructions on the target and will; vectorize a loop containing a function call that maps to the instructions. For; example, the loop below will be vectorized on Intel x86 if the SSE4.1 roundps; instruction is available. .. code-block:: c++. void foo(float *f) {; for (int i = 0; i != 1024; ++i); f[i] = floorf(f[i]);; }. Partial unrolling during vectorization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Modern processors feature multiple execution units, and only programs that contain a; high degree of parallelism can fully utilize the entire width of the machine.; The Loop Vectorizer increases the instruction level parallelism (ILP) by; performing partial-unrolling of loops. In the example below the entire array is accumulated into the variable 'sum'.; This is inefficient because only a single execution port can be used by the processor.; By unrolling the code the Loop Vectorizer allows two or more execution ports; to be used simultaneously. .. code-block:: c++. int foo(int *A, int n) {; unsigned sum = 0;; for (int i = 0; i < n; ++i); sum += A[i];; return sum;; }. The Loop Vectorizer uses a cost model to decide when it is profitable to unroll loops.; The decision to unroll the loop depends on the register pressure and the generated code size. Epilogue Vectorization; ^^^^^^^^^^^^^^^^^^^^^^. When vectorizing a loop, often a scalar remainder (epilogue) loop is necessary; to execute tail iterations of the loop if the loop trip count is unknown or it; does not evenly divide the vectorization and unroll factors. When the; vectorization and unroll factors are large, it's possible for loops with smaller; trip counts to end up spending most of their time in the scalar (rather than; the vector) code. In",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst:10693,variab,variable,10693,interpreter/llvm-project/llvm/docs/Vectorizers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Vectorizers.rst,1,['variab'],['variable']
Modifiability,"izing Tracks. In case the modeller is interfaced with a tracking engine, one might; consider quite useful being able to store and visualize at least a part; of the tracks in the context of the geometry. The base class; **`TVirtualGeoTrack`** provides this functionality. It currently has one; implementation inside the drawing package (**`TGeoTrack`** class). A; track can be defined like:. ``` {.cpp}; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; ```. Where: `id` is user-defined id of the track, `pdg` - `pdg` code,; `parent` - a pointer to parent track, `particle` - a pointer to an; arbitrary particle object (may be a **`TParticle`**). A track has a list of daughters that have to be filled using the; following method:. ``` {.cpp}; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; ```. The method above is pure virtual and have to create a track daughter; object. Tracks are fully customizable objects when inheriting from; **`TVirtualGeoTrack`** class. We will describe the structure and; functionality provided by the default implementation of these, which are; **`TGeoTrack`** objects. A **`TGeoTrack`** is storing a list of `control points` `(x,y,z)`; belonging to the track, having also time information `(t)`. The painting; algorithm of such tracks allows drawing them in any time interval after; their creation. The track position at a given time is computed by; interpolation between control points. ``` {.cpp}; myTrack->AddPoint(x,y,z,t);; ```. The creation and management of tracks is in fact fully controlled by the; **`TGeoManager`** class. This holds a list of `primary tracks` that is; also visible during browsing as `Tracks` folder. Primary tracks are; tracks having no parent in the tracking history (for instance the output; of particle generators may be considered as primaries from tracking; point of view). The manager class holds; in**` TGeoManager::fCurrentTrack` a pointer to the curr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:125261,inherit,inheriting,125261,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['inherit'],['inheriting']
Modifiability,"ject()` method. ``` {.cpp}; root[] T->Project(""quietHisto"",""fNtrack""); ```. #### Making a Profile Histogram; \index{histogram!profile}. In case of a two dimensional expression, you can generate a; **`TProfile`** histogram instead of a two dimensional histogram by; specifying the `'prof'` or '`profs'` option. The `prof` option is; automatically selected when the output is redirected into a; **`TProfile`**. For example `y:x>>pf` where `pf `is an existing; **`TProfile`** histogram. #### Tree Information. Once we have drawn a tree, we can get information about the tree. These; are the methods used to get information from a drawn tree **`TTree`**:. - `GetSelectedRows`: Returns the number of entries accepted by the; selection expression. In case where no selection was specified, it; returns the number of entries processed. - `GetV1`: Returns a pointer to the float array of the first variable. - `GetV2`: Returns a pointer to the float array of second variable. - `GetV3`: Returns a pointer to the float array of third variable. - `GetW`: Returns a pointer to the float array of Weights where the; weight equals the result of the selection expression. To read the drawn values of `fNtrack` into an array, and loop through; the entries follow the lines below. First, open the file and draw the; `fNtrack` variable:. ``` {.cpp}; root[] TFile *f = new TFile(""Event.root""); root[] T->Draw(""fNtrack""); ```. Then declare a pointer to a float and use the GetV1 method to retrieve; the first dimension of the tree. In this example we only drew one; dimension (`fNtrack`) if we had drawn two, we could use GetV2 to get the; second one. ``` {.cpp}; root[] Float_t *a; root[] a = T->GetV1(); ```. Loop through the first 10 entries and print the values of `fNtrack`:. ``` {.cpp}; root[] for (int i = 0; i < 10; i++); root[] cout << a[i] << "" "" << endl // need an endl to see the values; 594 597 606 595 604 610 604 602 603 596; ```. By default, `TTree::Draw` creates these arrays with `fEstimate` words; whe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:119100,variab,variable,119100,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['variab'],['variable']
Modifiability,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55224,variab,variables,55224,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"jects and are the; second case where that requires copy and dispose helper functions to be; generated. The copy helper functions generated by the compiler should use the; ``_Block_object_assign`` runtime helper function and in the dispose helper the; ``_Block_object_dispose`` runtime helper function should be called. For example, ``Block`` foo in the following:. .. code-block:: c. struct Opaque *__attribute__((NSObject)) objectPointer = ...;; ...; void (^foo)(void) = ^{ CFPrint(objectPointer); };. would have the following helper functions generated:. .. code-block:: c. void __block_copy_foo(struct __block_literal_5 *dst, struct __block_literal_5 *src) {; _Block_object_assign(&dst->objectPointer, src-> objectPointer, BLOCK_FIELD_IS_OBJECT);; }. void __block_dispose_foo(struct __block_literal_5 *src) {; _Block_object_dispose(src->objectPointer, BLOCK_FIELD_IS_OBJECT);; }. Imported ``__block`` marked variables; -------------------------------------. Layout of ``__block`` marked variables; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The compiler must embed variables that are marked ``__block`` in a specialized; structure of the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct Block_byref *forwarding;; int flags; //refcount;; int size;; typeof(marked_variable) marked_variable;; };. Variables of certain types require helper functions for when ``Block_copy()``; and ``Block_release()`` are performed upon a referencing ``Block``. At the ""C""; level only variables that are of type ``Block`` or ones that have; ``__attribute__((NSObject))`` marked require helper functions. In Objective-C; objects require helper functions and in C++ stack based objects require helper; functions. Variables that require helper functions use the form:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:11445,variab,variables,11445,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"jects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;; d->plotOn(framex) ;; w::model.plotOn(framex) ;. // Construct likelihood, profile likelihood in a, and draw the latter; RooAbsReal* nll = w::model.createNLL(*d,NumCPU(2)) ;; RooAbsReal* pll = nll->createProfile(w::a) ;; RooPlot* framea = w::a.frame(Title(""Profile likelihood in parameter a"")) ;; pll->plotOn(framea) ;. // Construct 2D cumulative distribution function from p.d.f.; RooAbsReal* cdfxy = w::model.createCdf(RooArgSet(w::x,w::y),ScanNoCdf()) ;; TH2* hhcdf = cdfxy->createHistogram(""x,y"",40,40) ;; hhcdf->SetLineColor(kRed) ;. TCanvas* c = new TCanvas(""c"",""c"",650,650) ; c->Divide(2,2) ;; c->cd(1) ; hh->Draw(""surf"") ; c->cd(2) ; framex->Draw() ;; c->cd(3) ; f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22699,adapt,adaptive,22699,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,1,['adapt'],['adaptive']
Modifiability,"js to calculate rendering order; - comp - show left and right components of TGeoCompositeShape; - compx - show all sub-components of TGeoCompositeShape. In the URL string several global settings can be changed:. - geosegm - grads per segment is cylindrical shapes, default is 6; - geocomp - compress results of composite shape production, default is true. It is possible to display only part of geometry model. For instance, one could select sub-item like:. - [file=rootgeom.root&item=simple1/TOP/REPLICA_1](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1/TOP/REPLICA_1). Or one can use simple selection syntax (work only with first-level volumes):. - [item=simple1&opt=-bar1-bar2](https://root.cern/js/latest/?file=../files/geom/rootgeom.root&item=simple1;1&opt=-bar1-bar2). Syntax uses '+' sign to enable visibility flag of specified volume and '-' sign to disable visibility.; One could use wildcard symbol like '+TUBE1*'. Another way to configure visibility flags is usage of ROOT macros, which typically looks like:. ```cpp; {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; // ...; gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"");; new TBrowser;; }; ```. Example of such macro can be found in root tutorials. From provided macro only following calls will be executed in JSROOT:. * `gGeoManager->DefaultColors()`; * `gGeoManager->GetVolume(""HALL"")->InvisibleAll()`; * `gGeoManager->GetVolume(""HALL"")->SetTransparency(30)`; * `gGeoManager->GetVolume(""HALL"")->SetLineColor(5)`; * `gGeoManager->GetVolume(""ALIC"")->Draw(""ogl"")`. All other will be ignored. Example of major LHC detectors:; * ALICE: [full](https://root.cern/js/latest/?file=https://root.cern/files/alice2.root&item=Geometry;1&opt=macro:https://root.cern/js/files/geomAlice.C); * ATLAS: [",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:23091,config,configure,23091,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['config'],['configure']
Modifiability,"k !1 dso_local i32 @pthread_create(ptr, ptr, ptr, ptr). ...; !2 = !{i64 2, i64 3, i1 false}; !1 = !{!2}. Another example is shown below. The callback callee is the second argument of; the ``__kmpc_fork_call`` function (``i64 2``). The callee is given two unknown; values (each identified by a ``i64 -1``) and afterwards all; variadic arguments that are passed to the ``__kmpc_fork_call`` call (due to the; final ``i1 true``). .. FIXME why does the llvm-sphinx-docs builder give a highlighting; error if the below is set to highlight as 'llvm', despite that we; have misc.highlighting_failure set?. .. code-block:: text. declare !callback !0 dso_local void @__kmpc_fork_call(ptr, i32, ptr, ...). ...; !1 = !{i64 2, i64 -1, i64 -1, i1 true}; !0 = !{!1}. '``exclude``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^. ``exclude`` metadata may be attached to a global variable to signify that its; section should not be included in the final executable or shared library. This; option is only valid for global variables with an explicit section targeting ELF; or COFF. This is done using the ``SHF_EXCLUDE`` flag on ELF targets and the; ``IMAGE_SCN_LNK_REMOVE`` and ``IMAGE_SCN_MEM_DISCARDABLE`` flags for COFF; targets. Additionally, this metadata is only used as a flag, so the associated; node must be empty. The explicit section should not conflict with any other; sections that the user does not want removed after linking. .. code-block:: text. @object = private constant [1 x i8] c""\00"", section "".foo"" !exclude !0. ...; !0 = !{}. '``unpredictable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``unpredictable`` metadata may be attached to any branch or switch; instruction. It can be used to express the unpredictability of control; flow. Similar to the llvm.expect intrinsic, it may be used to alter; optimizations related to compare and branch instructions. The metadata; is treated as a boolean value; if it exists, it signals that the branch; or switch that it is attached to is completely unpredictable. .. _md",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:291572,variab,variables,291572,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variables']
Modifiability,"k the validity of a given geometry is shooting random; points. This can be called with the method; **`TGeoVolume`**`::RandomPoints()` and it draws a volume with the current; visualization settings. Random points are generated in the bounding box; of the drawn volume. The points are drawn with the color of their; deepest container. Only points inside visible nodes are drawn. ![Random rays](pictures/030001E2.png). A ray tracing method can be called `TGeoVolume::RandomRays()`. This; shoots rays from a given point in the local reference frame with random; directions. The intersections with displayed nodes appear as segments; having the color of the touched node. ## The Drawing Package. ![](pictures/030001E3.png)The modeller provides a powerful drawing; package, supporting several different options of visualization. A; library separated from the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method `TGeoManager::GetGeomPainter()`loads the painting library in; memory. This is generally not needed since it is called automatically by; `TGeoVolume::Draw()` as well as by few other methods setting; visualization attributes. ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ``` {.cpp}; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:136679,plug-in,plug-in,136679,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['plug-in'],['plug-in']
Modifiability,"k, nor is there; any streamerinfo for such a member. A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a; pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL); is written. If the declaration line has a comment beginning with ""//->"", this indicates; that the pointer value will never be null, which allows a performance optimization.; Another optimization is that if two or more pointers pointing to the same object are; streamed in the same I/O operation, the object is written only once. The remaining; pointers reference the object through a unique object identifier. This saves space; and avoids the infinite loop that might otherwise arise if the directed graph of object; instance pointer references contains a cycle. If a data member is a pointer to a simple type, the Streamer presumes it is an array,; with the dimension defined in a comment of the form ""//[<length>]"", where length is; either an integer constant or a variable that is an integer data member of the class.; If a variable is used, it must be defined ahead of its use or in a base class. The above describes the function of the StreamerInfo record in decomposing a; self-identifying object if the user uses the streamer generated by ""rootcint"".; There are two reasons why a user may need to write a specialized streamer for a class.; One reason is that it may be necessary to execute some code before or after data is read; or written, for example, to initialize some non-persistent data members after the; persistent data is read. In this case, the custom streamer can use the StreamerInfo record; to decompose a self-identifying object in the exact same manner as the generated; streamer would have done. An example is given (for the Event class) in the Root User's; Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if; the user needs to writ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md:8680,variab,variable,8680,io/doc/TFile/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/README.md,1,['variab'],['variable']
Modifiability,"k:: text. error: no matching function for call to 'operator new'; 13 | new (__builtin_memset) S {};; | ^ ~~~~~~~~~~~~~~~~~~. note: candidate function not viable: no known conversion from '<builtin fn type>' to 'int' for 2nd argument; 5 | void* operator new(__SIZE_TYPE__, int);; | ^. After:. .. code-block:: text. error: builtin functions must be directly called; 13 | new (__builtin_memset) S {};; | ^. - Clang now diagnoses import before module declarations but not in global; module fragment.; (`#67627 <https://github.com/llvm/llvm-project/issues/67627>`_). - Clang now diagnoses include headers with angle in module purviews, which is; not usually intended.; (`#68615 <https://github.com/llvm/llvm-project/issues/68615>`_). - Clang now won't mention invisible namespace when diagnose invisible declarations; inside namespace. The original diagnostic message is confusing.; (`#73893 <https://github.com/llvm/llvm-project/issues/73893>`_). Improvements to Clang's time-trace; ----------------------------------; - Two time-trace scope variables are added. A time trace scope variable of; ``ParseDeclarationOrFunctionDefinition`` with the function's source location; is added to record the time spent parsing the function's declaration or; definition. Another time trace scope variable of ``ParseFunctionDefinition``; is also added to record the name of the defined function. Bug Fixes in This Version; -------------------------; - Fixed an issue where a class template specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:32603,variab,variables,32603,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"k``, including; ``__weak`` ``__block`` variables. C++ Extensions; ==============. Block literal expressions within functions are extended to allow const; use of C++ objects, pointers, or references held in automatic storage. As usual, within the block, references to captured variables become; const-qualified, as if they were references to members of a const; object. Note that this does not change the type of a variable of; reference type. For example, given a class Foo:. .. code-block:: c. Foo foo;; Foo &fooRef = foo;; Foo *fooPtr = &foo;. A Block that referenced these variables would import the variables as; const variations:. .. code-block:: c. const Foo block_foo = foo;; Foo &block_fooRef = fooRef;; Foo *const block_fooPtr = fooPtr;. Captured variables are copied into the Block at the instant of; evaluating the Block literal expression. They are also copied when; calling ``Block_copy()`` on a Block allocated on the stack. In both; cases, they are copied as if the variable were const-qualified, and; it's an error if there's no such constructor. Captured variables in Blocks on the stack are destroyed when control; leaves the compound statement that contains the Block literal; expression. Captured variables in Blocks on the heap are destroyed; when the reference count of the Block drops to zero. Variables declared as residing in ``__block`` storage may be initially; allocated in the heap or may first appear on the stack and be copied; to the heap as a result of a ``Block_copy()`` operation. When copied; from the stack, ``__block`` variables are copied using their normal; qualification (i.e. without adding const). In C++11, ``__block``; variables are copied as x-values if that is possible, then as l-values; if not; if both fail, it's an error. The destructor for any initial; stack-based version is called at the variable's normal end of scope. References to ``this``, as well as references to non-static members of; any enclosing class, are evaluated by capturing ``this",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:11909,variab,variable,11909,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['variab'],['variable']
Modifiability,"kdir PATH_TO_MINIUT2_BUILD; cd PATH_TO_MINUIT2_BUILD; cmake PATH_TO_MINUIT2_SOURCE; cmake --build .; ```. Of course, GUIs, IDEs, etc. that work with [CMake] will work with this package. The standard method of CMake building, with a build directory inside the Minuit2 source directory and using the makefile generator, would look like:. ```bash; cd PATH_TO_MINUIT2_SOURCE; mkdir build; cd build; cmake ..; make; ```. The standard [CMake] variables, such as `CMAKE_BUILD_TYPE` and `CMAKE_INSTALL_PREFIX`, work with Minuit2. There are two other options:. * `minuit2_mpi` activates the (outdated C++) MPI bindings.; * `minuit2_omp` activates OpenMP (make sure all FCNs are threadsafe). ## Testing. You can run `ctest` or `make test` to run the Minuit2 test suite. ## Installing or using in another package. You can install the package using `cmake --build --target install .` (or `make install` if directly using the make system), or you can use it from the build directory. You can also include it in another CMake project using `add_subdirectory()` and linking to the `Minuit2` target. Since this package also exports targets, `find_package(Minuit2)` will also work once this package is built or installed. (For the curious, CMake adds a config script to `~/.cmake/packages` when building or; `$CMAKE_INSTALL_PREFIX/share/cmake/Modules` when installing a package that has export commands.). To repeat; using this in your own CMake project usually amounts to:. ```cmake; find_package(Minuit2); # OR; add_subdirectory(Minuit2). target_link_libraries(MyExeOrLib PUBLIC Minuit2::Minuit2); ```. You do not need to add include directories or anything else for Minuit2; the CMake target system handles all of this for you. ## Packaging. To build a binary package (add other generators with `-G`):; ```bash; make package; ```. [DEVELOP.md]: ./DEVELOP.md; [ROOT]: https://root.cern; [minuitdoc]: https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#minuit2-package; [CMake]: https://cmake.org; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md:1885,config,config,1885,math/minuit2/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/README.md,1,['config'],['config']
Modifiability,"kePrimer` page. It has a basic overview of the CMake language. .. _Quick start:. Quick start; ===========. We use here the command-line, non-interactive CMake interface. #. `Download <http://www.cmake.org/cmake/resources/software.html>`_ and install; CMake. Version 3.20.0 is the minimum required. #. Open a shell. Your development tools must be reachable from this shell; through the PATH environment variable. #. Create a build directory. Building LLVM in the source; directory is not supported. cd to this directory:. .. code-block:: console. $ mkdir mybuilddir; $ cd mybuilddir. #. Execute this command in the shell replacing `path/to/llvm/source/root` with; the path to the root of your LLVM source tree:. .. code-block:: console. $ cmake path/to/llvm/source/root. CMake will detect your development environment, perform a series of tests, and; generate the files required for building LLVM. CMake will use default values; for all build parameters. See the `Options and variables`_ section for; a list of build parameters that you can modify. This can fail if CMake can't detect your toolset, or if it thinks that the; environment is not sane enough. In this case, make sure that the toolset that; you intend to use is the only one reachable from the shell, and that the shell; itself is the correct one for your development environment. CMake will refuse; to build MinGW makefiles if you have a POSIX shell reachable through the PATH; environment variable, for instance. You can force CMake to use a given build; tool; for instructions, see the `Usage`_ section, below. You may; also wish to control which targets LLVM enables, or which LLVM; components are built; see the `Frequently Used LLVM-related; variables`_ below. #. After CMake has finished running, proceed to use IDE project files, or start; the build from the build directory:. .. code-block:: console. $ cmake --build . The ``--build`` option tells ``cmake`` to invoke the underlying build; tool (``make``, ``ninja``, ``xcodebuild",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:2072,variab,variables,2072,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['variab'],['variables']
Modifiability,"keRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8048,rewrite,rewrite,8048,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['rewrite'],['rewrite']
Modifiability,"keep(struct _block_byref_blockStorageFoo *dst, struct _block_byref_blockStorageFoo *src) {; FOO_ctor(&dst->blockStorageFoo, &src->blockStorageFoo);; }. void _block_byref_obj_dispose(struct _block_byref_blockStorageFoo *src) {; FOO_dtor(&src->blockStorageFoo);; }. for the appropriately named constructor and destructor for the class/struct; ``FOO``. To support member variable and function access the compiler will synthesize a; ``const`` pointer to a block version of the ``this`` pointer. .. _RuntimeHelperFunctions:. Runtime Helper Functions; ========================. The runtime helper functions are described in; ``/usr/local/include/Block_private.h``. To summarize their use, a ``Block``; requires copy/dispose helpers if it imports any block variables, ``__block``; storage variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors. The (1<<26) bit is set and; functions are generated. The block copy helper function should, for each of the variables of the type; mentioned above, call:. .. code-block:: c. _Block_object_assign(&dst->target, src->target, BLOCK_FIELD_<apropos>);. in the copy helper and:. .. code-block:: c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLOCK = 7, // a block variable; BLOCK_FIELD_IS_BYREF = 8, // the on stack structure holding the __block variable. BLOCK_FIELD_IS_WEAK = 16, // declared __weak. BLOCK_BYREF_CALLER = 128, // called from byref copy/dispose helpers; };. and of course the constructors/destructors for ``const`` copied C++ objects. The ``block_byref`` data structure similarly requires copy/dispose helpers for; block variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors, and again the (1<<26) bit is set; and functions are generated in the sam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:28135,variab,variables,28135,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['variab'],['variables']
Modifiability,"kground-only, but when performing an inverted hypothesis test the null is a signal+background model. The new convention is that the p-value for both the null and the alternate are taken from the same tail (as specified by the test statistic). Both CLs+b and CLb are equivalent to these p-values, and the HypoTestResult has a simple switch SetBackgroundIsAlt() to specify the pairing between (null p-value, alternate p-value) and (CLb, CLs+b). HypoTestInverter, HypoTestInverterResult, HypoTestInverterPlot. These classes have been rewritten for using them with the new hypothesis test calculators. The HypoTestInverter; class can now be constructed by any generic HypoTestCalculator, and both the HybridCalculator and the new; FrequentistCalculator are supported. The HypoTestInverter class can be constructed in two ways: either passing an; HypoTestCalculator and a data set or by passing the model for the signal, for the background and a data set.; In the first case the user configure the HypoTestCalculator before passing to the HypoTestInverter.; It must be configured using as null model the signal plus background model as alternate model the background; model. Optionally the user can pass the parameter to scan, if it is not passed, the first parameter of interest of the; null model will be used. In the second case (when passing directly the model and the data) the HypoTestInverter; can be configured to use either the frequentist or the hybrid calculator. The user can then configure the class; afterwards. For example set the test statistic to use via the method SetTestStatistic, number of toys to run; for each hypothesis, by retrieving the contained HypoTestCalculator:. HypoTestInverter inverter(obsData, model_B, model_SB, parameterToScan, HypoTestInverter::kFrequentist);; ProfileLikelihoodRatioTestStat profLR( *model_SB->GetPdf() );; inverter.SetTestStatistic(&profLR);; FrequentistCalculator * htcalc = (FrequentistCalculator*) inverter.GetHypoTestCalculator();; htcalc->SetToy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html:3809,config,configure,3809,roofit/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v530/index.html,1,['config'],['configure']
Modifiability,known. 796; CD2; Lifetime of a closure object with members captured by reference; Unknown. 797; CD2; Converting a no-capture lambda to a function type; Unknown. 798; C++11; Overloaded subscript operator described in clause 5; Unknown. 799; CD2; Can reinterpret_cast be used to cast an operand to its own type?; Unknown. 800; NAD; Safely-derived pointers and object pointers converted from function pointers; Unknown. 801; CD2; Casting away constness in a cast to rvalue reference type; Unknown. 803; CD2; sizeof an enumeration type with a fixed underlying type; Unknown. 804; CD2; Deducing the type in new auto(x); Unknown. 805; CD2; Which exception to throw for overflow in array size calculation; Unknown. 806; CD2; Enumeration types in integral constant expressions; Unknown. 807; NAD; typeid expressions in constant expressions; Unknown. 808; CD2; Non-type decl-specifiers versus max-munch; Unknown. 809; CD2; Deprecation of the register keyword; Unknown. 810; CD2; Block-scope thread_local variables should be implicitly static; Unknown. 811; CD2; Unclear implications of const-qualification; Unknown. 812; CD2; Duplicate names in inline namespaces; Unknown. 813; open; typename in a using-declaration with a non-dependent name; Not resolved. 814; CD2; Attribute to indicate that a function throws nothing; Unknown. 815; CD2; Parameter pack expansion inside attributes; Unknown. 816; CD2; Diagnosing violations of [[final]]; Unknown. 817; CD2; Meaning of [[final]] applied to a class definition; Unknown. 818; CD2; Function parameter packs in non-final positions; Unknown. 819; NAD; Access control and deleted implicitly-declared special member functions; Unknown. 820; CD2; Deprecation of export; Unknown. 822; NAD; Additional contexts for template aliases; Unknown. 823; CD2; Literal types with constexpr conversions as non-type template arguments; Unknown. 828; CD2; Destruction of exception objects; Unknown. 829; NAD; At what point is std::unexpected called?; Unknown. 830; CD2; Deprecating ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:55127,variab,variables,55127,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['variab'],['variables']
Modifiability,"knownValue == 42. call void @foo(ptr %ptr); %newPtr2 = call ptr @llvm.launder.invariant.group.p0(ptr %ptr); %d = load i8, ptr %newPtr2, !invariant.group !0 ; Can't step through launder.invariant.group to get value of %ptr. ...; declare void @foo(ptr); declare ptr @getPointer(ptr); declare ptr @llvm.launder.invariant.group.p0(ptr). !0 = !{}. The invariant.group metadata must be dropped when replacing one pointer by; another based on aliasing information. This is because invariant.group is tied; to the SSA value of the pointer operand. .. code-block:: llvm. %v = load i8, ptr %x, !invariant.group !0; ; if %x mustalias %y then we can replace the above instruction with; %v = load i8, ptr %y. Note that this is an experimental feature, which means that its semantics might; change in the future. '``type``' Metadata; ^^^^^^^^^^^^^^^^^^^. See :doc:`TypeMetadata`. '``associated``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``associated`` metadata may be attached to a global variable definition with; a single argument that references a global object (optionally through an alias). This metadata lowers to the ELF section flag ``SHF_LINK_ORDER`` which prevents; discarding of the global variable in linker GC unless the referenced object is; also discarded. The linker support for this feature is spotty. For best; compatibility, globals carrying this metadata should:. - Be in ``@llvm.compiler.used``.; - If the referenced global variable is in a comdat, be in the same comdat. ``!associated`` can not express many-to-one relationship. A global variable with; the metadata should generally not be referenced by a function: the function may; be inlined into other functions, leading to more references to the metadata.; Ideally we would want to keep metadata alive as long as any inline location is; alive, but this many-to-one relationship is not representable. Moreover, if the; metadata is retained while the function is discarded, the linker will report an; error of a relocation referencing a di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:317998,variab,variable,317998,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['variab'],['variable']
Modifiability,"l = nullptr;; FoundDeclsList = Look up all Decls in the ""to"" Ctx with the same name of FromD;; for (auto FoundDecl : FoundDeclsList) {; if (StructurallyEquivalentDecls(FoundDecl, FromD)) {; ToDecl = FoundDecl;; Mark FromD as imported;; break;; } else {; Report ODR violation;; return error;; }; }; if (FoundDeclsList is empty) {; Import dependent declarations and types of ToDecl;; ToDecl = create a new AST node in ""to"" Ctx;; Mark FromD as imported;; }; return ToDecl;; }. Two AST nodes are *structurally equivalent* if they are. - builtin types and refer to the same type, e.g. ``int`` and ``int`` are structurally equivalent,; - function types and all their parameters have structurally equivalent types,; - record types and all their fields in order of their definition have the same identifier names and structurally equivalent types,; - variable or function declarations and they have the same identifier name and their types are structurally equivalent. We could extend the definition of structural equivalency to templates similarly. If A and B are AST nodes and *A depends on B*, then we say that A is a **dependant** of B and B is a **dependency** of A.; The words ""dependant"" and ""dependency"" are nouns in British English.; Unfortunately, in American English, the adjective ""dependent"" is used for both meanings.; In this document, with the ""dependent"" adjective we always address the dependencies, the B node in the example. API; ---. Let's create a tool which uses the ASTImporter class!; First, we build two ASTs from virtual files; the content of the virtual files are synthesized from string literals:. .. code-block:: cpp. std::unique_ptr<ASTUnit> ToUnit = buildASTFromCode(; """", ""to.cc""); // empty file; std::unique_ptr<ASTUnit> FromUnit = buildASTFromCode(; R""(; class MyClass {; int m1;; int m2;; };; )"",; ""from.cc"");. The first AST corresponds to the destination (""to"") context - which is empty - and the second for the source (""from"") context.; Next, we define a matcher to match",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst:4138,extend,extend,4138,interpreter/llvm-project/clang/docs/LibASTImporter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTImporter.rst,1,['extend'],['extend']
Modifiability,"l AlignCaseColons`` Whether aligned case labels are aligned on the colon, or on the; , or on the tokens after the colon. .. code-block:: c++. true:; switch (level) {; case log::info : return ""info:"";; case log::warning: return ""warning:"";; default : return """";; }. false:; switch (level) {; case log::info: return ""info:"";; case log::warning: return ""warning:"";; default: return """";; }. .. _AlignEscapedNewlines:. **AlignEscapedNewlines** (``EscapedNewlineAlignmentStyle``) :versionbadge:`clang-format 5` :ref:`¶ <AlignEscapedNewlines>`; Options for aligning backslashes in escaped newlines. Possible values:. * ``ENAS_DontAlign`` (in configuration: ``DontAlign``); Don't align escaped newlines. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. * ``ENAS_Left`` (in configuration: ``Left``); Align escaped newlines as far left as possible. .. code-block:: c++. true:; #define A \; int aaaa; \; int b; \; int dddddddddd;. false:. * ``ENAS_Right`` (in configuration: ``Right``); Align escaped newlines in the right-most column. .. code-block:: c++. #define A \; int aaaa; \; int b; \; int dddddddddd;. .. _AlignOperands:. **AlignOperands** (``OperandAlignmentStyle``) :versionbadge:`clang-format 3.5` :ref:`¶ <AlignOperands>`; If ``true``, horizontally align operands of binary and ternary; expressions. Possible values:. * ``OAS_DontAlign`` (in configuration: ``DontAlign``); Do not align operands of binary and ternary expressions.; The wrapped lines are indented ``ContinuationIndentWidth`` spaces from; the start of the line. * ``OAS_Align`` (in configuration: ``Align``); Horizontally align operands of binary and ternary expressions. Specifically, this aligns operands of a single expression that needs; to be split over multiple lines, e.g.:. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb +; ccccccccccccccc;. When ``BreakBeforeBinaryOperators`` is set, the wrapped operator is; aligned with the operand on the first line. .. code-block:: c++. int aaa = bbbbbbbbbbbbbbb; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:21154,config,configuration,21154,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['config'],['configuration']
Modifiability,"l View:; [000] {File} 'pr-43860-dwarf-gcc.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [002] {Producer} 'GNU C++14 9.3.0'; [002] 2 {Function} extern declared_inlined 'InlineFunction' -> 'int'; [003] {Block}; [004] 5 {Variable} 'Var_2' -> 'int'; [003] 2 {Parameter} 'Param' -> 'int'; [003] 3 {Variable} 'Var_1' -> 'int'; [002] 11 {Function} extern not_inlined 'test' -> 'int'; [003] 12 {Variable} 'A' -> 'int'; [003] 13 {InlinedFunction} declared_inlined 'InlineFunction' -> 'int'; [004] {Block}; [005] {Variable} 'Var_2' -> 'int'; [004] {Parameter} 'Param' -> 'int'; [004] {Variable} 'Var_1' -> 'int'; [003] 11 {Parameter} 'Param_1' -> 'int'; [003] 11 {Parameter} 'Param_2' -> 'int'. From the previous logical views, we can see that the CodeView debug; information generated by the Clang compiler shows the variables **Var_1**; and **Var_2** are at the same lexical scope (**4**) in the function; **InlineFuction**. The DWARF generated by GCC/Clang and CodeView; generated by MSVC, show those variables at the correct lexical scope:; **3** and **4** respectively. Using the :program:`llvm-debuginfo-analyzer` selection facilities, we; can produce a simple tabular output showing just the logical elements; that have in their name the *var* pattern. The logical view is sorted; by the variables name. .. code-block:: none. llvm-debuginfo-analyzer --attribute=level,format; --output-sort=name; --select-regex --select-nocase --select=Var; --report=list; --print=symbols; pr-43860-*.o. .. code-block:: none. Logical View:; [000] {File} 'pr-43860-codeview-clang.o' -> COFF-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-codeview-msvc.o' -> COFF-i386. [001] {CompileUnit} 'pr-43860.cpp'; [003] {Variable} 'Var_1' -> 'int'; [004] {Variable} 'Var_2' -> 'int'. Logical View:; [000] {File} 'pr-43860-dwarf-clang.o' -> elf64-x86-64. [001] {CompileUnit} 'pr-43860.cpp'; [004] {Variable} 'Var_1' ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:53259,variab,variables,53259,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,1,['variab'],['variables']
Modifiability,"l call which could use it is known to the compiler, or; whether another translation unit could introduce more calls through the vtable.; This is not the same as the linkage of the vtable, because call sites could be; using a pointer of a more widely-visible base class. For example, consider this; code:. .. code-block:: c++. __attribute__((visibility(""default""))); struct A {; virtual void f();; };. __attribute__((visibility(""hidden""))); struct B : A {; virtual void f();; };. With LTO, we know that all code which can see the declaration of ``B`` is; visible to us. However, a pointer to a ``B`` could be cast to ``A*`` and passed; to another linkage unit, which could then call ``f`` on it. This call would; load from the vtable for ``B`` (using the object pointer), and then call; ``B::f``. This means we can't remove the function pointer from ``B``'s vtable,; or the implementation of ``B::f``. However, if we can see all code which knows; about any dynamic base class (which would be the case if ``B`` only inherited; from classes with hidden visibility), then this optimisation would be valid. This concept is represented in IR by the ``!vcall_visibility`` metadata; attached to vtable objects, with the following values:. .. list-table::; :header-rows: 1; :widths: 10 90. * - Value; - Behavior. * - 0 (or omitted); - **Public**; Virtual function calls using this vtable could be made from external; code. * - 1; - **Linkage Unit**; All virtual function calls which might use this vtable are in the; current LTO unit, meaning they will be in the current module once; LTO linking has been performed. * - 2; - **Translation Unit**; All virtual function calls which might use this vtable are in the; current module. In addition, all function pointer loads from a vtable marked with the; ``!vcall_visibility`` metadata (with a non-zero value) must be done using the; :ref:`llvm.type.checked.load <type.checked.load>` intrinsic, so that virtual; calls sites can be correlated with the vtables which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:9594,inherit,inherited,9594,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['inherit'],['inherited']
Modifiability,"l entry point that can rebuild a; stack frame from the values located by the stack map. '``llvm.experimental.patchpoint.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void; @llvm.experimental.patchpoint.void(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...); declare i64; @llvm.experimental.patchpoint.i64(i64 <id>, i32 <numBytes>,; ptr <target>, i32 <numArgs>, ...). Overview:; """""""""""""""""". The '``llvm.experimental.patchpoint.*``' intrinsics creates a function; call to the specified ``<target>`` and records the location of specified; values in the stack map. Operands:; """""""""""""""""". The first operand is an ID, the second operand is the number of bytes; reserved for the patchable region, the third operand is the target; address of a function (optionally null), and the fourth operand; specifies how many of the following variable operands are considered; function call arguments. The remaining variable number of operands are; the ``live values`` for which locations will be recorded in the stack; map. Semantics:; """""""""""""""""""". The patch point intrinsic generates a stack map. It also emits a; function call to the address specified by ``<target>`` if the address; is not a constant null. The function call and its arguments are; lowered according to the calling convention specified at the; intrinsic's callsite. Variants of the intrinsic with non-void return; type also return a value according to calling convention. On PowerPC, note that ``<target>`` must be the ABI function pointer for the; intended target of the indirect call. Specifically, when compiling for the; ELF V1 ABI, ``<target>`` is the function-descriptor address normally used as; the C/C++ function-pointer representation. Requesting zero patch point arguments is valid. In this case, all; variable operands are handled just like; ``llvm.experimental.stackmap.*``. The difference is that space will; still be reserved for patching, a call will be emitted, and a return; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:8190,variab,variable,8190,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['variab'],['variable']
Modifiability,"l every part of LLVM that your build is configured to generate except the; LLVM testing tools. Alternatively the ``install-distribution`` target, which is; recommended for building distributions, only installs specific parts of LLVM as; specified at configuration time by *LLVM_DISTRIBUTION_COMPONENTS*. Additionally by default the ``install`` target will install the LLVM testing; tools as the public tools. This can be changed well by setting; *LLVM_INSTALL_TOOLCHAIN_ONLY* to ``On``. The LLVM tools are intended for; development and testing of LLVM, and should only be included in distributions; that support LLVM development. When building with *LLVM_DISTRIBUTION_COMPONENTS* the build system also; generates a ``distribution`` target which builds all the components specified in; the list. This is a convenience build target to allow building just the; distributed pieces without needing to build all configured targets. .. _Multi-distribution configurations:. Multi-distribution configurations; ---------------------------------. The ``install-distribution`` target described above is for building a single; distribution. LLVM's build system also supports building multiple distributions,; which can be used to e.g. have one distribution containing just tools and; another for libraries (to enable development). These are configured by setting; the *LLVM_DISTRIBUTIONS* variable to hold a list of all distribution names; (which conventionally start with an uppercase letter, e.g. ""Development""), and; then setting the *LLVM_<distribution>_DISTRIBUTION_COMPONENTS* variable to the; list of targets for that distribution. For each distribution, the build system; generates an ``install-${distribution}-distribution`` target, where; ``${distribution}`` is the name of the distribution in lowercase, to install; that distribution. Each distribution creates its own set of CMake exports, and the target to; install the CMake exports for a particular distribution for a project is named; ``${project}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst:4215,config,configurations,4215,interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BuildingADistribution.rst,1,['config'],['configurations']
Modifiability,"l functions. The aim of these classes is to extend and improve the fitting functionality provided in ROOT via the TVirtualFitter classes and the fitting methods present in many data analysis object, such as TH1::Fit.; ; The fit data are decoupled from the fitter class and described by the dedicated fit data classes like the ROOT::Fit::BinData for bin data containing coordinate values of any dimensions, bin content values and optionally errors in coordinate and bin content, and ROOT::Fit::UnBinData classes for any dimension un-bin data.; The fitter class, ROOT::Fit::Fitter, provides the functionality for fitting those data with any model function implementing the parametric function interface, ROOT::Math::IParamMultiFunction. Fit methods such as least square, bin and un-bin likelihood are supported. The fit solution is then found by using the ROOT::Math::Minimizer interface class and the results are stored in the ROOT::Fit::FitResult class. Fit parameter can be configured individually using the ROOT::Fit::FitParameterSettings class.; ; Various implementation of the minimizer interface can be used automatically using the ROOT plug-in manager mechanism, including the linear fitter for a fast and direct solution, in case of a linear least square model, or by using Minuit, Minuit2 or GSL minimization methods provided by the MathMore library. Functions for filling the new ROOT::Fit::BinData classes with all the histogram and graph types have been added in the histogram library (libHist) and graph library:; ; ROOT::Fit::FillData( BinData & , const TH1 *, TF1 * ) for histograms (in libHist); ROOT::Fit::FillData( BinData & , const TGraph2D *, TF1 * ) for 2D graphs (in libHist); ROOT::Fit::FillData( BinData & , const TGraph *, TF1 * ) for all 1D graphs (in libGraf); ROOT::Fit::FillData( BinData & , const TMultiGraph *, TF1 * ) for multi-graphs (in libGraf); . MathCore Numerical Algorithms. Classes implementing numerical methods which can be used by all the other ROOT library ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html:5054,config,configured,5054,math/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v520/index.html,1,['config'],['configured']
Modifiability,"l just use it to emit code. Expression Code Generation; ==========================. Generating LLVM code for expression nodes is very straightforward: less; than 45 lines of commented code for all four of our expression nodes.; First we'll do numeric literals:. .. code-block:: c++. Value *NumberExprAST::codegen() {; return ConstantFP::get(*TheContext, APFloat(Val));; }. In the LLVM IR, numeric constants are represented with the; ``ConstantFP`` class, which holds the numeric value in an ``APFloat``; internally (``APFloat`` has the capability of holding floating point; constants of Arbitrary Precision). This code basically just creates; and returns a ``ConstantFP``. Note that in the LLVM IR that constants; are all uniqued together and shared. For this reason, the API uses the; ""foo::get(...)"" idiom instead of ""new foo(..)"" or ""foo::Create(..)"". .. code-block:: c++. Value *VariableExprAST::codegen() {; // Look this variable up in the function.; Value *V = NamedValues[Name];; if (!V); LogErrorV(""Unknown variable name"");; return V;; }. References to variables are also quite simple using LLVM. In the simple; version of Kaleidoscope, we assume that the variable has already been; emitted somewhere and its value is available. In practice, the only; values that can be in the ``NamedValues`` map are function arguments.; This code simply checks to see that the specified name is in the map (if; not, an unknown variable is being referenced) and returns the value for; it. In future chapters, we'll add support for `loop induction; variables <LangImpl05.html#for-loop-expression>`_ in the symbol table, and for `local; variables <LangImpl07.html#user-defined-local-variables>`_. .. code-block:: c++. Value *BinaryExprAST::codegen() {; Value *L = LHS->codegen();; Value *R = RHS->codegen();; if (!L || !R); return nullptr;. switch (Op) {; case '+':; return Builder->CreateFAdd(L, R, ""addtmp"");; case '-':; return Builder->CreateFSub(L, R, ""subtmp"");; case '*':; return Builder->CreateFMul(L, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:5700,variab,variable,5700,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['variab'],['variable']
Modifiability,"l macros are expressions, and require a semi-colon to be; added; sometimes this is not the case, and this allows to make; clang-format aware of such cases. For example: Q_UNUSED. .. _TabWidth:. **TabWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <TabWidth>`; The number of columns used for tab stops. .. _TypeNames:. **TypeNames** (``List of Strings``) :versionbadge:`clang-format 17` :ref:`¶ <TypeNames>`; A vector of non-keyword identifiers that should be interpreted as type; names. A ``*``, ``&``, or ``&&`` between a type name and another non-keyword; identifier is annotated as a pointer or reference token instead of a; binary operator. .. _TypenameMacros:. **TypenameMacros** (``List of Strings``) :versionbadge:`clang-format 9` :ref:`¶ <TypenameMacros>`; A vector of macros that should be interpreted as type declarations; instead of as function calls. These are expected to be macros of the form:. .. code-block:: c++. STACK_OF(...). In the .clang-format configuration file, this can be configured like:. .. code-block:: yaml. TypenameMacros: ['STACK_OF', 'LIST']. For example: OpenSSL STACK_OF, BSD LIST_ENTRY. .. _UseCRLF:. **UseCRLF** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <UseCRLF>`; This option is **deprecated**. See ``LF`` and ``CRLF`` of ``LineEnding``. .. _UseTab:. **UseTab** (``UseTabStyle``) :versionbadge:`clang-format 3.7` :ref:`¶ <UseTab>`; The way to use tab characters in the resulting file. Possible values:. * ``UT_Never`` (in configuration: ``Never``); Never use tab. * ``UT_ForIndentation`` (in configuration: ``ForIndentation``); Use tabs only for indentation. * ``UT_ForContinuationAndIndentation`` (in configuration: ``ForContinuationAndIndentation``); Fill all leading whitespace with tabs, and use spaces for alignment that; appears within a line (e.g. consecutive assignments and declarations). * ``UT_AlignWithSpaces`` (in configuration: ``AlignWithSpaces``); Use tabs for line continuation and indentation, and spaces for; align",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:131604,config,configuration,131604,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,2,['config'],"['configuration', 'configured']"
Modifiability,"l memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by the PTE C-bit.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CPU can be kept coherent by using the MTYPE; UC (uncached) which bypasses the L2. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:289359,config,configured,289359,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['config'],['configured']
Modifiability,"l other; cross-coding is based on strings that are run on the Python interpreter; and vise-versa. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first before use. It is possible to switch between interpreters; by calling **`TPython::Prompt()`** on the ROOT side, while returning with; `^D` (`EOF`). State is preserved between successive switches, and string; based cross calls can nest as long as shared resources are properly; handled. ``` {.cpp}; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; ```. ### Installation. There are several ways of obtaining `PyROOT`, and which is best depends; on your specific situation. If you work at CERN, you can use the; installation available on `afs`. Otherwise, you will want to build from; source, as `PyROOT` is not build by default in the binaries distributed; from the ROOT project site. If you download the ROOT binaries, take care; to download and install the Python distribution from; <http://www.python.org/> against which they were built. #### Environment Settings. ROOT installations with the build of `PyROOT` enabled are available from; the CERN `afs` cell `/afs/cern.ch/sw/root/<version>/<platform>`. To use; them, simply modify your shell environment accordingly. For Unix:. `export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH`. `export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH`. `export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH`. For Windows:. `set PATH=%ROOTSYS%/bin;%PYTHO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:5304,variab,variables,5304,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['variab'],['variables']
Modifiability,"l pointer, then a null pointer is passed as the argument,; and no further work is required for the pass-by-writeback.; #. Otherwise, a temporary of type ``T __autoreleasing`` is created and; initialized to a null pointer.; #. If the parameter is not an Objective-C method parameter marked ``out``,; then ``*p`` is read, and the result is written into the temporary with; primitive semantics.; #. The address of the temporary is passed as the argument to the actual call.; #. After the call completes, the temporary is loaded with primitive; semantics, and that value is assigned into ``*p``. .. admonition:: Rationale. This is all admittedly convoluted. In an ideal world, we would see that a; local variable is being passed to an out-parameter and retroactively modify; its type to be ``__autoreleasing`` rather than ``__strong``. This would be; remarkably difficult and not always well-founded under the C type system.; However, it was judged unacceptably invasive to require programmers to write; ``__autoreleasing`` on all the variables they intend to use for; out-parameters. This was the least bad solution. .. _arc.ownership.restrictions.records:. Ownership-qualified fields of structs and unions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A member of a struct or union may be declared to have ownership-qualified; type. If the type is qualified with ``__unsafe_unretained``, the semantics; of the containing aggregate are unchanged from the semantics of an unqualified type in a non-ARC mode. If the type is qualified with ``__autoreleasing``, the program is ill-formed. Otherwise, if the type is nontrivially ownership-qualified, additional rules apply. Both Objective-C and Objective-C++ support nontrivially ownership-qualified; fields. Due to formal differences between the standards, the formal; treatment is different; however, the basic language model is intended to; be the same for identical code. .. admonition:: Rationale. Permitting ``__strong`` and ``__weak`` references ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:51086,variab,variables,51086,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['variab'],['variables']
Modifiability,"l to an immediate function.; (`#66324 <https://github.com/llvm/llvm-project/issues/66324>`_). - Fix crash for a lambda attribute with a statement expression; that contains a `return`.; (`#48527 <https://github.com/llvm/llvm-project/issues/48527>`_). - Clang now no longer asserts when an UnresolvedLookupExpr is used as an; expression requirement. (`#66612 <https://github.com/llvm/llvm-project/issues/66612>`_). - Clang now disambiguates NTTP types when printing diagnostics where the; NTTP types are compared with the 'diff' method.; (`#66744 <https://github.com/llvm/llvm-project/issues/66744>`_). - Fix crash caused by a spaceship operator returning a comparision category by; reference. Fixes:; (`#64162 <https://github.com/llvm/llvm-project/issues/64162>`_); - Fix a crash when calling a consteval function in an expression used as; the size of an array.; (`#65520 <https://github.com/llvm/llvm-project/issues/65520>`_). - Clang no longer tries to capture non-odr-used variables that appear; in the enclosing expression of a lambda expression with a noexcept specifier.; (`#67492 <https://github.com/llvm/llvm-project/issues/67492>`_). - Fix crash when fold expression was used in the initialization of default; argument. Fixes:; (`#67395 <https://github.com/llvm/llvm-project/issues/67395>`_). - Fixed a bug causing destructors of constant-evaluated structured bindings; initialized by array elements to be called in the wrong evaluation context. - Fix crash where ill-formed code was being treated as a deduction guide and; we now produce a diagnostic. Fixes:; (`#65522 <https://github.com/llvm/llvm-project/issues/65522>`_). - Fixed a bug where clang incorrectly considered implicitly generated deduction; guides from a non-templated constructor and a templated constructor as ambiguous,; rather than prefer the non-templated constructor as specified in; [standard.group]p3. - Fixed a crash caused by incorrect handling of dependence on variable templates; with non-type template parameters o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:50682,variab,variables,50682,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['variab'],['variables']
Modifiability,"l variables that can be shared in the parallel regions; are stored in the global memory. In `Cuda` mode local variables are not shared; between the threads and it is user responsibility to share the required data; between the threads in the parallel regions. Often, the optimizer is able to; reduce the cost of `Generic` mode to the level of `Cuda` mode, but the flag,; as well as other assumption flags, can be used for tuning. Features not supported or with limited support for Cuda devices; ---------------------------------------------------------------. - Cancellation constructs are not supported. - Doacross loop nest is not supported. - User-defined reductions are supported only for trivial types. - Nested parallelism: inner parallel regions are executed sequentially. - Debug information for OpenMP target regions is supported, but sometimes it may; be required to manually specify the address class of the inspected variables.; In some cases the local variables are actually allocated in the global memory,; but the debug info may be not aware of it. .. _OpenMP implementation details:. OpenMP 5.0 Implementation Details; =================================. The following table provides a quick overview over various OpenMP 5.0 features; and their implementation status. Please post on the; `Discourse forums (Runtimes - OpenMP category)`_ for more; information or if you want to help with the; implementation. +------------------------------+--------------------------------------------------------------+--------------------------+-----------------------------------------------------------------------+; |Category | Feature | Status | Reviews |; +==============================+==============================================================+==========================+=======================================================================+; | loop | support != in the canonical loop form | :good:`done` | D54441 |; +------------------------------+--------------------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst:2739,variab,variables,2739,interpreter/llvm-project/clang/docs/OpenMPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenMPSupport.rst,1,['variab'],['variables']
Modifiability,"l(""#id"") references; 17. Use latest three.js r85; 18. Fix 'transpXY' URL parameter handling - it was used as opacity, but opacity=1-transparency. ## Changes in 5.1.2; 1. Fix - support newest TFormula in TF1 (#127); 2. Fix - ignore NaN value in saved TF1 buffer; 3. Fix - correctly treat transparency in geo painter; 4. Fix - disable useFontCache for SVG mathjax output; 5. Fix - produce PNG image for objects with special symbols in names. ## Changes in 5.1.1; 1. Fix - invoke callback in JSROOT.draw() at proper time; 2. Fix - support TGeoHMatrix, produced after GDML conversion; 3. Fix - support also TGeoScale and TGeoGenTrans matrices; 4. Fix - update histograms with all provided functions (#125). ## Changes in 5.1.0; 1. New 'float' browser kind overlays with objects drawing; 2. Browser can be enabled after drawing with 'nobrowser' mode; 3. One can hide browser or switch browser kind at any time; 4. New 'horizontal' and 'vertical' layouts for object display.; One could configure several frames, each divided on sub-frames.; Like display=horiz231 will create three horizontal frames,; divided on 2,3 and 1 sub-frames.; 5. One could enable status line where current tooltip info will be shown; 6. Improve enlarge functionality - now works with all layouts; 7. Do not display all canvas tool buttons by default - provide toggle button instead; 8. Let move TAxis title, its position now similar to ROOT graphics; 9. Support 'col0' option for TH2Poly class to suppress empty bins; 10. Implement for TH3 'box2', 'box3', 'glbox2', 'glcol' draw options; 11. Support more superscript/subscript letters in normal text output; 12. Correctly handle unzoom with logx/logy scales; 13. Let disable stamp parameter in file url with ""-"" sign at the end of file name; 14. Let use quotes in the URL parameters to protect complex arguments with special symbols; 15. Introduce direct streamers - like TBasket or TRef; Benefit - one can add custom streamers of such kind or reuse existing; 16. Handle TMatrixTSym",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:44613,config,configure,44613,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['config'],['configure']
Modifiability,"l(), Scope));; }. This both tells the main ``IRBuilder`` where we are, but also what scope; we're in. The scope can either be on compile-unit level or be the nearest; enclosing lexical block like the current function.; To represent this we create a stack of scopes in ``DebugInfo``:. .. code-block:: c++. std::vector<DIScope *> LexicalBlocks;. and push the scope (function) to the top of the stack when we start; generating the code for each function:. .. code-block:: c++. KSDbgInfo.LexicalBlocks.push_back(SP);. Also, we may not forget to pop the scope back off of the scope stack at the; end of the code generation for the function:. .. code-block:: c++. // Pop off the lexical block for the function since we added it; // unconditionally.; KSDbgInfo.LexicalBlocks.pop_back();. Then we make sure to emit the location every time we start to generate code; for a new AST object:. .. code-block:: c++. KSDbgInfo.emitLocation(this);. Variables; =========. Now that we have functions, we need to be able to print out the variables; we have in scope. Let's get our function arguments set up so we can get; decent backtraces and see how our functions are being called. It isn't; a lot of code, and we generally handle it when we're creating the; argument allocas in ``FunctionAST::codegen``. .. code-block:: c++. // Record the function arguments in the NamedValues map.; NamedValues.clear();; unsigned ArgIdx = 0;; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Create a debug descriptor for the variable.; DILocalVariable *D = DBuilder->createParameterVariable(; SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(),; true);. DBuilder->insertDeclare(Alloca, D, DBuilder->createExpression(),; DILocation::get(SP->getContext(), LineNo, 0, SP),; Builder->GetInsertBlock());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to varia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst:12986,variab,variables,12986,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl09.rst,1,['variab'],['variables']
Modifiability,"l. ## Status and usage. **Status**: Experimental work in progress. Enabling is strongly advised against; except for development and testing. **Enable in Clang**: `-Xclang -fexperimental-assignment-tracking`. That causes Clang to get LLVM to run the pass `declare-to-assign`. The pass; converts conventional debug intrinsics to assignment tracking metadata and sets; the module flag `debug-info-assignment-tracking` to the value `i1 true`. To; check whether assignment tracking is enabled for a module call; `isAssignmentTrackingEnabled(const Module &M)` (from `llvm/IR/DebugInfo.h`). ## Design and implementation. ### Assignment markers: `llvm.dbg.assign`. `llvm.dbg.value`, a conventional debug intrinsic, marks out a position in the; IR where a variable takes a particular value. Similarly, Assignment Tracking; marks out the position of assignments with a new intrinsic called; `llvm.dbg.assign`. In order to know where in IR it is appropriate to use a memory location for a; variable, each assignment marker must in some way refer to the store, if any; (or multiple!), that performs the assignment. That way, the position of the; store and marker can be considered together when making that choice. Another; important benefit of referring to the store is that we can then build a two-way; mapping of stores<->markers that can be used to find markers that need to be; updated when stores are modified. An `llvm.dbg.assign` marker that is not linked to any instruction signals that; the store that performed the assignment has been optimised out, and therefore; the memory location will not be valid for at least some part of the program. Here's the `llvm.dbg.assign` signature. Each parameter is wrapped in; `MetadataAsValue`, and `Value *` type parameters are first wrapped in; `ValueAsMetadata`:. ```; void @llvm.dbg.assign(Value *Value,; DIExpression *ValueExpression,; DILocalVariable *Variable,; DIAssignID *ID,; Value *Address,; DIExpression *AddressExpression); ```. The first three paramete",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md:2067,variab,variable,2067,interpreter/llvm-project/llvm/docs/AssignmentTracking.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AssignmentTracking.md,1,['variab'],['variable']
Modifiability,"l. Accepted values are:. * add - Returns the sum of its two operands.; * div - Returns the quotient of its two operands.; * max - Returns the largest of its two operands.; * min - Returns the smallest of its two operands.; * mul - Returns the product of its two operands.; * sub - Returns the difference of its two operands. * ``<arguments>`` is a comma separated list of expressions. For example:. .. code-block:: llvm. ; CHECK: load r[[#REG:]], [r0]; ; CHECK: load r[[#REG+1]], [r1]; ; CHECK: Loading from 0x[[#%x,ADDR:]]; ; CHECK-SAME: to 0x[[#ADDR + 7]]. The above example would match the text:. .. code-block:: gas. load r5, [r0]; load r6, [r1]; Loading from 0xa0463440 to 0xa0463447. but would not match the text:. .. code-block:: gas. load r5, [r0]; load r7, [r1]; Loading from 0xa0463440 to 0xa0463443. Due to ``7`` being unequal to ``5 + 1`` and ``a0463443`` being unequal to; ``a0463440 + 7``. A numeric variable can also be defined to the result of a numeric expression,; in which case the numeric expression constraint is checked and if verified the; variable is assigned to the value. The unified syntax for both checking a; numeric expression and capturing its value into a numeric variable is thus; ``[[#%<fmtspec>,<NUMVAR>: <constraint> <expr>]]`` with each element as; described previously. One can use this syntax to make a testcase more; self-describing by using variables instead of values:. .. code-block:: gas. ; CHECK: mov r[[#REG_OFFSET:]], 0x[[#%X,FIELD_OFFSET:12]]; ; CHECK-NEXT: load r[[#]], [r[[#REG_BASE:]], r[[#REG_OFFSET]]]. which would match:. .. code-block:: gas. mov r4, 0xC; load r6, [r5, r4]. The ``--enable-var-scope`` option has the same effect on numeric variables as; on string variables. Important note: In its current implementation, an expression cannot use a; numeric variable defined earlier in the same CHECK directive. FileCheck Pseudo Numeric Variables; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Sometimes there's a need to verify output that contains line n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst:32609,variab,variable,32609,interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/FileCheck.rst,2,['variab'],['variable']
Modifiability,"l; In 2020, the monorepo had just under 35 thousand commits. This works; out to an average of 4 commits per hour. Already, we can see that a; builder must cycle in less than 15 minutes to have a hope of being; useful. However, those commits are not uniformly distributed. They; tend to cluster strongly during US working hours. Looking at a couple; of recent (Nov 2021) working days, we routinely see ~10 commits per; hour during peek times, with occasional spikes as high as ~15 commits; per hour. Thus, as a rule of thumb, we should plan for our builder to; complete ~10-15 builds an hour. Resource Appropriately; At 10-15 builds per hour, we need to complete a new build on average every; 4 to 6 minutes. For anything except the fastest of hardware/build configs,; this is going to be well beyond the ability of a single machine. In buildbot; terms, we likely going to need multiple workers to build requests in parallel; under a single builder configuration. For some rough back of the envelope; numbers, if your build config takes e.g. 30 minutes, you will need something; on the order of 5-8 workers. If your build config takes ~2 hours, you'll; need something on the order of 20-30 workers. The rest of this section; focuses on how to reduce cycle times. Restrict what you build and test; Think hard about why you're setting up a bot, and restrict your build; configuration as much as you can. Basic functionality is probably; already covered by other bots, and you don't need to duplicate that; testing. You only need to be building and testing the *unique* parts; of the configuration. (e.g. For a multi-stage clang builder, you probably; don't need to be enabling every target or building all the various utilities.). It can sometimes be worthwhile splitting a single builder into two or more,; if you have multiple distinct purposes for the same builder. As an example,; if you want to both a) confirm that all of LLVM builds with your host; compiler, and b) want to do a multi-stage clang",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:9116,config,config,9116,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,1,['config'],['config']
Modifiability,"l; read it from the file and create an object in memory. Here we draw the; profile histogram, and then we list the contents. ``` {.cpp}; root[] hprof->Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; root[] f->ls(); TFile** hsimple.root; TFile* hsimple.root; OBJ: TProfile hprof Profile of pz versus px : 0; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; ```. We now see a new line that starts with OBJ. This means that an object of; class **`TProfile`**, called `hprof` has been added in memory to this; directory. This new `hprof` in memory is independent from the `hprof` on; disk. If we make changes to the `hprof` in memory, they are not; propagated to the `hprof` on disk. A new version of `hprof` will be; saved once we call `Write`. You may wonder why `hprof` is added to the objects in the current; directory. `hprof` is of the class **`TProfile`** that inherits from; **`TH1D`**, which inherits from **`TH1`**. **`TH1`** is the basic; histogram. All histograms and trees are created in the current directory; (also see ""Histograms and the Current Directory""). The reference to ""all; histograms"" includes objects of any class descending directly or; indirectly from **`TH1`**. Hence, our **`TProfile`** `hprof` is created; in the current directory `f.`There was another side effect when we; called the `TH1::Draw` method. ROOT printed this statement:. ``` {.cpp}; <TCanvas::MakeDefCanvas>: created default TCanvas with name c1; ```. It tells us that a **`TCanvas`** was created and it named it `c1`. This; is where ROOT is being nice, and it creates a canvas for drawing the; histogram if no canvas was named in the draw command, and if no active; canvas exists. The newly created canvas, however, is NOT listed in the; contents of the current directory. Why is that? The canvas is not added; to the current directory, because by default ONLY histograms and tr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:25586,inherit,inherits,25586,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,2,['inherit'],['inherits']
Modifiability,"lClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). NCycles No 3000 − Number of training cycles. HiddenLayers No N,N-1 − Specification of hidden layer architecture. Configuration options for MVA method :. Configuration options reference for MVA method: KNN. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel No Default Default, Debug, Verbose, Info, Warning, Error, Fatal Verbosity level. VarTransform No None − List of variable transformations performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). nkNN No 20 − Number of k-nearest neighbors. BalanceDepth No 6 − Binary tree balance depth. ScaleFrac No 0.8 − Fraction of events used to compute variable width. SigmaFact No 1 − Scale factor for sigma in Gaussian kernel. Kernel No Gaus − Use polynomial (=Poln) or Gaussian (=Gaus) kernel. Trim No False − Use equal number of signal and background events. UseKernel No False − Use polynomial kernel weight. UseWeight No T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:9786,variab,variable,9786,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,1,['variab'],['variable']
Modifiability,lOrigin.h; clang-tools-extra/clangd/index/YAMLSerialization.cpp; clang-tools-extra/clangd/index/dex/Iterator.cpp; clang-tools-extra/clangd/index/dex/Iterator.h; clang-tools-extra/clangd/index/dex/PostingList.cpp; clang-tools-extra/clangd/index/dex/PostingList.h; clang-tools-extra/clangd/index/dex/Token.h; clang-tools-extra/clangd/index/dex/Trigram.cpp; clang-tools-extra/clangd/index/dex/Trigram.h; clang-tools-extra/clangd/index/dex/dexp/Dexp.cpp; clang-tools-extra/clangd/index/remote/Client.cpp; clang-tools-extra/clangd/index/remote/Client.h; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.cpp; clang-tools-extra/clangd/index/remote/marshalling/Marshalling.h; clang-tools-extra/clangd/index/remote/monitor/Monitor.cpp; clang-tools-extra/clangd/index/remote/server/Server.cpp; clang-tools-extra/clangd/index/remote/unimplemented/UnimplementedClient.cpp; clang-tools-extra/clangd/indexer/IndexerMain.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.cpp; clang-tools-extra/clangd/refactor/InsertionPoint.h; clang-tools-extra/clangd/refactor/Rename.h; clang-tools-extra/clangd/refactor/Tweak.cpp; clang-tools-extra/clangd/refactor/Tweak.h; clang-tools-extra/clangd/refactor/tweaks/AddUsing.cpp; clang-tools-extra/clangd/refactor/tweaks/AnnotateHighlightings.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineInline.cpp; clang-tools-extra/clangd/refactor/tweaks/DefineOutline.cpp; clang-tools-extra/clangd/refactor/tweaks/DumpAST.cpp; clang-tools-extra/clangd/refactor/tweaks/ExpandMacro.cpp; clang-tools-extra/clangd/refactor/tweaks/ExtractFunction.cpp; clang-tools-extra/clangd/refactor/tweaks/ObjCLocalizeStringLiteral.cpp; clang-tools-extra/clangd/refactor/tweaks/RemoveUsingNamespace.cpp; clang-tools-extra/clangd/refactor/tweaks/SwapIfBranches.cpp; clang-tools-extra/clangd/support/Cancellation.cpp; clang-tools-extra/clangd/support/Cancellation.h; clang-tools-extra/clangd/support/Context.cpp; clang-tools-extra/clangd/support/Context.h; clang-tools-extra/clangd/support,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:80079,refactor,refactor,80079,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['refactor'],['refactor']
Modifiability,"l` or `cvmfs-server` ones. - As root user, run:. # cvmfs_config setup. - Start the `autofs` service: how to to this depends on your operating; system. On Ubuntu using Upstart:. # restart autofs. On RHEL-based or older Ubuntus:. # service autofs restart. - Prepare a `/etc/cvmfs/default.local` file (create it if it does not; exists) with the following configuration bits:. ``` {.bash}; CVMFS_HTTP_PROXY=http://your-proxy-server.domain.ch:3128,DIRECT; CVMFS_REPOSITORIES=your-experiment.cern.ch,sft.cern.ch; CVMFS_QUOTA_LIMIT=50000; ```. You need to properly specify your closest HTTP caching proxy:; separate many of them via commas. The last fallback value, `DIRECT`,; tells cvmfs to connect directly without using any proxy at all. Among the list of repositories (comma-separated), always specify; `sft.cern.ch` and the one containing the software to your experiment; (e.g., `cms.cern.ch`). The quota limit is, in Megabytes, the amount of local disk space to; use as cache. - Check the configuration and repositories with:. # cvmfs_config chksetup; OK; # cvmfs_config probe; Probing /cvmfs/cms.cern.ch... OK; Probing /cvmfs/sft.cern.ch... OK. > You might need special configurations for some custom software; > repositories! Special cases are not covered in this guide. ### Firewall configuration. [PROOF on Demand](http://pod.gsi.de/) is very flexible in handling; various cases of network topologies. The best solution would be to allow; all TCP communications between the cluster machines. No other incoming communication is required from the outside. Configuration steps for the head node only; ------------------------------------------. ### Setup HTTPS+SSH (sshcertauth) authentication. > Latest recommended sshcertauth version is 0.8.5.; >; > [Download](https://github.com/dberzano/sshcertauth/archive/v0.8.5.zip); > and [read the; > instructions](http://newton.ph.unito.it/~berzano/w/doku.php?id=proof:sshcertauth). If you want your users to connect to the PROOF cluster using their Grid; u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:3385,config,configuration,3385,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,1,['config'],['configuration']
